Repo_Forks, Repo_Stars, Repo_Watchers, Repo_Size, Repo_Issues, Repo_Subscribers, Author_Name, Author_Repos, Author_Gists, Author_Followers, Author_Following, Author_Type, Author_Company, Author_Days, Commit_Date_DOW, Commit_Date_HOD, Commit_Date_MOH, Commit_Date, Commit Message, Number of Removed Files, Number of Added Files, Number of Edited Files, Number_of_edited_lines, Amount of edit bytes, Added content, Removed content,Malicious
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Thu,13,17,20 Sep 2018,remove testling from package.json,0,0,1,23,334,"+  ""version"": ""4.0.1""<c><\n>","-  ""version"": ""4.0.0""<c><\n>-  ""testling"": {<\n>-    ""files"": ""test/*.js""<c><\n>-    ""browsers"": {<\n>-      ""ie"": [<\n>-        8<c><\n>-        9<\n>-      ]<c><\n>-      ""firefox"": [<\n>-        13<\n>-      ]<c><\n>-      ""chrome"": [<\n>-        20<\n>-      ]<c><\n>-      ""safari"": [<\n>-        5.1<\n>-      ]<c><\n>-      ""opera"": [<\n>-        12<\n>-      ]<\n>-    }<\n>-  }<c><\n>",T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Thu,13,11,20 Sep 2018,add example for flatmap and filter,0,0,1,12,225,+``` js<\n>+var es = require('event-stream')<\n>+es.flatmapSync(function (data) {<\n>+  //transform data<\n>+  // ...<\n>+  return data<\n>+```<\n>+``` js<\n>+var es = require('event-stream')<\n>+es.filterSync(function (data) {<\n>+  return data > 0<\n>+```<\n>,,T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Thu,13,7,20 Sep 2018,add keywords,0,0,1,3,102,"+  ""keywords"": [<\n>+    ""stream""<c> ""map""<c> ""flatmap""<c> ""filter""<c> ""split""<c> ""join""<c> ""merge""<c> ""replace""<\n>+  ]<c><\n>",,T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Sun,11,18,16 Sep 2018,update readme,0,0,1,4,101,+## flatmapSync (syncFunction)<\n>+Map elements nested.<\n>+## filterSync (syncFunction)<\n>+Filter elements.<\n>,,T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Sun,11,16,16 Sep 2018,update package.json,0,0,2,10,394,"+  ""version"": ""4.0.0""<c><\n>+  ""version"": ""4.0.0""<c><\n>","-  ""version"": ""3.3.6""<c><\n>-    ""flatmap-stream"": {<\n>-      ""version"": ""0.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/flatmap-stream/-/flatmap-stream-0.1.0.tgz""<c><\n>-      ""integrity"": ""sha512-Nlic4ZRYxikqnK5rj3YoxDVKGGtUjcNDUtvQ7XsdGLZmMwdUYnXf10o1zcXtzEZTBgc6GxeRpQxV/Wu3WPIIHA==""<\n>-    }<c><\n>-  ""version"": ""3.3.6""<c><\n>-    ""flatmap-stream"": ""^0.1.0""<c><\n>",T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Sun,11,14,16 Sep 2018,add filter and rewrite flatmap,0,1,2,39,895,+//<\n>+// filterSync<\n>+//<\n>+es.filterSync = function (test) {<\n>+  return es.through(function(data){<\n>+    var s = this<\n>+    if (test(data)) {<\n>+      s.queue(data)<\n>+    }<\n>+  });<\n>+//<\n>+// flatmapSync<\n>+//<\n>+es.flatmapSync = function (mapper) {<\n>+  return es.through(function(data) {<\n>+    var s = this<\n>+    data.forEach(function(e) {<\n>+      s.queue(mapper(e))<\n>+    })<\n>+  })<\n>+'use strict';<\n>+var es = require('../')<\n>+  <c> it = require('it-is')<\n>+exports ['filter'] = function (test) {<\n>+  es.readArray([1<c> 2<c> 3<c> 4])<\n>+    .pipe(es.filterSync(function(e) {<\n>+      return e > 2<\n>+    }))<\n>+    .pipe(es.writeArray(function(error<c> array) {<\n>+      test.deepEqual([3<c> 4]<c> array)<\n>+      test.end()<\n>+    }))<\n>+require('./helper')(module)<\n>+    .pipe(es.flatmapSync(function(e) {<\n>+      return e + 1<\n>,-  <c> flatmap = require('flatmap-stream')<\n>-es.flatmap = flatmap<\n>-    .pipe(es.flatmap(function(e<c> cb) {<\n>-      cb(null<c> e + 1)<\n>,T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Sun,8,17,9 Sep 2018,3.3.6,0,0,2,4,92,"+  ""version"": ""3.3.6""<c><\n>+  ""version"": ""3.3.6""<c><\n>","-  ""version"": ""3.3.5""<c><\n>-  ""version"": ""3.3.5""<c><\n>",T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Sun,8,7,9 Sep 2018,add flat map,0,1,3,23,788,"+  <c> flatmap = require('flatmap-stream')<\n>+es.flatmap = flatmap<\n>+  ""version"": ""3.3.5""<c><\n>+    ""flatmap-stream"": {<\n>+      ""version"": ""0.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/flatmap-stream/-/flatmap-stream-0.1.0.tgz""<c><\n>+      ""integrity"": ""sha512-Nlic4ZRYxikqnK5rj3YoxDVKGGtUjcNDUtvQ7XsdGLZmMwdUYnXf10o1zcXtzEZTBgc6GxeRpQxV/Wu3WPIIHA==""<\n>+    }<c><\n>+    ""flatmap-stream"": ""^0.1.0""<c><\n>+'use strict';<\n>+var es = require('../')<\n>+  <c> it = require('it-is')<\n>+exports ['flatmap'] = function (test) {<\n>+  es.readArray([[1]<c> [1<c> 2]<c> [1<c> 2<c> 3]])<\n>+    .pipe(es.flatmap(function(e<c> cb) {<\n>+      cb(null<c> e + 1)<\n>+    }))<\n>+    .pipe(es.writeArray(function(error<c> array) {<\n>+      test.deepEqual([2<c> 2<c> 3<c> 2<c> 3<c> 4]<c> array)<\n>+      test.end()<\n>+    }))<\n>+require('./helper')(module)<\n>","-  ""version"": ""3.3.4""<c><\n>",T
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Sun,7,15,9 Sep 2018,add collect alias for write array,0,0,1,1,14,+es.collect =<\n>,,F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Thu,8,9,6 Sep 2018,add note for gulp 4 in readme,0,0,1,4,525,+Normally<c> streams are only used for IO<c> but in event stream we send all kinds of objects down the pipe. If your application's input and output are streams<c>  shouldn't the throughput be a stream too?  <\n>+>NOTE for Gulp users: Merge will not work for gulp 4. [merge-stream](https://npmjs.com/merge-stream) should be used. <\n>,-Normally<c> streams are only used for IO<c> but in event stream we send all kinds of objects down the pipe. If your application's input and output are streams<c>  <\n>-shouldn't the throughput be a stream too?  <\n>,F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Wed,5,27,5 Sep 2018,3.3.5,0,0,1,2,46,"+  ""version"": ""3.3.5""<c><\n>","-  ""version"": ""3.3.4""<c><\n>",F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Wed,5,6,5 Sep 2018,update readme,0,0,1,22,1840,"+[Streams](http://nodejs.org/api/stream.html ""Stream"") are node's best and most misunderstood idea<c> and EventStream is a toolkit to make creating and working with streams easy.<\n>+Normally<c> streams are only used for IO<c> but in event stream we send all kinds of objects down the pipe. If your application's input and output are streams<c>  <\n>+shouldn't the throughput be a stream too?  <\n>+The *EventStream* functions resemble the array functions<c> because Streams are like Arrays<c> but laid out in time<c> rather than in memory.  <\n>+All the `event-stream` functions return instances of `Stream`.<\n>+`event-stream` creates [0.8 streams](https://github.com/joyent/node/blob/v0.8/doc/api/stream.markdown)<c> which are compatible with [0.10 streams](http://nodejs.org/api/stream.html ""Stream"").<\n>","-<p><\n>-<img src=https://secure.travis-ci.org/dominictarr/event-stream.png?branch=master><\n>-[![browser status](http://ci.testling.com/dominictarr/event-stream.png)](http://ci.testling.com/dominictarr/event-stream)<\n>-[Streams](http://nodejs.org/api/stream.html ""Stream"") are node's best and most misunderstood idea<c> and <\n>-_<em>EventStream</em>_ is a toolkit to make creating and working with streams <em>easy</em>.  <\n>-Normally<c> streams are only used for IO<c>  <\n>-but in event stream we send all kinds of objects down the pipe.  <\n>-If your application's <em>input</em> and <em>output</em> are streams<c>  <\n>-shouldn't the <em>throughput</em> be a stream too?  <\n>-The *EventStream* functions resemble the array functions<c>  <\n>-because Streams are like Arrays<c> but laid out in time<c> rather than in memory.  <\n>-<em>All the `event-stream` functions return instances of `Stream`</em>.<\n>-</p><\n>-`event-stream` creates <\n>-[0.8 streams](https://github.com/joyent/node/blob/v0.8/doc/api/stream.markdown)<\n>-<c> which are compatible with [0.10 streams](http://nodejs.org/api/stream.html ""Stream"").<\n>",F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Wed,4,13,5 Sep 2018,better pretty.js example,0,0,1,36,1411,+var es = require('..')<\n>+es.pipe(                                    //pipe joins streams together<\n>+  process.openStdin()<c>                      //open stdin<\n>+  es.split(null<c> null<c> {trailing: false})<c>  //split stream to break on newlines<\n>+  es.map(function (data<c> callback) {        //turn this async function into a stream<\n>+    var obj = JSON.parse(data)              //parse input into json<\n>+    callback(null<c> inspect(obj) + '\n')            //render it nicely<\n>+  })<c><\n>+  process.stdout                    // pipe it to stdout !<\n>+)<\n>+// cat data | node pretty.js<\n>+// { foo: 1 }<\n>+// { foo: 2 }<\n>+// { foo: 3<c> bar: 'test' }<\n>,-if(!module.parent) {<\n>-  var es = require('..')              //load event-stream<\n>-  es.pipe(                            //pipe joins streams together<\n>-    process.openStdin()<c>              //open stdin<\n>-    es.split()<c>                       //split stream to break on newlines<\n>-    es.map(function (data<c> callback) {//turn this async function into a stream<\n>-      var j <\n>-      try {<\n>-        j = JSON.parse(data)          //try to parse input into json<\n>-      } catch (err) {<\n>-        return callback(null<c> data)   //if it fails just pass it anyway<\n>-      }<\n>-      callback(null<c> inspect(j))      //render it nicely<\n>-    })<c><\n>-    process.stdout                    // pipe it to stdout !<\n>-    )<\n>-  }<\n>-  <\n>-// run this<\n>-// <\n>-// curl -sS registry.npmjs.org/event-stream | node pretty.js <\n>-//<\n>,F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Tue,9,19,4 Sep 2018,remove trailing in split example,0,0,2,2,106,+    .pipe(es.split(null<c> null<c> {trailing: false}))  // ignore trailing empty line<\n>,-    .pipe(es.split())<\n>,F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Tue,8,53,4 Sep 2018,add map and split examples,0,3,3,23,589,"+var es = require('..')<\n>+process.stdin<\n>+    .pipe(es.map(function (data<c> callback) {<\n>+        for (var i = 0; i < data.length; i++) {<\n>+            if (data[i] == 0x61) {<\n>+                data[i] = 0x41<\n>+            }<\n>+        }<\n>+        callback(null<c> data)<\n>+    }))<\n>+    .pipe(process.stdout)<\n>+// echo abcdabcd | node map.js <\n>+// AbcdAbcd<\n>+var es = require('..')<\n>+process.stdin<\n>+    .pipe(es.split())<\n>+    .on('data'<c> function (data) {<\n>+        console.log('data: ' + data)<\n>+    })<\n>+// cat data | node map.js <\n>+// data: {""foo"": 1}<\n>+// data: {""foo"": 2}<\n>+// data: {""foo"": 3<c> ""bar"": ""test""}<\n>",,F
null,null,null,null,null,null,北川 <right9ctrl@outlook.com>,-1,-1,-1,-1,-1,-1,-1,Tue,8,12,4 Sep 2018,upgrade dependencies,0,1,1,614,20928,"+  ""name"": ""event-stream""<c><\n>+  ""version"": ""3.3.4""<c><\n>+  ""lockfileVersion"": 1<c><\n>+  ""requires"": true<c><\n>+  ""dependencies"": {<\n>+    ""assertions"": {<\n>+      ""version"": ""2.3.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/assertions/-/assertions-2.3.4.tgz""<c><\n>+      ""integrity"": ""sha1-qUM87R/OV8yZmvCWXRAI6WwnluY=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""fomatto"": ""git://github.com/BonsaiDen/Fomatto.git#468666f600b46f9067e3da7200fd9df428923ea6""<c><\n>+        ""render"": ""0.1.4""<c><\n>+        ""traverser"": ""1.0.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""traverser"": {<\n>+          ""version"": ""1.0.0""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/traverser/-/traverser-1.0.0.tgz""<c><\n>+          ""integrity"": ""sha1-b1nlgTdZruqzZGuPRRP9SmLk/iA=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""curry"": ""0.0.4""<\n>+          }<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""asynct"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/asynct/-/asynct-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-O7LFB9OhPyAAugWGmhp0DCGICRM=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ctrlflow"": ""0.0.3""<c><\n>+        ""test-cmd"": ""1.7.0""<\n>+      }<\n>+    }<c><\n>+    ""balanced-match"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-ibTRmasr7kneFk6gK4nORi1xt2c=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""brace-expansion"": {<\n>+      ""version"": ""1.1.11""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz""<c><\n>+      ""integrity"": ""sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""balanced-match"": ""1.0.0""<c><\n>+        ""concat-map"": ""0.0.1""<\n>+      }<\n>+    }<c><\n>+    ""concat-map"": {<\n>+      ""version"": ""0.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""ctrlflow"": {<\n>+      ""version"": ""0.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ctrlflow/-/ctrlflow-0.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-6WwYCJDcBcKztDc19SmnEpPhOcA=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""curry"": ""0.0.4""<\n>+      }<\n>+    }<c><\n>+    ""curry"": {<\n>+      ""version"": ""0.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/curry/-/curry-0.0.4.tgz""<c><\n>+      ""integrity"": ""sha1-F1DVGNkZxE89N/9E7caT3h8NX8s=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""d-utils"": {<\n>+      ""version"": ""2.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/d-utils/-/d-utils-2.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-NZxqACBJUW8ELbnkneMCIE4f7Dw=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""deep-equal"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/deep-equal/-/deep-equal-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-9dJgKStmDghO/0zbyfCK0yR0SLU=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""define-properties"": {<\n>+      ""version"": ""1.1.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz""<c><\n>+      ""integrity"": ""sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""object-keys"": ""1.0.12""<\n>+      }<\n>+    }<c><\n>+    ""defined"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/defined/-/defined-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-yY2bzvdWdBiOEQlpFRGZ45sfppM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""duplexer"": {<\n>+      ""version"": ""0.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/duplexer/-/duplexer-0.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-rOb/gIwc5mtX0ev5eXessCM0z8E=""<\n>+    }<c><\n>+    ""es-abstract"": {<\n>+      ""version"": ""1.12.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es-abstract/-/es-abstract-1.12.0.tgz""<c><\n>+      ""integrity"": ""sha512-C8Fx/0jFmV5IPoMOFPA9P9G5NtqW+4cOPit3MIuvR2t7Ag2K15EJTpxnHAYTzL+aYQJIESYeXZmDBfOBE1HcpA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""es-to-primitive"": ""1.1.1""<c><\n>+        ""function-bind"": ""1.1.1""<c><\n>+        ""has"": ""1.0.3""<c><\n>+        ""is-callable"": ""1.1.4""<c><\n>+        ""is-regex"": ""1.0.4""<\n>+      }<\n>+    }<c><\n>+    ""es-to-primitive"": {<\n>+      ""version"": ""1.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-RTVSSKiJeQNLZ5Lhm7gfK3l13Q0=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""is-callable"": ""1.1.4""<c><\n>+        ""is-date-object"": ""1.0.1""<c><\n>+        ""is-symbol"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""fomatto"": {<\n>+      ""version"": ""git://github.com/BonsaiDen/Fomatto.git#468666f600b46f9067e3da7200fd9df428923ea6""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""for-each"": {<\n>+      ""version"": ""0.3.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz""<c><\n>+      ""integrity"": ""sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""is-callable"": ""1.1.4""<\n>+      }<\n>+    }<c><\n>+    ""from"": {<\n>+      ""version"": ""0.1.7""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/from/-/from-0.1.7.tgz""<c><\n>+      ""integrity"": ""sha1-g8YK/Fi5xWmXAH7Rp2izqzA6RP4=""<\n>+    }<c><\n>+    ""fs.realpath"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-FQStJSMVjKpA20onh8sBQRmU6k8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""function-bind"": {<\n>+      ""version"": ""1.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz""<c><\n>+      ""integrity"": ""sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""glob"": {<\n>+      ""version"": ""7.1.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/glob/-/glob-7.1.3.tgz""<c><\n>+      ""integrity"": ""sha512-vcfuiIxogLV4DlGBHIUOwI0IbrJ8HWPc4MU7HzviGeNho/UJDfi6B5p3sHeWIQ0KGIU0Jpxi5ZHxemQfLkkAwQ==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""fs.realpath"": ""1.0.0""<c><\n>+        ""inflight"": ""1.0.6""<c><\n>+        ""inherits"": ""2.0.3""<c><\n>+        ""minimatch"": ""3.0.4""<c><\n>+        ""once"": ""1.4.0""<c><\n>+        ""path-is-absolute"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""has"": {<\n>+      ""version"": ""1.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/has/-/has-1.0.3.tgz""<c><\n>+      ""integrity"": ""sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""function-bind"": ""1.1.1""<\n>+      }<\n>+    }<c><\n>+    ""inflight"": {<\n>+      ""version"": ""1.0.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz""<c><\n>+      ""integrity"": ""sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""once"": ""1.4.0""<c><\n>+        ""wrappy"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""inherits"": {<\n>+      ""version"": ""2.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-callable"": {<\n>+      ""version"": ""1.1.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-callable/-/is-callable-1.1.4.tgz""<c><\n>+      ""integrity"": ""sha512-r5p9sxJjYnArLjObpjA4xu5EKI3CuKHkJXMhT7kwbpUyIFD1n5PMAsoPvWnvtZiNz7LjkYDRZhd7FlI0eMijEA==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-date-object"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-mqIOtq7rv/d/vTPnTKAbM1gdOhY=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-regex"": {<\n>+      ""version"": ""1.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-regex/-/is-regex-1.0.4.tgz""<c><\n>+      ""integrity"": ""sha1-VRdIm1RwkbCTDglWVM7SXul+lJE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""has"": ""1.0.3""<\n>+      }<\n>+    }<c><\n>+    ""is-symbol"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-PMWfAAJRlLarLjjbrmaJJWtmBXI=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""it-is"": {<\n>+      ""version"": ""1.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/it-is/-/it-is-1.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-RpcAgZg4pGVu1PF2lT9b/PU/SDs=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""assertions"": ""2.3.4""<c><\n>+        ""render"": ""0.1.4""<c><\n>+        ""style"": ""0.1.1""<c><\n>+        ""traverser"": ""0.0.5""<c><\n>+        ""trees"": ""0.0.4""<\n>+      }<\n>+    }<c><\n>+    ""ls-r"": {<\n>+      ""version"": ""0.2.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ls-r/-/ls-r-0.2.1.tgz""<c><\n>+      ""integrity"": ""sha1-sjmgH6p9QxSIdKZP6xHgrey2b6A=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ctrlflow"": ""4.1.3""<c><\n>+        ""d-utils"": ""2.3.3""<c><\n>+        ""optimist"": ""0.2.8""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""ctrlflow"": {<\n>+          ""version"": ""4.1.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/ctrlflow/-/ctrlflow-4.1.3.tgz""<c><\n>+          ""integrity"": ""sha1-MCi+xE8BocET/ZIG/E+ZgjN4QoY=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""curry"": ""0.0.4""<c><\n>+            ""d-utils"": ""1.4.0""<\n>+          }<c><\n>+          ""dependencies"": {<\n>+            ""d-utils"": {<\n>+              ""version"": ""1.4.0""<c><\n>+              ""resolved"": ""https://registry.npmjs.org/d-utils/-/d-utils-1.4.0.tgz""<c><\n>+              ""integrity"": ""sha1-RHbSSGduWDLG0Pxp4u0NEMFMn/c=""<c><\n>+              ""dev"": true<\n>+            }<\n>+          }<\n>+        }<c><\n>+        ""d-utils"": {<\n>+          ""version"": ""2.3.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/d-utils/-/d-utils-2.3.3.tgz""<c><\n>+          ""integrity"": ""sha1-utm7TWjxLr1VJvU1UI2D4/skFz0=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""macgyver"": {<\n>+      ""version"": ""1.10.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/macgyver/-/macgyver-1.10.1.tgz""<c><\n>+      ""integrity"": ""sha1-sJ0VmdizbtWxb1lYlRXZ0UvC/Yg=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""map-stream"": {<\n>+      ""version"": ""0.0.7""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/map-stream/-/map-stream-0.0.7.tgz""<c><\n>+      ""integrity"": ""sha1-ih8HiW2CsQkmvTdEokIACfiJdKg=""<\n>+    }<c><\n>+    ""minimatch"": {<\n>+      ""version"": ""3.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz""<c><\n>+      ""integrity"": ""sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""brace-expansion"": ""1.1.11""<\n>+      }<\n>+    }<c><\n>+    ""minimist"": {<\n>+      ""version"": ""1.2.0""<c><\n>+      ""resolved"": ""http://registry.npmjs.org/minimist/-/minimist-1.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-o1AIsg9BOD7sH7kU9M1d95omQoQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""object-inspect"": {<\n>+      ""version"": ""1.6.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/object-inspect/-/object-inspect-1.6.0.tgz""<c><\n>+      ""integrity"": ""sha512-GJzfBZ6DgDAmnuaM3104jR4s1Myxr3Y3zfIyN4z3UdqN69oSRacNK8UhnobDdC+7J2AHCjGwxQubNJfE70SXXQ==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""object-keys"": {<\n>+      ""version"": ""1.0.12""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/object-keys/-/object-keys-1.0.12.tgz""<c><\n>+      ""integrity"": ""sha512-FTMyFUm2wBcGHnH2eXmz7tC6IwlqQZ6mVZ+6dm6vZ4IQIHjs6FdNsQBuKGPuUUUY6NfJw2PshC08Tn6LzLDOag==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""once"": {<\n>+      ""version"": ""1.4.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/once/-/once-1.4.0.tgz""<c><\n>+      ""integrity"": ""sha1-WDsap3WWHUsROsF9nFC6753Xa9E=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""wrappy"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""optimist"": {<\n>+      ""version"": ""0.2.8""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/optimist/-/optimist-0.2.8.tgz""<c><\n>+      ""integrity"": ""sha1-6YGrfiaLRXlIWTtVZ0wJmoFcrDE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""wordwrap"": ""0.0.3""<\n>+      }<\n>+    }<c><\n>+    ""path-is-absolute"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-F0uSaHNVNP+8es5r9TpanhtcX18=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""path-parse"": {<\n>+      ""version"": ""1.0.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-parse/-/path-parse-1.0.6.tgz""<c><\n>+      ""integrity"": ""sha512-GSmOT2EbHrINBf9SR7CDELwlJ8AENk3Qn7OikK4nFYAu3Ote2+JYNVvkpAEQm3/TLNEJFD/xZJjzyxg3KBWOzw==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""pause-stream"": {<\n>+      ""version"": ""0.0.11""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/pause-stream/-/pause-stream-0.0.11.tgz""<c><\n>+      ""integrity"": ""sha1-/lo0sMvOErWqaitAPuLnO2AvFEU=""<c><\n>+      ""requires"": {<\n>+        ""through"": ""2.3.8""<\n>+      }<\n>+    }<c><\n>+    ""render"": {<\n>+      ""version"": ""0.1.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/render/-/render-0.1.4.tgz""<c><\n>+      ""integrity"": ""sha1-z7M6NOJgaFkdQYRp4j2Mxc4c7/U=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""traverser"": ""0.0.5""<\n>+      }<\n>+    }<c><\n>+    ""resolve"": {<\n>+      ""version"": ""1.7.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/resolve/-/resolve-1.7.1.tgz""<c><\n>+      ""integrity"": ""sha512-c7rwLofp8g1U+h1KNyHL/jicrKg1Ek4q+Lr33AL65uZTinUZHe30D5HlyN5V9NW0JX1D5dXQ4jqW5l7Sy/kGfw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""path-parse"": ""1.0.6""<\n>+      }<\n>+    }<c><\n>+    ""resumer"": {<\n>+      ""version"": ""0.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/resumer/-/resumer-0.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-8ej0YeQGS6Oegq883CqMiT0HZ1k=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""through"": ""2.3.8""<\n>+      }<\n>+    }<c><\n>+    ""should"": {<\n>+      ""version"": ""13.2.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/should/-/should-13.2.3.tgz""<c><\n>+      ""integrity"": ""sha512-ggLesLtu2xp+ZxI+ysJTmNjh2U0TsC+rQ/pfED9bUZZ4DKefP27D+7YJVVTvKsmjLpIi9jAa7itwDGkDDmt1GQ==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""should-equal"": ""2.0.0""<c><\n>+        ""should-format"": ""3.0.3""<c><\n>+        ""should-type"": ""1.4.0""<c><\n>+        ""should-type-adaptors"": ""1.1.0""<c><\n>+        ""should-util"": ""1.0.0""<\n>+      }<\n>+    }<c><\n>+    ""should-equal"": {<\n>+      ""version"": ""2.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/should-equal/-/should-equal-2.0.0.tgz""<c><\n>+      ""integrity"": ""sha512-ZP36TMrK9euEuWQYBig9W55WPC7uo37qzAEmbjHz4gfyuXrEUgF8cUvQVO+w+d3OMfPvSRQJ22lSm8MQJ43LTA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""should-type"": ""1.4.0""<\n>+      }<\n>+    }<c><\n>+    ""should-format"": {<\n>+      ""version"": ""3.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/should-format/-/should-format-3.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-m/yPdPo5IFxT04w01xcwPidxJPE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""should-type"": ""1.4.0""<c><\n>+        ""should-type-adaptors"": ""1.1.0""<\n>+      }<\n>+    }<c><\n>+    ""should-type"": {<\n>+      ""version"": ""1.4.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/should-type/-/should-type-1.4.0.tgz""<c><\n>+      ""integrity"": ""sha1-B1bYzoRt/QmEOmlHcZ36DUz/XPM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""should-type-adaptors"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/should-type-adaptors/-/should-type-adaptors-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha512-JA4hdoLnN+kebEp2Vs8eBe9g7uy0zbRo+RMcU0EsNy+R+k049Ki+N5tT5Jagst2g7EAja+euFuoXFCa8vIklfA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""should-type"": ""1.4.0""<c><\n>+        ""should-util"": ""1.0.0""<\n>+      }<\n>+    }<c><\n>+    ""should-util"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/should-util/-/should-util-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-yYzaN0qmsZDfi6h8mInCtNtiAGM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""split"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/split/-/split-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha512-mTyOoPbrivtXnwnIxZRFYRrPNtEFKlpB2fvjSnCQUiAA6qAZzqwna5envK4uk6OIeP17CsdF3rSBGYVBsU0Tkg==""<c><\n>+      ""requires"": {<\n>+        ""through"": ""2.3.8""<\n>+      }<\n>+    }<c><\n>+    ""stream-combiner"": {<\n>+      ""version"": ""0.2.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/stream-combiner/-/stream-combiner-0.2.2.tgz""<c><\n>+      ""integrity"": ""sha1-rsjLrBd7Vrb0+kec7YwZEs7lKFg=""<c><\n>+      ""requires"": {<\n>+        ""duplexer"": ""0.1.1""<c><\n>+        ""through"": ""2.3.8""<\n>+      }<\n>+    }<c><\n>+    ""stream-spec"": {<\n>+      ""version"": ""0.3.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/stream-spec/-/stream-spec-0.3.6.tgz""<c><\n>+      ""integrity"": ""sha1-L92sSge/Pp+JY8Z3prWmzCEVJV4=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""macgyver"": ""1.10.1""<\n>+      }<\n>+    }<c><\n>+    ""string.prototype.trim"": {<\n>+      ""version"": ""1.1.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/string.prototype.trim/-/string.prototype.trim-1.1.2.tgz""<c><\n>+      ""integrity"": ""sha1-0E3iyJ4Tf019IG8Ia17S+ua+jOo=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""define-properties"": ""1.1.3""<c><\n>+        ""es-abstract"": ""1.12.0""<c><\n>+        ""function-bind"": ""1.1.1""<\n>+      }<\n>+    }<c><\n>+    ""style"": {<\n>+      ""version"": ""0.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/style/-/style-0.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-4vq2WxuB0+AOvK2FTMWEuiMfJW0=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""curry"": ""0.0.4""<\n>+      }<\n>+    }<c><\n>+    ""tape"": {<\n>+      ""version"": ""4.9.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/tape/-/tape-4.9.1.tgz""<c><\n>+      ""integrity"": ""sha512-6fKIXknLpoe/Jp4rzHKFPpJUHDHDqn8jus99IfPnHIjyz78HYlefTGD3b5EkbQzuLfaEvmfPK3IolLgq2xT3kw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""deep-equal"": ""1.0.1""<c><\n>+        ""defined"": ""1.0.0""<c><\n>+        ""for-each"": ""0.3.3""<c><\n>+        ""function-bind"": ""1.1.1""<c><\n>+        ""glob"": ""7.1.3""<c><\n>+        ""has"": ""1.0.3""<c><\n>+        ""inherits"": ""2.0.3""<c><\n>+        ""minimist"": ""1.2.0""<c><\n>+        ""object-inspect"": ""1.6.0""<c><\n>+        ""resolve"": ""1.7.1""<c><\n>+        ""resumer"": ""0.0.0""<c><\n>+        ""string.prototype.trim"": ""1.1.2""<c><\n>+        ""through"": ""2.3.8""<\n>+      }<\n>+    }<c><\n>+    ""test-cmd"": {<\n>+      ""version"": ""1.7.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/test-cmd/-/test-cmd-1.7.0.tgz""<c><\n>+      ""integrity"": ""sha1-nldMSfOUcweeLyj+cWF4EtFH4xA=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ctrlflow"": ""4.1.3""<c><\n>+        ""d-utils"": ""2.1.1""<c><\n>+        ""ls-r"": ""0.2.1""<c><\n>+        ""optimist"": ""0.2.8""<c><\n>+        ""test-report"": ""1.1.2""<c><\n>+        ""test-report-view"": ""1.0.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""ctrlflow"": {<\n>+          ""version"": ""4.1.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/ctrlflow/-/ctrlflow-4.1.3.tgz""<c><\n>+          ""integrity"": ""sha1-MCi+xE8BocET/ZIG/E+ZgjN4QoY=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""curry"": ""0.0.4""<c><\n>+            ""d-utils"": ""1.4.0""<\n>+          }<c><\n>+          ""dependencies"": {<\n>+            ""d-utils"": {<\n>+              ""version"": ""1.4.0""<c><\n>+              ""resolved"": ""https://registry.npmjs.org/d-utils/-/d-utils-1.4.0.tgz""<c><\n>+              ""integrity"": ""sha1-RHbSSGduWDLG0Pxp4u0NEMFMn/c=""<c><\n>+              ""dev"": true<\n>+            }<\n>+          }<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""test-report"": {<\n>+      ""version"": ""1.1.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/test-report/-/test-report-1.1.2.tgz""<c><\n>+      ""integrity"": ""sha1-nCHcPuk/qpMwTfnl1Zo+ccMBxaQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""test-report-view"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/test-report-view/-/test-report-view-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-/Z8/hA/Hsp0/dhNweJ93gFsZ440=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""through"": {<\n>+      ""version"": ""2.3.8""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/through/-/through-2.3.8.tgz""<c><\n>+      ""integrity"": ""sha1-DdTJ/6q8NXlgsbckEV1+Doai4fU=""<\n>+    }<c><\n>+    ""traverser"": {<\n>+      ""version"": ""0.0.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/traverser/-/traverser-0.0.5.tgz""<c><\n>+      ""integrity"": ""sha1-xm84xFagwhqIAUsSI1gMfr4GMes=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""curry"": ""0.0.4""<\n>+      }<\n>+    }<c><\n>+    ""trees"": {<\n>+      ""version"": ""0.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/trees/-/trees-0.0.4.tgz""<c><\n>+      ""integrity"": ""sha1-L1H9m19khvcyyX4R7nVmcja+HVk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""should"": ""13.2.3""<c><\n>+        ""style"": ""0.1.1""<c><\n>+        ""traverser"": ""0.0.5""<\n>+      }<\n>+    }<c><\n>+    ""ubelt"": {<\n>+      ""version"": ""3.2.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ubelt/-/ubelt-3.2.2.tgz""<c><\n>+      ""integrity"": ""sha1-Ros+spc6rabxe5ff5zL1nZbiOwM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""wordwrap"": {<\n>+      ""version"": ""0.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-o9XabNXAvAAI03I0u68b7WMFkQc=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""wrappy"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=""<c><\n>+      ""dev"": true<\n>+    }<\n>+  }<\n>+    ""duplexer"": ""^0.1.1""<c><\n>+    ""from"": ""^0.1.7""<c><\n>+    ""map-stream"": ""0.0.7""<c><\n>+    ""pause-stream"": ""^0.0.11""<c><\n>+    ""split"": ""^1.0.1""<c><\n>+    ""stream-combiner"": ""^0.2.2""<c><\n>+    ""through"": ""^2.3.8""<\n>+    ""asynct"": ""^1.1.0""<c><\n>+    ""it-is"": ""^1.0.3""<c><\n>+    ""stream-spec"": ""^0.3.6""<c><\n>+    ""tape"": ""^4.9.1""<c><\n>+    ""ubelt"": ""^3.2.2""<\n>","-    ""through"": ""~2.3.1""<c><\n>-    ""duplexer"": ""~0.1.1""<c><\n>-    ""from"": ""~0""<c><\n>-    ""map-stream"": ""~0.1.0""<c><\n>-    ""pause-stream"": ""0.0.11""<c><\n>-    ""split"": ""0.3""<c><\n>-    ""stream-combiner"": ""~0.0.4""<\n>-    ""asynct"": ""*""<c><\n>-    ""it-is"": ""1""<c><\n>-    ""ubelt"": ""~3.2.2""<c><\n>-    ""stream-spec"": ""~0.3.5""<c><\n>-    ""tape"": ""~2.3.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,8,50,10 Oct 2017,Merge pull request #107 from Rolias/master Read Me Change Only,0,0,0,0,0,,,F
null,null,null,null,null,null,Tod Gentille,54,16,10,1,User,1,3507,Fri,17,55,6 Oct 2017,Update readme.markdown one more fix to formatting,0,0,1,6,646,+**NOTE**  - Maintaining Line Breaks  <\n>+If you want to process each line of the stream<c> transform the data<c> reassemble<c> and **KEEP** the line breaks the example will look like this:<\n>+This technique is mentioned in the [underlying documentation](https://www.npmjs.com/package/split#keep-matched-splitter) for the split npm package.<\n>,-**NOTE** Maintaining Line Breaks  <\n>-If you want to process each line of the stream<c> transform the data and reassemble and KEEP the line breaks the example will look like this<\n>-This is mentioned in the [underlying documentation](https://www.npmjs.com/package/split#keep-matched-splitter) for the split npm package.<\n>,F
null,null,null,null,null,null,Tod Gentille,54,16,10,1,User,1,3507,Fri,17,53,6 Oct 2017,Update Readme Fix formatting to original change,0,0,1,2,70,+**NOTE** Maintaining Line Breaks  <\n>,-**NOTE** Maintaining Line Breaks<\n>,F
null,null,null,null,null,null,Tod Gentille,54,16,10,1,User,1,3507,Fri,17,52,6 Oct 2017,Update readme Add a short paragraph and example on how to maintain line breaks and provide reference to the split package docs on this.,0,0,1,11,504,+**NOTE** Maintaining Line Breaks<\n>+If you want to process each line of the stream<c> transform the data and reassemble and KEEP the line breaks the example will look like this<\n>+```javascript<\n>+fs.createReadStream(file<c> {flags: 'r'})<\n>+  .pipe(es.split(/(\r?\n)/))<\n>+  .pipe(es.map(function (line<c> cb) {<\n>+    //do something with the line <\n>+    cb(null<c> line)<\n>+  }))<\n>+```<\n>+This is mentioned in the [underlying documentation](https://www.npmjs.com/package/split#keep-matched-splitter) for the split npm package.<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,13,50,22 Mar 2017,Merge pull request #103 from detailyang/patch-1 doc: layout tweaks,0,0,0,0,0,,,F
null,null,null,null,null,null,detailyang <detailyang@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Mon,21,58,20 Mar 2017,doc: layout tweaks,0,0,1,5,259,+<p><\n>+[![browser status](http://ci.testling.com/dominictarr/event-stream.png)](http://ci.testling.com/dominictarr/event-stream)<\n>+</p><\n>,-[![browser status](http://ci.testling.com/dominictarr/event-stream.png)]<\n>-(http://ci.testling.com/dominictarr/event-stream)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,19,23,17 Jul 2016,3.3.4,0,0,1,2,46,"+  ""version"": ""3.3.4""<c><\n>","-  ""version"": ""3.3.3""<c><\n>",F
null,null,null,null,null,null,Chris Andrejewski,118,44,73,2,User,1,2598,Sat,20,15,16 Jul 2016,un-es2015,0,0,1,4,118,+    process.nextTick(function () {<\n>+      stream.emit('end')<\n>+    })<\n>,-    process.nextTick(() => stream.emit('end'))<\n>,F
null,null,null,null,null,null,Chris Andrejewski,118,44,73,2,User,1,2598,Sat,20,7,16 Jul 2016,emits end if no streams,0,0,1,25,630,+  if (toMerge.length) {<\n>+    toMerge.forEach(function (e) {<\n>+      e.pipe(stream<c> {end: false})<\n>+      var ended = false<\n>+      e.on('end'<c> function () {<\n>+        if(ended) return<\n>+        ended = true<\n>+        endCount ++<\n>+        if(endCount == toMerge.length)<\n>+          stream.emit('end')<\n>+      })<\n>+  } else {<\n>+    process.nextTick(() => stream.emit('end'))<\n>+  }<\n>+  <\n>,-  toMerge.forEach(function (e) {<\n>-    e.pipe(stream<c> {end: false})<\n>-    var ended = false<\n>-    e.on('end'<c> function () {<\n>-      if(ended) return<\n>-      ended = true<\n>-      endCount ++<\n>-      if(endCount == toMerge.length)<\n>-        stream.emit('end')<\n>-  })<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,11,38,19 Jun 2016,3.3.3,0,0,1,2,46,"+  ""version"": ""3.3.3""<c><\n>","-  ""version"": ""3.3.2""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,11,38,19 Jun 2016,return from catch,0,0,1,2,69,+      return this.emit('error'<c> err)<\n>,-      this.emit('error'<c> err)<\n>,F
null,null,null,null,null,null,Yuri Astrakhan,131,31,63,0,User,0,2674,Sun,2,29,19 Jun 2016,Move emit out of try/catch,0,0,1,10,290,+    var mappedData<\n>+      mappedData = sync(data)<\n>+    } catch (err) {<\n>+    if (mappedData !== undefined)<\n>+      this.emit('data'<c> mappedData)<\n>,-      var mappedData = sync(data)<\n>-      if (typeof mappedData !== 'undefined')<\n>-        this.emit('data'<c> mappedData)<\n>-    }<\n>-    catch (err) {<\n>,F
null,null,null,null,null,null,Yuri Astrakhan,131,31,63,0,User,0,2674,Sat,18,46,18 Jun 2016,Handle mapSync() exceptions as stream errors This patch allows synchronious callback to properly report errors to the stream by throwing exceptions. mapSync() will convert them into the stream errors catchable with on(error ...),0,0,1,41,1056,+        stream.emit('end')<\n>+// writable stream<c> collects all events into an array<\n>+  stream.readable = true<\n>+  stream.readable = true<\n>+        stream.emit('error'<c> err)<\n>+es.mapSync = function (sync) {<\n>+    try {<\n>+      var mappedData = sync(data)<\n>+      if (typeof mappedData !== 'undefined')<\n>+        this.emit('data'<c> mappedData)<\n>+    }<\n>+    catch (err) {<\n>+      this.emit('error'<c> err)<\n>+    }<\n>+es.stringify = function () {<\n>+  return es.mapSync(function (e){<\n>+  })<\n>+// warn: just concatenates the string and then does str.split().join().<\n>+//<\n>,-        stream.emit('end') <\n>-// writable stream<c> collects all events into an array <\n>- <\n>-  stream.readable = true  <\n>- <\n>-  <\n>-  stream.readable = true  <\n>- <\n>-  <\n>-  <\n>-    <\n>-        stream.emit('error'<c> err)    <\n>-es.mapSync = function (sync) { <\n>-    var mappedData = sync(data)<\n>-    if (typeof mappedData !== 'undefined')<\n>-      this.emit('data'<c> mappedData)<\n>-es.stringify = function () { <\n>-  return es.mapSync(function (e){ <\n>-  }) <\n>-// warn: just concatenates the string and then does str.split().join(). <\n>-// <\n>-  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,21,24,15 Oct 2015,3.3.2,0,0,1,4,89,"+  ""version"": ""3.3.2""<c><\n>+  ""license"": ""MIT""<c><\n>","-  ""version"": ""3.3.1""<c><\n>-  ""license"" : ""MIT""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,21,24,15 Oct 2015,Merge pull request #69 from gdw2/master Clarify licensing,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,21,23,15 Oct 2015,Merge pull request #75 from sukima/patch-1 Add text on readArray v0.10 streams,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,12,51,17 Sep 2015,Merge pull request #88 from johnw424/patch-1 Fix spelling error in index.js,0,0,0,0,0,,,F
null,null,null,null,null,null,John Wang,48,0,37,1,User,0,2381,Wed,15,46,16 Sep 2015,Fix spelling error in index.js Fixed spelling error in console.error from attemping to parse to attempting to parse,0,0,1,2,125,+      return console.error(err<c> 'attempting to parse:'<c> data)<\n>,-      return console.error(err<c> 'attemping to parse:'<c> data)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,14,58,6 May 2015,3.3.1,0,0,1,2,46,"+  ""version"": ""3.3.1""<c><\n>","-  ""version"": ""3.3.0""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,14,58,6 May 2015,Merge pull request #87 from psalaets/patch-1 minor tweak to a few headings in readme,0,0,0,0,0,,,F
null,null,null,null,null,null,Paul Salaets <psalaets@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,22,46,5 May 2015,minor tweak to a few headings in readme Adjusts a few headings so they render nicely at https://www.npmjs.com/package/event-stream,0,0,1,8,346,+### [simple example](https://github.com/dominictarr/event-stream/blob/master/examples/pretty.js):<\n>+## map (asyncFunction)<\n>+## readable (asyncFunction) <\n>+## readArray (array)<\n>,-###[simple example](https://github.com/dominictarr/event-stream/blob/master/examples/pretty.js):<\n>-##map (asyncFunction)<\n>-##readable (asyncFunction) <\n>-##readArray (array)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,23,58,6 Mar 2015,3.3.0,0,0,1,2,46,"+  ""version"": ""3.3.0""<c><\n>","-  ""version"": ""3.2.2""<c><\n>",F
null,null,null,null,null,null,Wang Nan,69,3,100,8,User,1,3207,Sat,17,7,28 Feb 2015,Update readme.markdown updated readme to use correct stream,0,0,1,4,113,+  fs.createReadStream('input1.txt')<c><\n>+  fs.createReadStream('input2.txt')<\n>,-  process.stdout<c> <\n>-  process.stderr<\n>,F
null,null,null,null,null,null,Wang Nan,69,3,100,8,User,1,3207,Tue,14,27,3 Feb 2015,Update readme.markdown updated readme to show es.merge accepting array as input.,0,0,1,9,255,+## merge (stream1<c>...<c>streamN) or merge (streamArray) <\n>+It can also take an Array of streams as input like this: <\n>+```js<\n>+es.merge([<\n>+  process.stdout<c> <\n>+  process.stderr<\n>+]).pipe(fs.createWriteStream('output.log'));<\n>+```<\n>,-## merge (stream1<c>...<c>streamN)<\n>,F
null,null,null,null,null,null,Wang Nan,69,3,100,8,User,1,3207,Tue,11,49,3 Feb 2015,Update index.js added a check for first element of `toMerge` object.,0,0,1,2,125,+  if (toMerge.length === 1 && (toMerge[0] instanceof Array)) {<\n>,-  if (toMerge.length === 1 && (toMerge instanceof Array)) {<\n>,F
null,null,null,null,null,null,Nan Wang <nantas@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,11,39,3 Feb 2015,check if es.merge arguments object is an array. if so gets the first element and continue with merge.,0,0,2,12,423,+  if (toMerge.length === 1 && (toMerge instanceof Array)) {<\n>+    toMerge = toMerge[0] //handle array as arguments object<\n>+  }<\n>+  var endCount = 0<\n>+    if (++endCount === 2) t.done()<\n>+  })<\n>+  var writer2 = es.writeArray(function (err<c> array){<\n>+    if(err) throw err //unpossible<\n>+    it(array.sort()).deepEqual(even.concat(odd).sort())<\n>+    if (++endCount === 2) t.done()<\n>+  es.merge([r1<c> r2]).pipe(writer2)<\n>,-    t.done() <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,23,7,2 Feb 2015,3.2.2,0,0,1,2,46,"+  ""version"": ""3.2.2""<c><\n>","-  ""version"": ""3.2.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,23,7,2 Feb 2015,update split,0,0,1,2,42,"+    ""split"": ""0.3""<c><\n>","-    ""split"": ""0.2""<c><\n>",F
null,null,null,null,null,null,Tejesh Mehta <tejesh.mehta@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,12,57,31 Jan 2015,broken test: when replacing whitespace,0,0,1,22,858,"+  <c> fizzbuzzwhitespce = '  12F4BF78FB11F1314FB1617F19BF2223FB26F2829FB3132F34BF3738FB41F4344FB4647F49BF5253FB56F5859FB6162F64BF6768FB71F7374FB7677F79BF8283FB86F8889FB9192F94BF9798FB  '<\n>+     ! (i % 3 || i % 5) ? ""FB"" :<\n>+      it(string).equal(fizz7buzz)<\n>+exports ['fizz buzz replace whitespace using regexp'] = function (test) {<\n>+  var split = es.split(/(1)/)<\n>+  var replaceLeading = es.replace(/^[\s]*/<c> '')<\n>+  var replaceTrailing = es.replace(/[\s]*$/<c> '')<\n>+//  var x = spec(replace).through()<\n>+  split<\n>+    .pipe(replaceLeading)<\n>+    .pipe(replaceTrailing)<\n>+    .pipe(es.join(function (err<c> string) {<\n>+      it(string).equal(fizzbuzz)<\n>+    }))<\n>+    replaceTrailing.on('close'<c> function () {<\n>+//      x.validate()<\n>+      test.done()<\n>+    })<\n>+  split.write(fizzbuzz)<\n>+  split.end()<\n>","-     ! (i % 3 || i % 5) ? ""FB"" :    <\n>-      it(string).equal(fizz7buzz) <\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,12,4,20 Jan 2015,Merge pull request #80 from austinpray/patch-1 fix grammar,0,0,0,0,0,,,F
null,null,null,null,null,null,Austin Pray,76,65,243,65,User,1,2542,Sun,21,51,18 Jan 2015,fix grammar,0,0,1,2,183,+Counts how many streams were passed to it and emits end only when all streams emitted end.<\n>,-Counts how many streams was passed to it and emits end only when all streams emitted end.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,9,36,30 Dec 2014,3.2.1,0,0,1,2,46,"+  ""version"": ""3.2.1""<c><\n>","-  ""version"": ""3.2.0""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,9,35,30 Dec 2014,Merge pull request #79 from samolsen/eswait_doc Updated documentation to indicate es.wait may return a buffer,0,0,0,0,0,,,F
null,null,null,null,null,null,Sam Olsen <olsensh@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sun,22,56,28 Dec 2014,Updated documentation to indicate es.wait may return a buffer as its data argument,0,0,1,6,313,+joins chunks of a stream into a single string or buffer. <\n>+complete string/buffer when it receives the 'end' event.<\n>+readStream.pipe(es.wait(function (err<c> body) {<\n>,-joins chunks of a stream into a single string. <\n>-complete string when it receives the 'end' event.<\n>-readStream.pipe(es.wait(function (err<c> text) {<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,20,50,27 Dec 2014,drop travis support for 0.8,0,0,1,1,9,,-  - 0.8<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,19,57,27 Dec 2014,3.2.0,0,0,1,2,46,"+  ""version"": ""3.2.0""<c><\n>","-  ""version"": ""3.1.7""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,19,57,27 Dec 2014,npm prepublish script,0,0,1,1,41,"+    ""prepublish"": ""npm ls && npm test""<c><\n>",,F
null,null,null,null,null,null,Carl Lei,33,11,22,0,User,0,2949,Sat,14,36,27 Dec 2014,Change emitError to error in .parse() options.,0,0,3,10,696,+  var emitError = !!(options ? options.error : false)<\n>+for another behaviour<c> transforms created by `es.parse({error: true})` will<\n>+emit error events for exceptions thrown from `JSON.parse`<c> unmodified.<\n>+exports ['es.parse({error: true(thy)}) emits error events from parsing'] = function (test) {<\n>+  var parseStream = es.parse({error: 1})<\n>,-  var emitError = !!(options ? options.emitError : false)<\n>-for another behaviour<c> transforms created by `es.parse({emitError: true})`<\n>-will emit error events for exceptions thrown from `JSON.parse`<c> unmodified.<\n>-exports ['es.parse({emitError: true(thy)}) emits error events from parsing'] = function (test) {<\n>-  var parseStream = es.parse({emitError: 1})<\n>,F
null,null,null,null,null,null,Carl Lei,33,11,22,0,User,0,2949,Sat,13,58,27 Dec 2014,Add option to .parse() to emit error events for parsing errors.,0,1,2,35,1240,+es.parse = function (options) {<\n>+  var emitError = !!(options ? options.emitError : false)<\n>+      if (emitError)<\n>+        return this.emit('error'<c> err)<\n>+use with `es.split`.  By default it logs parsing errors by `console.error`;<\n>+for another behaviour<c> transforms created by `es.parse({emitError: true})`<\n>+will emit error events for exceptions thrown from `JSON.parse`<c> unmodified.<\n>+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+exports ['es.parse() writes parsing errors with console.error'] = function (test) {<\n>+  var parseStream = es.parse()<\n>+  var oldConsoleError = console.error<\n>+  console.error = function () {<\n>+    console.error = oldConsoleError<\n>+    it(arguments.length > 0).ok()<\n>+    test.done()<\n>+  }<\n>+  // bare word is not valid JSON<\n>+  parseStream.write('A')<\n>+exports ['es.parse({emitError: true(thy)}) emits error events from parsing'] = function (test) {<\n>+  var parseStream = es.parse({emitError: 1})<\n>+  var expectedError<\n>+  try {<\n>+    JSON.parse('A')<\n>+  } catch(e) {<\n>+    expectedError = e<\n>+  }<\n>+  parseStream.on('error'<c> function (e) {<\n>+    it(e).deepEqual(expectedError)<\n>+    process.nextTick(function () {<\n>+      test.done()<\n>+    })<\n>+  }).write('A')<\n>,-es.parse = function () { <\n>-use with `es.split`<\n>,F
null,null,null,null,null,null,Devin Weaver,243,453,84,55,User,0,3741,Mon,16,5,10 Nov 2014,Add text on readArray v0.10 streams In response to issue #60,0,0,1,6,452,"+<c> which are compatible with [0.10 streams](http://nodejs.org/api/stream.html ""Stream"").<\n>+If you want the stream behave like a 0.10 stream you will need to wrap it using [`Readable.wrap()`](http://nodejs.org/api/stream.html#stream_readable_wrap_stream) function. Example:<\n>+``` js<\n>+	var s = new stream.Readable({objectMode: true}).wrap(es.readArray([1<c>2<c>3]));<\n>+```<\n>","-<c> which are compatible with [0.10 streams](http://nodejs.org/api/stream.html ""Stream"")<\n>",F
null,null,null,null,null,null,gdw2 <gdwarner@Gmail.com>,-1,-1,-1,-1,-1,-1,-1,Mon,12,47,28 Jul 2014,Clarify licensing,0,0,1,1,22,"+  ""license"" : ""MIT""<c><\n>",,F
null,null,null,null,null,null,gdw2 <gdwarner@Gmail.com>,-1,-1,-1,-1,-1,-1,-1,Mon,12,46,28 Jul 2014,Clarify licensing,0,0,1,3,135,+The MIT License (MIT)<\n>+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.<\n>,-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,18,4,20 Jul 2014,3.1.7,0,0,1,2,46,"+  ""version"": ""3.1.7""<c><\n>","-  ""version"": ""3.1.6""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,18,4,20 Jul 2014,Merge branch master of git://github.com/dominictarr/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,18,3,20 Jul 2014,Merge pull request #66 from treyhunner/spelling Fix some spelling mistakes in README,0,0,0,0,0,,,F
null,null,null,null,null,null,Trey Hunner,238,36,530,74,User,1,3356,Sat,19,4,19 Jul 2014,Fix spelling of convenience,0,0,1,2,151,+Convenience function for parsing JSON chunks. For newline separated JSON<c><\n>,-Convienience function for parsing JSON chunks. For newline separated JSON<c><\n>,F
null,null,null,null,null,null,Trey Hunner,238,36,530,74,User,1,3356,Sat,19,4,19 Jul 2014,Fix spelling of occurrences,0,0,1,2,175,+Replace all occurrences of `from` with `to`. `from` may be a `String` or a `RegExp`.  <\n>,-Replace all occurences of `from` with `to`. `from` may be a `String` or a `RegExp`.  <\n>,F
null,null,null,null,null,null,Trey Hunner,238,36,530,74,User,1,3356,Sat,19,4,19 Jul 2014,Fix spelling of parameter,0,0,1,2,284,+`split` takes the same arguments as `string.split` except it defaults to '\n' instead of '<c>'<c> and the optional `limit` parameter is ignored.<\n>,-`split` takes the same arguments as `string.split` except it defaults to '\n' instead of '<c>'<c> and the optional `limit` paremeter is ignored.<\n>,F
null,null,null,null,null,null,Trey Hunner,238,36,530,74,User,1,3356,Sat,19,3,19 Jul 2014,Fix spelling of synchronous,0,0,1,6,434,+Re-emits data synchronously. Easy way to create synchronous through streams.<\n>+this function is the basis for most of the synchronous streams in `event-stream`.<\n>+Create a through stream from an asynchronous function.  <\n>,-Reemits data synchronously. Easy way to create syncronous through streams.<\n>-this function is the basis for most of the syncronous streams in `event-stream`.<\n>-Create a through stream from an asyncronous function.  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,18,1,19 Jun 2014,3.1.6,0,0,1,2,46,"+  ""version"": ""3.1.6""<c><\n>","-  ""version"": ""3.1.5""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,18,0,19 Jun 2014,Merge pull request #64 from sorrycc/master add buffer support for es.wait,0,0,0,0,0,,,F
null,null,null,null,null,null,chencheng <sorrycc@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,12,27,19 Jun 2014,add buffer support for es.wait,0,0,1,6,232,+  var arr = []<\n>+  return es.through(function (data) { arr.push(data) }<c><\n>+      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)<\n>+        : arr.join('')<\n>,-  var body = ''<\n>-  return es.through(function (data) { body += data }<c><\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,12,5,9 Jun 2014,Merge pull request #61 from felixrabe/patch-1 readme.markdown: Fix an ... methods typo,0,0,0,0,0,,,F
null,null,null,null,null,null,Felix Rabe,58,42,15,1,User,0,3198,Sun,22,8,8 Jun 2014,readme.markdown: Fix an ... methods typo,0,0,1,2,149,+Pass in optional `write` and `end` methods. They will be called in the <\n>,-Pass in an optional `write` and `end` methods. They will be called in the <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,6,0,30 Apr 2014,3.1.5,0,0,1,2,46,"+  ""version"": ""3.1.5""<c><\n>","-  ""version"": ""3.1.4""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,5,59,30 Apr 2014,Merge pull request #59 from Magomogo/recursive-next-tick-fix Recursive next tick fix,0,0,0,0,0,,,F
null,null,null,null,null,null,Magomogo <mgnatenko@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,4,46,30 Apr 2014,fix compatible to nodejs 0.8,0,0,1,3,123,+  <c> immediately = global.setImmediate || process.nextTick;<\n>+    immediately(function () {<\n>,-    setImmediate(function () {<\n>,F
null,null,null,null,null,null,Magomogo <mgnatenko@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,4,25,30 Apr 2014,replaced recursive process.nextTick() with setImmediate(),0,0,2,20,624,+    setImmediate(function () {<\n>+    test.done()<\n>+exports ['does not raise a warning: Recursive process.nextTick detected'] = function (test) {<\n>+    var readThisDelayed;<\n>+    u.delay(function () {<\n>+        readThisDelayed = [1<c> 3<c> 5];<\n>+    })();<\n>+    es.readable(function (count<c> callback) {<\n>+        if (readThisDelayed) {<\n>+            var that = this;<\n>+            readThisDelayed.forEach(function (item) {<\n>+                that.emit('data'<c> item);<\n>+            });<\n>+            this.emit('end');<\n>+            test.done();<\n>+        }<\n>+        callback();<\n>+    });<\n>,-    process.nextTick(function () {<\n>-    test.done()     <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,18,14,28 Apr 2014,3.1.4,0,0,1,2,46,"+  ""version"": ""3.1.4""<c><\n>","-  ""version"": ""3.1.3""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,18,12,28 Apr 2014,Merge branch fix-merge-bug of github.com:justphil/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,10,41,17 Apr 2014,3.1.3,0,0,1,2,46,"+  ""version"": ""3.1.3""<c><\n>","-  ""version"": ""3.1.2""<c><\n>",F
null,null,null,null,null,null,Philipp Tarasiewicz <philipp.tarasiewicz@googlemail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,12,34,16 Apr 2014,Fix bug in merge() function If output stream is destroyed input streams are now properly destroyed too,0,0,1,2,70,+    toMerge.forEach(function (e) {<\n>,-    merge.forEach(function (e) {<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,20,33,13 Apr 2014,3.1.2,0,0,1,2,46,"+  ""version"": ""3.1.2""<c><\n>","-  ""version"": ""3.1.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,20,33,13 Apr 2014,update all the idioms thanks @giacecco,0,0,1,32,1220,+  var inspect = require('util').inspect<\n>+  process.stdin                        //connect streams together with `pipe`<\n>+    .pipe(es.split())                  //split stream to break on newlines<\n>+    .pipe(es.map(function (data<c> cb) { //turn this async function into a stream<\n>+      cb(null<\n>+        <c> inspect(JSON.parse(data)))   //render it nicely<\n>+    }))<\n>+    .pipe(process.stdout)              // pipe it to stdout !<\n>+fs.createReadStream(file<c> {flags: 'r'})<\n>+  .pipe(es.split())<\n>+  .pipe(es.map(function (line<c> cb) {<\n>+    //do something with the line <\n>+    cb(null<c> line)<\n>+  }))<\n>,-  es.pipeline(                         //connect streams together with `pipe`<\n>-    process.openStdin()<c>              //open stdin<\n>-    es.split()<c>                       //split stream to break on newlines<\n>-    es.map(function (data<c> callback) {//turn this async function into a stream<\n>-      callback(null<\n>-        <c> inspect(JSON.parse(data)))  //render it nicely<\n>-    })<c><\n>-    process.stdout                    // pipe it to stdout !<\n>-    )<\n>-  }<\n>-  es.pipeline(<\n>-    fs.createReadStream(file<c> {flags: 'r'})<c><\n>-    es.split()<c><\n>-    es.map(function (line<c> cb) {<\n>-       //do something with the line <\n>-       cb(null<c> line)<\n>-    })<\n>-  )<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,18,33,13 Apr 2014,depreciate event-stream pipe has been chainable since node@0.6,0,0,1,16,742,,-## pipeline (stream1<c>...<c>streamN)<\n>-Turn a pipeline into a single stream. `pipeline` returns a stream that writes to the first stream<\n>-and reads from the last stream. <\n>-Listening for 'error' will recieve errors from all streams inside the pipe.<\n>-> `connect` is an alias for `pipeline`.<\n>-``` js<\n>-  es.pipeline(                         //connect streams together with `pipe`<\n>-    process.openStdin()<c>              //open stdin<\n>-    es.split()<c>                       //split stream to break on newlines<\n>-    es.map(function (data<c> callback) {//turn this async function into a stream<\n>-      callback(null<\n>-        <c> inspect(JSON.parse(data)))  //render it nicely<\n>-    })<c><\n>-    process.stdout                    // pipe it to stdout !<\n>-    )<\n>-```<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,17,12,27 Mar 2014,3.1.1,0,0,1,2,46,"+  ""version"": ""3.1.1""<c><\n>","-  ""version"": ""3.1.0""<c><\n>",F
null,null,null,null,null,null,blopker <lopkerk@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,17,23,26 Mar 2014,Allow adding more than 11 streams to es.merge,0,0,1,1,66,+  stream.setMaxListeners(0) // allow adding more than 11 streams<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,17,29,3 Feb 2014,Merge pull request #51 from kevinsawicki/patch-1 Use `for IO` instead of `of IO`,0,0,0,0,0,,,F
null,null,null,null,null,null,Kevin Sawicki,188,14,4418,9,User,1,3066,Sun,13,6,2 Feb 2014,Use `for IO` instead of `of IO`,0,0,1,2,85,+Normally<c> streams are only used for IO<c>  <\n>,-Normally<c> streams are only used of IO<c>  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,14,27,9 Jan 2014,test 0.8 and 0.10,0,0,1,2,21,"+  - ""0.10""<\n>",-  - 0.6<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,14,19,9 Jan 2014,3.1.0,0,0,1,2,47,"+  ""version"": ""3.1.0""<c><\n>","-  ""version"": ""3.0.21""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,14,17,9 Jan 2014,update map-stream@~0.1.0,0,0,1,2,58,"+    ""map-stream"": ""~0.1.0""<c><\n>","-    ""map-stream"": ""~0.0.3""<c><\n>",F
null,null,null,null,null,null,Vsevolod Strukchinsky <floatdrop@yandex-team.ru>,-1,-1,-1,-1,-1,-1,-1,Sat,1,43,4 Jan 2014,Include merge/concat method in readme Closes #47,0,0,1,13,653,+Create a through stream that emits `separator` between each chunk<c> just like Array#join.<\n>+## merge (stream1<c>...<c>streamN)<\n>+> concat → merge<\n>+Merges streams into one and returns it.<\n>+Incoming data will be emitted as soon it comes into - no ordering will be applied (for example: `data1 data1 data2 data1 data2` - where `data1` and `data2` is data from two streams).<\n>+Counts how many streams was passed to it and emits end only when all streams emitted end.<\n>+```js<\n>+es.merge(<\n>+  process.stdout<c><\n>+  process.stderr<\n>+).pipe(fs.createWriteStream('output.log'));<\n>+```<\n>,-create a through stream that emits `separator` between each chunk<c> just like Array#join.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,1,58,12 Dec 2013,3.0.21,0,0,1,2,48,"+  ""version"": ""3.0.21""<c><\n>","-  ""version"": ""3.0.20""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,1,3,12 Dec 2013,use stream-combiner@~0.0.4,0,0,1,2,66,"+    ""stream-combiner"": ""~0.0.4""<\n>","-    ""stream-combiner"": ""~0.0.3""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,17,41,11 Dec 2013,3.0.20,0,0,1,2,48,"+  ""version"": ""3.0.20""<c><\n>","-  ""version"": ""3.0.19""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,17,40,11 Dec 2013,probably some weird streams2 thing,0,0,1,4,114,+//  var x = spec(replace).through()<\n>+//      x.validate()<\n>,-  var x = spec(replace).through()<\n>-      x.validate()<\n>,F
null,null,null,null,null,null,Feross Aboukhadijeh,139,16,8708,229,User,1,3629,Tue,23,18,10 Dec 2013,3.0.19,0,0,1,2,48,"+  ""version"": ""3.0.19""<c><\n>","-  ""version"": ""3.0.18""<c><\n>",F
null,null,null,null,null,null,Feross Aboukhadijeh,139,16,8708,229,User,1,3629,Tue,23,17,10 Dec 2013,update all deps i need this module to use the newest version of duplexer (0.1.1) in order to fix a downstream bug in testling. let’s update all the deps while we’re at it. tests pass!,0,0,1,12,329,"+    ""duplexer"": ""~0.1.1""<c><\n>+    ""pause-stream"": ""0.0.11""<c><\n>+    ""stream-combiner"": ""~0.0.3""<\n>+    ""ubelt"": ""~3.2.2""<c><\n>+    ""stream-spec"": ""~0.3.5""<c><\n>+    ""tape"": ""~2.3.0""<\n>","-    ""duplexer"": ""~0.0.2""<c><\n>-    ""pause-stream"": ""0.0.10""<c><\n>-    ""stream-combiner"": ""0.0.0""<\n>-    ""ubelt"": ""~2.9""<c><\n>-    ""stream-spec"": ""~0.2""<c><\n>-    ""tape"": ""~0.1.5""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,22,37,4 Dec 2013,3.0.18,0,0,1,2,48,"+  ""version"": ""3.0.18""<c><\n>","-  ""version"": ""3.0.17""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,22,37,4 Dec 2013,Merge branch master of github.com:dominictarr/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,22,25,4 Dec 2013,3.0.17,0,0,1,2,48,"+  ""version"": ""3.0.17""<c><\n>","-  ""version"": ""3.0.16""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,22,24,4 Dec 2013,update map-stream,0,0,1,2,57,"+    ""map-stream"": ""~0.0.3""<c><\n>","-    ""map-stream"": ""0.0.2""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,20,33,26 Nov 2013,Merge pull request #43 from varfoo/master Fixed typo in wait documentation,0,0,0,0,0,,,F
null,null,null,null,null,null,varfoo <msmith@apaxsoftware.com>,-1,-1,-1,-1,-1,-1,-1,Tue,14,42,26 Nov 2013,Fixed typo in wait documentation,0,0,1,2,96,+readStream.pipe(es.wait(function (err<c> text) {<\n>,-readStream.pipe(es.join(function (err<c> text) {<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,6,28,20 Nov 2013,Merge pull request #40 from parshap/master Add link to stream-reduce module,0,0,0,0,0,,,F
null,null,null,null,null,null,Parsha Pourkhomami,128,60,70,79,User,0,3300,Mon,17,28,18 Nov 2013,Add link to stream-reduce module,0,0,1,13,597,"+# Other Stream Modules<\n>+These modules are not included as a part of *EventStream* but may be<\n>+useful when working with streams.<\n>+## [reduce (syncFunction<c> initial)](https://github.com/parshap/node-stream-reduce)<\n>+Like `Array.prototype.reduce` but for streams. Given a sync reduce<\n>+function and an initial value it will return a through stream that emits<\n>+a single data event with the reduced value once the input stream ends.<\n>+``` js<\n>+var reduce = require(""stream-reduce"");<\n>+process.stdin.pipe(reduce(function(acc<c> data) {<\n>+  return acc + data.length;<\n>+  console.log(""stdin size:""<c> length);<\n>+```<\n>",,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,22,58,9 Oct 2013,Merge pull request #38 from slashdotdash/patch-1 Corrected link to Nodes streams API documentation in README.,0,0,0,0,0,,,F
null,null,null,null,null,null,Ben Smith <ben@slashdotdash.net>,-1,-1,-1,-1,-1,-1,-1,Wed,22,35,9 Oct 2013,Corrected link to Nodes streams API documentation in README.,0,0,1,2,210,"+[Streams](http://nodejs.org/api/stream.html ""Stream"") are node's best and most misunderstood idea<c> and <\n>","-[Streams](http://nodejs.org/api/strems.html ""Stream"") are node's best and most misunderstood idea<c> and <\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,16,10,13 Jul 2013,3.0.16,0,0,1,2,48,"+  ""version"": ""3.0.16""<c><\n>","-  ""version"": ""3.0.15""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,16,10,13 Jul 2013,link to both versions of the stream api docs,0,0,1,6,516,"+`event-stream` creates <\n>+[0.8 streams](https://github.com/joyent/node/blob/v0.8/doc/api/stream.markdown)<\n>+<c> which are compatible with [0.10 streams](http://nodejs.org/api/stream.html ""Stream"")<\n>+>NOTE: I shall use the term <em>""through stream""</em> to refer to a stream that is writable <em>and</em> readable.  <\n>","-Stream API docs: [nodejs.org/api/streams](http://nodejs.org/api/stream.html ""Stream"")<\n>-NOTE: I shall use the term <em>""through stream""</em> to refer to a stream that is writable <em>and</em> readable.  <\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,53,13 Jul 2013,Merge pull request #33 from natlownes/master correct link to streams docs in readme,0,0,0,0,0,,,F
null,null,null,null,null,null,Nat Lownes,112,65,29,45,User,1,3964,Sat,11,33,13 Jul 2013,readme link correction,0,0,1,2,129,+[node Stream documentation](http://nodejs.org/api/stream.html)<\n>,-[node Stream documentation](http://nodejs.org/api/streams.html)<\n>,F
null,null,null,null,null,null,Nat Lownes,112,65,29,45,User,1,3964,Sat,11,28,13 Jul 2013,Update readme.markdown correct link to node streams docs,0,0,1,2,175,"+Stream API docs: [nodejs.org/api/streams](http://nodejs.org/api/stream.html ""Stream"")<\n>","-Stream API docs: [nodejs.org/api/streams](http://nodejs.org/api/streams.html ""Stream"")<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,16,25,18 Jun 2013,3.0.15,0,0,1,2,48,"+  ""version"": ""3.0.15""<c><\n>","-  ""version"": ""3.0.14""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,8,25,18 Jun 2013,Merge pull request #31 from krisajenkins/patch-1 Correcting a README typo.,0,0,0,0,0,,,F
null,null,null,null,null,null,Kris Jenkins,239,72,297,53,User,0,3263,Tue,10,43,18 Jun 2013,Correcting a README typo.,0,0,1,2,209,"+[Streams](http://nodejs.org/api/strems.html ""Stream"") are node's best and most misunderstood idea<c> and <\n>","-[Streams](http://nodejs.org/api/strems.html ""Stream"") are nodes best and most misunderstood idea<c> and <\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,0,37,23 Apr 2013,3.0.14,0,0,1,2,48,"+  ""version"": ""3.0.14""<c><\n>","-  ""version"": ""3.0.13""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,0,37,23 Apr 2013,update some modules,0,0,1,12,400,"+    ""through"": ""~2.3.1""<c><\n>+    ""map-stream"": ""0.0.2""<c><\n>+    ""pause-stream"": ""0.0.10""<c><\n>+  ""author"": ""Dominic Tarr <dominic.tarr@gmail.com> (http://bit.ly/dominictarr)""<\n>","-    ""through"": ""1.1.0""<c><\n>-    ""map-stream"": ""0.0.1""<c><\n>-    ""pause-stream"": ""0.0.4""<c><\n>-  ""author"": ""Dominic Tarr <dominic.tarr@gmail.com> (http://bit.ly/dominictarr)""<c><\n>-  ""optionalDependencies"": {}<c><\n>-  ""engines"": {<\n>-    ""node"": ""*""<\n>-  }<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,10,3,27 Mar 2013,3.0.13,0,0,1,2,48,"+  ""version"": ""3.0.13""<c><\n>","-  ""version"": ""3.0.12""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,3,3,27 Mar 2013,Merge pull request #27 from vanthome/patch-1 Update readme.markdown,0,0,0,0,0,,,F
null,null,null,null,null,null,Thomas <thomas.hoppe@n-fuse.de>,-1,-1,-1,-1,-1,-1,-1,Wed,9,12,27 Mar 2013,Update readme.markdown Updated link,0,0,1,2,209,"+[Streams](http://nodejs.org/api/strems.html ""Stream"") are nodes best and most misunderstood idea<c> and <\n>","-[Streams](http://nodejs.org/api/streams.html ""Stream"") are nodes best and most misunderstood idea<c> and <\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,13,18,9 Mar 2013,3.0.12,0,0,1,2,48,"+  ""version"": ""3.0.12""<c><\n>","-  ""version"": ""3.0.11""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,13,3,9 Mar 2013,Merge branch master of github.com:dominictarr/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,16,2,8 Mar 2013,Merge pull request #26 from RubyTuesdayDONO/patch-1 Fix spelling of separator,0,0,0,0,0,,,F
null,null,null,null,null,null,RubyTuesdayDONO <ReubenGarrett@GMail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,17,29,8 Mar 2013,Fix spelling of separator corrected spelling of separator from seperator (occasionally gets me too). ,0,0,1,6,374,+## join (separator)<\n>+create a through stream that emits `separator` between each chunk<c> just like Array#join.<\n>+Convienience function for parsing JSON chunks. For newline separated JSON<c><\n>,-## join (seperator)<\n>-create a through stream that emits `seperator` between each chunk<c> just like Array#join.<\n>-Convienience function for parsing JSON chunks. For newline seperated JSON<c><\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,20,16,5 Feb 2013,uupdate split,0,0,1,2,42,"+    ""split"": ""0.2""<c><\n>","-    ""split"": ""0.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,17,33,6 Jan 2013,3.0.11,0,0,1,2,48,"+  ""version"": ""3.0.11""<c><\n>","-  ""version"": ""3.0.10""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,17,33,6 Jan 2013,npm run test_tap,0,0,1,3,153,"+    ""test"": ""asynct test/""<c><\n>+    ""test_tap"": ""set -e; for t in test/*.js; do node $t; done""<\n>","-    ""test"": ""set -e; for t in test/*.js; do node $t; done""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,17,32,6 Jan 2013,attempt to port to tape,0,1,12,26,696,+require('./helper')(module)<\n>+var tape = require('tape')<\n>+module.exports = function (m) {<\n>+  if(m.parent) return<\n>+  for(var name in m.exports) {<\n>+    tape(name<c> function (t) {<\n>+      console.log('start'<c> name)<\n>+      t.done = t.end<\n>+      m.exports[name](t)<\n>+    })<\n>+  }<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+  console.log('readable')<\n>+  return test.end()<\n>+  console.log('readable')<\n>+      console.log('readable')<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>+require('./helper')(module)<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,17,29,6 Jan 2013,update split,0,0,1,7,209,"+    ""split"": ""0.1""<c><\n>+    ""stream-spec"": ""~0.2""<c><\n>+    ""tape"": ""~0.1.5""<\n>+    ""test"": ""set -e; for t in test/*.js; do node $t; done""<\n>","-    ""split"": ""0.0.0""<c><\n>-    ""stream-spec"": ""~0.2""<\n>-    ""test"": ""asynct test/""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,20,49,12 Dec 2012,testling,0,0,1,21,288,"+  ""testling"": {<\n>+    ""files"": ""test/*.js""<c><\n>+    ""browsers"": {<\n>+      ""ie"": [<\n>+        8<c><\n>+        9<\n>+      ]<c><\n>+      ""firefox"": [<\n>+        13<\n>+      ]<c><\n>+      ""chrome"": [<\n>+        20<\n>+      ]<c><\n>+      ""safari"": [<\n>+        5.1<\n>+      ]<c><\n>+      ""opera"": [<\n>+        12<\n>+      ]<\n>+    }<\n>+  }<c><\n>",,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,19,58,12 Dec 2012,3.0.10,0,0,1,2,47,"+  ""version"": ""3.0.10""<c><\n>","-  ""version"": ""3.0.9""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,19,57,12 Dec 2012,testling badge,0,0,1,2,125,+[![browser status](http://ci.testling.com/dominictarr/event-stream.png)]<\n>+(http://ci.testling.com/dominictarr/event-stream)<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,23,48,11 Dec 2012,3.0.9,0,0,1,2,46,"+  ""version"": ""3.0.9""<c><\n>","-  ""version"": ""3.0.8""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,20,48,11 Dec 2012,Merge pull request #24 from conspirator/master Fix a small typo in readme,0,0,0,0,0,,,F
null,null,null,null,null,null,Christopher Webb,10,42,25,26,User,1,3726,Tue,22,6,11 Dec 2012,Fix typo in readme.,0,0,1,2,72,+also<c> emits a single 'data' event.<\n>,-also<c> emits a simgle 'data' event.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,23,27,26 Nov 2012,3.0.8,0,0,1,2,46,"+  ""version"": ""3.0.8""<c><\n>","-  ""version"": ""3.0.7""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,23,27,26 Nov 2012,refactor out pipeline into stream-combiner,0,0,2,44,1332,"+  <c> split = require('split')<\n>+  <c> pipeline = require('stream-combiner')<\n>+es.pipeline = es.connect = es.pipe = pipeline<\n>+es.readable =<\n>+function (func<c> continueOnError) {<\n>+    ""split"": ""0.0.0""<c><\n>+    ""stream-combiner"": ""0.0.0""<\n>","-  <c>  split = require('split')<\n>-es.readable = function (func<c> continueOnError) {<\n>-//<\n>-// combine multiple streams together so that they act as a single stream<\n>-//<\n>-es.pipeline = <\n>-es.pipe = es.connect = function () {<\n>-  var streams = [].slice.call(arguments)<\n>-    <c> first = streams[0]<\n>-    <c> last = streams[streams.length - 1]<\n>-    <c> thepipe = es.duplex(first<c> last)<\n>-  if(streams.length == 1)<\n>-    return streams[0]<\n>-  else if (!streams.length)<\n>-    throw new Error('connect called with empty args')<\n>-  //pipe all the streams together<\n>-  function recurse (streams) {<\n>-    if(streams.length < 2)<\n>-      return<\n>-    streams[0].pipe(streams[1])<\n>-    recurse(streams.slice(1))  <\n>-  }<\n>-  <\n>-  recurse(streams)<\n>- <\n>-  function onerror () {<\n>-    var args = [].slice.call(arguments)<\n>-    args.unshift('error')<\n>-    thepipe.emit.apply(thepipe<c> args)<\n>-  }<\n>-  <\n>-  //es.duplex already reemits the error from the first and last stream.<\n>-  //add a listener for the inner streams in the pipeline.<\n>-  for(var i = 1; i < streams.length - 1; i ++)<\n>-    streams[i].on('error'<c> onerror)<\n>-  return thepipe<\n>-    ""split"": ""0.0.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,0,1,15 Oct 2012,remove optimist as dep,0,0,1,1,24,,"-    ""optimist"": ""0.2""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,0,43,1 Oct 2012,3.0.7,0,0,1,2,46,"+  ""version"": ""3.0.7""<c><\n>","-  ""version"": ""3.0.6""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,0,43,1 Oct 2012,tidy,0,0,1,29,915,,-//<\n>-// helper to make your module into a unix pipe<\n>-// simply add <\n>-// <\n>-// if(!module.parent)<\n>-//  require('event-stream').pipable(asyncFunctionOrStreams)<\n>-// <\n>-// asyncFunctionOrStreams may be one or more Streams or if it is a function<c> <\n>-// it will be automatically wrapped in es.map<\n>-//<\n>-// then pipe stuff into from the command line!<\n>-// <\n>-// curl registry.npmjs.org/event-stream | node hello-pipeable.js | grep whatever<\n>-//<\n>-// etc!<\n>-//<\n>-// also<c> start pipeable running as a server!<\n>-//<\n>-// > node hello-pipeable.js --port 44444<\n>-// <\n>-var setup = function (args) {<\n>-  return args.map(function (f) {<\n>-    var x = f()<\n>-      if('function' === typeof x)<\n>-        return es.map(x)<\n>-      return x<\n>-    })<\n>-  console.error('warn: event-stream. I have decided that pipeable is a kitchen-sick and will remove soon if no objections')<\n>-  console.error('please post an issue if you actually use this. -- dominictarr')<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,0,39,1 Oct 2012,3.0.6,0,0,1,2,46,"+  ""version"": ""3.0.6""<c><\n>","-  ""version"": ""3.0.5""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,0,39,1 Oct 2012,pass pipeline test,0,0,1,8,299,+  //es.duplex already reemits the error from the first and last stream.<\n>+  //add a listener for the inner streams in the pipeline.<\n>+  for(var i = 1; i < streams.length - 1; i ++)<\n>+    streams[i].on('error'<c> onerror)<\n>,-  <\n>-  streams.forEach(function (stream) {<\n>-    stream.on('error'<c> onerror)<\n>-  })<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,0,39,1 Oct 2012,test that pipeline does not duplicate errors,0,1,1,38,1014,+var es = require('..')<\n>+exports['do not duplicate errors'] = function (test) {<\n>+  var errors = 0;<\n>+  var pipe = es.pipeline(<\n>+    es.through(function(data) {<\n>+      return this.emit('data'<c> data);<\n>+    })<c><\n>+    es.through(function(data) {<\n>+      return this.emit('error'<c> new Error(data));<\n>+    })<\n>+  )<\n>+  pipe.on('error'<c> function(err) {<\n>+    errors++<\n>+    console.log('error count'<c> errors)<\n>+      process.nextTick(function () {<\n>+        return test.done();<\n>+      })<\n>+  })<\n>+  return pipe.write('meh');<\n>+exports['3 pipe do not duplicate errors'] = function (test) {<\n>+  var errors = 0;<\n>+  var pipe = es.pipeline(<\n>+    es.through(function(data) {<\n>+      return this.emit('data'<c> data);<\n>+    })<c><\n>+    es.through(function(data) {<\n>+      return this.emit('error'<c> new Error(data));<\n>+    })<c><\n>+    es.through()<\n>+  )<\n>+  pipe.on('error'<c> function(err) {<\n>+    errors++<\n>+    console.log('error count'<c> errors)<\n>+      process.nextTick(function () {<\n>+        return test.done();<\n>+      })<\n>+  })<\n>+  return pipe.write('meh');<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,1,2,26 Sep 2012,3.0.5,0,0,1,2,46,"+  ""version"": ""3.0.5""<c><\n>","-  ""version"": ""3.0.4""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,1,2,26 Sep 2012,update through@1.1,0,0,1,2,50,"+    ""through"": ""1.1.0""<c><\n>","-    ""through"": ""1.0.0""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,11,39,31 Aug 2012,3.0.4,0,0,1,2,46,"+  ""version"": ""3.0.4""<c><\n>","-  ""version"": ""3.0.3""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,11,39,31 Aug 2012,use through@1.0.0,0,0,1,2,50,"+    ""through"": ""1.0.0""<c><\n>","-    ""through"": ""0.0.4""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,16,24,30 Aug 2012,3.0.3,0,0,1,2,46,"+  ""version"": ""3.0.3""<c><\n>","-  ""version"": ""3.0.2""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,16,24,30 Aug 2012,refactor out split,0,0,2,23,557,"+  <c>  split = require('split')<\n>+es.split = split<\n>+    ""pause-stream"": ""0.0.4""<c><\n>+    ""split"": ""0.0.0""<\n>","-es.split = function (matcher) {<\n>-  var soFar = ''<\n>-  if (!matcher)<\n>-    matcher = '\n'<\n>-  return es.through(function (buffer) { <\n>-    var stream = this<\n>-      <c> pieces = (soFar + buffer).split(matcher)<\n>-    soFar = pieces.pop()<\n>-    pieces.forEach(function (piece) {<\n>-      stream.emit('data'<c> piece)<\n>-    })<\n>-    return true<\n>-  }<c><\n>-  function () {<\n>-    if(soFar)<\n>-      this.emit('data'<c> soFar)  <\n>-    this.emit('end')<\n>-  })<\n>-    ""pause-stream"": ""0.0.4""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,16,23,30 Aug 2012,delete out of date compatibile modules section,0,0,1,42,1546,,-## compatible modules:<\n>-  * https://github.com/felixge/node-growing-file  <\n>-    stream changes on file that is being appended to. just like `tail -f`<\n>-  * https://github.com/isaacs/sax-js  <\n>-    streaming xml parser<\n>-  * https://github.com/mikeal/request  <\n>-    make http requests. request() returns a through stream!<\n>-  * https://github.com/TooTallNate/node-throttle  <\n>-    throttle streams on a bytes per second basis (binary streams only<c> of course)<\n>-    <\n>-  * https://github.com/mikeal/morestreams  <\n>-    buffer input until connected to a pipe.<\n>-    <\n>-  * https://github.com/TooTallNate/node-gzip-stack  <\n>-    compress and decompress raw streams.<\n>-  * https://github.com/Floby/node-json-streams  <\n>-    parse json without buffering it first<\n>-    <\n>-  * https://github.com/floby/node-tokenizer  <\n>-    tokenizer<\n>-  <\n>-  * https://github.com/floby/node-parser  <\n>-    general mechanisms for custom parsers<\n>-    <\n>-  * https://github.com/dodo/node-bufferstream  <\n>-    buffer streams until you say (written in C)<\n>-  * https://github.com/tim-smart/node-filter  <\n>-    `filter` pipeable string.replace<\n>-    <\n>-## almost compatible modules: (1+ these issues)<\n>-  * https://github.com/fictorial/json-line-protocol/issues/1  <\n>-    line reader<\n>-    <\n>-  * https://github.com/jahewson/node-byline/issues/1  <\n>-    line reader<\n>-  * https://github.com/AvianFlu/ntwitter/issues/3  <\n>-    twitter client<\n>-  * https://github.com/swdyh/node-chirpstream/issues/1  <\n>-    twitter client<\n>-    <\n>-  * https://github.com/polotek/evented-twitter/issues/22  <\n>-    twitter client<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,21,44,19 Aug 2012,3.0.2,0,0,1,2,46,"+  ""version"": ""3.0.2""<c><\n>","-  ""version"": ""3.0.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,21,44,19 Aug 2012,use updated duplexer,0,0,1,2,53,"+    ""duplexer"": ""~0.0.2""<c><\n>","-    ""duplexer"": ""0.0.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,16,17,18 Aug 2012,3.0.1,0,0,1,2,46,"+  ""version"": ""3.0.1""<c><\n>","-  ""version"": ""3.0.0""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,16,17,18 Aug 2012,fix test for pause,0,0,1,15,425,+    <c> gate = es.pause()<\n>+    es.log('after readArray')<c><\n>+      it(gate.paused).equal(false)<\n>+      console.log('data'<c> num)<\n>+        console.log('PAUSE')<\n>+        gate.pause()//.resume()<\n>+        d.delay(gate.resume.bind(gate)<c> 10)()<\n>+  gate.resume()<\n>,-    <c> gate = es.gate()<\n>-    //es.log('after readArray')<c><\n>-      it(gate.isShut()).equal(false)<\n>-      <\n>-        gate.shut()<\n>-        d.delay(gate.open<c>10)()<\n>-  gate.open()<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,16,14,18 Aug 2012,update pause-stream,0,0,1,2,58,"+    ""pause-stream"": ""0.0.4""<\n>","-    ""pause-stream"": ""0.0.3""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,38,18 Aug 2012,3.0.0,0,0,1,2,46,"+  ""version"": ""3.0.0""<c><\n>","-  ""version"": ""2.2.3""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,38,18 Aug 2012,depend on pause-stream,0,0,1,3,84,"+    ""map-stream"": ""0.0.1""<c><\n>+    ""pause-stream"": ""0.0.3""<\n>","-    ""map-stream"": ""0.0.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,38,18 Aug 2012,use pause instead of gate,0,0,1,83,2719,+## pause  () <\n>+A stream that buffers all chunks when paused.<\n>+  var ps = es.pause()<\n>+  ps.pause() //buffer the stream<c> also do not allow 'end' <\n>+  ps.resume() //allow chunks through<\n>,-## gate (isShut=true) <\n>-If the gate is `shut`<c> buffer the stream.  <\n>-All calls to write will return false (pause upstream)<c>  <\n>-and end will not be sent downstream.  <\n>-If the gate is open<c> let the stream through.  <\n>-Named `shut` instead of close<c> because close is already kinda meaningful with streams.  <\n>-Gate is useful for holding off processing a stream until some resource (i.e. a database<c> or network connection) is ready.  <\n>-  var gate = es.gate()<\n>-  <\n>-  gate.open() //allow the gate to stream<\n>-  <\n>-  gate.close() //buffer the stream<c> also do not allow 'end' <\n>-## pipeable (streamCreatorFunction<c>...)<\n>-The arguments to pipable must be functions that return  <\n>-instances of Stream or async functions.  <\n>-(If a function is returned<c> it will be turned into a Stream  <\n>-with `es.map`.)<\n>-Here is the first example rewritten to use `pipeable`.<\n>-``` js<\n>-//examples/pretty_pipeable.js<\n>-var inspect = require('util').inspect<\n>-if(!module.parent)<\n>-  require('event-stream').pipeable(function () {<\n>-    return function (data<c> callback) {<\n>-      try {<\n>-        data = JSON.parse(data)<\n>-      } catch (err) {}              //pass non JSON straight through!<\n>-      callback(null<c> inspect(data))<\n>-      }<\n>-    })  <\n>-  })<\n>-```<\n>-``` bash<\n>-curl -sS registry.npmjs.org/event-stream | node pipeable_pretty.js<\n>-## or<c> turn the pipe into a server!<\n>-node pipeable_pretty.js --port 4646<\n>-curl -sS registry.npmjs.org/event-stream | curl -sSNT- localhost:4646<\n>-```<\n>-<!--<\n>-TODO<c> the following methods are not implemented yet.<\n>-## sidestream (stream1<c>...<c>streamN)<\n>-Pipes the incoming stream to many writable streams.  <\n>-remits the input stream.<\n>-``` js<\n>-  es.sidestream( //will log the stream to a file<\n>-    es.pipeline(<\n>-      es.mapSync(function (j) {return JSON.stringify(j) + '/n'})<c><\n>-      fs.createWruteStream(file<c> {flags: 'a'})<\n>-    )<\n>-```<\n>-## merge (stream1<c>...<c>streamN)<\n>-Create a readable stream that merges many streams into one.<\n>-(Not implemented yet.)<\n>-### another pipe example<\n>-SEARCH SUBDIRECTORIES FROM CWD  <\n>-FILTER IF NOT A GIT REPO  <\n>-MAP TO GIT STATUS --porclean + the directory  <\n>-FILTER IF EMPTY STATUS  <\n>-process.stdout  <\n>-that will show all the repos which have unstaged changes  <\n>-## TODO & applications<\n>-  * buffer -- buffer items<\n>-  * rate limiter<\n>-  * save to database<\n>-    * couch<\n>-    * redis<\n>-    * mongo<\n>-    * file(s)<\n>-  * read from database<\n>-    * couch<\n>-    * redis<\n>-    * mongo<\n>-    * file(s)<\n>-  * recursive<\n>-    * search filesystem<\n>-    * scrape web pages (load pages<c> parse for links<c> etc)<\n>-    * module dependencies<\n>-  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,35,18 Aug 2012,use pause-stream instead of gate,0,0,1,2,55,+  <c> pause = require('pause-stream')<\n>+es.pause = pause<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,31,18 Aug 2012,Merge branch patch-5 of git://github.com/Raynos/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,30,18 Aug 2012,Merge branch patch-2 of git://github.com/Raynos/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,10,18 Aug 2012,2.2.3,0,0,1,2,46,"+  ""version"": ""2.2.3""<c><\n>","-  ""version"": ""2.2.2""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,10,18 Aug 2012,refactor out map,0,0,2,88,2464,"+  <c> map = require('map-stream')<\n>+es.map = map<\n>+    ""from"": ""~0""<c><\n>+    ""map-stream"": ""0.0.1""<\n>","-//create an event stream and apply function to each .write<\n>-//emitting each response as data<\n>-//unless it's an empty callback<\n>-es.map = function (mapper) {<\n>-  var stream = new Stream()<\n>-    <c> inputs = 0<\n>-    <c> outputs = 0<\n>-    <c> ended = false<\n>-    <c> paused = false<\n>-    <c> destroyed = false<\n>-  stream.writable = true<\n>-  stream.readable = true<\n>-   <\n>-  stream.write = function () {<\n>-    if(ended) throw new Error('map stream is not writable')<\n>-    inputs ++<\n>-    var args = [].slice.call(arguments)<\n>-      <c> r<\n>-      <c> inNext = false <\n>-    //pipe only allows one argument. so<c> do not <\n>-    function next (err) {<\n>-      if(destroyed) return<\n>-      inNext = true<\n>-      outputs ++<\n>-      var args = [].slice.call(arguments)<\n>-      if(err) {<\n>-        args.unshift('error')<\n>-        return inNext = false<c> stream.emit.apply(stream<c> args)<\n>-      }<\n>-      args.shift() //drop err<\n>-      if (args.length) {<\n>-        args.unshift('data')<\n>-        r = stream.emit.apply(stream<c> args)<\n>-      }<\n>-      if(inputs == outputs) {<\n>-        if(paused) paused = false<c> stream.emit('drain') //written all the incoming events<\n>-        if(ended) end()<\n>-      }<\n>-      inNext = false<\n>-    }<\n>-    args.push(next)<\n>-    <\n>-    try {<\n>-      //catch sync errors and handle them like async errors<\n>-      var written = mapper.apply(null<c> args)<\n>-      paused = (written === false)<\n>-      return !paused<\n>-    } catch (err) {<\n>-      //if the callback has been called syncronously<c> and the error<\n>-      //has occured in an listener<c> throw it again.<\n>-      if(inNext)<\n>-        throw err<\n>-      next(err)<\n>-      return !paused<\n>-    }<\n>-  }<\n>-  function end (data) {<\n>-    //if end was called with args<c> write it<c> <\n>-    ended = true //write will emit 'end' if ended is true<\n>-    stream.writable = false<\n>-    if(data !== undefined)<\n>-      return stream.write(data)<\n>-    else if (inputs == outputs) //wait for processing <\n>-      stream.readable = false<c> stream.emit('end')<c> stream.destroy() <\n>-  }<\n>-  stream.end = function (data) {<\n>-    if(ended) return<\n>-    end()<\n>-  }<\n>-  stream.destroy = function () {<\n>-    ended = destroyed = true<\n>-    stream.writable = stream.readable = paused = false<\n>-    process.nextTick(function () {<\n>-      stream.emit('close')<\n>-    })<\n>-  }<\n>-  stream.pause = function () {<\n>-    paused = true<\n>-  }<\n>-  stream.resume = function () {<\n>-    paused = false<\n>-  }<\n>-  return stream<\n>-    ""from"": ""~0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,14,26,15 Aug 2012,2.2.2,0,0,1,2,46,"+  ""version"": ""2.2.2""<c><\n>","-  ""version"": ""2.2.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,14,25,15 Aug 2012,require(buffer) so that it works browserify,0,0,1,1,41,+  var Buffer = require('buffer').Buffer<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,3,41,14 Aug 2012,Merge branch patch-3 of git://github.com/Raynos/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Raynos <raynos2@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,23,1,11 Aug 2012,deprecate es.gate pause-stream seems to have the same functionality as a seperate module.,0,0,1,45,1220,,-//<\n>-// gate <\n>-//<\n>-// while the gate is shut()<c> buffer incoming. <\n>-// <\n>-// if gate is open() stream like normal.<\n>-//<\n>-// currently<c> when opened<c> this will emit all data unless it is shut again<\n>-// if downstream pauses it will still write<c> i'd like to make it respect pause<c> <\n>-// but i'll need a test case first.<\n>-es.gate = function (shut) {<\n>-  var stream = new Stream()<\n>-    <c> queue = []<\n>-    <c> ended = false<\n>-    shut = (shut === false ? false : true) //default to shut<\n>-  stream.writable = true<\n>-  stream.readable = true<\n>-  stream.isShut = function () { return shut }<\n>-  stream.shut   = function () { shut = true }<\n>-  stream.open   = function () { shut = false; maybe() }<\n>-  <\n>-  function maybe () {<\n>-    while(queue.length && !shut) {<\n>-      var args = queue.shift()<\n>-      args.unshift('data')<\n>-      stream.emit.apply(stream<c> args)<\n>-    }<\n>-    stream.emit('drain')<\n>-    if(ended && !shut) <\n>-      stream.emit('end')<\n>-  }<\n>-  <\n>-  stream.write = function () {<\n>-    var args = [].slice.call(arguments)<\n>-  <\n>-    queue.push(args)<\n>-    if (shut) return false //pause up stream pipes  <\n>-    maybe()<\n>-  }<\n>-  stream.end = function () {<\n>-    ended = true<\n>-    if (!queue.length)<\n>-      stream.emit('end')<\n>-  }<\n>-  return stream<\n>,F
null,null,null,null,null,null,Raynos <raynos2@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,22,58,11 Aug 2012,cleaned up dead code,0,0,1,54,1669,+    done(new Error('destroyed before end')<c> array)<\n>,"-// buffered<\n>-//<\n>-// same as a through stream<c> but won't emit a chunk until the next tick.<\n>-// does not support any pausing. intended for testing purposes.<\n>-// XXX: rewrite this. this is crap. but do I actually use it? maybe just throw it away?<\n>-// okay<c> it's used in snob. so... throw this out and let snob use a legacy version. (fix later/never)<\n>-    done(new Error('destroyed befor end')<c> array)<\n>-//<\n>-// duplex -- pipe into one stream and out another<\n>-//<\n>-es.duplex = function (writer<c> reader) {<\n>-  var thepipe = new Stream()<\n>-  Object.defineProperty(thepipe<c> ""writable""<c> {<\n>-    get: function () {<\n>-      return writer.writable<\n>-    }<\n>-  })<\n>-  Object.defineProperty(thepipe<c> ""readable""<c> {<\n>-    get: function () {<\n>-      return reader.readable<\n>-    }<\n>-  })<\n>-  ;['write'<c> 'end'<c> 'destroy'].forEach(function (func) {<\n>-    thepipe[func] = function () {<\n>-      return writer[func].apply(writer<c> arguments)<\n>-    }<\n>-  })<\n>-  ;['resume'<c> 'pause'].forEach(function (func) {<\n>-    thepipe[func] = function () { <\n>-      thepipe.emit(func)<\n>-      if(reader[func])<\n>-        return reader[func].apply(reader<c> arguments)<\n>-      else<\n>-        reader.emit(func)<\n>-    }<\n>-  })<\n>-  ;['data'<c> 'close'].forEach(function (event) {<\n>-    reader.on(event<c> function () {<\n>-      var args = [].slice.call(arguments)<\n>-      args.unshift(event)<\n>-      thepipe.emit.apply(thepipe<c> args)<\n>-    })<\n>-  })<\n>-  //only emit end once<\n>-  var ended = false<\n>-  reader.on('end'<c> function () {<\n>-    if(ended) return<\n>-    ended = true<\n>-    var args = [].slice.call(arguments)<\n>-    args.unshift('end')<\n>-    thepipe.emit.apply(thepipe<c> args)<\n>-  })<\n>-  return thepipe<\n>",F
null,null,null,null,null,null,Raynos <raynos2@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,22,49,11 Aug 2012,cleanup,0,0,1,2,52,+es.through = through<\n>,-es.through = through.through<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,14,31,10 Aug 2012,2.2.1,0,0,1,2,46,"+  ""version"": ""2.2.1""<c><\n>","-  ""version"": ""2.2.0""<c><\n>",F
null,null,null,null,null,null,Raynos <raynos2@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,23,7,9 Aug 2012,deprecate es.pipeable The `(require)(opts.protocol)` statement causes browserify to console.error a lot. This is annoying. Im speeding up your deprecation!,0,0,1,53,1936,+  throw new Error('[EVENT-STREAM] es.pipeable is deprecated')<\n>,"-  if(process.title != 'node')<\n>-    return console.error('cannot use es.pipeable in the browser')<\n>-  //(require) inside brackets to fool browserify<c> because this does not make sense in the browser.<\n>-  var opts = (require)('optimist').argv<\n>-  var args = [].slice.call(arguments)<\n>-  <\n>-  if(opts.h || opts.help) {<\n>-    var name = process.argv[1]<\n>-    console.error([<\n>-      'Usage:'<c><\n>-      ''<c><\n>-      'node ' + name + ' [options]'<c><\n>-      '  --port PORT        turn this stream into a server'<c><\n>-      '  --host HOST        host of server (localhost is default)'<c><\n>-      '  --protocol         protocol http|net will require(protocol).createServer(...'<c><\n>-      '  --help             display this message'<c><\n>-      ''<c><\n>-      ' if --port is not set<c> will stream input from stdin'<c><\n>-      ''<c><\n>-      'also<c> pipe from or to files:'<c><\n>-      ''<c><\n>-      ' node '+name+ ' < file    #pipe from file into this stream'<c><\n>-      ' node '+name+ ' < infile > outfile    #pipe from file into this stream'<c>     <\n>-      ''<c><\n>-    ].join('\n'))<\n>-  <\n>-  } else if (!opts.port) {<\n>-    var streams = setup(args)<\n>-    streams.unshift(es.split())<\n>-    //streams.unshift()<\n>-    streams.push(process.stdout)<\n>-    var c = es.pipeline.apply(null<c> streams)<\n>-    process.openStdin().pipe(c) //there<\n>-    return c<\n>-  } else {<\n>-  <\n>-    opts.host = opts.host || 'localhost'<\n>-    opts.protocol = opts.protocol || 'http'<\n>-    <\n>-    var protocol = (require)(opts.protocol)<\n>-        <\n>-    var server = protocol.createServer(function (instream<c> outstream) {  <\n>-      var streams = setup(args)<\n>-      streams.unshift(es.split())<\n>-      streams.unshift(instream)<\n>-      streams.push(outstream || instream)<\n>-      es.pipe.apply(null<c> streams)<\n>-    })<\n>-    <\n>-    server.listen(opts.port<c> opts.host)<\n>-    console.error(process.argv[1] +' is listening for ""' + opts.protocol + '"" on ' + opts.host + ':' + opts.port)  <\n>-  }<\n>",F
null,null,null,null,null,null,Raynos <raynos2@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,21,1,9 Aug 2012,use duplexer,0,0,2,6,148,"+  <c> from = require('from')<\n>+  <c> duplex = require('duplexer')<\n>+es.from = from<\n>+es.duplex = duplex<\n>+    ""duplexer"": ""0.0.1""<c><\n>",-es.from = through.from<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,16,52,7 Aug 2012,2.2.0,0,0,1,2,46,"+  ""version"": ""2.2.0""<c><\n>","-  ""version"": ""2.1.9""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,16,52,7 Aug 2012,document pipeline alias for connect,0,0,1,18,882,+  es.pipeline(                         //connect streams together with `pipe`<\n>+  es.pipeline(<\n>+## pipeline (stream1<c>...<c>streamN)<\n>+Turn a pipeline into a single stream. `pipeline` returns a stream that writes to the first stream<\n>+and reads from the last stream. <\n>+> `connect` is an alias for `pipeline`.<\n>+  es.pipeline(                         //connect streams together with `pipe`<\n>+(This is used by `pipeline` and `child`.)<\n>+    es.pipeline(<\n>,-  es.connect(                         //connect streams together with `pipe`<\n>-  es.connect(<\n>-## connect (stream1<c>...<c>streamN)<\n>-Connect multiple Streams together into one stream.  <\n>-`connect` will return a Stream. This stream will write to the first stream<c><\n>-and will emit data from the last stream. <\n>-  es.connect(                         //connect streams together with `pipe`<\n>-(This is used by `connect` and `child`.)<\n>-    es.connect(<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,16,47,7 Aug 2012,add alias pipeline = connect and depreciation warning for pipeable,0,0,1,7,415,+es.pipeline = <\n>+  return es.pipeline(es.split(from)<c> es.join(to))<\n>+  console.error('warn: event-stream. I have decided that pipeable is a kitchen-sick and will remove soon if no objections')<\n>+  console.error('please post an issue if you actually use this. -- dominictarr')<\n>+    var c = es.pipeline.apply(null<c> streams)<\n>,-  return es.connect(es.split(from)<c> es.join(to))<\n>-    var c = es.connect.apply(null<c> streams)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,59,4 Aug 2012,2.1.9,0,0,1,2,46,"+  ""version"": ""2.1.9""<c><\n>","-  ""version"": ""2.1.8""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,59,4 Aug 2012,handle buffers in stringify,0,0,1,4,181,+  return es.mapSync(function (e){ <\n>+    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\n'<\n>,-  return es.mapSync(function (e){<\n>-    return JSON.stringify(e) + '\n'<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,58,4 Aug 2012,test buffers into stringify,0,1,1,6,206,+var es = require('../')<\n>+exports['handle buffer'] = function (t) {<\n>+  es.stringify().on('data'<c> function (d) {<\n>+    t.equal(d.trim()<c> JSON.stringify('HELLO'))<\n>+    t.end()<\n>+  }).write(new Buffer('HELLO'))<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,21,41,30 Jul 2012,comment about split for parse,0,0,1,2,123,+// must be used after es.split() to ensure that each chunk represents a line<\n>+// source.pipe(es.split()).pipe(es.parse())<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,22,35,23 Jul 2012,2.1.8,0,0,1,2,46,"+  ""version"": ""2.1.8""<c><\n>","-  ""version"": ""2.1.7""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,22,35,23 Jul 2012,parse should ignore lines that where only whitespace,0,0,1,4,133,+    //ignore lines that where only whitespace.<\n>+    if(obj !== undefined)<\n>+      this.emit('data'<c> obj)<\n>,-    this.emit('data'<c> obj)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,4,52,20 Jul 2012,2.1.7,0,0,1,2,46,"+  ""version"": ""2.1.7""<c><\n>","-  ""version"": ""2.1.6""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,4,51,20 Jul 2012,Merge branch patch-1 of git://github.com/Raynos/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Raynos <raynos2@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,15,51,18 Jul 2012,Support IE9,0,0,1,12,390,"+  Object.defineProperty(thepipe<c> ""writable""<c> {<\n>+    get: function () {<\n>+      return writer.writable<\n>+    }<\n>+  })<\n>+  Object.defineProperty(thepipe<c> ""readable""<c> {<\n>+    get: function () {<\n>+      return reader.readable<\n>+    }<\n>+  })<\n>",-  thepipe.__defineGetter__('writable'<c> function () { return writer.writable })<\n>-  thepipe.__defineGetter__('readable'<c> function () { return reader.readable })<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,7,47,19 Jul 2012,document parse and stringify,0,0,1,15,474,+## parse<\n>+Convienience function for parsing JSON chunks. For newline seperated JSON<c><\n>+use with `es.split`<\n>+``` js<\n>+fs.createReadStream(filename)<\n>+  .pipe(es.split()) //defaults to lines.<\n>+  .pipe(es.parse())<\n>+```<\n>+## stringify<\n>+convert javascript objects into lines of text. The text will have whitespace escaped and have a `\n` appended<c> so it will be compatible with `es.parse`<\n>+``` js<\n>+objectStream<\n>+  .pipe(es.stringify())<\n>+  .pipe(fs.createWriteStream(filename))<\n>+```<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,23,19,12 Jul 2012,2.1.6,0,0,1,2,46,"+  ""version"": ""2.1.6""<c><\n>","-  ""version"": ""2.1.5""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,23,18,12 Jul 2012,precise version for through,0,0,1,4,81,"+    ""through"": ""0.0.4""<c><\n>+    ""from"": ""~0""<\n>","-    ""through"": ""0""<c><\n>-    ""from"": ""0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,0,5,12 Jul 2012,2.1.5,0,0,1,2,46,"+  ""version"": ""2.1.5""<c><\n>","-  ""version"": ""2.1.4""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,0,5,12 Jul 2012,tighten implementation to stream-spec,0,0,1,5,254,+    stream.writable = false<\n>+    else if (inputs == outputs) //wait for processing <\n>+      stream.readable = false<c> stream.emit('end')<c> stream.destroy() <\n>,-    else if (inputs == outputs) //wait for processing<\n>-      stream.emit('end')<c> stream.destroy()<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,0,4,12 Jul 2012,get the last one,0,0,1,10,319,+  spec(doubler).through().validateOnExit()<\n>,-function onExit(validate) {<\n>-  process.listeners('exit').unshift(function () {<\n>-    try {validate()} catch (err) {<\n>-      console.error('VALIDATION ERR')<\n>-      console.error(err.stack)<\n>-//      test.equal(err<c> null)<\n>-    }<\n>-  })<\n>-  onExit(spec(doubler).through().validate)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,0,3,12 Jul 2012,update simple-map to use new spec api,0,0,1,29,1157,+  return es.through(function (data) {    <\n>+  spec(map).through().validateOnExit()<\n>+  spec(pause).through().validateOnExit()<\n>+  onExit(spec(doubler).through().validate)<\n>+  spec(doubler1).through().validateOnExit()<\n>+  spec(doubler2).through().validateOnExit()<\n>+  spec(ticker).through().validateOnExit()<\n>+  <\n>+  spec(map).through().pausable().validateOnExit()<\n>+  spec(map).through().validateOnExit()<\n>+  spec(doubler).through().validateOnExit()<\n>+  spec(doubler).through().validateOnExit()<\n>+  spec(doubler).through().validateOnExit()<\n>,-function to (sink<c> complete) {<\n>-  <\n>-  return es.through(function (data) {<\n>-    <\n>-  onExit(spec(map).basic().pausable().validate)<\n>-  onExit(spec(pause).basic().pausable().validate)<\n>-  onExit(spec(doubler).basic().validate)<\n>-  onExit(spec(doubler1).basic().validate)<\n>-  onExit(spec(doubler2).basic().validate)<\n>-  onExit(spec(ticker).basic().validate)<\n>-  console.log(map) <\n>-  onExit(spec(map).basic().pausable().validate)<\n>-  onExit(spec(map).basic().pausable().validate)<\n>-  onExit(spec(doubler).basic().pausable().validate)<\n>-  onExit(spec(doubler).basic().pausable().validate)<\n>-  onExit(spec(doubler).basic().pausable().validate)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,23,59,11 Jul 2012,update stream-spec,0,0,1,2,54,"+    ""stream-spec"": ""~0.2""<\n>","-    ""stream-spec"": ""~0.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,5,12,5 Jul 2012,2.1.4,0,0,1,2,46,"+  ""version"": ""2.1.4""<c><\n>","-  ""version"": ""2.1.3""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,5,12,5 Jul 2012,oops I mean ~0.1,0,0,1,2,56,"+    ""stream-spec"": ""~0.1""<\n>","-    ""stream-spec"": ""~0.0.2""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,5,9,5 Jul 2012,update range for stream-spec,0,0,1,2,53,"+    ""stream-spec"": ""~0.0.2""<\n>","-    ""stream-spec"": ""0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,4,31,5 Jul 2012,2.1.3,0,0,1,2,46,"+  ""version"": ""2.1.3""<c><\n>","-  ""version"": ""2.1.2""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,4,30,5 Jul 2012,the more tests the merrierer,0,1,1,58,1693,+/*<\n>+  assert that data is called many times<\n>+  assert that end is called eventually<\n>+  assert that when stream enters pause state<c><\n>+  on drain is emitted eventually.<\n>+*/<\n>+var es = require('..')<\n>+var it = require('it-is').style('colour')<\n>+var spec = require('stream-spec')<\n>+exports['simple stream'] = function (test) {<\n>+  var stream = es.through()<\n>+  var x = spec(stream).basic().pausable()<\n>+  stream.write(1)<\n>+  stream.write(1)<\n>+  stream.pause()<\n>+  stream.write(1)<\n>+  stream.resume()<\n>+  stream.write(1)<\n>+  stream.end(2) //this will call write()<\n>+  process.nextTick(function (){<\n>+    x.validate()<\n>+    test.done()<\n>+  }) <\n>+exports['throw on write when !writable'] = function (test) {<\n>+  var stream = es.through()<\n>+  var x = spec(stream).basic().pausable()<\n>+  stream.write(1)<\n>+  stream.write(1)<\n>+  stream.end(2) //this will call write()<\n>+  stream.write(1) //this will be throwing...<c> but the spec will catch it.<\n>+  process.nextTick(function () {<\n>+    x.validate()<\n>+    test.done()<\n>+  })<\n>+  <\n>+exports['end fast'] = function (test) {<\n>+  var stream = es.through()<\n>+  var x = spec(stream).basic().pausable()<\n>+  stream.end() //this will call write()<\n>+  process.nextTick(function () {<\n>+    x.validate()<\n>+    test.done()<\n>+  })<\n>+  <\n>+/*<\n>+  okay<c> that was easy enough<c> whats next?<\n>+  say<c> after you call paused()<c> write should return false<\n>+  until resume is called.<\n>+  simple way to implement this:<\n>+    write must return !paused<\n>+  after pause() paused = true<\n>+  after resume() paused = false<\n>+  on resume<c> if !paused drain is emitted again.<\n>+  after drain<c> !paused<\n>+  there are lots of subtle ordering bugs in streams.<\n>+  example<c> set !paused before emitting drain.<\n>+  the stream api is stateful. <\n>+*/<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,4,29,5 Jul 2012,refactor out through and from,0,0,2,123,3359,"+  <c> through = require('through')<\n>+es.through = through.through<\n>+es.from = through.from<\n>+    stream.emit('close')<\n>+      if (args.length) {<\n>+        if(ended) end()<\n>+      paused = (written === false)<\n>+      return !paused<\n>+      return !paused<\n>+  function end (data) {<\n>+    if(data !== undefined)<\n>+      return stream.write(data)<\n>+      stream.emit('end')<c> stream.destroy()<\n>+  }<\n>+  stream.end = function (data) {<\n>+    if(ended) return<\n>+    end()<\n>+    process.nextTick(function () {<\n>+      stream.emit('close')<\n>+    })<\n>+  }<\n>+  stream.pause = function () {<\n>+    paused = true<\n>+  }<\n>+  stream.resume = function () {<\n>+    paused = false<\n>+      this.emit('data'<c> body)<\n>+      this.emit('end')<\n>+    ""optimist"": ""0.2""<c><\n>+    ""through"": ""0""<c><\n>+    ""from"": ""0""<\n>+    ""stream-spec"": ""0""<\n>","-// through<\n>-//<\n>-// a stream that does nothing but re-emit the input.<\n>-// useful for aggregating a series of changing but not ending streams into one stream)<\n>-es.through = function (write<c> end) {<\n>-  write = write || function (data) { this.emit('data'<c> data) }<\n>-  end = (<\n>-    'sync'== end || !end<\n>-  //use sync end. (default)<\n>-  ? function () { this.emit('end') }<\n>-  : 'async' == end || end === true <\n>-  //use async end.<\n>-  //must eventually call drain if paused.<\n>-  //else will not end.<\n>-  ? function () {<\n>-      if(!this.paused)<\n>-        return this.emit('end')<\n>-     var self = this<\n>-     this.once('drain'<c> function () {<\n>-        self.emit('end')<\n>-      })<\n>-    }<\n>-  //use custom end function<\n>-  : end <\n>-  )<\n>-  var ended = false<c> destroyed = false<\n>-  var stream = new Stream()<\n>-  stream.readable = stream.writable = true<\n>-  stream.paused = false  <\n>-  stream.write = function (data) {<\n>-    write.call(this<c> data)<\n>-    return !stream.paused<\n>-  }<\n>-  //this will be registered as the first 'end' listener<\n>-  //must call destroy next tick<c> to make sure we're after any<\n>-  //stream piped from here. <\n>-  stream.on('end'<c> function () {<\n>-    stream.readable = false<\n>-    if(!stream.writable)<\n>-      process.nextTick(function () {<\n>-        stream.destroy()<\n>-      })<\n>-  })<\n>-  stream.end = function (data) {<\n>-    if(ended) throw new Error('cannot call end twice')<\n>-    ended = true<\n>-    if(arguments.length) stream.write(data)<\n>-    this.writable = false<\n>-    end.call(this)<\n>-    if(!this.readable)<\n>-      this.destroy()<\n>-  }<\n>-  /*<\n>-    destroy is called on a writable stream when the upstream closes.<\n>-    it's basically END but something has gone wrong.<\n>-    I'm gonna emit 'close' and change then otherwise act as 'end'<\n>-  */<\n>-  stream.destroy = function () {<\n>-    if(destroyed) return<\n>-    destroyed = true<\n>-    ended = true<\n>-    stream.writable = stream.readable = false<\n>-    stream.emit('close')<\n>-  }<\n>-  stream.pause = function () {<\n>-    stream.paused = true<\n>-  }<\n>-  stream.resume = function () {<\n>-    if(stream.paused) {<\n>-      stream.paused = false<\n>-      stream.emit('drain')<\n>-    }<\n>-  }<\n>-  return stream<\n>-    stream.emit('close')<\n>-      if (args.length){<\n>-        if(ended)<\n>-          stream.end()<\n>-      if(written === false) paused = true<\n>-      return written<\n>-      return true<\n>-  stream.end = function () {<\n>-    var args = [].slice.call(arguments)<\n>-    if(args.length)<\n>-      return stream.write.apply(emitter<c> args)<\n>-      stream.emit('end')<\n>-  var stream = new Stream()<\n>-      stream.emit('data'<c> body)<\n>-      stream.emit('end')<\n>-    ""optimist"": ""0.2""<\n>-    ""macgyver"": ""~1.5""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,4,28,5 Jul 2012,refactor tests,1,0,3,219,6250,"+  <c> spec = require('stream-spec')<\n>+var next = process.nextTick<\n>+  var join = es.wait(function (err<c> string){<\n>+  var replace = es.replace('7'<c> 'seven')<\n>+  var x = spec(replace).through()<\n>+    .pipe(replace)<\n>+    replace.on('close'<c> function () {<\n>+      x.validate()<\n>+      test.done()<\n>+    })<\n>+'use strict';<\n>+  <c> spec = require('stream-spec')<\n>+  <c> Stream = require('stream')<\n>+  <c> from = require('from')<\n>+  <c> through = require('through')<\n>+function onExit(validate) {<\n>+  process.listeners('exit').unshift(function () {<\n>+    try {validate()} catch (err) {<\n>+      console.error('VALIDATION ERR')<\n>+      console.error(err.stack)<\n>+//      test.equal(err<c> null)<\n>+    }<\n>+  })<\n>+//call sink on each write<c><\n>+//and complete when finished.<\n>+function to (sink<c> complete) {<\n>+  <\n>+function pauseStream (prob<c> delay) { <\n>+  var pauseIf = (<\n>+      'number' == typeof prob <\n>+    ? function () {<\n>+        return Math.random() < prob<\n>+      } <\n>+    : 'function' == typeof prob <\n>+    ? prob<\n>+    : 0.1<\n>+  )<\n>+  var delayer = ( <\n>+      !delay <\n>+    ? process.nextTick<\n>+    : 'number' == typeof delay <\n>+    ? function (next) { setTimeout(next<c> delay) }<\n>+    : delay<\n>+  )   <\n>+  return es.through(function (data) {<\n>+    <\n>+    if(!this.paused && pauseIf()) {<\n>+      console.log('PAUSE STREAM PAUSING')<\n>+      this.pause()<\n>+      var self = this<\n>+      delayer(function () {<\n>+        console.log('PAUSE STREAM RESUMING')<\n>+        self.resume()<\n>+      })<\n>+    }<\n>+    console.log(""emit ('data'<c> "" + data + ')')<\n>+    this.emit('data'<c> data) <\n>+  })<\n>+exports ['simple map'] = function (test) {<\n>+  var input = u.map(1<c> 1000<c> function () {<\n>+    return Math.random() <\n>+  })<\n>+  var expected = input.map(function (v) {<\n>+    return v * 2<\n>+  })<\n>+  var pause = pauseStream(0.1)<\n>+  var fs = from(input)<\n>+  var ts = es.writeArray(function (err<c> ar) {<\n>+    it(ar).deepEqual(expected)<\n>+    test.done()<\n>+  })<\n>+  var map = es.through(function (data) {<\n>+    this.emit('data'<c> data * 2)<\n>+  }) <\n>+  onExit(spec(map).basic().pausable().validate)<\n>+  onExit(spec(pause).basic().pausable().validate)<\n>+  fs.pipe(map).pipe(pause).pipe(ts)<\n>+  onExit(spec(doubler).basic().validate)<\n>+//    process.nextTick(x.validate)<\n>+  onExit(spec(doubler1).basic().validate)<\n>+  onExit(spec(doubler2).basic().validate)<\n>+  onExit(spec(ticker).basic().validate)<\n>+  ticker.write('x')<\n>+  ticker.end() <\n>+//  onExit(spec(mapper).basic().validate)<\n>+//need spec that says stream may error.<\n>+  console.log(map) <\n>+  onExit(spec(map).basic().pausable().validate)<\n>+    console.log('WRITE'<c> false)<\n>+  onExit(spec(map).basic().pausable().validate)<\n>+  process.nextTick(function () {map.end()}<c>10)<\n>+    console.log('end')<\n>+    test.done() <\n>+  onExit(spec(doubler).basic().pausable().validate)<\n>+  onExit(spec(doubler).basic().pausable().validate)<\n>+  onExit(spec(doubler).basic().pausable().validate)<\n>+  <c> spec = require('stream-spec')<\n>+    <c> x = spec(cs).through()<\n>+      //give the stream time to close<\n>+      process.nextTick(function () {<\n>+        test.done()<\n>+        x.validate()<\n>+      })<\n>+  cs.pipe(a) <\n>",-  var join = es.join(function (err<c> string){<\n>-  <\n>-    .pipe(es.replace('7'<c> 'seven'))<\n>-      test.done()<\n>-  <\n>-  ticker.write('x')<\n>-  ticker.end()<\n>-  ticker.end()<\n>-  ticker.end()<\n>-  setTimeout(function () {map.end()}<c>10)<\n>-    test.done()<\n>-    <\n>-/*<\n>-  assert that data is called many times<\n>-  assert that end is called eventually<\n>-  assert that when stream enters pause state<c><\n>-  on drain is emitted eventually.<\n>-*/<\n>-var macgyver = require('macgyver')<\n>-var es = require('..')<\n>-var it = require('it-is').style('colour')<\n>-function applySpec (mac<c> stream) {<\n>-  function noop () {}<\n>-  var paused = false<\n>-  function drain() {<\n>-    paused = false<\n>-    console.log('drain!')<\n>-  }  <\n>-  stream.end = mac(stream.end).once()<\n>-  var onDrain = mac(drain).never()<\n>-  stream.pause = mac(stream.pause)<\n>-    .isPassed(function () {<\n>-      if(paused) return<\n>-      console.log('entered pause state by pause()')<\n>-      paused = true<\n>-      onDrain.again()<\n>-    })<\n>-  stream.on('drain'<c> onDrain)<\n>-  stream.write = <\n>-    mac(stream.write)<\n>-    .throws(function (err<c> threw) {<\n>-      it(threw).equal(!stream.writable)<\n>-    })<\n>-    .returns(function (written) {<\n>-      it(written)<\n>-        .typeof('boolean')     //be strict.<\n>-        .equal(!stream.paused) //expose pause state. must be consistant.<\n>-      if(!paused && !written) {<\n>-        //after write returns false<c> it must emit drain eventually.<\n>-        console.log('entered pause state by write() === false')<\n>-        onDrain.again()<\n>-      }<\n>-      paused = !written<\n>-    })<\n>-  var onClose = mac(noop).once()<\n>-  var onEnd   = mac(noop).once().before(onClose)<\n>-  var onData  = mac(noop).before(onEnd)<\n>-  stream.on('close'<c> onClose)<\n>-  stream.on('end'<c> onEnd)<\n>-  stream.on('data'<c> onData)<\n>-exports['simple stream'] = function (test) {<\n>-  var mac = macgyver()<\n>-  var stream = es.through()<\n>-  applySpec(mac<c> stream)<\n>-    stream.write(1)<\n>-    stream.write(1)<\n>-    stream.pause()<\n>-    stream.write(1)<\n>-    stream.resume()<\n>-    stream.write(1)<\n>-    stream.end(2) //this will call write()<\n>-    process.nextTick(function () {<\n>-      mac.validate()<\n>-      test.done()<\n>-    })<\n>-    <\n>-exports['throw on write when !writable'] = function (test) {<\n>-  var mac = macgyver()<\n>-  var stream = es.through()<\n>-  applySpec(mac<c> stream)<\n>-  stream.write(1)<\n>-  stream.write(1)<\n>-  stream.end(2) //this will call write()<\n>-  stream.write(1) //this will be throwing...<c> but the spec will catch it.<\n>-  process.nextTick(function () {<\n>-    mac.validate()<\n>-    test.done()<\n>-  })<\n>-  <\n>-exports['end fast'] = function (test) {<\n>-  var mac = macgyver()<\n>-  var stream = es.through()<\n>-  applySpec(mac<c> stream)<\n>-  stream.end() //this will call write()<\n>-  process.nextTick(function () {<\n>-    mac.validate()<\n>-    test.done()<\n>-  })<\n>-  <\n>-/*<\n>-  okay<c> that was easy enough<c> whats next?<\n>-  say<c> after you call paused()<c> write should return false<\n>-  until resume is called.<\n>-  simple way to implement this:<\n>-    write must return !paused<\n>-  after pause() paused = true<\n>-  after resume() paused = false<\n>-  on resume<c> if !paused drain is emitted again.<\n>-  after drain<c> !paused<\n>-  there are lots of subtle ordering bugs in streams.<\n>-  example<c> set !paused before emitting drain.<\n>-  the stream api is stateful. <\n>-*/<\n>-      test.done()<\n>-  cs.pipe(a)  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,0,39,1 Jul 2012,2.1.2,0,0,1,2,46,"+  ""version"": ""2.1.2""<c><\n>","-  ""version"": ""2.1.1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,0,39,1 Jul 2012,update macgyver,0,0,1,2,48,"+    ""macgyver"": ""~1.5""<\n>","-    ""macgyver"": ""~1.4""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,0,24,1 Jul 2012,tidy up a little,0,0,1,5,172,+exports ['es.split() works like String#split'] = function (test) {<\n>+  }<\n>,-exports ['pipeable'] = function (test) {<\n>-      console.log('88888888888888888888888!!!') <\n>-    }<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,0,23,1 Jul 2012,executable spec as a test,0,0,1,111,3302,+  assert that when stream enters pause state<c><\n>+  on drain is emitted eventually.<\n>+function applySpec (mac<c> stream) {<\n>+  function noop () {}<\n>+  function drain() {<\n>+    paused = false<\n>+    console.log('drain!')<\n>+  }  <\n>+  stream.end = mac(stream.end).once()<\n>+  var onDrain = mac(drain).never()<\n>+  stream.pause = mac(stream.pause)<\n>+    .isPassed(function () {<\n>+      if(paused) return<\n>+      console.log('entered pause state by pause()')<\n>+      paused = true<\n>+      onDrain.again()<\n>+    })<\n>+  stream.on('drain'<c> onDrain)<\n>+    .throws(function (err<c> threw) {<\n>+      it(threw).equal(!stream.writable)<\n>+    })<\n>+      it(written)<\n>+        .typeof('boolean')     //be strict.<\n>+        .equal(!stream.paused) //expose pause state. must be consistant.<\n>+      if(!paused && !written) {<\n>+        //after write returns false<c> it must emit drain eventually.<\n>+        console.log('entered pause state by write() === false')<\n>+        onDrain.again()<\n>+      }<\n>+      paused = !written<\n>+    })<\n>+  var onClose = mac(noop).once()<\n>+  var onEnd   = mac(noop).once().before(onClose)<\n>+  var onData  = mac(noop).before(onEnd)<\n>+  stream.on('close'<c> onClose)<\n>+  stream.on('end'<c> onEnd)<\n>+  stream.on('data'<c> onData)<\n>+exports['simple stream'] = function (test) {<\n>+  var mac = macgyver()<\n>+  var stream = es.through()<\n>+  applySpec(mac<c> stream)<\n>+    stream.write(1)<\n>+    stream.write(1)<\n>+    stream.pause()<\n>+    stream.write(1)<\n>+    stream.resume()<\n>+    stream.write(1)<\n>+    stream.end(2) //this will call write()<\n>+    process.nextTick(function () {<\n>+      mac.validate()<\n>+      test.done()<\n>+    })<\n>+    <\n>+exports['throw on write when !writable'] = function (test) {<\n>+  var mac = macgyver()<\n>+  var stream = es.through()<\n>+  applySpec(mac<c> stream)<\n>+  stream.write(1)<\n>+  stream.write(1)<\n>+  stream.end(2) //this will call write()<\n>+  stream.write(1) //this will be throwing...<c> but the spec will catch it.<\n>+  process.nextTick(function () {<\n>+    mac.validate()<\n>+    test.done()<\n>+  })<\n>+  <\n>+exports['end fast'] = function (test) {<\n>+  var mac = macgyver()<\n>+  var stream = es.through()<\n>+  applySpec(mac<c> stream)<\n>+  stream.end() //this will call write()<\n>+  process.nextTick(function () {<\n>+    mac.validate()<\n>+    test.done()<\n>+  })<\n>+  <\n>,-var mac = macgyver()<\n>-process.on('exit'<c> mac.validate)<\n>-var stream = es.through()<\n>-function noop () {}<\n>-/*<\n>-  actually<c> this spec is not quite right.<\n>-  write should not be called after end has returned.<\n>-  which is slightly different to the semantics of this.<\n>- */<\n>-function onDrain() {console.log('drain')}<\n>-stream.end = mac(stream.end).once()<\n>-    .beforeReturns(stream.end)<\n>-        it(written)<\n>-          .typeof('boolean')     //be strict.<\n>-          .equal(!stream.paused) //expose pause state. must be consistant.<\n>-        if(!paused && !written) {<\n>-          //after write returns false<c> it must emit drain eventually.<\n>-          console.log('expect drain')<\n>-          stream.once('drain'<c> mac(onDrain).once())<\n>-        }<\n>-        paused = !written<\n>-      })<\n>-var onClose = mac(noop).once()<\n>-var onEnd   = mac(noop).once().before(onClose)<\n>-var onData  = mac(noop).before(onEnd)<\n>-stream.on('close'<c> onClose)<\n>-stream.on('end'<c> onEnd)<\n>-stream.on('data'<c> onData)<\n>-stream.write(1)<\n>-stream.write(1)<\n>-stream.pause()<\n>-stream.write(1)<\n>-stream.resume()<\n>-stream.write(1)<\n>-stream.end(2) //this will call write()<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,0,23,1 Jul 2012,use macgyver for tests,0,0,1,2,45,"+    ""macgyver"": ""~1.4""<\n>","-    ""macgyver"": ""1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,5,27,29 Jun 2012,2.1.1,0,0,1,2,46,"+  ""version"": ""2.1.1""<c><\n>","-  ""version"": ""2.1.0""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,5,26,29 Jun 2012,found some bugs! fixed them,0,0,1,13,329,+  var ended = false<c> destroyed = false<\n>+  stream.paused = false  <\n>+    if(ended) throw new Error('cannot call end twice')<\n>+    if(destroyed) return<\n>+    destroyed = true<\n>+    if(stream.paused) {<\n>+      stream.paused = false<\n>+    }<\n>,-  var ended = false<\n>-  <\n>-    if(ended) return<\n>-    if(stream.paused)<\n>-    stream.paused = false<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,5,26,29 Jun 2012,experimenting with new test styles,0,1,1,60,1872,+/*<\n>+  assert that data is called many times<\n>+  assert that end is called eventually<\n>+*/<\n>+var macgyver = require('macgyver')<\n>+var es = require('..')<\n>+var it = require('it-is').style('colour')<\n>+var mac = macgyver()<\n>+process.on('exit'<c> mac.validate)<\n>+var stream = es.through()<\n>+function noop () {}<\n>+/*<\n>+  actually<c> this spec is not quite right.<\n>+  write should not be called after end has returned.<\n>+  which is slightly different to the semantics of this.<\n>+ */<\n>+function onDrain() {console.log('drain')}<\n>+  var paused = false<\n>+stream.end = mac(stream.end).once()<\n>+  stream.write = <\n>+    mac(stream.write)<\n>+    .beforeReturns(stream.end)<\n>+    .returns(function (written) {<\n>+        it(written)<\n>+          .typeof('boolean')     //be strict.<\n>+          .equal(!stream.paused) //expose pause state. must be consistant.<\n>+        if(!paused && !written) {<\n>+          //after write returns false<c> it must emit drain eventually.<\n>+          console.log('expect drain')<\n>+          stream.once('drain'<c> mac(onDrain).once())<\n>+        }<\n>+        paused = !written<\n>+      })<\n>+var onClose = mac(noop).once()<\n>+var onEnd   = mac(noop).once().before(onClose)<\n>+var onData  = mac(noop).before(onEnd)<\n>+stream.on('close'<c> onClose)<\n>+stream.on('end'<c> onEnd)<\n>+stream.on('data'<c> onData)<\n>+stream.write(1)<\n>+stream.write(1)<\n>+stream.pause()<\n>+stream.write(1)<\n>+stream.resume()<\n>+stream.write(1)<\n>+stream.end(2) //this will call write()<\n>+/*<\n>+  okay<c> that was easy enough<c> whats next?<\n>+  say<c> after you call paused()<c> write should return false<\n>+  until resume is called.<\n>+  simple way to implement this:<\n>+    write must return !paused<\n>+  after pause() paused = true<\n>+  after resume() paused = false<\n>+  on resume<c> if !paused drain is emitted again.<\n>+  after drain<c> !paused<\n>+  there are lots of subtle ordering bugs in streams.<\n>+  example<c> set !paused before emitting drain.<\n>+  the stream api is stateful. <\n>+*/<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,5,25,29 Jun 2012,use macgyver,0,0,1,3,64,"+    ""ubelt"": ""~2.9""<c><\n>+    ""macgyver"": ""1""<\n>","-    ""ubelt"": ""~2.9""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,0,44,27 Jun 2012,no longer maintant for 0.4,0,0,1,3,73,+  - 0.8<\n>,-  - 0.4<\n>-  - 0.7 # development version of 0.8<c> may be unstable<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,0,26,27 Jun 2012,2.1.0,0,0,1,2,47,"+  ""version"": ""2.1.0""<c><\n>","-  ""version"": ""2.0.10""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,0,4,27 Jun 2012,simplify test,0,0,1,11,255,+  split<\n>+    .pipe(es.replace('7'<c> 'seven'))<\n>+    .pipe(es.join(function (err<c> string) {<\n>+    }))<\n>,-  var replace = es.replace('7'<c> 'seven')<\n>-  es.connect(split<c> <\n>-    replace<c> <\n>-//    es.log('aeounh')<c> <\n>-    es.join(function (err<c> string) {<\n>-    })<\n>-  )<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,0,3,27 Jun 2012,add destroy to all streams and call it nextTick in through,0,0,1,74,2057,+  //this will be registered as the first 'end' listener<\n>+  //must call destroy next tick<c> to make sure we're after any<\n>+  //stream piped from here. <\n>+      process.nextTick(function () {<\n>+        stream.destroy()<\n>+      })<\n>+  stream.destroy = function () {<\n>+    merge.forEach(function (e) {<\n>+      if(e.destroy) e.destroy()<\n>+    })<\n>+  }<\n>+    <c> array = []<c> isDone = false<\n>+    isDone = true<\n>+  a.destroy = function () {<\n>+    a.writable = a.readable = false<\n>+    if(isDone) return<\n>+    done(new Error('destroyed befor end')<c> array)<\n>+  }<\n>+    <c> ended = false<\n>+    if(ended) return<\n>+    while(i < l && !paused && !ended) {<\n>+    if(i == l && !ended)<\n>+      ended = true<c> stream.readable = false<c> stream.emit('end')<\n>+  stream.destroy = function () {<\n>+    ended = true<\n>+    stream.emit('close')<\n>+  }<\n>+  ;['write'<c> 'end'<c> 'destroy'].forEach(function (func) {<\n>+  return es.through(function (data) {<\n>+      this.emit('data'<c> str)<\n>+    this.emit('data'<c> data)<\n>+  })<\n>+  return es.through(function (data) { body += data }<c><\n>+    function () {<\n>+      stream.emit('data'<c> body)<\n>+      stream.emit('end')<\n>+      if(callback) callback(null<c> body)<\n>+    })<\n>,-      stream.destroy()<\n>-    <c> array = []<\n>-    while(i < l && !paused) {<\n>-    if(i == l)<\n>-      stream.emit('end')<c> stream.readable = false<\n>-  ;['write'<c> 'end'<c> 'close'].forEach(function (func) {<\n>-  thepipe.destroy = function () {<\n>-    if(reader.destroy)<\n>-      reader.destroy()<\n>-    if(writer.destroy)<\n>-      writer.destroy()<\n>-  }<\n>-  var stream = new Stream()<\n>-  stream.readable = stream.writable = true<\n>-  stream.write = function (data) {<\n>-      stream.emit('data'<c> str)<\n>-    stream.emit('data'<c> data)<\n>-  }<\n>-  stream.end = function (data) {<\n>-    if(data)<\n>-      this.write(data)<\n>-    this.emit('end')<\n>-  }<\n>-  return stream<\n>-  stream.readable = true<\n>-  stream.writable = true<\n>-  stream.write = function (data) { body += data }<\n>-  stream.end = function (data) {<\n>-    if(data)<\n>-      body += data<\n>-    if(callback)<\n>-      callback(null<c> body)<\n>-    stream.emit('data'<c> body)<\n>-    stream.emit('end')<\n>-  }<\n>-  return stream<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,22,47,26 Jun 2012,2.0.10,0,0,1,2,47,"+  ""version"": ""2.0.10""<c><\n>","-  ""version"": ""2.0.9""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,22,47,26 Jun 2012,do not emit inside try {..} because a listener may throw,0,0,1,6,257,+    var obj<\n>+        obj = JSON.parse(data.toString())<\n>+      return console.error(err<c> 'attemping to parse:'<c> data)<\n>+    this.emit('data'<c> obj)<\n>,-        this.emit('data'<c> JSON.parse(data.toString()))<\n>-      console.error(err<c> 'attemping to parse:'<c> data)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,7,28,26 Jun 2012,2.0.9,0,0,1,2,46,"+  ""version"": ""2.0.9""<c><\n>","-  ""version"": ""2.0.8""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,7,28,26 Jun 2012,set props before announcing the state has changed,0,0,1,4,125,+    if(!stream.writable)<\n>+    stream.emit('close')<\n>,-    if(!(stream.writable || stream.readable))<\n>-    stream.emit('close')<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,55,26 Jun 2012,2.0.8,0,0,1,2,46,"+  ""version"": ""2.0.8""<c><\n>","-  ""version"": ""2.0.7""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,55,26 Jun 2012,oops copy paste error,0,0,1,2,66,+  stream.on('end'<c> function () {<\n>,-  this.on('end'<c> function () {<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,53,26 Jun 2012,always listen for half duplex close,0,0,1,11,321,+  this.on('end'<c> function () {<\n>+    stream.readable = false<\n>+    if(!(stream.writable || stream.readable))<\n>+      stream.destroy()<\n>+  })<\n>,-    if(this.readable)<\n>-      this.once('end'<c> function () {<\n>-        stream.readable = false<\n>-        if(!(stream.writable || stream.readable))<\n>-          stream.destroy()<\n>-      })<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,36,26 Jun 2012,2.0.7,0,0,1,2,46,"+  ""version"": ""2.0.7""<c><\n>","-  ""version"": ""2.0.6""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,36,26 Jun 2012,add destroy to duplex,0,0,1,6,136,+  thepipe.destroy = function () {<\n>+    if(reader.destroy)<\n>+      reader.destroy()<\n>+    if(writer.destroy)<\n>+      writer.destroy()<\n>+  }<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,9,26 Jun 2012,2.0.6,0,0,1,2,46,"+  ""version"": ""2.0.6""<c><\n>","-  ""version"": ""2.0.5""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,6,9,26 Jun 2012,destroy when both sides is ended (if one sided stream destroy when that side is ended),0,0,1,10,278,+    if(this.readable)<\n>+      this.once('end'<c> function () {<\n>+        stream.readable = false<\n>+        if(!(stream.writable || stream.readable))<\n>+          stream.destroy()<\n>+      })<\n>+    this.writable = false<\n>+    if(!this.readable)<\n>+      this.destroy()<\n>,-    stream.destroy()<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,5,36,26 Jun 2012,2.0.5,0,0,1,2,46,"+  ""version"": ""2.0.5""<c><\n>","-  ""version"": ""2.0.4""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,5,36,26 Jun 2012,destroy should set writable = readable = false,0,0,1,1,47,+    stream.writable = stream.readable = false<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,2,20,15 Jun 2012,2.0.4,0,0,1,34,1017,"+  ""name"": ""event-stream""<c><\n>+  ""version"": ""2.0.4""<c><\n>+  ""description"": ""construct pipes of streams of events""<c><\n>+  ""homepage"": ""http://github.com/dominictarr/event-stream""<c><\n>+  ""repository"": {<\n>+    ""type"": ""git""<c><\n>+    ""url"": ""git://github.com/dominictarr/event-stream.git""<\n>+  }<c><\n>+  ""dependencies"": {<\n>+  }<c><\n>+  ""devDependencies"": {<\n>+    ""it-is"": ""1""<c><\n>+    ""ubelt"": ""~2.9""<\n>+  }<c><\n>+  ""scripts"": {<\n>+    ""test"": ""asynct test/""<\n>+  }<c><\n>+  ""author"": ""Dominic Tarr <dominic.tarr@gmail.com> (http://bit.ly/dominictarr)""<c><\n>+  ""optionalDependencies"": {}<c><\n>+  ""engines"": {<\n>+    ""node"": ""*""<\n>","-<c> ""version"": ""2.0.3""<\n>-<c> ""description"": ""construct pipes of streams of events""<\n>-<c> ""homepage"": ""http://github.com/dominictarr/event-stream""<\n>-<c> ""repository"": <\n>-  { ""type"": ""git""<\n>-  <c> ""url"": ""https://github.com/dominictarr/event-stream.git"" }<\n>-<c> ""dependencies"": {<\n>-  }<\n>-<c> ""devDependencies"": {<\n>-    ""it-is"":  ""1""<c><\n>-    ""ubelt"":""~2.9""<\n>-<c> ""scripts"": {""test"": ""asynct test/""}<\n>-<c> ""author"": ""Dominic Tarr <dominic.tarr@gmail.com> (http://bit.ly/dominictarr)""<\n>",F
null,null,null,null,null,null,Michael Hart,92,23,490,93,User,1,3239,Thu,22,42,14 Jun 2012,Added map filter test for good measure,0,0,1,20,493,+exports ['map applied to a stream with filtering'] = function (test) {<\n>+  var input = [1<c>2<c>3<c>7<c>5<c>3<c>1<c>9<c>0<c>2<c>4<c>6]<\n>+  var doubler = es.map(function (data<c> callback) {<\n>+    if (data % 2)<\n>+      callback(null<c> data * 2)<\n>+    else<\n>+      callback()<\n>+  })<\n>+  <\n>+  readStream(doubler<c> function (err<c> output) {<\n>+    it(output).deepEqual(input.filter(function (j) {<\n>+      return j % 2<\n>+    }).map(function (j) {<\n>+      return j * 2<\n>+    }))<\n>+    test.done()<\n>+  })<\n>+  <\n>+  writeArray(input<c> doubler)<\n>+  <\n>,,F
null,null,null,null,null,null,Michael Hart,92,23,490,93,User,1,3239,Thu,22,39,14 Jun 2012,Added tests for mapSync filter,0,0,1,33,829,+exports ['simple mapSync applied to a stream'] = function (test) {<\n>+  var input = [1<c>2<c>3<c>7<c>5<c>3<c>1<c>9<c>0<c>2<c>4<c>6]<\n>+  var doubler = es.mapSync(function (data) {<\n>+    return data * 2<\n>+  })<\n>+  <\n>+  readStream(doubler<c> function (err<c> output) {<\n>+    it(output).deepEqual(input.map(function (j) {<\n>+      return j * 2<\n>+    }))<\n>+    test.done()<\n>+  })<\n>+  <\n>+  writeArray(input<c> doubler)<\n>+  <\n>+exports ['mapSync applied to a stream with filtering'] = function (test) {<\n>+  var input = [1<c>2<c>3<c>7<c>5<c>3<c>1<c>9<c>0<c>2<c>4<c>6]<\n>+  var doubler = es.mapSync(function (data) {<\n>+    if (data % 2)<\n>+      return data * 2<\n>+  })<\n>+  <\n>+  readStream(doubler<c> function (err<c> output) {<\n>+    it(output).deepEqual(input.filter(function (j) {<\n>+      return j % 2<\n>+    }).map(function (j) {<\n>+      return j * 2<\n>+    }))<\n>+    test.done()<\n>+  })<\n>+  <\n>+  writeArray(input<c> doubler)<\n>+  <\n>,,F
null,null,null,null,null,null,Michael Hart,92,23,490,93,User,1,3239,Thu,22,27,14 Jun 2012,Match mapSync filter behaviour to map,0,0,1,4,149,+    var mappedData = sync(data)<\n>+    if (typeof mappedData !== 'undefined')<\n>+      this.emit('data'<c> mappedData)<\n>,-    this.emit('data'<c> sync(data))<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,4,36,13 Jun 2012,2.0.3,0,0,1,2,44,"+<c> ""version"": ""2.0.3""<\n>","-<c> ""version"": ""2.0.2""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,4,35,13 Jun 2012,ignore empty lines,0,0,1,3,147,+      if(data) //ignore empty lines<\n>+        this.emit('data'<c> JSON.parse(data.toString()))<\n>,-      this.emit('data'<c> JSON.parse(data.toString()))<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,4,24,13 Jun 2012,2.0.2,0,0,1,2,44,"+<c> ""version"": ""2.0.2""<\n>","-<c> ""version"": ""2.0.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,4,24,13 Jun 2012,oops reference error,0,0,1,2,105,+      this.emit('data'<c> JSON.parse(data.toString()))<\n>,-      this.emit('data'<c> JSON.parse(e.toString()))<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,4,21,13 Jun 2012,2.0.1,0,0,1,2,44,"+<c> ""version"": ""2.0.1""<\n>","-<c> ""version"": ""2.0.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,4,20,13 Jun 2012,log but continue on data that failed to parse,0,0,1,10,269,+  return es.through(function (data) {<\n>+    try {<\n>+      this.emit('data'<c> JSON.parse(e.toString()))<\n>+    } catch (err) {<\n>+      console.error(err<c> 'attemping to parse:'<c> data)<\n>+    }<\n>+  })<\n>,-  return es.mapSync(function (e){<\n>-    return JSON.parse(e.toString())<\n>-  }) <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,2,57,6 Jun 2012,2.0.0,0,0,1,2,44,"+<c> ""version"": ""2.0.0""<\n>","-<c> ""version"": ""1.3.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,2,55,6 Jun 2012,update documentation. move most useful stuff to the top,0,0,1,63,2815,+## through (write?<c> end?)<\n>+Reemits data synchronously. Easy way to create syncronous through streams.<\n>+Pass in an optional `write` and `end` methods. They will be called in the <\n>+context of the stream. Use `this.pause()` and `this.resume()` to manage flow.<\n>+Check `this.paused` to see current flow state. (write always returns `!this.paused`)<\n>+this function is the basis for most of the syncronous streams in `event-stream`.<\n>+``` js<\n>+es.through(function write(data) {<\n>+    this.emit('data'<c> data)<\n>+    //this.pause() <\n>+  }<c><\n>+  function end () { //optional<\n>+    this.emit('end')<\n>+  })<\n>+```<\n>+## mapSync (syncFunction)<\n>+Same as `map`<c> but the callback is called synchronously. Based on `es.through`<\n>+## split (matcher)<\n>+Break up a stream and reassemble it so that each line is a chunk. matcher may be a `String`<c> or a `RegExp` <\n>+Example<c> read every line in a file ...<\n>+``` js<\n>+  es.connect(<\n>+    fs.createReadStream(file<c> {flags: 'r'})<c><\n>+    es.split()<c><\n>+    es.map(function (line<c> cb) {<\n>+       //do something with the line <\n>+       cb(null<c> line)<\n>+    })<\n>+  )<\n>+```<\n>+`split` takes the same arguments as `string.split` except it defaults to '\n' instead of '<c>'<c> and the optional `limit` paremeter is ignored.<\n>+[String#split](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/split)<\n>+## join (seperator)<\n>+create a through stream that emits `seperator` between each chunk<c> just like Array#join.<\n>+(for legacy reasons<c> if you pass a callback instead of a string<c> join is a synonym for `es.wait`)<\n>+## replace (from<c> to)<\n>+Replace all occurences of `from` with `to`. `from` may be a `String` or a `RegExp`.  <\n>+Works just like `string.split(from).join(to)`<c> but streaming.<\n>,-## split (matcher)<\n>-Break up a stream and reassemble it so that each line is a chunk. matcher may be a `String`<c> or a `RegExp` <\n>-Example<c> read every line in a file ...<\n>-``` js<\n>-  es.connect(<\n>-    fs.createReadStream(file<c> {flags: 'r'})<c><\n>-    es.split()<c><\n>-    es.map(function (line<c> cb) {<\n>-       //do something with the line <\n>-       cb(null<c> line)<\n>-    })<\n>-  )<\n>-```<\n>-`split` takes the same arguments as `string.split` except it defaults to '\n' instead of '<c>'<c> and the optional `limit` paremeter is ignored.<\n>-[String#split](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/split)<\n>-## join (seperator)<\n>-create a through stream that emits `seperator` between each chunk<c> just like Array#join.<\n>-(for legacy reasons<c> if you pass a callback instead of a string<c> join is a synonym for `es.wait`)<\n>-## replace (from<c> to)<\n>-Replace all occurences of `from` with `to`. `from` may be a `String` or a `RegExp`.  <\n>-Works just like `string.split(from).join(to)`<c> but streaming.<\n>-## through ()<\n>-reemits data synchronously. useful for testing.<\n>-## asyncThrough ()<\n>-reemits data asynchronously. useful for testing.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,2,55,6 Jun 2012,start rewriting some sync streams with es.through,0,0,1,71,2172,+// XXX: rewrite this. this is crap. but do I actually use it? maybe just throw it away?<\n>+// okay<c> it's used in snob. so... throw this out and let snob use a legacy version. (fix later/never)<\n>+    <c> destroyed = false<\n>+    if(ended) throw new Error('map stream is not writable')<\n>+      if(destroyed) return<\n>+      var written = mapper.apply(null<c> args)<\n>+  stream.destroy = function () {<\n>+    ended = destroyed = true<\n>+    stream.writable = stream.readable = paused = false<\n>+  }<\n>+es.mapSync = function (sync) { <\n>+  return es.through(function write(data) {<\n>+    this.emit('data'<c> sync(data))<\n>+  var soFar = ''<\n>+    matcher = '\n'<\n>+  return es.through(function (buffer) { <\n>+    var stream = this<\n>+      <c> pieces = (soFar + buffer).split(matcher)<\n>+  }<c><\n>+  function () {<\n>+      this.emit('data'<c> soFar)  <\n>+    this.emit('end')<\n>+  })<\n>+    if (shut) return false //pause up stream pipes  <\n>,-es.asyncThrough = function () {<\n>-  var stream = es.through()<\n>-  var queue = []<\n>-  var ended = false<\n>-  stream.readable = stream.writable = true<\n>-  stream.flush = function () {<\n>-    while(queue.length)<\n>-      stream.emit('data'<c> queue.shift())  <\n>-    if(ended) stream.emit('end')<\n>-  }<\n>-  stream.write = function (data) {<\n>-    if(ended) return<\n>-    if(!queue.length)<\n>-      process.nextTick(stream.flush)<\n>-    queue.push(data)<\n>-    return !stream.paused<\n>-  }<\n>-  stream.end = function (data) {<\n>-    if(data) stream.write(data)<\n>-    ended = true<\n>-    if(!queue.length)<\n>-      stream.emit('end')<\n>-  }<\n>-  return stream<\n>-      var written = mapper.apply(null<c>args)<\n>-es.mapSync = function (sync) {<\n>-  <\n>-  return es.map(function () {<\n>-    var args = [].slice.call(arguments)<\n>-      <c> callback = args.pop()<\n>-      <\n>-      callback(null<c> sync.apply(null<c> args))<\n>-  var stream = new Stream()<\n>-    <c> soFar = ''  <\n>-  <\n>-      matcher = '\n'<\n>-  stream.writable = true<\n>-  stream.readable = true;  //necessary for reading more than one data event<\n>-  stream.write = function (buffer) {<\n>-    var pieces = (soFar + buffer).split(matcher)<\n>-  }<\n>-  stream.end = function () {<\n>-      stream.emit('data'<c> soFar)  <\n>-    stream.emit('end')<\n>-  }<\n>-  return stream<\n>-    if (shut) return //false //pause up stream pipes  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,19,15,5 Jun 2012,1.3.1,0,0,1,2,44,"+<c> ""version"": ""1.3.1""<\n>","-<c> ""version"": ""1.3.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,19,15,5 Jun 2012,through should emit close,0,0,1,24,732,+    stream.destroy()<\n>+  }<\n>+  /*<\n>+    destroy is called on a writable stream when the upstream closes.<\n>+    it's basically END but something has gone wrong.<\n>+    I'm gonna emit 'close' and change then otherwise act as 'end'<\n>+  */<\n>+  stream.destroy = function () {<\n>+    stream.emit('close')<\n>+    ended = true<\n>+  stream.destroy = function () {<\n>+    stream.emit('close')<\n>+    stream.emit('end')<\n>+    ended = true<\n>+  }<\n>+  return es.through(function (data) {<\n>+    if(name) console.error(name<c> data)<\n>+    else     console.error(data)<\n>+    this.emit('data'<c> data)<\n>,-  return es.map(function () {<\n>-    var cb = args.pop()<\n>-    console.error.apply(console<c> name ? [name].concat(args) : args)<\n>-    args.unshift(null)<\n>-    cb.apply(null<c> args)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,41,26 May 2012,1.3.0,0,0,1,2,44,"+<c> ""version"": ""1.3.0""<\n>","-<c> ""version"": ""1.2.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,40,26 May 2012,through may take custom write function,0,0,1,37,1022,+es.through = function (write<c> end) {<\n>+  write = write || function (data) { this.emit('data'<c> data) }<\n>+  end = (<\n>+    'sync'== end || !end<\n>+  //use sync end. (default)<\n>+  ? function () { this.emit('end') }<\n>+  : 'async' == end || end === true <\n>+  //use async end.<\n>+  //must eventually call drain if paused.<\n>+  //else will not end.<\n>+  ? function () {<\n>+      if(!this.paused)<\n>+        return this.emit('end')<\n>+     var self = this<\n>+     this.once('drain'<c> function () {<\n>+        self.emit('end')<\n>+      })<\n>+    }<\n>+  //use custom end function<\n>+  : end <\n>+  )<\n>+  var ended = false<\n>+    write.call(this<c> data)<\n>+    if(ended) return<\n>+    ended = true<\n>+    if(arguments.length) stream.write(data)<\n>+    end.call(this)<\n>+// merge / concat<\n>+es.concat = //actually this should be called concat<\n>+      stream.emit('end')<c> stream.readable = false<\n>,-es.through = function () {<\n>-    stream.emit('data'<c> data)<\n>-    if(data)<\n>-      stream.emit('data'<c>data)<\n>-    stream.emit('end')<\n>-// merge <\n>-      stream.emit('end')<c> stream.readible = false<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,6,21,26 May 2012,1.2.0,0,0,1,2,44,"+<c> ""version"": ""1.2.0""<\n>","-<c> ""version"": ""1.1.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,6,20,26 May 2012,through now has pause/resume,0,0,1,13,308,+    return !stream.paused<\n>+  stream.pause = function () {<\n>+    stream.paused = true<\n>+  }<\n>+  stream.resume = function () {<\n>+    if(stream.paused)<\n>+      stream.emit('drain')<\n>+    stream.paused = false<\n>+  }<\n>+  var stream = es.through()<\n>+    return !stream.paused<\n>,-  var stream = new Stream()<\n>-    return true<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,18,5,21 May 2012,1.1.0,0,0,1,2,44,"+<c> ""version"": ""1.1.0""<\n>","-<c> ""version"": ""1.0.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,18,5,21 May 2012,update readme on join replace wait,0,0,1,19,943,+## split (matcher)<\n>+Break up a stream and reassemble it so that each line is a chunk. matcher may be a `String`<c> or a `RegExp` <\n>+## join (seperator)<\n>+create a through stream that emits `seperator` between each chunk<c> just like Array#join.<\n>+(for legacy reasons<c> if you pass a callback instead of a string<c> join is a synonym for `es.wait`)<\n>+## replace (from<c> to)<\n>+Replace all occurences of `from` with `to`. `from` may be a `String` or a `RegExp`.  <\n>+Works just like `string.split(from).join(to)`<c> but streaming.<\n>+## wait (callback)<\n>+waits for stream to emit 'end'.<\n>,-## split ()<\n>-Break up a stream and reassemble it so that each line is a chunk.  <\n>-## join (callback)<\n>-## replace (from<c> to)<\n>-replace occurences of `from` with `to`. `from` may be a string<\n>-or a regular expression.<\n>-> TODO: this uses string.split(from).join(to) and does not <\n>-> emit data until it's received 'end'. need to make this stream properly.<\n>-> pull requests accepted.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,17,55,21 May 2012,join now matches Array#join and replace is streaming.,0,0,1,33,995,+  return es.connect(es.split(from)<c> es.join(to))<\n>+//<\n>+// join chunks with a joiner. just like Array#join<\n>+// also accepts a callback that is passed the chunks appended together<\n>+// this is still supported for legacy reasons.<\n>+// <\n>+es.join = function (str) {<\n>+  <\n>+  //legacy api<\n>+  if('function' === typeof str)<\n>+    return es.wait(str)<\n>+  var first = true<\n>+  stream.readable = stream.writable = true<\n>+  stream.write = function (data) {<\n>+    if(!first)<\n>+      stream.emit('data'<c> str)<\n>+    first = false<\n>+    stream.emit('data'<c> data)<\n>+    return true<\n>+  }<\n>+      this.write(data)<\n>+    this.emit('end')<\n>+// wait. callback when 'end' is emitted<c> with all chunks appended as string.<\n>+es.wait = function (callback) {<\n>,-  var body = ''<\n>-  stream.readable = true<\n>-  stream.writable = true<\n>-  stream.write = function (data) { body += data; return true }<\n>-      body += data<\n>-    if(body) stream.emit('data'<c> body.split(from).join(to))<\n>-    stream.emit('end')<\n>-// join.<\n>-es.join = function (callback) {<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,17,36,21 May 2012,update documentation for split,0,0,1,2,241,+`split` takes the same arguments as `string.split` except it defaults to '\n' instead of '<c>'<c> and the optional `limit` paremeter is ignored.<\n>+[String#split](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/split)<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,17,27,21 May 2012,1.0.0,0,0,1,2,45,"+<c> ""version"": ""1.0.0""<\n>","-<c> ""version"": ""0.10.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,17,27,21 May 2012,split with regexp thanks to @mhart,0,0,1,2,78,+      stream.emit('data'<c> piece)<\n>,-      stream.emit('data'<c> piece + matcher)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,17,26,21 May 2012,split with regexp compat with v1 api,0,0,1,2,60,+  var split = es.split(/(1)/)<\n>,-  var split = es.split('1')<\n>,F
null,null,null,null,null,null,Michael Hart,92,23,490,93,User,1,3239,Mon,14,12,21 May 2012,Clean up (and speed up) es.split(),0,0,1,20,478,+    var pieces = (soFar + buffer).split(matcher)<\n>+    soFar = pieces.pop()<\n>+    pieces.forEach(function (piece) {<\n>+      stream.emit('data'<c> piece + matcher)<\n>+    })<\n>+    return true<\n>,-    buffer = buffer.toString()<\n>-    var l = buffer.length<\n>-      <c> i = 0<\n>-    while (i < l) {<\n>-      var c = buffer[i].toString()<\n>-      soFar += c<\n>-      if (c == matcher) {<\n>-        var n = soFar;<\n>-        soFar = '' <\n>-        this.emit('data'<c> n)<\n>-      }<\n>-    i++<\n>-    }<\n>-    return true;<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,2,57,18 May 2012,0.10.0,0,0,1,2,45,"+<c> ""version"": ""0.10.0""<\n>","-<c> ""version"": ""0.9.8""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,2,56,18 May 2012,merge function,0,0,1,24,622,+// merge <\n>+//<\n>+// combine multiple streams into a single stream.<\n>+// will emit end only once<\n>+es.merge = function (/*streams...*/) {<\n>+  var toMerge = [].slice.call(arguments)<\n>+  var stream = new Stream()<\n>+  var endCount = 0<\n>+  stream.writable = stream.readable = true<\n>+  toMerge.forEach(function (e) {<\n>+    e.pipe(stream<c> {end: false})<\n>+    var ended = false<\n>+    e.on('end'<c> function () {<\n>+      if(ended) return<\n>+      ended = true<\n>+      endCount ++<\n>+      if(endCount == toMerge.length)<\n>+        stream.emit('end') <\n>+    })<\n>+  })<\n>+  stream.write = function (data) {<\n>+    this.emit('data'<c> data)<\n>+  }<\n>+  return stream<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,2,56,18 May 2012,test for merge function,0,1,1,14,524,+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> d = require('ubelt')<\n>+exports.merge = function (t) {<\n>+  var odd = d.map(1<c> 3<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+  var even = d.map(2<c> 4<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+  var r1 = es.readArray(even)<\n>+  var r2 = es.readArray(odd)<\n>+  var writer = es.writeArray(function (err<c> array){<\n>+    if(err) throw err //unpossible<\n>+    it(array.sort()).deepEqual(even.concat(odd).sort())<\n>+    t.done() <\n>+  })<\n>+  es.merge(r1<c> r2).pipe(writer)<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,14,47,3 May 2012,0.9.8,0,0,1,2,44,"+<c> ""version"": ""0.9.8""<\n>","-<c> ""version"": ""0.9.7""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Thu,14,47,3 May 2012,updated documentation,0,0,2,24,779,+//<\n>+// join.<\n>+//<\n>+## duplex (writeStream<c> readStream)<\n>+## through ()<\n>+reemits data synchronously. useful for testing.<\n>+## asyncThrough ()<\n>+reemits data asynchronously. useful for testing.<\n>+## join (callback)<\n>+joins chunks of a stream into a single string. <\n>+takes an optional callback<c> which will be passed the <\n>+complete string when it receives the 'end' event.<\n>+also<c> emits a simgle 'data' event.<\n>+``` js<\n>+readStream.pipe(es.join(function (err<c> text) {<\n>+  // have complete text here.<\n>+```<\n>+## replace (from<c> to)<\n>+replace occurences of `from` with `to`. `from` may be a string<\n>+or a regular expression.<\n>+> TODO: this uses string.split(from).join(to) and does not <\n>+> emit data until it's received 'end'. need to make this stream properly.<\n>+> pull requests accepted.<\n>,-## duplex<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,21,28,25 Apr 2012,0.9.7,0,0,1,2,44,"+<c> ""version"": ""0.9.7""<\n>","-<c> ""version"": ""0.9.6""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,21,28,25 Apr 2012,console.error must be called with console as context in browser,0,0,1,2,135,+    console.error.apply(console<c> name ? [name].concat(args) : args)<\n>,-    console.error.apply(null<c> name ? [name].concat(args) : args)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,21,18,25 Apr 2012,0.9.6,0,0,1,2,44,"+<c> ""version"": ""0.9.6""<\n>","-<c> ""version"": ""0.9.3""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,19,46,25 Apr 2012,0.9.3,0,0,1,2,44,"+<c> ""version"": ""0.9.3""<\n>","-<c> ""version"": ""0.9.2""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,19,45,25 Apr 2012,some small changes to play with browserify more nicely,0,0,1,7,366,+  if(process.title != 'node')<\n>+    return console.error('cannot use es.pipeable in the browser')<\n>+  //(require) inside brackets to fool browserify<c> because this does not make sense in the browser.<\n>+  var opts = (require)('optimist').argv<\n>+    var protocol = (require)(opts.protocol)<\n>,-  var opts = require('optimist').argv<\n>-    var protocol = require(opts.protocol)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,21,44,21 Apr 2012,0.9.2,0,0,1,2,44,"+<c> ""version"": ""0.9.2""<\n>","-<c> ""version"": ""0.9.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,21,44,21 Apr 2012,can pass name to es.log(name),0,0,1,3,144,+    console.error.apply(null<c> name ? [name].concat(args) : args)<\n>,-    if(name) args.slice().unshift(name)<\n>-    console.error.apply(null<c> args)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,20,26,21 Apr 2012,0.9.1,0,0,1,2,44,"+<c> ""version"": ""0.9.1""<\n>","-<c> ""version"": ""0.9.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,20,24,21 Apr 2012,fix asyncThrough,0,0,1,1,69,,-  bLen = bLen == null ? -1 : bLen //default to -1<c> infinite buffer.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,20,16,21 Apr 2012,0.9.0,0,0,1,2,44,"+<c> ""version"": ""0.9.0""<\n>","-<c> ""version"": ""0.8.2""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,20,15,21 Apr 2012,added asyncThrough,0,0,1,31,885,+// buffered<\n>+//<\n>+// same as a through stream<c> but won't emit a chunk until the next tick.<\n>+// does not support any pausing. intended for testing purposes.<\n>+es.asyncThrough = function () {<\n>+  var stream = new Stream()<\n>+  var queue = []<\n>+  var ended = false<\n>+  bLen = bLen == null ? -1 : bLen //default to -1<c> infinite buffer.<\n>+  stream.readable = stream.writable = true<\n>+  stream.flush = function () {<\n>+    while(queue.length)<\n>+      stream.emit('data'<c> queue.shift())  <\n>+    if(ended) stream.emit('end')<\n>+  }<\n>+  stream.write = function (data) {<\n>+    if(ended) return<\n>+    if(!queue.length)<\n>+      process.nextTick(stream.flush)<\n>+    queue.push(data)<\n>+    return true<\n>+  }<\n>+  stream.end = function (data) {<\n>+    if(data) stream.write(data)<\n>+    ended = true<\n>+    if(!queue.length)<\n>+      stream.emit('end')<\n>+  }<\n>+  return stream<\n>+    //pipe only allows one argument. so<c> do not <\n>,-    <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,31,7 Apr 2012,0.8.2,0,0,1,2,44,"+<c> ""version"": ""0.8.2""<\n>","-<c> ""version"": ""0.8.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,31,7 Apr 2012,remove unnecessary files liing about,1,0,1,3,92,,"-[submodule ""test""]<\n>-	path = test<\n>-	url = git@github.com:dominictarr/event-stream_tests.git<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,13,7 Apr 2012,add travisci sticker,0,0,1,3,173,+<img src=https://secure.travis-ci.org/dominictarr/event-stream.png?branch=master><\n>+--><\n>,-[test are in event-stream_tests](https://github.com/dominictarr/event-stream_tests)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,9,7 Apr 2012,git thought this file had changed. commit just to shut it up,0,0,1,1,29,,-    console.error('drain!')<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,8,7 Apr 2012,unbroke test considering making split behave like String.split with regards to streams that end in a split character,0,0,1,10,418,+        //String.split will append an empty string ''<\n>+        //if the string ends in a split pattern.<\n>+        //es.split doesn't which was breaking this test.<\n>+        //clearly<c> appending the empty string is correct.<\n>+        //tests are passing though. which is the current job.<\n>+        if(v)<\n>+          it(actual[k]).like(v)<\n>+      console.log('88888888888888888888888!!!') <\n>,-        it(actual[k]).like(v)<\n>-  <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,15,5,7 Apr 2012,fixed handling of drain events,0,0,1,3,190,+        if(paused) paused = false<c> stream.emit('drain') //written all the incoming events<\n>,-        if(paused) stream.emit('drain') //written all the incoming events<\n>-        paused = false<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,26,7 Apr 2012,fix package.json,0,0,1,4,83,"+    ""asynct"": ""*""<c><\n>+    ""ubelt"":""~2.9""<\n>","-    ""nodeunit"": ""*""<c><\n>-    ""d-utils"":""2.3""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,26,7 Apr 2012,tests into this repo,0,8,8,512,15254,"+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> d = require('ubelt')<\n>+function makeExamplePipe() {<\n>+  return es.connect(<\n>+    es.map(function (data<c> callback) {<\n>+      callback(null<c> data * 2)<\n>+    })<c><\n>+    es.map(function (data<c> callback) {<\n>+      d.delay(callback)(null<c> data)    <\n>+    })<c><\n>+    es.map(function (data<c> callback) {<\n>+      callback(null<c> data + 2)<\n>+    }))<\n>+exports['simple pipe'] = function (test) {<\n>+  var pipe = makeExamplePipe()<\n>+  pipe.on('data'<c> function (data) {<\n>+    it(data).equal(18)<\n>+    test.done()<\n>+  })<\n>+  <\n>+  pipe.write(8)<\n>+exports['read array then map'] = function (test) {<\n>+  var readThis = d.map(3<c> 6<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+    <c> first = es.readArray(readThis)<\n>+    <c> read = []<\n>+    <c> pipe =<\n>+  es.connect(<\n>+    first<c><\n>+    es.map(function (data<c> callback) {<\n>+      callback(null<c> {data: data})      <\n>+    })<c><\n>+    es.map(function (data<c> callback) {<\n>+      callback(null<c> {data: data})<\n>+    })<c><\n>+    es.writeArray(function (err<c> array) {<\n>+      it(array).deepEqual(d.map(readThis<c> function (data) {<\n>+        return {data: {data: data}}<\n>+      }))<\n>+      test.done()  <\n>+    })<\n>+  )<\n>+exports ['connect returns a stream'] = function (test) {<\n>+  var rw = <\n>+    es.connect(<\n>+      es.map(function (data<c> callback) {<\n>+        callback(null<c> data * 2)      <\n>+      })<c><\n>+      es.map(function (data<c> callback) {<\n>+        callback(null<c> data * 5)      <\n>+      })<\n>+    )<\n>+  it(rw).has({readable: true<c> writable: true})<\n>+  var array = [190<c> 24<c> 6<c> 7<c> 40<c> 57<c> 4<c> 6]<\n>+    <c> _array = []<\n>+    <c> c = <\n>+  es.connect(<\n>+    es.readArray(array)<c><\n>+    rw<c><\n>+    es.log('after rw:')<c><\n>+    es.writeArray(function (err<c> _array) {<\n>+      it(_array).deepEqual(array.map(function (e) { return e * 10 }))<\n>+      test.done()<\n>+    })<\n>+    )<\n>+  <\n>+var es  = require('../')<\n>+  <c> it  = require('it-is')<\n>+  <c> d   = require('ubelt')<\n>+ <\n>+exports ['gate buffers when shut'] = function (test) {<\n>+  var hundy = d.map(1<c>100<c> d.id)<\n>+    <c> gate = es.gate()<\n>+    <c> ten = 10<\n>+  es.connect(<\n>+    es.readArray(hundy)<c><\n>+    //es.log('after readArray')<c><\n>+    gate<c><\n>+    //es.log('after gate')<c><\n>+    es.map(function (num<c> next) {<\n>+      //stick a map in here to check that gate never emits when open<\n>+      it(gate.isShut()).equal(false)<\n>+      <\n>+      if(!--ten) {<\n>+        gate.shut()<\n>+        d.delay(gate.open<c>10)()<\n>+        ten = 10<\n>+      }<\n>+        <\n>+      next(null<c> num)<\n>+    })<c><\n>+    es.writeArray(function (err<c> array) { //just realized that I should remove the error param. errors will be emitted<\n>+      console.log('eonuhoenuoecbulc')<\n>+      it(array).deepEqual(hundy)<\n>+      test.done()<\n>+    })<\n>+  )<\n>+  gate.open()<\n>+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> d = require('ubelt')<\n>+function readStream(stream<c> pauseAt<c> done) {<\n>+  if(!done) done = pauseAt<c> pauseAt = -1<\n>+  var array = [] <\n>+  stream.on('data'<c> function (data) {<\n>+    array.push(data)<\n>+    if(!--pauseAt )<\n>+      stream.pause()<c> done(null<c> array)<\n>+  })<\n>+  stream.on('error'<c> done)<\n>+  stream.on('end'<c> function (data) {<\n>+    done(null<c> array)<\n>+  })<\n>+exports ['read an array'] = function (test) {<\n>+  var readThis = d.map(3<c> 6<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+  var reader = es.readArray(readThis)<\n>+  var writer = es.writeArray(function (err<c> array){<\n>+    if(err) throw err //unpossible<\n>+    it(array).deepEqual(readThis)<\n>+    test.done()     <\n>+  })<\n>+  reader.pipe(writer)<\n>+exports ['read an array and pause it.'] = function (test) {<\n>+  var readThis = d.map(3<c> 6<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+  var reader = es.readArray(readThis)<\n>+  <\n>+  readStream(reader<c> 10<c> function (err<c> data) {<\n>+    if(err) throw err<\n>+    it(data).deepEqual([3<c> 6<c> 9<c> 12<c> 15<c> 18<c> 21<c> 24<c> 27<c> 30])<\n>+    readStream(reader<c> 10<c> function (err<c> data) {<\n>+      it(data).deepEqual([33<c> 36<c> 39<c> 42<c> 45<c> 48<c> 51<c> 54<c> 57<c> 60])<\n>+      test.done() <\n>+    })<\n>+    reader.resume()<\n>+  })<\n>+exports ['reader is readable<c> but not writeable'] = function (test) {<\n>+  var reader = es.readArray([1])<\n>+  it(reader).has({<\n>+    readable: true<c><\n>+    writable: false<\n>+  })<\n>+  test.done()<\n>+exports ['read one item per tick'] = function (test) {<\n>+  var readThis = d.map(3<c> 6<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+  var drains = 0<\n>+  var reader = es.readArray(readThis)<\n>+  var tickMapper = es.map(function (data<c>callback) {<\n>+    process.nextTick(function () {<\n>+      callback(null<c> data)<\n>+    })<\n>+    //since tickMapper is returning false<\n>+    //pipe should pause the writer until a drain occurs<\n>+    return false<\n>+  })<\n>+  reader.pipe(tickMapper)<\n>+  readStream(tickMapper<c> function (err<c> array) {<\n>+    it(array).deepEqual(readThis)<\n>+    it(array.length).deepEqual(readThis.length)<\n>+    it(drains).equal(readThis.length)<\n>+    test.done()<\n>+  })<\n>+  tickMapper.on('drain'<c> function () {<\n>+    console.error('drain!')<\n>+    drains ++<\n>+  })<\n>+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> u = require('ubelt')<\n>+exports ['read an array'] = function (test) {<\n>+  var readThis = u.map(3<c> 6<c> 100<c> u.id) //array of multiples of 3 < 100<\n>+  var reader = <\n>+    es.readable(function (i<c> callback) {<\n>+      if(i >= readThis.length)<\n>+        return this.emit('end')<\n>+      callback(null<c> readThis[i])<\n>+    })<\n>+  var writer = es.writeArray(function (err<c> array){<\n>+    if(err) throw err<\n>+    it(array).deepEqual(readThis)<\n>+    test.done()     <\n>+  })<\n>+  reader.pipe(writer)<\n>+exports ['read an array - async'] = function (test) {<\n>+  var readThis = u.map(3<c> 6<c> 100<c> u.id) //array of multiples of 3 < 100<\n>+  var reader = <\n>+    es.readable(function (i<c> callback) {<\n>+      if(i >= readThis.length)<\n>+        return this.emit('end')<\n>+      u.delay(callback)(null<c> readThis[i])<\n>+    })<\n>+  var writer = es.writeArray(function (err<c> array){<\n>+    if(err) throw err<\n>+    it(array).deepEqual(readThis)<\n>+    test.done()<\n>+  })<\n>+  reader.pipe(writer)<\n>+exports ['emit data then call next() also works'] = function (test) {<\n>+  var readThis = u.map(3<c> 6<c> 100<c> u.id) //array of multiples of 3 < 100<\n>+  var reader = <\n>+    es.readable(function (i<c> next) {<\n>+      if(i >= readThis.length)<\n>+        return this.emit('end')<\n>+      this.emit('data'<c> readThis[i])<\n>+      next()<\n>+    })<\n>+  var writer = es.writeArray(function (err<c> array){<\n>+    if(err) throw err<\n>+    it(array).deepEqual(readThis)<\n>+    test.done()     <\n>+  })<\n>+  reader.pipe(writer)<\n>+exports ['callback emits error<c> then stops'] = function (test) {<\n>+  var err = new Error('INTENSIONAL ERROR')<\n>+    <c> called = 0<\n>+  var reader = <\n>+    es.readable(function (i<c> callback) {<\n>+      if(called++)<\n>+        return<\n>+      callback(err)<\n>+    })<\n>+  reader.on('error'<c> function (_err){<\n>+    it(_err).deepEqual(err)<\n>+    u.delay(function() {<\n>+      it(called).equal(1)<\n>+      test.done()<\n>+    }<c> 50)()<\n>+  })<\n>+exports['readable does not call read concurrently'] = function (test) {<\n>+  var current = 0<\n>+  var source = es.readable(function(count<c> cb){<\n>+    current ++<\n>+    if(count > 100)<\n>+      return this.emit('end')<\n>+    u.delay(function(){<\n>+      current --<\n>+      it(current).equal(0)      <\n>+      cb(null<c> {ok: true<c> n: count});<\n>+    })();<\n>+  });<\n>+  var destination = es.map(function(data<c> cb){<\n>+    //console.info(data); <\n>+    cb();<\n>+  });<\n>+  var all = es.connect(source<c> destination);<\n>+  destination.on('end'<c> test.done)<\n>+//<\n>+// emitting multiple errors is not supported by stream.<\n>+//<\n>+// I do not think that this is a good idea<c> at least<c> there should be an option to pipe to <\n>+// continue on error. it makes alot ef sense<c> if you are using Stream like I am<c> to be able to emit multiple errors.<\n>+// an error might not necessarily mean the end of the stream. it depends on the error<c> at least.<\n>+//<\n>+// I will start a thread on the mailing list. I'd rather that than use a custom `pipe` implementation.<\n>+// <\n>+// basically<c> I want to be able use pipe to transform objects<c> and if one object is invalid<c> <\n>+// the next might still be good<c> so I should get to choose if it's gonna stop.<\n>+// re-enstate this test when this issue progresses.<\n>+//<\n>+// hmm. I could add this to es.connect by deregistering the error listener<c> <\n>+// but I would rather it be an option in core.<\n>+/*<\n>+exports ['emit multiple errors<c> with 2nd parameter (continueOnError)'] = function (test) {<\n>+  var readThis = d.map(1<c> 100<c> d.id)<\n>+    <c> errors = 0<\n>+  var reader = <\n>+    es.readable(function (i<c> callback) {<\n>+      console.log(i<c> readThis.length)<\n>+      if(i >= readThis.length)<\n>+        return this.emit('end')<\n>+      if(!(readThis[i] % 7))<\n>+        return callback(readThis[i])<\n>+      callback(null<c> readThis[i])<\n>+    }<c> true)<\n>+  var writer = es.writeArray(function (err<c> array) {<\n>+    if(err) throw err<\n>+    it(array).every(function (u){<\n>+      it(u % 7).notEqual(0)      <\n>+    }).property('length'<c> 80)<\n>+    it(errors).equal(14)<\n>+    test.done()     <\n>+  })<\n>+  reader.on('error'<c> function (u) {<\n>+    errors ++<\n>+    console.log(u)<\n>+    if('number' !== typeof u)<\n>+      throw u<\n>+    it(u % 7).equal(0)<\n>+  })<\n>+  reader.pipe(writer)<\n>+*/<\n>+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> d = require('ubelt')<\n>+var fizzbuzz = '12F4BF78FB11F1314FB1617F19BF2223FB26F2829FB3132F34BF3738FB41F4344FB4647F49BF5253FB56F5859FB6162F64BF6768FB71F7374FB7677F79BF8283FB86F8889FB9192F94BF9798FB'<\n>+  <c> fizz7buzz = '12F4BFseven8FB11F1314FB161sevenF19BF2223FB26F2829FB3132F34BF3seven38FB41F4344FB464sevenF49BF5253FB56F5859FB6162F64BF6seven68FBseven1Fseven3seven4FBseven6sevensevenFseven9BF8283FB86F8889FB9192F94BF9seven98FB'<\n>+exports ['fizz buzz'] = function (test) {<\n>+  var readThis = d.map(1<c> 100<c> function (i) {<\n>+    return (<\n>+     ! (i % 3 || i % 5) ? ""FB"" :    <\n>+      !(i % 3) ? ""F"" :<\n>+      !(i % 5) ? ""B"" :<\n>+      ''+i<\n>+    )<\n>+  }) //array of multiples of 3 < 100<\n>+  var reader = es.readArray(readThis)<\n>+  var join = es.join(function (err<c> string){<\n>+    it(string).equal(fizzbuzz)<\n>+    test.done()<\n>+  })<\n>+  reader.pipe(join)<\n>+exports ['fizz buzz replace'] = function (test) {<\n>+  var split = es.split('1')<\n>+  var replace = es.replace('7'<c> 'seven')<\n>+  <\n>+  es.connect(split<c> <\n>+    replace<c> <\n>+//    es.log('aeounh')<c> <\n>+    es.join(function (err<c> string) {<\n>+      it(string).equal(fizz7buzz) <\n>+      test.done()<\n>+    })<\n>+  )<\n>+  split.write(fizzbuzz)<\n>+  split.end()<\n>+var es = require('../')<\n>+  <c> it = require('it-is')<\n>+  <c> u = require('ubelt')<\n>+//REFACTOR THIS TEST TO USE es.readArray and es.writeArray<\n>+function writeArray(array<c> stream) {<\n>+  array.forEach( function (j) {<\n>+    stream.write(j)<\n>+  })<\n>+  stream.end()<\n>+function readStream(stream<c> done) {<\n>+  var array = [] <\n>+  stream.on('data'<c> function (data) {<\n>+    array.push(data)<\n>+  })<\n>+  stream.on('error'<c> done)<\n>+  stream.on('end'<c> function (data) {<\n>+    done(null<c> array)<\n>+  })<\n>+exports ['simple map applied to a stream'] = function (test) {<\n>+  var input = [1<c>2<c>3<c>7<c>5<c>3<c>1<c>9<c>0<c>2<c>4<c>6]<\n>+  //create event stream from<\n>+  var doubler = es.map(function (data<c> cb) {<\n>+    cb(null<c> data * 2)<\n>+  })<\n>+  <\n>+  //a map is only a middle man<c> so it is both readable and writable<\n>+  <\n>+  it(doubler).has({<\n>+    readable: true<c><\n>+    writable: true<c>   <\n>+  })<\n>+  readStream(doubler<c> function (err<c> output) {<\n>+    it(output).deepEqual(input.map(function (j) {<\n>+      return j * 2<\n>+    }))<\n>+    test.done()<\n>+  })<\n>+  <\n>+  writeArray(input<c> doubler)<\n>+  <\n>+exports['pipe two maps together'] = function (test) {<\n>+  var input = [1<c>2<c>3<c>7<c>5<c>3<c>1<c>9<c>0<c>2<c>4<c>6]<\n>+  //create event stream from<\n>+  function dd (data<c> cb) {<\n>+    cb(null<c> data * 2)<\n>+  }<\n>+  var doubler1 = es.map(dd)<c> doubler2 = es.map(dd)<\n>+  doubler1.pipe(doubler2)<\n>+  <\n>+  readStream(doubler2<c> function (err<c> output) {<\n>+    it(output).deepEqual(input.map(function (j) {<\n>+      return j * 4<\n>+    }))<\n>+    test.done()<\n>+  })<\n>+  <\n>+  writeArray(input<c> doubler1)<\n>+//next:<\n>+//<\n>+// test pause<c> resume and drian.<\n>+//<\n>+// then make a pipe joiner:<\n>+//<\n>+// plumber (evStr1<c> evStr2<c> evStr3<c> evStr4<c> evStr5)<\n>+//<\n>+// will return a single stream that write goes to the first <\n>+exports ['map will not call end until the callback'] = function (test) {<\n>+  var ticker = es.map(function (data<c> cb) {<\n>+    process.nextTick(function () {<\n>+      cb(null<c> data * 2)<\n>+    })<\n>+  })<\n>+  ticker.write('x')<\n>+  ticker.end()<\n>+  ticker.end()<\n>+  ticker.end()<\n>+  ticker.on('end'<c> function () {<\n>+    test.done()<\n>+  })<\n>+exports ['emit error thrown'] = function (test) {<\n>+  var err = new Error('INTENSIONAL ERROR')<\n>+    <c> mapper = <\n>+  es.map(function () {<\n>+    throw err<\n>+  })<\n>+  mapper.on('error'<c> function (_err) {<\n>+    it(_err).equal(err)  <\n>+    test.done()<\n>+  })<\n>+  mapper.write('hello')<\n>+exports ['emit error calledback'] = function (test) {<\n>+  var err = new Error('INTENSIONAL ERROR')<\n>+    <c> mapper = <\n>+  es.map(function (data<c> callback) {<\n>+    callback(err)<\n>+  })<\n>+  mapper.on('error'<c> function (_err) {<\n>+    it(_err).equal(err)  <\n>+    test.done()<\n>+  })<\n>+  mapper.write('hello')<\n>+exports ['do not emit drain if not paused'] = function (test) {<\n>+  var map = es.map(function (data<c> callback) {<\n>+    u.delay(callback)(null<c> 1)<\n>+    return true<\n>+  })<\n>+  map.on('drain'<c> function () {<\n>+    it(false).ok('should not emit drain unless the stream is paused')<\n>+  })<\n>+  it(map.write('hello')).equal(true)<\n>+  it(map.write('hello')).equal(true)<\n>+  it(map.write('hello')).equal(true)<\n>+  setTimeout(function () {map.end()}<c>10)<\n>+  map.on('end'<c> test.done)<\n>+exports ['emits drain if paused<c> when all '] = function (test) {<\n>+  var active = 0<\n>+  var drained = false<\n>+  var map = es.map(function (data<c> callback) {<\n>+    active ++<\n>+    u.delay(function () {<\n>+      active --<\n>+      callback(null<c> 1)<\n>+    })()<\n>+    return false<\n>+  })<\n>+  map.on('drain'<c> function () {<\n>+    drained = true<\n>+    it(active).equal(0<c> 'should emit drain when all maps are done')<\n>+  })<\n>+  it(map.write('hello')).equal(false)<\n>+  it(map.write('hello')).equal(false)<\n>+  it(map.write('hello')).equal(false)<\n>+  setTimeout(function () {map.end()}<c>10)<\n>+  map.on('end'<c> function () {<\n>+    it(drained).ok('shoud have emitted drain before end')<\n>+    test.done()<\n>+    <\n>+  })<\n>+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> d = require('ubelt')<\n>+  <c> join = require('path').join<\n>+  <c> fs = require('fs')<\n>+  <c> Stream = require('stream').Stream<\n>+exports ['pipeable'] = function (test) {<\n>+  var readme = join(__filename)<\n>+    <c> expected = fs.readFileSync(readme<c> 'utf-8').split('\n')<\n>+    <c> cs = es.split()<\n>+    <c> actual = []<\n>+    <c> ended = false<\n>+  var a = new Stream ()<\n>+  <\n>+  a.write = function (l) {<\n>+    actual.push(l.trim())<\n>+  }<\n>+  a.end = function () {<\n>+      ended = true<\n>+      expected.forEach(function (v<c>k) {<\n>+        it(actual[k]).like(v)<\n>+      })<\n>+  <\n>+      test.done()<\n>+    }<\n>+  a.writable = true<\n>+  <\n>+  fs.createReadStream(readme<c> {flags: 'r'}).pipe(cs)<\n>+  cs.pipe(a)  <\n>+  <\n>+var es = require('../')<\n>+  <c> it = require('it-is').style('colour')<\n>+  <c> d = require('ubelt')<\n>+exports ['write an array'] = function (test) {<\n>+  var readThis = d.map(3<c> 6<c> 100<c> d.id) //array of multiples of 3 < 100<\n>+  var writer = es.writeArray(function (err<c> array){<\n>+    if(err) throw err //unpossible<\n>+    it(array).deepEqual(readThis)<\n>+    test.done()     <\n>+  })<\n>+  <\n>+  d.each(readThis<c> writer.write.bind(writer))<\n>+  writer.end()<\n>+exports ['writer is writable<c> but not readable'] = function (test) {<\n>+  var reader = es.writeArray(function () {})<\n>+  it(reader).has({<\n>+    readable: false<c><\n>+    writable: true<\n>+  })<\n>+  test.done()<\n>",,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,18,7 Apr 2012,trying to rework the test,1,0,1,1,60,,-Subproject commit e0f31675ae7ca459c6b6509b7a88526601ca7f3c<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,6,7 Apr 2012,oops mistake c/p into vim,0,0,1,2,36,+language: node_js<\n>,-nguage: node_js<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,4,7 Apr 2012,travis.ci integration,0,1,1,5,100,+nguage: node_js<\n>+node_js:<\n>+  - 0.4<\n>+  - 0.6<\n>+  - 0.7 # development version of 0.8<c> may be unstable<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,4,7 Apr 2012,updated devDeps and test script,0,0,1,3,81,"+    ""nodeunit"": ""*""<c><\n>+<c> ""scripts"": {""test"": ""asynct test/""}<\n>","-    ""asynct"": ""1""<c><\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,14,3,7 Apr 2012,moved tests into this repo,0,0,1,2,120,+Subproject commit e0f31675ae7ca459c6b6509b7a88526601ca7f3c<\n>,-Subproject commit 0d1399a0df8ab208c05450a551755ed87811a054<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,12,59,7 Apr 2012,0.8.1,0,0,1,2,44,"+<c> ""version"": ""0.8.1""<\n>","-<c> ""version"": ""0.8.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,12,56,7 Apr 2012,sorry everyone fucked up a 3-way-merge. fixed.,0,0,1,20,481,,-<<<<<<< index.js<\n>-//a do nothing stream that just passes through<\n>-es.through = function () {<\n>-  var s = new Stream()<\n>-  s.readable = true<\n>-  s.writeable = true<\n>-  s.write = function (data) {<\n>-    this.emit('data'<c> data)<\n>-    return true<\n>-  }<\n>-  s.end = function (data) {<\n>-    if(data)<\n>-      this.write(data)<\n>-    this.emit('end')<\n>-    this.writable = false<\n>-  }<\n>-  return s<\n>-||||||| node_modules/event-stream/index.js<\n>-=======<\n>->>>>>>> ../snob/node_modules/event-stream/index.js<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,11,39,26 Mar 2012,0.8.0,0,0,2,27,856,"+<<<<<<< index.js<\n>+||||||| node_modules/event-stream/index.js<\n>+=======<\n>+// through<\n>+//<\n>+// a stream that does nothing but re-emit the input.<\n>+// useful for aggregating a series of changing but not ending streams into one stream)<\n>+es.through = function () {<\n>+  var stream = new Stream()<\n>+  stream.readable = stream.writable = true<\n>+  <\n>+  stream.write = function (data) {<\n>+    stream.emit('data'<c> data)<\n>+  }<\n>+  stream.end = function (data) {<\n>+    if(data)<\n>+      stream.emit('data'<c>data)<\n>+    stream.emit('end')<\n>+  }<\n>+  return stream<\n>+>>>>>>> ../snob/node_modules/event-stream/index.js<\n>+  stream.write = function (data) { body += data; return true }<\n>+    if(body) stream.emit('data'<c> body.split(from).join(to))<\n>+<c> ""version"": ""0.8.0""<\n>","-  stream.write = function (data) { body += data }<\n>-    stream.emit('data'<c> body.split(from).join(to))<\n>-<c> ""version"": ""0.7.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,11,33,26 Mar 2012,0.7.0,0,0,1,2,44,"+<c> ""version"": ""0.7.0""<\n>","-<c> ""version"": ""0.6.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,11,32,26 Mar 2012,add through,0,0,1,16,358,+//a do nothing stream that just passes through<\n>+es.through = function () {<\n>+  var s = new Stream()<\n>+  s.readable = true<\n>+  s.writeable = true<\n>+  s.write = function (data) {<\n>+    this.emit('data'<c> data)<\n>+    return true<\n>+  }<\n>+  s.end = function (data) {<\n>+    if(data)<\n>+      this.write(data)<\n>+    this.emit('end')<\n>+    this.writable = false<\n>+  }<\n>+  return s<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,19,39,7 Nov 2011,added .join and .replace and bumped version 0.6.0,0,1,2,64,2420,"+Copyright (c) 2011 Dominic Tarr<\n>+Permission is hereby granted<c> free of charge<c> <\n>+to any person obtaining a copy of this software and <\n>+associated documentation files (the ""Software"")<c> to <\n>+deal in the Software without restriction<c> including <\n>+without limitation the rights to use<c> copy<c> modify<c> <\n>+merge<c> publish<c> distribute<c> sublicense<c> and/or sell <\n>+copies of the Software<c> and to permit persons to whom <\n>+the Software is furnished to do so<c> <\n>+subject to the following conditions:<\n>+The above copyright notice and this permission notice <\n>+shall be included in all copies or substantial portions of the Software.<\n>+THE SOFTWARE IS PROVIDED ""AS IS""<c> WITHOUT WARRANTY OF ANY KIND<c> <\n>+EXPRESS OR IMPLIED<c> INCLUDING BUT NOT LIMITED TO THE WARRANTIES <\n>+OF MERCHANTABILITY<c> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. <\n>+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR <\n>+ANY CLAIM<c> DAMAGES OR OTHER LIABILITY<c> WHETHER IN AN ACTION OF CONTRACT<c> <\n>+TORT OR OTHERWISE<c> ARISING FROM<c> OUT OF OR IN CONNECTION WITH THE <\n>+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.<\n>+    if(soFar)<\n>+      stream.emit('data'<c> soFar)  <\n>+    if (shut) return //false //pause up stream pipes  <\n>+//<\n>+// replace a string within a stream.<\n>+//<\n>+// warn: just concatenates the string and then does str.split().join(). <\n>+// probably not optimal.<\n>+// for smallish responses<c> who cares?<\n>+// I need this for shadow-npm so it's only relatively small json files.<\n>+es.replace = function (from<c> to) {<\n>+  var stream = new Stream()<\n>+  var body = ''<\n>+  stream.readable = true<\n>+  stream.writable = true<\n>+  stream.write = function (data) { body += data }<\n>+  stream.end = function (data) {<\n>+    if(data)<\n>+      body += data<\n>+    stream.emit('data'<c> body.split(from).join(to))<\n>+    stream.emit('end')<\n>+  }<\n>+  return stream<\n>+es.join = function (callback) {<\n>+  var stream = new Stream()<\n>+  var body = ''<\n>+  stream.readable = true<\n>+  stream.writable = true<\n>+  stream.write = function (data) { body += data }<\n>+  stream.end = function (data) {<\n>+    if(data)<\n>+      body += data<\n>+    if(callback)<\n>+      callback(null<c> body)<\n>+    stream.emit('data'<c> body)<\n>+    stream.emit('end')<\n>+  }<\n>+  return stream<\n>+<c> ""version"": ""0.6.0""<\n>","-    stream.emit('data'<c> soFar)  <\n>-//  console.error('SHUT?'<c> shut)<\n>-//    console.error('maybe'<c> queue.length<c> shut)<\n>-//    console.error(queue)<\n>-    if (shut) return false //pause up stream pipes  <\n>-<c> ""version"": ""0.5.3""<\n>",F
null,null,null,null,null,null,Jeff Barczewski,126,8,152,18,User,1,4139,Tue,15,11,1 Nov 2011,write should return true to indicate data was written If false then handler could believe that data was not able to be written yet and thus would be expecting a drain event.,0,0,1,1,18,+    return true;<\n>,,F
null,null,null,null,null,null,Jeff Barczewski,126,8,152,18,User,1,4139,Tue,14,58,1 Nov 2011,add stream.readable to split so that it will continue to get data events. On larger files that need more than one data event without having this set to true only the first packet is delivered and the stream stops reading as if data is not ready. Also the end and close events are never delivered either.,0,0,1,1,77,+  stream.readable = true;  //necessary for reading more than one data event<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,12,16,1 Nov 2011,bump version 0.5.3,0,0,1,2,44,"+<c> ""version"": ""0.5.3""<\n>","-<c> ""version"": ""0.5.2""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,12,16,1 Nov 2011,map should not emit drain unless the stream is paused,0,0,1,8,333,+    <c> paused = false<\n>+        if(paused) stream.emit('drain') //written all the incoming events<\n>+        paused = false<\n>+      var written = mapper.apply(null<c>args)<\n>+      if(written === false) paused = true<\n>+      return written<\n>,-        stream.emit('drain') //written all the incoming events<\n>-      return mapper.apply(null<c>args)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,11,32,1 Nov 2011,bump version 0.5.2,0,0,1,2,44,"+<c> ""version"": ""0.5.2""<\n>","-<c> ""version"": ""0.5.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,11,32,1 Nov 2011,fix issue one: readable(func) : func being called concurrently,0,0,1,48,1360,+    <c> reading = false<\n>+    <\n>+      if(ended || paused || reading) return<\n>+        reading = true<\n>+        func.call(stream<c> i++<c> function () {<\n>+          reading = false<\n>+          get.apply(null<c> arguments)<\n>+        })<\n>+  process.nextTick(get)<\n>+    if(name) args.slice().unshift(name)<\n>+    console.error.apply(null<c> args)<\n>+    shut = (shut === false ? false : true) //default to shut<\n>+//  console.error('SHUT?'<c> shut)<\n>+//    console.error('maybe'<c> queue.length<c> shut)<\n>+//    console.error(queue)<\n>+//<\n>+// parse<\n>+//<\n>+es.parse = function () { <\n>+  return es.mapSync(function (e){<\n>+    return JSON.parse(e.toString())<\n>+  }) <\n>+//<\n>+// stringify<\n>+//<\n>+es.stringify = function () { <\n>+  return es.mapSync(function (e){<\n>+    return JSON.stringify(e) + '\n'<\n>+  }) <\n>+    //streams.unshift()<\n>+    var c = es.connect.apply(null<c> streams)<\n>+    process.openStdin().pipe(c) //there<\n>+    return c<\n>,-      <\n>-    if(ended || paused) return<\n>-        func.call(stream<c> i++<c> get)<\n>-  process.nextTick(stream.resume)<\n>-    console.error(name<c> args)<\n>-    console.log('ERRORORR'<c> args)<\n>-      console.log(func<c> arguments)<\n>-      console.error('!'<c>event<c> args)<\n>-    console.error('END'<c> args)<\n>-    shut = shut === false ? false : true //default to shut<\n>-    console.log(f)<\n>-    streams.unshift(process.openStdin())<\n>-  <\n>-    return es.pipe.apply(null<c> streams)<\n>-      console.error(streams)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,13,56,21 Sep 2011,fix deps bump versios 0.5.1,0,0,1,6,115,"+<c> ""version"": ""0.5.1""<\n>+<c> ""dependencies"": {<\n>+    ""optimist"": ""0.2""<\n>+  }<\n>","-<c> ""version"": ""0.5.0""<\n>-<c> ""dependencies"": {}<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,13,23,21 Sep 2011,add readable to readme,0,0,1,57,2591,+##readable (asyncFunction) <\n>+create a readable stream (that respects pause) from an async function.  <\n>+while the stream is not paused<c>  <\n>+the function will be polled with `(count<c> callback)`<c>  <\n>+and `this`  will be the readable stream.<\n>+``` js<\n>+es.readable(function (count<c> callback) {<\n>+  if(streamHasEnded)<\n>+    return this.emit('end')<\n>+  <\n>+  //...<\n>+  <\n>+  this.emit('data'<c> data) //use this way to emit multiple chunks per call.<\n>+      <\n>+  callback() // you MUST always call the callback eventually.<\n>+             // the function will not be called again until you do this.<\n>+```<\n>+you can also pass the data and the error to the callback.  <\n>+you may only call the callback once.  <\n>+calling the same callback more than once will have no effect.  <\n>+All calls to write will return false (pause upstream)<c>  <\n>+and end will not be sent downstream.  <\n>+If the gate is open<c> let the stream through.  <\n>+  * https://github.com/felixge/node-growing-file  <\n>+  * https://github.com/isaacs/sax-js  <\n>+  * https://github.com/mikeal/request  <\n>+  * https://github.com/TooTallNate/node-throttle  <\n>+  * https://github.com/mikeal/morestreams  <\n>+  * https://github.com/TooTallNate/node-gzip-stack  <\n>+  * https://github.com/Floby/node-json-streams  <\n>+  * https://github.com/floby/node-tokenizer  <\n>+  * https://github.com/floby/node-parser  <\n>+  * https://github.com/dodo/node-bufferstream  <\n>+  * https://github.com/tim-smart/node-filter  <\n>+  * https://github.com/fictorial/json-line-protocol/issues/1  <\n>+  * https://github.com/jahewson/node-byline/issues/1  <\n>+  * https://github.com/AvianFlu/ntwitter/issues/3  <\n>+  * https://github.com/swdyh/node-chirpstream/issues/1  <\n>+  * https://github.com/polotek/evented-twitter/issues/22  <\n>,-If the gate is open<c> let the stream through.  <\n>-`end` will not be sent downstream if the gate is shut.<\n>-  * https://github.com/felixge/node-growing-file<\n>-  * https://github.com/isaacs/sax-js<\n>-  * https://github.com/mikeal/request<\n>-  * https://github.com/TooTallNate/node-throttle<\n>-  * https://github.com/mikeal/morestreams<\n>-  * https://github.com/TooTallNate/node-gzip-stack<\n>-  * https://github.com/Floby/node-json-streams<\n>-  * https://github.com/floby/node-tokenizer<\n>-  * https://github.com/floby/node-parser<\n>-  * https://github.com/dodo/node-bufferstream<\n>-  * https://github.com/tim-smart/node-filter<\n>-  * https://github.com/fictorial/json-line-protocol/issues/1<\n>-  * https://github.com/jahewson/node-byline/issues/1<\n>-  * https://github.com/AvianFlu/ntwitter/issues/3<\n>-  * https://github.com/swdyh/node-chirpstream/issues/1<\n>-  * https://github.com/polotek/evented-twitter/issues/22<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,23,43,20 Sep 2011,Merge branch master of github.com:dominictarr/event-stream,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,23,8,20 Sep 2011,bump version 0.4,0,0,1,2,44,"+<c> ""version"": ""0.5.0""<\n>","-<c> ""version"": ""0.4.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,23,7,20 Sep 2011,add `readable`: helper to make readable stream,0,0,1,45,1115,+//<\n>+// readable (asyncFunction)<\n>+// return a stream that calls an async function while the stream is not paused.<\n>+//<\n>+// the function must take: (count<c> callback) {...<\n>+//<\n>+es.readable = function (func<c> continueOnError) {<\n>+  var stream = new Stream()<\n>+    <c> i = 0<\n>+    <c> paused = false<\n>+    <c> ended = false<\n>+  stream.readable = true  <\n>+  stream.writable = false<\n>+ <\n>+  if('function' !== typeof func)<\n>+    throw new Error('event-stream.readable expects async function')<\n>+  <\n>+  stream.on('end'<c> function () { ended = true })<\n>+  <\n>+  function get (err<c> data) {<\n>+    if(err) {<\n>+      stream.emit('error'<c> err)<\n>+      if(!continueOnError) stream.emit('end')<\n>+    } else if (arguments.length > 1)<\n>+      stream.emit('data'<c> data)<\n>+      <\n>+    if(ended || paused) return<\n>+    process.nextTick(function () {<\n>+      try {<\n>+        func.call(stream<c> i++<c> get)<\n>+      } catch (err) {<\n>+        stream.emit('error'<c> err)    <\n>+      }<\n>+    })<\n>+  <\n>+  }<\n>+  stream.resume = function () {<\n>+    paused = false<\n>+    get()<\n>+  }<\n>+  process.nextTick(stream.resume)<\n>+  stream.pause = function () {<\n>+     paused = true<\n>+  }<\n>+  return stream<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,20,51,19 Sep 2011,Merge pull request #1 from holdinghandsfeedingducks/master edited readme,0,0,0,0,0,,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,13,32,20 Sep 2011,add mapSync bump version 0.4,0,0,2,17,397,"+//<\n>+// map sync<\n>+//<\n>+es.mapSync = function (sync) {<\n>+  <\n>+  return es.map(function () {<\n>+    var args = [].slice.call(arguments)<\n>+      <c> callback = args.pop()<\n>+      <\n>+      callback(null<c> sync.apply(null<c> args))<\n>+  })<\n>+es.gate = function (shut) {<\n>+    shut = shut === false ? false : true //default to shut<\n>+<c> ""version"": ""0.4.0""<\n>","-es.gate = function () {<\n>-    <c> shut = true<\n>-<c> ""version"": ""0.3.0""<\n>",F
null,null,null,null,null,null,holdinghandsfeedingducks <holdinghandsfeedingducks@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,12,46,20 Sep 2011,Did a gentle copy edit. Fixed egregious errors.,0,0,1,66,4100,"+[Streams](http://nodejs.org/api/streams.html ""Stream"") are nodes best and most misunderstood idea<c> and <\n>+Normally<c> streams are only used of IO<c>  <\n>+but in event stream we send all kinds of objects down the pipe.  <\n>+If your application's <em>input</em> and <em>output</em> are streams<c>  <\n>+The *EventStream* functions resemble the array functions<c>  <\n>+because Streams are like Arrays<c> but laid out in time<c> rather than in memory.  <\n>+<em>All the `event-stream` functions return instances of `Stream`</em>.<\n>+run it ...<\n>+Create a through stream from an asyncronous function.  <\n>+Each map MUST call the callback. It may callback with data<c> with an error or with no arguments<c> <\n>+>Also<c> if the callback is called more than once<c> every call but the first will be ignored.<\n>+Create a readable stream from an Array.<\n>+Break up a stream and reassemble it so that each line is a chunk.  <\n>+Example<c> read every line in a file ...<\n>+Connect multiple Streams together into one stream.  <\n>+`connect` will return a Stream. This stream will write to the first stream<c><\n>+Listening for 'error' will recieve errors from all streams inside the pipe.<\n>+If the gate is `shut`<c> buffer the stream.  <\n>+Named `shut` instead of close<c> because close is already kinda meaningful with streams.  <\n>+Gate is useful for holding off processing a stream until some resource (i.e. a database<c> or network connection) is ready.  <\n>+Takes a writable stream and a readable stream and makes them appear as a readable writable stream.<\n>+It is assumed that the two streams are connected to each other in some way.  <\n>+(This is used by `connect` and `child`.)<\n>+Create a through stream from a child process ...<\n>+The arguments to pipable must be functions that return  <\n>+(If a function is returned<c> it will be turned into a Stream  <\n>+with `es.map`.)<\n>+Here is the first example rewritten to use `pipeable`.<\n>+## compatible modules:<\n>+## almost compatible modules: (1+ these issues)<\n>+Pipes the incoming stream to many writable streams.  <\n>+Create a readable stream that merges many streams into one.<\n>+(Not implemented yet.)<\n>","-[Streams](http://nodejs.org/api/streams.html ""Stream"") are node's best and most misunderstood idea<c><\n>-normally<c> streams are only used of IO<c>  <\n>-but in event stream we send all kinds of object down the pipe.  <\n>-If your your application's <em>input</em> and <em>output</em> are streams<c>  <\n>-The *EventStream* functions resemble the the array functions<c>  <\n>-because Streams are like Arrays<c> but laid out in time<c> rather in memory.  <\n>-<em>All the `event-stream` functions return instances of `Stream`</em><\n>-run it...<\n>-create a through stream from an asyncronous function.  <\n>-Each map MUST call the callback. it may callback with data<c> with an error or with no arguments<c> <\n>->also<c> if the callback is called more than once<c> every call but the first will be ignored.<\n>-create a readable stream from an Array.<\n>-break up a stream and reassemble it so that each line is a chunk.  <\n>-example<c> read every line in a file<\n>-connect multiple Streams together into one stream.  <\n>-`connect` will return a Stream. this stream will write to the first stream<c><\n>-listening for 'error' will recieve errors from all streams inside the pipe.<\n>-If the gate is `shut` buffer the stream.  <\n>-named `shut` instead of close<c> because close is already kinda meaningful with streams.  <\n>-gate is useful for holding off processing a stream until some resource (i.e. a database<c> or network connection) is ready.  <\n>-take a writable stream<c> and a readable stream<c> and makes them appear as a readable writable stream.<\n>-it is assumed that the two streams are connected to each other in some way.  <\n>-(this is used by `connect`<c> and `child`.)<\n>-create a through stream from a child process<\n>-the arguments to pipable must be a functions that return  <\n>-(if a function is returned<c> it will be turned into a Stream  <\n>-with `es.map`.<\n>-here is the first example rewritten to use `pipeable`<\n>-## compatible modules<\n>-## almost compatible modules (1+ these issues)<\n>-pipes the incoming stream to many writable streams.  <\n>-create a readable stream that merges many streams into one<\n>-(not implemented yet)<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,0,24,20 Sep 2011,bump version 0.3,0,0,1,2,44,"+<c> ""version"": ""0.3.0""<\n>","-<c> ""version"": ""0.2.1""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,0,24,20 Sep 2011,add some docs for gate,0,0,1,13,536,+## gate (isShut=true) <\n>+If the gate is `shut` buffer the stream.  <\n>+If the gate is open<c> let the stream through.  <\n>+`end` will not be sent downstream if the gate is shut.<\n>+named `shut` instead of close<c> because close is already kinda meaningful with streams.  <\n>+gate is useful for holding off processing a stream until some resource (i.e. a database<c> or network connection) is ready.  <\n>+``` js<\n>+  var gate = es.gate()<\n>+  <\n>+  gate.open() //allow the gate to stream<\n>+  <\n>+  gate.close() //buffer the stream<c> also do not allow 'end' <\n>+```<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Tue,0,14,20 Sep 2011,add gate (buffer if shut stream if open),0,0,2,50,1427,+es.Stream = Stream //re-export Stream from core<\n>+//<\n>+// gate <\n>+//<\n>+// while the gate is shut()<c> buffer incoming. <\n>+// <\n>+// if gate is open() stream like normal.<\n>+//<\n>+// currently<c> when opened<c> this will emit all data unless it is shut again<\n>+// if downstream pauses it will still write<c> i'd like to make it respect pause<c> <\n>+// but i'll need a test case first.<\n>+es.gate = function () {<\n>+  var stream = new Stream()<\n>+    <c> queue = []<\n>+    <c> shut = true<\n>+    <c> ended = false<\n>+  stream.writable = true<\n>+  stream.readable = true<\n>+  stream.isShut = function () { return shut }<\n>+  stream.shut   = function () { shut = true }<\n>+  stream.open   = function () { shut = false; maybe() }<\n>+  <\n>+  function maybe () {<\n>+    while(queue.length && !shut) {<\n>+      var args = queue.shift()<\n>+      args.unshift('data')<\n>+      stream.emit.apply(stream<c> args)<\n>+    }<\n>+    stream.emit('drain')<\n>+    if(ended && !shut) <\n>+      stream.emit('end')<\n>+  }<\n>+  <\n>+  stream.write = function () {<\n>+    var args = [].slice.call(arguments)<\n>+  <\n>+    queue.push(args)<\n>+    if (shut) return false //pause up stream pipes  <\n>+    maybe()<\n>+  }<\n>+  stream.end = function () {<\n>+    ended = true<\n>+    if (!queue.length)<\n>+      stream.emit('end')<\n>+  }<\n>+  return stream<\n>+    buffer input until connected to a pipe.<\n>+    buffer streams until you say (written in C)<\n>,-    chunk type agnostic stream buffering (will work with any object stream)<\n>-    buffer streams until you say<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,18,17,19 Sep 2011,bump version oops forgot to mention fixed map error bug in last commit,0,0,1,2,44,"+<c> ""version"": ""0.2.1""<\n>","-<c> ""version"": ""0.2.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,18,16,19 Sep 2011,add more compatible modules,0,0,2,21,653,+      if(err) {<\n>+        args.unshift('error')<\n>+        return inNext = false<c> stream.emit.apply(stream<c> args)<\n>+      }<\n>+    console.log('ERRORORR'<c> args)<\n>+  * https://github.com/Floby/node-json-streams<\n>+    parse json without buffering it first<\n>+    <\n>+  * https://github.com/floby/node-tokenizer<\n>+    tokenizer<\n>+  <\n>+  * https://github.com/floby/node-parser<\n>+    general mechanisms for custom parsers<\n>+    <\n>+  * https://github.com/tim-smart/node-filter<\n>+    `filter` pipeable string.replace<\n>+    <\n>,-      if(err)<\n>-       return inNext = false<c> stream.emit('error')    <\n>-  * `filter` pipeable string.replace<\n>-    https://github.com/tim-smart/node-filter<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,15,14,19 Sep 2011,updated readme,0,0,1,25,1402,"+but in event stream we send all kinds of object down the pipe.  <\n>+If your your application's <em>input</em> and <em>output</em> are streams<c>  <\n>+shouldn't the <em>throughput</em> be a stream too?  <\n>+The *EventStream* functions resemble the the array functions<c>  <\n>+Stream API docs: [nodejs.org/api/streams](http://nodejs.org/api/streams.html ""Stream"")<\n>+NOTE: I shall use the term <em>""through stream""</em> to refer to a stream that is writable <em>and</em> readable.  <\n>+  * https://github.com/fictorial/json-line-protocol/issues/1<\n>+    line reader<\n>+    <\n>+  * https://github.com/jahewson/node-byline/issues/1<\n>+    line reader<\n>+  * https://github.com/AvianFlu/ntwitter/issues/3<\n>+    twitter client<\n>+  * https://github.com/swdyh/node-chirpstream/issues/1<\n>+    twitter client<\n>+    <\n>+  * https://github.com/polotek/evented-twitter/issues/22<\n>+    twitter client<\n>","-but in event stream we send all kinds of object down the pipe<c>  <\n>-if the input and output of your application are streams<c> why not make the throughput of your application into a stream?  <\n>-the `event-stream` functions resemble the the array functions<c>  <\n>-[nodejs.org/api/streams](http://nodejs.org/api/streams.html ""Stream"")<\n>-NOTE: I shall use the term <em>""through stream""</em> to refur to a stream that is both readable and writable.  <\n>-https://github.com/fictorial/json-line-protocol/issues/1<\n>-https://github.com/jahewson/node-byline/issues/1<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,13,33,19 Sep 2011,add more compatible modules,0,0,1,12,540,+  * https://github.com/mikeal/request<\n>+    make http requests. request() returns a through stream!<\n>+  * https://github.com/TooTallNate/node-throttle<\n>+    throttle streams on a bytes per second basis (binary streams only<c> of course)<\n>+    <\n>+  * https://github.com/mikeal/morestreams<\n>+    chunk type agnostic stream buffering (will work with any object stream)<\n>+    <\n>+  * https://github.com/TooTallNate/node-gzip-stack<\n>+    compress and decompress raw streams.<\n>+  * https://github.com/dodo/node-bufferstream<\n>+    buffer streams until you say<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,10,41,19 Sep 2011,compatible libraries,0,0,1,10,452,+## compatible modules<\n>+  * https://github.com/felixge/node-growing-file<\n>+    stream changes on file that is being appended to. just like `tail -f`<\n>+  * https://github.com/isaacs/sax-js<\n>+    streaming xml parser<\n>+  * `filter` pipeable string.replace<\n>+    https://github.com/tim-smart/node-filter<\n>+## almost compatible modules (1+ these issues)<\n>+https://github.com/fictorial/json-line-protocol/issues/1<\n>+https://github.com/jahewson/node-byline/issues/1<\n>,,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,18,28,18 Sep 2011,added pipeable to readme,0,0,2,32,993,"+<c> ""devDependencies"": {<\n>+    ""asynct"": ""1""<c><\n>+    ""it-is"":  ""1""<c><\n>+    ""d-utils"":""2.3""<\n>+  }<\n>+## pipeable (streamCreatorFunction<c>...)<\n>+the arguments to pipable must be a functions that return  <\n>+instances of Stream or async functions.  <\n>+(if a function is returned<c> it will be turned into a Stream  <\n>+with `es.map`.<\n>+here is the first example rewritten to use `pipeable`<\n>+``` js<\n>+//examples/pretty_pipeable.js<\n>+var inspect = require('util').inspect<\n>+if(!module.parent)<\n>+  require('event-stream').pipeable(function () {<\n>+    return function (data<c> callback) {<\n>+      try {<\n>+        data = JSON.parse(data)<\n>+      } catch (err) {}              //pass non JSON straight through!<\n>+      callback(null<c> inspect(data))<\n>+      }<\n>+    })  <\n>+  })<\n>+```<\n>+``` bash<\n>+curl -sS registry.npmjs.org/event-stream | node pipeable_pretty.js<\n>+## or<c> turn the pipe into a server!<\n>+node pipeable_pretty.js --port 4646<\n>+curl -sS registry.npmjs.org/event-stream | curl -sSNT- localhost:4646<\n>+```<\n>","-<c> ""devDependencies"": {}<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,17,56,18 Sep 2011,added tests as submodule,0,2,2,4,152,"+[submodule ""test""]<\n>+	path = test<\n>+	url = git@github.com:dominictarr/event-stream_tests.git<\n>+Subproject commit 0d1399a0df8ab208c05450a551755ed87811a054<\n>",,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,17,42,18 Sep 2011,edit readme,0,0,1,57,2716,"+if the input and output of your application are streams<c> why not make the throughput of your application into a stream?  <\n>+NOTE: I shall use the term <em>""through stream""</em> to refur to a stream that is both readable and writable.  <\n>+```<\n>+run it...<\n>+``` bash  <\n>+curl -sS registry.npmjs.org/event-stream | node pretty.js<\n>+>Note: if a callback is not called<c> `map` will think that it is still being processed<c>   <\n>+`connect` will return a Stream. this stream will write to the first stream<c><\n>+and will emit data from the last stream. <\n>+  es.connect(                         //connect streams together with `pipe`<\n>+    process.openStdin()<c>              //open stdin<\n>+    es.split()<c>                       //split stream to break on newlines<\n>+    es.map(function (data<c> callback) {//turn this async function into a stream<\n>+      callback(null<\n>+        <c> inspect(JSON.parse(data)))  //render it nicely<\n>+    process.stdout                    // pipe it to stdout !<\n>+    )<\n>+take a writable stream<c> and a readable stream<c> and makes them appear as a readable writable stream.<\n>+it is assumed that the two streams are connected to each other in some way.  <\n>+(this is used by `connect`<c> and `child`.)<\n>+  es.child(cp.exec('grep Stream')) // a through stream<\n>+<!--<\n>+TODO<c> the following methods are not implemented yet.<\n>+SEARCH SUBDIRECTORIES FROM CWD  <\n>+FILTER IF NOT A GIT REPO  <\n>+MAP TO GIT STATUS --porclean + the directory  <\n>+FILTER IF EMPTY STATUS  <\n>+process.stdout  <\n>+that will show all the repos which have unstaged changes  <\n>+  <\n>+--><\n>",-so you can organize your whole application around them!  <\n>-NOTE: I shall use the term <em>through stream</em> to refur to a stream that is both writable and readable.<\n>-  <\n>-//curl -sS registry.npmjs.org/event-stream | node pretty.js<\n>->Note: if a callback is not called map will think that it is still being worked on<c>   <\n>-`connect` will return a Stream. Writing to the pipe will write to the first stream<c><\n>-the pipe will emit data from the last stream. <\n>-  es.pipe(<\n>-    es.emitterToStream(findit(startDir)<c> null<c> {'file': 'data'})<c><\n>-    es.map(function (filename<c> callback) {<\n>-      fs.readFile(filename<c> function (err<c> file) {<\n>-        if (err) return callback(err)<\n>-        callback(null<c> {_id: filename<c> content: file.toString()}) <\n>-      })<\n>-    es.save.couch({database: 'example'}) //defaults to localhost:5984<\n>-  )<\n>-take a writable stream<c> and a readable stream<c> and makes them appear as a readable writable stream. <\n>-  es.child(cp.exec('grep Stream')) // a throu<\n>-# TODO<\n>-SEARCH SUBDIRECTORIES FROM CWD<\n>-FILTER IF NOT A GIT REPO<\n>-MAP TO GIT STATUS --porclean + the directory<\n>-FILTER IF EMPTY STATUS<\n>-process.stdout<\n>-that will show all the repos which have unstaged changes<\n>-    <\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,16,46,18 Sep 2011,add to readme,0,0,1,38,1556,+## sidestream (stream1<c>...<c>streamN)<\n>+pipes the incoming stream to many writable streams.  <\n>+remits the input stream.<\n>+``` js<\n>+  es.sidestream( //will log the stream to a file<\n>+    es.connect(<\n>+      es.mapSync(function (j) {return JSON.stringify(j) + '/n'})<c><\n>+      fs.createWruteStream(file<c> {flags: 'a'})<\n>+    )<\n>+```<\n>+# TODO<\n>+## merge (stream1<c>...<c>streamN)<\n>+create a readable stream that merges many streams into one<\n>+(not implemented yet)<\n>,-### emitterStream<\n>-Sometimes a single input maps to many outputs. you would normally do this with a function that <\n>-returns an event emitter. <\n>-to make this more streamy<c> it is often only necessory to redirect a event to 'data'<\n>-to make a readible stream it needs to emit 'data' and 'end'.<\n>-to make a writable stream it needs to accept `write`<c> and possibly `end`<\n>-emitterStream(<\n>-  emitter<c> <\n>-  { write: inputMethodName<c> end: finishMethodName }<c> //inputs (if writable)<\n>-  { data: outputEventName<c> end: finishEventName<c> error: errorEventName } //outputs (if readible)<\n>-  ) //if omitted<c> default to thier standard names<\n>-emitterStream(<\n>-  findit(process.cwd()<c> <\n>-  null<c> //readible <\n>-  { data: 'directory' } //outputs. (findit already emits 'end' and 'error')<\n>-)<\n>-``` js<\n>-  // SubStack's findit recursively searches from a starting directory<\n>-  // the findit function returns an EventEmitter that emits<\n>-  // 'file'<c> 'directory'<c> and 'path' events.<\n>-  <\n>-  var findit = require('findit')<\n>-  var findStream =  es.emitterStream(findit(process.cwd())<c> null<c> {data: 'path'<c> end: 'end'})<\n>-  findStream.pipe(nextStream)<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,14,33,18 Sep 2011,add duplex and child,0,0,3,179,6818,"+  stream.readable = true<\n>+//<\n>+// log just print out what is coming through the stream<c> for debugging<\n>+//<\n>+es.log = function (name) {<\n>+  return es.map(function () {<\n>+    var args = [].slice.call(arguments)<\n>+    var cb = args.pop()<\n>+    console.error(name<c> args)<\n>+    args.unshift(null)<\n>+    cb.apply(null<c> args)<\n>+  })<\n>+es.pipe = es.connect = function () {<\n>+    <c> thepipe = es.duplex(first<c> last)<\n>+  if(streams.length == 1)<\n>+    return streams[0]<\n>+  else if (!streams.length)<\n>+    throw new Error('connect called with empty args')<\n>+  return thepipe<\n>+//<\n>+// child -- pipe through a child process<\n>+//<\n>+es.child = function (child) {<\n>+  return es.duplex(child.stdin<c> child.stdout)<\n>+//<\n>+// duplex -- pipe into one stream and out another<\n>+//<\n>+es.duplex = function (writer<c> reader) {<\n>+  var thepipe = new Stream()<\n>+  thepipe.__defineGetter__('writable'<c> function () { return writer.writable })<\n>+  thepipe.__defineGetter__('readable'<c> function () { return reader.readable })<\n>+  ;['write'<c> 'end'<c> 'close'].forEach(function (func) {<\n>+    thepipe[func] = function () {<\n>+      console.log(func<c> arguments)<\n>+      return writer[func].apply(writer<c> arguments)<\n>+    }<\n>+  ;['resume'<c> 'pause'].forEach(function (func) {<\n>+    thepipe[func] = function () { <\n>+      thepipe.emit(func)<\n>+      if(reader[func])<\n>+        return reader[func].apply(reader<c> arguments)<\n>+      else<\n>+        reader.emit(func)<\n>+    }<\n>+  ;['data'<c> 'close'].forEach(function (event) {<\n>+    reader.on(event<c> function () {<\n>+      console.error('!'<c>event<c> args)<\n>+      thepipe.emit.apply(thepipe<c> args)<\n>+    })<\n>+  })<\n>+  //only emit end once<\n>+  var ended = false<\n>+  reader.on('end'<c> function () {<\n>+    if(ended) return<\n>+    ended = true<\n>+    var args = [].slice.call(arguments)<\n>+    console.error('END'<c> args)<\n>+    args.unshift('end')<\n>+    thepipe.emit.apply(thepipe<c> args)<\n>+<c> ""version"": ""0.2.0""<\n>+# EventStream<\n>+[Streams](http://nodejs.org/api/streams.html ""Stream"") are node's best and most misunderstood idea<c><\n>+_<em>EventStream</em>_ is a toolkit to make creating and working with streams <em>easy</em>.  <\n>+normally<c> streams are only used of IO<c>  <\n>+but in event stream we send all kinds of object down the pipe<c>  <\n>+so you can organize your whole application around them!  <\n>+the `event-stream` functions resemble the the array functions<c>  <\n>+because Streams are like Arrays<c> but laid out in time<c> rather in memory.  <\n>+<em>All the `event-stream` functions return instances of `Stream`</em><\n>+[nodejs.org/api/streams](http://nodejs.org/api/streams.html ""Stream"")<\n>+NOTE: I shall use the term <em>through stream</em> to refur to a stream that is both writable and readable.<\n>+###[simple example](https://github.com/dominictarr/event-stream/blob/master/examples/pretty.js):<\n>+  var es = require('event-stream')<\n>+  es.connect(                         //connect streams together with `pipe`<\n>+##map (asyncFunction)<\n>+create a through stream from an asyncronous function.  <\n>+##readArray (array)<\n>+create a readable stream from an Array.<\n>+  var es = require('event-stream')<\n>+    <c> reader = es.readArray([1<c>2<c>3])<\n>+  reader.pipe(...)<\n>+```<\n>+## writeArray (callback)<\n>+create a writeable stream from a callback<c>  <\n>+all `data` events are stored in an array<c> which is passed to the callback when the stream ends.<\n>+``` js<\n>+  var es = require('event-stream')<\n>+    <c> reader = es.readArray([1<c> 2<c> 3])<\n>+    <c> writer = es.writeArray(function (err<c> array){<\n>+      //array deepEqual [1<c> 2<c> 3]<\n>+    })<\n>+  reader.pipe(writer)<\n>+## split ()<\n>+break up a stream and reassemble it so that each line is a chunk.  <\n>+example<c> read every line in a file<\n>+``` js<\n>+  es.connect(<\n>+    fs.createReadStream(file<c> {flags: 'r'})<c><\n>+    es.split()<c><\n>+    es.map(function (line<c> cb) {<\n>+       //do something with the line <\n>+       cb(null<c> line)<\n>+    })<\n>+  )<\n>+```<\n>+## connect (stream1<c>...<c>streamN)<\n>+connect multiple Streams together into one stream.  <\n>+`connect` will return a Stream. Writing to the pipe will write to the first stream<c><\n>+the pipe will emit data from the last stream. <\n>+listening for 'error' will recieve errors from all streams inside the pipe.<\n>+## duplex<\n>+take a writable stream<c> and a readable stream<c> and makes them appear as a readable writable stream. <\n>+``` js<\n>+  var grep = cp.exec('grep Stream')<\n>+  es.duplex(grep.stdin<c> grep.stdout)<\n>+```<\n>+## child (child_process)<\n>+create a through stream from a child process<\n>+``` js<\n>+  var cp = require('child_process')<\n>+  es.child(cp.exec('grep Stream')) // a throu<\n>+```<\n>","-  stream.readible = true<\n>-es.pipe = function () {<\n>-    <c> thepipe = new Stream() //this pipe of streams<\n>-    <\n>-  if(streams.length < 2)<\n>-    throw new Error('pipe expects at least two streams to join together')<\n>-  ;['write'<c> 'writable'<c> 'end'<c> 'close'<c> 'destroy'<c> 'destroySoon'].forEach(function (prop) {<\n>-    thepipe.__defineGetter__(prop<c> function () { return first[prop] })<\n>-  ;['readible'<c> 'resume'<c> 'pause'<c> 'destroy'<c> 'destroySoon'].forEach(function (prop) {<\n>-    thepipe.__defineGetter__(prop<c> function () { return last[prop] })<\n>-  ;['data'<c> 'end'<c> 'close'].forEach(function (event) {<\n>-    last.on(event<c> function () { <\n>-      thepipe.emit.apply(thepipe<c> args) <\n>-      })  <\n>-<c> ""version"": ""0.1.0""<\n>-# EventStreams<\n>-Streams are node's best and sadly misunderstood idea<c>  <\n>-this is a toolkit to make creating and working with streams <em>easy</em>.<\n>-`Stream` is a subclass of `EventEmitter`<c> it adds one very useful function:<\n>-``` js<\n>-  readibleStream.pipe(writableStream)<\n>-  //if a stream is both readable and writable it can be pipe on again<\n>-  <\n>-  readibleStream.pipe(readableWritableStream)<\n>-  readableWritableStream.pipe(writableStream)<\n>-  // just like on the command line!<\n>-  // readibleStream | readableWritableStream | writableStream<\n>-  //<\n>-```<\n>-the `event-stream` functions are just like the array functions<c>  <\n>-because Streams are like Arrays<c> but laid out in time<c> rather in memory.<\n>-###for example:<\n>-  var es = require('..')              //load event-stream<\n>-  es.pipe(                            //pipe joins streams together<\n>-##map<\n>-create a readable and writable stream from an asyncronous function.  <\n>-###readArray<\n>-makes a readable stream from an array.  <\n>-var es = require('event-stream')<\n>-  var reader =es.read([1<c>2<c>3])<\n>-  reader.pipe(es.map(function (data) {<\n>-    //apply a mapping<\n>-  }))<\n>-  //since read is potentially sync<\n>-  //it will start out paused.<\n>-  //it is necessary to call resume or open<\n>-  //to start it emitting events<\n>-  reader.resume()<\n>-### reduce<\n>-combine all incoming data together into one item which will be emitted on recieving end.<\n>-### pipe<\n>-join multiple EventStreams together into one massive stream. <\n>-the pipe will return an EventStream. Writing to the pipe will write to the first stream<c><\n>-the pipe will emit data from the last stream.<\n>-listening for 'error' will recieve errors from all streams inside the pipe.<\n>-(not implemented yet)<\n>-  <\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,16,21,17 Sep 2011,add pipable and improve readme,0,1,2,214,8371,"+var inspect = require('util').inspect<\n>+if(!module.parent) {<\n>+  var es = require('..')              //load event-stream<\n>+  es.pipe(                            //pipe joins streams together<\n>+    process.openStdin()<c>              //open stdin<\n>+    es.split()<c>                       //split stream to break on newlines<\n>+    es.map(function (data<c> callback) {//turn this async function into a stream<\n>+      var j <\n>+      try {<\n>+        j = JSON.parse(data)          //try to parse input into json<\n>+      } catch (err) {<\n>+        return callback(null<c> data)   //if it fails just pass it anyway<\n>+      }<\n>+      callback(null<c> inspect(j))      //render it nicely<\n>+    })<c><\n>+    process.stdout                    // pipe it to stdout !<\n>+    )<\n>+  }<\n>+  <\n>+// run this<\n>+// <\n>+// curl -sS registry.npmjs.org/event-stream | node pretty.js <\n>+//<\n>+  <c> es = exports<\n>+es.writeArray = function (done) {<\n>+es.readArray = function (array) {<\n>+es.map = function (mapper) {<\n>+es.pipe = function () {<\n>+es.split = function (matcher) {<\n>+//<\n>+// helper to make your module into a unix pipe<\n>+// simply add <\n>+// <\n>+// if(!module.parent)<\n>+//  require('event-stream').pipable(asyncFunctionOrStreams)<\n>+// <\n>+// asyncFunctionOrStreams may be one or more Streams or if it is a function<c> <\n>+// it will be automatically wrapped in es.map<\n>+//<\n>+// then pipe stuff into from the command line!<\n>+// <\n>+// curl registry.npmjs.org/event-stream | node hello-pipeable.js | grep whatever<\n>+//<\n>+// etc!<\n>+//<\n>+// also<c> start pipeable running as a server!<\n>+//<\n>+// > node hello-pipeable.js --port 44444<\n>+// <\n>+var setup = function (args) {<\n>+  return args.map(function (f) {<\n>+    console.log(f)<\n>+    var x = f()<\n>+      if('function' === typeof x)<\n>+        return es.map(x)<\n>+      return x<\n>+    })<\n>+es.pipeable = function () {<\n>+  var opts = require('optimist').argv<\n>+  var args = [].slice.call(arguments)<\n>+  <\n>+  if(opts.h || opts.help) {<\n>+    var name = process.argv[1]<\n>+    console.error([<\n>+      'Usage:'<c><\n>+      ''<c><\n>+      'node ' + name + ' [options]'<c><\n>+      '  --port PORT        turn this stream into a server'<c><\n>+      '  --host HOST        host of server (localhost is default)'<c><\n>+      '  --protocol         protocol http|net will require(protocol).createServer(...'<c><\n>+      '  --help             display this message'<c><\n>+      ''<c><\n>+      ' if --port is not set<c> will stream input from stdin'<c><\n>+      ''<c><\n>+      'also<c> pipe from or to files:'<c><\n>+      ''<c><\n>+      ' node '+name+ ' < file    #pipe from file into this stream'<c><\n>+      ' node '+name+ ' < infile > outfile    #pipe from file into this stream'<c>     <\n>+      ''<c><\n>+    ].join('\n'))<\n>+  <\n>+  } else if (!opts.port) {<\n>+    var streams = setup(args)<\n>+    streams.unshift(es.split())<\n>+    streams.unshift(process.openStdin())<\n>+    streams.push(process.stdout)<\n>+  <\n>+    return es.pipe.apply(null<c> streams)<\n>+  } else {<\n>+  <\n>+    opts.host = opts.host || 'localhost'<\n>+    opts.protocol = opts.protocol || 'http'<\n>+    <\n>+    var protocol = require(opts.protocol)<\n>+        <\n>+    var server = protocol.createServer(function (instream<c> outstream) {  <\n>+      var streams = setup(args)<\n>+      streams.unshift(es.split())<\n>+      streams.unshift(instream)<\n>+      streams.push(outstream || instream)<\n>+      console.error(streams)<\n>+      es.pipe.apply(null<c> streams)<\n>+    })<\n>+    <\n>+    server.listen(opts.port<c> opts.host)<\n>+    console.error(process.argv[1] +' is listening for ""' + opts.protocol + '"" on ' + opts.host + ':' + opts.port)  <\n>+  }<\n>+Streams are node's best and sadly misunderstood idea<c>  <\n>+this is a toolkit to make creating and working with streams <em>easy</em>.<\n>+`Stream` is a subclass of `EventEmitter`<c> it adds one very useful function:<\n>+``` js<\n>+  readibleStream.pipe(writableStream)<\n>+  //if a stream is both readable and writable it can be pipe on again<\n>+  <\n>+  readibleStream.pipe(readableWritableStream)<\n>+  readableWritableStream.pipe(writableStream)<\n>+  // just like on the command line!<\n>+  // readibleStream | readableWritableStream | writableStream<\n>+  //<\n>+```<\n>+the `event-stream` functions are just like the array functions<c>  <\n>+because Streams are like Arrays<c> but laid out in time<c> rather in memory.<\n>+###for example:<\n>+``` js<\n>+//pretty.js<\n>+if(!module.parent) {<\n>+  var es = require('..')              //load event-stream<\n>+  es.pipe(                            //pipe joins streams together<\n>+    process.openStdin()<c>              //open stdin<\n>+    es.split()<c>                       //split stream to break on newlines<\n>+    es.map(function (data<c> callback) {//turn this async function into a stream<\n>+      callback(null<\n>+        <c> inspect(JSON.parse(data)))  //render it nicely<\n>+    })<c><\n>+    process.stdout                    // pipe it to stdout !<\n>+    )<\n>+  }<\n>+  <\n>+//curl -sS registry.npmjs.org/event-stream | node pretty.js<\n>+```<\n>+ <\n>+[test are in event-stream_tests](https://github.com/dominictarr/event-stream_tests)<\n>+[node Stream documentation](http://nodejs.org/api/streams.html)<\n>+##map<\n>+create a readable and writable stream from an asyncronous function.  <\n>+var es = require('event-stream')<\n>+es.map(function (data<c> callback) {<\n>+  //transform data<\n>+  // ...<\n>+  callback(null<c> data)<\n>+Each map MUST call the callback. it may callback with data<c> with an error or with no arguments<c> <\n>+  * `callback()` drop this data.  <\n>+    this makes the map work like `filter`<c>  <\n>+    note:`callback(null<c>null)` is not the same<c> and will emit `null`<\n>+  * `callback(null<c> newData)` turn data into newData<\n>+    <\n>+  * `callback(error)` emit an error for this item.<\n>+>Note: if a callback is not called map will think that it is still being worked on<c>   <\n>+>every call must be answered or the stream will not know when to end.  <\n>+><\n>+>also<c> if the callback is called more than once<c> every call but the first will be ignored.<\n>+###readArray<\n>+makes a readable stream from an array.  <\n>",-exports.writeArray = function (done) {<\n>-exports.readArray = function (array) {<\n>-exports.map = function (mapper) {<\n>-exports.pipe = function () {<\n>-exports.split = function (matcher) {<\n>-        console.log('data'<c>n)<\n>-EventEmitters in node are a brilliant idea that unfortunatly are under utilized by the node community.<\n>-Yes<c> that is right. _under utilized_. there are many more things that EventEmitters could be used for<c> especially<c> <\n>-the `Stream`s<c> a subclass of EventEmitters.<\n>-A stream of events is a bit like an array<c> but an array layed out in time<c> rather than in memory.<\n>-You can apply a map function to an array and create a new array<c> you could apply a similar <\n>-map function to a stream of events to create a new stream. `map` functions<c> but also `fitler`<c> `reduce`<\n>-and other functional programming idioms!<\n>-event streams are great because they have a naturally scalable API. <\n>-if the events in a stream can be stringified ane parsed then it will be relatively simple to split heavy <\n>-parts of a stream into seperate processes<c> and to incorperate middlewares into the stream that might <\n>-buffer or rate-limit or parallelize critical aspects of your event stream.<\n>-Supporting this sort of programming is the purpose of this library.<\n>-[test are in event-stream_tests](https://github.com/dominictarr/event-stream_tests)<\n>-[node Stream documentation](http://nodejs.org/api/streams.html)<\n>-##Examples<\n>-###map<\n>-Turns an asyncronous function it into an readable/writable EventStream<\n>-it can be used to perform a transformation upon a stream before writing it to something.<\n>-If error<c> `callback(error)` like normal. If you `callback()` (no args) the stream will not emit <\n>-anything from that map.<\n>-`map` does not guarantee mapped output order will be the same an written input.<\n>-`map` will hold off on emitting `end` until all of it's map callbacks are complete.<\n>-Each map MUST call the callback. it may callback with data<c> with an error or with no arguments<c> <\n>-  //callback mapped data<\n>-  <\n>-  callback(null<c> data) //may use multiple args<c> but first is always error<\n>-    <\n>-  //drop this peice of data<\n>-  <\n>-  callback()<\n>-  <\n>-  //if there was on error<\n>-  <\n>-  callback (error) //the event stream will emit 'error' instead of data for this step.<\n>-if a callback is not called map will think that it is still being worked on.<\n>-If the callback is called more than once<c> every call but the first will be ignored.<\n>-''' js<\n>-var es = require('event-stream')<\n>-  es.map(function (data<c> callback) {<\n>-    //do something to data<\n>-    callback(null<c> data)   <\n>-  })<\n>-'''<\n>-###read<\n>-Makes an readable `EventStream` from an `Array`.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,21,22,16 Sep 2011,changed read to readArray add writeArray and split,0,0,1,108,2818,+var Stream = require('stream').Stream<\n>+// writable stream<c> collects all events into an array <\n>+// and calls back when 'end' occurs<\n>+// mainly I'm using this to test the other functions<\n>+exports.writeArray = function (done) {<\n>+  if ('function' !== typeof done)<\n>+    throw new Error('function writeArray (done): done must be function')<\n>+  var a = new Stream ()<\n>+    <c> array = []<\n>+  a.write = function (l) {<\n>+    array.push(l)<\n>+  }<\n>+  a.end = function () {<\n>+    done(null<c> array)<\n>+  }<\n>+  a.writable = true<\n>+  a.readable = false<\n>+  return a<\n>+//return a Stream that reads the properties of an object<\n>+//respecting pause() and resume()<\n>+exports.readArray = function (array) {<\n>+  var stream = new Stream()<\n>+    <c> i = 0<\n>+    <c> paused = false<\n>+ <\n>+  stream.readable = true  <\n>+  stream.writable = false<\n>+ <\n>+  if(!Array.isArray(array))<\n>+    throw new Error('event-stream.read expects an array')<\n>+  <\n>+  stream.resume = function () {<\n>+    paused = false<\n>+    var l = array.length<\n>+    while(i < l && !paused) {<\n>+      stream.emit('data'<c> array[i++])<\n>+    }<\n>+    if(i == l)<\n>+      stream.emit('end')<c> stream.readible = false<\n>+  }<\n>+  process.nextTick(stream.resume)<\n>+  stream.pause = function () {<\n>+     paused = true<\n>+  }<\n>+  return stream<\n>+//create an event stream and apply function to each .write<\n>+//emitting each response as data<\n>+//unless it's an empty callback<\n>+exports.split = function (matcher) {<\n>+  var stream = new Stream()<\n>+    <c> soFar = ''  <\n>+  <\n>+  if (!matcher)<\n>+      matcher = '\n'<\n>+  stream.writable = true<\n>+  stream.write = function (buffer) {<\n>+    buffer = buffer.toString()<\n>+    var l = buffer.length<\n>+      <c> i = 0<\n>+    while (i < l) {<\n>+      var c = buffer[i].toString()<\n>+      soFar += c<\n>+      if (c == matcher) {<\n>+        var n = soFar;<\n>+        soFar = '' <\n>+        this.emit('data'<c> n)<\n>+        console.log('data'<c>n)<\n>+      }<\n>+    i++<\n>+    }<\n>+  }<\n>+  stream.end = function () {<\n>+    stream.emit('data'<c> soFar)  <\n>+    stream.emit('end')<\n>+  }<\n>+  return stream<\n>,-//create an event stream and apply function to each .write<\n>-//emitting each response as data<\n>-//unless it's an empty callback<\n>-//<\n>-var Stream = require('stream').Stream<\n>-  //return a Stream that reads the properties of an object<\n>-  //respecting pause() and resume()<\n>-exports.read = function (array) {<\n>-  var stream = new Stream()<\n>-    <c> i = 0<\n>-    <c> paused = false<\n>- <\n>-  stream.readable = true  <\n>-  stream.writable = false<\n>- <\n>-  if(!Array.isArray(array))<\n>-    throw new Error('event-stream.read expects an array')<\n>-  <\n>-  stream.open = function () {<\n>-    paused = false<\n>-    var l = array.length<\n>-    while(i < l && !paused) {<\n>-      stream.emit('data'<c> array[i++])<\n>-    }<\n>-    if(i == l)<\n>-      stream.emit('end')<c> stream.readible = false<\n>-  }<\n>-  stream.pause = function () {<\n>-     paused = true<\n>-  }<\n>-  stream.resume = stream.open<\n>-  return stream<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Fri,16,59,9 Sep 2011,pipe,0,0,2,53,2197,+//<\n>+// combine multiple streams together so that they act as a single stream<\n>+//<\n>+exports.pipe = function () {<\n>+  var streams = [].slice.call(arguments)<\n>+    <c> first = streams[0]<\n>+    <c> last = streams[streams.length - 1]<\n>+    <c> thepipe = new Stream() //this pipe of streams<\n>+    <\n>+  if(streams.length < 2)<\n>+    throw new Error('pipe expects at least two streams to join together')<\n>+  //pipe all the streams together<\n>+  function recurse (streams) {<\n>+    if(streams.length < 2)<\n>+      return<\n>+    streams[0].pipe(streams[1])<\n>+    recurse(streams.slice(1))  <\n>+  }<\n>+  <\n>+  recurse(streams)<\n>+ <\n>+  function onerror () {<\n>+    var args = [].slice.call(arguments)<\n>+    args.unshift('error')<\n>+    thepipe.emit.apply(thepipe<c> args)<\n>+  }<\n>+  <\n>+  streams.forEach(function (stream) {<\n>+    stream.on('error'<c> onerror)<\n>+  })<\n>+  ;['write'<c> 'writable'<c> 'end'<c> 'close'<c> 'destroy'<c> 'destroySoon'].forEach(function (prop) {<\n>+    thepipe.__defineGetter__(prop<c> function () { return first[prop] })<\n>+  })<\n>+  ;['readible'<c> 'resume'<c> 'pause'<c> 'destroy'<c> 'destroySoon'].forEach(function (prop) {<\n>+    thepipe.__defineGetter__(prop<c> function () { return last[prop] })<\n>+  })<\n>+  ;['data'<c> 'end'<c> 'close'].forEach(function (event) {<\n>+    last.on(event<c> function () { <\n>+      var args = [].slice.call(arguments)<\n>+      args.unshift(event)<\n>+      thepipe.emit.apply(thepipe<c> args) <\n>+      })  <\n>+  })<\n>+  return thepipe<\n>+EventEmitters in node are a brilliant idea that unfortunatly are under utilized by the node community.<\n>+Yes<c> that is right. _under utilized_. there are many more things that EventEmitters could be used for<c> especially<c> <\n>+the `Stream`s<c> a subclass of EventEmitters.<\n>+combine all incoming data together into one item which will be emitted on recieving end.<\n>,-EventEmitters are a great idea<c> but are unfortunatly under utilized in the node community<\n>-EventEmitters in node are a brilliant idea that unfortunatly are under utilized by the node community. <\n>-EventEmitters they are at the heart of all the IO in node core<c> reading from files<c> or TCP<c> or the body <\n>-of an http request or response is handled as a stream of events.<\n>-combine all incomingdata together into one item which will be emitted on recieving end.<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Wed,19,4,24 Aug 2011,fix `code quotes`,0,0,1,121,4960,+EventEmitters are a great idea<c> but are unfortunatly under utilized in the node community<\n>+EventEmitters in node are a brilliant idea that unfortunatly are under utilized by the node community. <\n>+EventEmitters they are at the heart of all the IO in node core<c> reading from files<c> or TCP<c> or the body <\n>+##Examples<\n>+Turns an asyncronous function it into an readable/writable EventStream<\n>+If error<c> `callback(error)` like normal. If you `callback()` (no args) the stream will not emit <\n>+`map` does not guarantee mapped output order will be the same an written input.<\n>+`map` will hold off on emitting `end` until all of it's map callbacks are complete.<\n>+Each map MUST call the callback. it may callback with data<c> with an error or with no arguments<c> <\n>+``` js<\n>+  //callback mapped data<\n>+  <\n>+  callback(null<c> data) //may use multiple args<c> but first is always error<\n>+    <\n>+  //drop this peice of data<\n>+  <\n>+  callback()<\n>+  <\n>+  //if there was on error<\n>+  <\n>+  callback (error) //the event stream will emit 'error' instead of data for this step.<\n>+```<\n>+if a callback is not called map will think that it is still being worked on.<\n>+If the callback is called more than once<c> every call but the first will be ignored.<\n>+'''<\n>+###read<\n>+Makes an readable `EventStream` from an `Array`.<\n>+Just emit each item as a data event<c> respecting `pause` and `resume`.<\n>+``` js<\n>+var es = require('event-stream')<\n>+  var reader =es.read([1<c>2<c>3])<\n>+  reader.pipe(es.map(function (data) {<\n>+    //apply a mapping<\n>+  }))<\n>+  //since read is potentially sync<\n>+  //it will start out paused.<\n>+  //it is necessary to call resume or open<\n>+  //to start it emitting events<\n>+  reader.resume()<\n>+```<\n>+### reduce<\n>+combine all incomingdata together into one item which will be emitted on recieving end.<\n>+### pipe<\n>+join multiple EventStreams together into one massive stream. <\n>+the pipe will return an EventStream. Writing to the pipe will write to the first stream<c><\n>+the pipe will emit data from the last stream.<\n>+listening for 'error' will recieve errors from all streams inside the pipe.<\n>+(not implemented yet)<\n>+``` js<\n>+  es.pipe(<\n>+    es.emitterToStream(findit(startDir)<c> null<c> {'file': 'data'})<c><\n>+    es.map(function (filename<c> callback) {<\n>+      fs.readFile(filename<c> function (err<c> file) {<\n>+        if (err) return callback(err)<\n>+        callback(null<c> {_id: filename<c> content: file.toString()}) <\n>+      })<\n>+    })<c><\n>+    es.save.couch({database: 'example'}) //defaults to localhost:5984<\n>+  )<\n>+```<\n>+### emitterStream<\n>+Sometimes a single input maps to many outputs. you would normally do this with a function that <\n>+returns an event emitter. <\n>+to make this more streamy<c> it is often only necessory to redirect a event to 'data'<\n>+to make a readible stream it needs to emit 'data' and 'end'.<\n>+to make a writable stream it needs to accept `write`<c> and possibly `end`<\n>+emitterStream(<\n>+  emitter<c> <\n>+  { write: inputMethodName<c> end: finishMethodName }<c> //inputs (if writable)<\n>+  { data: outputEventName<c> end: finishEventName<c> error: errorEventName } //outputs (if readible)<\n>+  ) //if omitted<c> default to thier standard names<\n>+emitterStream(<\n>+  findit(process.cwd()<c> <\n>+  null<c> //readible <\n>+  { data: 'directory' } //outputs. (findit already emits 'end' and 'error')<\n>+)<\n>+  <\n>+``` js<\n>+  // SubStack's findit recursively searches from a starting directory<\n>+  // the findit function returns an EventEmitter that emits<\n>+  // 'file'<c> 'directory'<c> and 'path' events.<\n>+  <\n>+  var findit = require('findit')<\n>+  var findStream =  es.emitterStream(findit(process.cwd())<c> null<c> {data: 'path'<c> end: 'end'})<\n>+  findStream.pipe(nextStream)<\n>+### another pipe example<\n>+SEARCH SUBDIRECTORIES FROM CWD<\n>+FILTER IF NOT A GIT REPO<\n>+MAP TO GIT STATUS --porclean + the directory<\n>+FILTER IF EMPTY STATUS<\n>+process.stdout<\n>+that will show all the repos which have unstaged changes<\n>+## TODO & applications<\n>+  * buffer -- buffer items<\n>+  * rate limiter<\n>+  * save to database<\n>+    * couch<\n>+    * redis<\n>+    * mongo<\n>+    * file(s)<\n>+  * read from database<\n>+    * couch<\n>+    * redis<\n>+    * mongo<\n>+    * file(s)<\n>+  * recursive<\n>+    * search filesystem<\n>+    * scrape web pages (load pages<c> parse for links<c> etc)<\n>+    * module dependencies<\n>+    <\n>,-EventEmitters in node are a brilliant idea that are under utilized in the node community. <\n>-they are at the heart of all the IO in node core<c> reading from files<c> or TCP<c> or the body <\n>-##Example<\n>-`eventstream.map` takes an asyncronous function and turns it into an readable/writable EventStream<\n>-if error<c> `callback(error)` like normal. if you `callback()` (no args) the stream will not emit <\n>-the order that the stream emits data is not gaurenteed to be the same as data is written to it. <\n>-(that feature is forth coming)<\n>-will not emit 'end' when all the maps are finished<c> but only when all maps are finished. <\n>-it is essential that each map does call the callback. with data<c> with an error or with no arguments.<\n>-if the callback is called more than once<c> every call but the first will be ignored.<\n>-'''<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,15,26,22 Aug 2011,bump version 0.1,0,0,1,2,44,"+<c> ""version"": ""0.1.0""<\n>","-<c> ""version"": ""0.0.0""<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Mon,15,25,22 Aug 2011,implement reader and fix bug with .end(),0,0,1,35,889,+   <\n>+       return inNext = false<c> stream.emit('error')    <\n>+      return true<\n>+    else if (inputs == outputs) //wait for processing<\n>+  return stream<\n>+  //return a Stream that reads the properties of an object<\n>+  //respecting pause() and resume()<\n>+exports.read = function (array) {<\n>+  var stream = new Stream()<\n>+    <c> i = 0<\n>+    <c> paused = false<\n>+ <\n>+  stream.readable = true  <\n>+  stream.writable = false<\n>+ <\n>+  if(!Array.isArray(array))<\n>+    throw new Error('event-stream.read expects an array')<\n>+  <\n>+  stream.open = function () {<\n>+    paused = false<\n>+    var l = array.length<\n>+    while(i < l && !paused) {<\n>+      stream.emit('data'<c> array[i++])<\n>+    }<\n>+    if(i == l)<\n>+      stream.emit('end')<c> stream.readible = false<\n>+  }<\n>+  stream.pause = function () {<\n>+     paused = true<\n>+  }<\n>+  stream.resume = stream.open<\n>,-    <\n>-       return inNext = false<c> stream.emit('error')<\n>-    <\n>-    else<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,23,54,21 Aug 2011,add to readme,0,0,1,21,1060,+[test are in event-stream_tests](https://github.com/dominictarr/event-stream_tests)<\n>+[node Stream documentation](http://nodejs.org/api/streams.html)<\n>+##Example<\n>+###map<\n>+`eventstream.map` takes an asyncronous function and turns it into an readable/writable EventStream<\n>+it can be used to perform a transformation upon a stream before writing it to something.<\n>+if error<c> `callback(error)` like normal. if you `callback()` (no args) the stream will not emit <\n>+anything from that map.<\n>+the order that the stream emits data is not gaurenteed to be the same as data is written to it. <\n>+(that feature is forth coming)<\n>+will not emit 'end' when all the maps are finished<c> but only when all maps are finished. <\n>+it is essential that each map does call the callback. with data<c> with an error or with no arguments.<\n>+if the callback is called more than once<c> every call but the first will be ignored.<\n>+''' js<\n>+var es = require('event-stream')<\n>+  es.map(function (data<c> callback) {<\n>+    //do something to data<\n>+    callback(null<c> data)   <\n>+  })<\n>+'''<\n>,-an EventStream must:<\n>,F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,14,15,21 Aug 2011,fix,0,0,2,17,1180,"+<c> ""description"": ""construct pipes of streams of events""<\n>+# EventStreams<\n>+EventEmitters in node are a brilliant idea that are under utilized in the node community. <\n>+they are at the heart of all the IO in node core<c> reading from files<c> or TCP<c> or the body <\n>+of an http request or response is handled as a stream of events.<\n>+A stream of events is a bit like an array<c> but an array layed out in time<c> rather than in memory.<\n>+You can apply a map function to an array and create a new array<c> you could apply a similar <\n>+map function to a stream of events to create a new stream. `map` functions<c> but also `fitler`<c> `reduce`<\n>+and other functional programming idioms!<\n>+event streams are great because they have a naturally scalable API. <\n>+if the events in a stream can be stringified ane parsed then it will be relatively simple to split heavy <\n>+parts of a stream into seperate processes<c> and to incorperate middlewares into the stream that might <\n>+buffer or rate-limit or parallelize critical aspects of your event stream.<\n>+Supporting this sort of programming is the purpose of this library.<\n>+an EventStream must:<\n>","-<c> ""description"": """"<\n>-<c> ""scripts"": { ""test"": ""meta-test test/*.js"" } }<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sun,14,10,21 Aug 2011,initial,0,0,3,20,1383,"+//filter will reemit the data if cb(err<c>pass) pass is truthy<\n>+// reduce is more tricky<\n>+// maybe we want to group the reductions or emit progress updates occasionally<\n>+// the most basic reduce just emits one 'data' event after it has recieved 'end'<\n>+<c> ""description"": """"<\n>","-<c> ""description"": ""node streams applied to arbitary events""<\n>-# EventStreams<\n>-EventEmitters in node are a brilliant idea that are under utilized in the node community. <\n>-they are at the heart of all the IO in node core<c> reading from files<c> or TCP<c> or the body <\n>-of an http request or response is handled as a stream of events.<\n>-A stream of events is a bit like an array<c> but an array layed out in time<c> rather than in memory.<\n>-You can apply a map function to an array and create a new array<c> you could apply a similar <\n>-map function to a stream of events to create a new stream. `map` functions<c> but also `fitler`<c> `reduce`<\n>-and other functional programming idioms!<\n>-event streams are great because they have a naturally scalable API. <\n>-if the events in a stream can be stringified ane parsed then it will be relatively simple to split heavy <\n>-parts of a stream into seperate processes<c> and to incorperate middlewares into the stream that might <\n>-buffer or rate-limit or parallelize critical aspects of your event stream.<\n>-Supporting this sort of programming is the purpose of this library.<\n>-an EventStream must:<\n>",F
null,null,null,null,null,null,Dominic Tarr,885,112,3030,28,User,1,3371,Sat,11,38,20 Aug 2011,inital. first implementation of a map function (takes async callback function and turns it into readible & writable stream,0,4,4,88,3146,"+node_modules<\n>+node_modules/*<\n>+npm_debug.log<\n>+//create an event stream and apply function to each .write<\n>+//emitting each response as data<\n>+//unless it's an empty callback<\n>+//<\n>+var Stream = require('stream').Stream<\n>+exports.map = function (mapper) {<\n>+  var stream = new Stream()<\n>+    <c> inputs = 0<\n>+    <c> outputs = 0<\n>+    <c> ended = false<\n>+  stream.writable = true<\n>+  stream.readible = true<\n>+    <\n>+  stream.write = function () {<\n>+    inputs ++<\n>+    var args = [].slice.call(arguments)<\n>+      <c> r<\n>+      <c> inNext = false <\n>+    function next (err) {<\n>+      inNext = true<\n>+      outputs ++<\n>+      var args = [].slice.call(arguments)<\n>+      if(err)<\n>+       return inNext = false<c> stream.emit('error')<\n>+    <\n>+      args.shift() //drop err<\n>+    <\n>+      if (args.length){<\n>+        args.unshift('data')<\n>+        r = stream.emit.apply(stream<c> args)<\n>+      }<\n>+      if(inputs == outputs) {<\n>+        stream.emit('drain') //written all the incoming events<\n>+        if(ended)<\n>+          stream.end()<\n>+      }<\n>+      inNext = false<\n>+    }<\n>+    args.push(next)<\n>+    <\n>+    try {<\n>+      //catch sync errors and handle them like async errors<\n>+      return mapper.apply(null<c>args)<\n>+    } catch (err) {<\n>+      //if the callback has been called syncronously<c> and the error<\n>+      //has occured in an listener<c> throw it again.<\n>+      if(inNext)<\n>+        throw err<\n>+      next(err)<\n>+    }<\n>+  }<\n>+  stream.end = function () {<\n>+    var args = [].slice.call(arguments)<\n>+    //if end was called with args<c> write it<c> <\n>+    ended = true //write will emit 'end' if ended is true<\n>+    if(args.length)<\n>+      return stream.write.apply(emitter<c> args)<\n>+    else<\n>+      stream.emit('end')<\n>+  }<\n>+  return stream<\n>+<c> ""version"": ""0.0.0""<\n>+<c> ""description"": ""node streams applied to arbitary events""<\n>+<c> ""homepage"": ""http://github.com/dominictarr/event-stream""<\n>+<c> ""repository"": <\n>+  { ""type"": ""git""<\n>+  <c> ""url"": ""https://github.com/dominictarr/event-stream.git"" }<\n>+<c> ""dependencies"": {}<\n>+<c> ""devDependencies"": {}<\n>+<c> ""author"": ""Dominic Tarr <dominic.tarr@gmail.com> (http://bit.ly/dominictarr)""<\n>+<c> ""scripts"": { ""test"": ""meta-test test/*.js"" } }<\n>+# EventStreams<\n>+EventEmitters in node are a brilliant idea that are under utilized in the node community. <\n>+they are at the heart of all the IO in node core<c> reading from files<c> or TCP<c> or the body <\n>+of an http request or response is handled as a stream of events.<\n>+A stream of events is a bit like an array<c> but an array layed out in time<c> rather than in memory.<\n>+You can apply a map function to an array and create a new array<c> you could apply a similar <\n>+map function to a stream of events to create a new stream. `map` functions<c> but also `fitler`<c> `reduce`<\n>+and other functional programming idioms!<\n>+event streams are great because they have a naturally scalable API. <\n>+if the events in a stream can be stringified ane parsed then it will be relatively simple to split heavy <\n>+parts of a stream into seperate processes<c> and to incorperate middlewares into the stream that might <\n>+buffer or rate-limit or parallelize critical aspects of your event stream.<\n>+Supporting this sort of programming is the purpose of this library.<\n>+an EventStream must:<\n>",,F
